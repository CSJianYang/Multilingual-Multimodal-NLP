[
    {
        "title": "Add Binary",
        "question_content": "Given two binary strings a and b, return their sum as a binary string.\n&nbsp;\nExample 1:\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n&nbsp;\nConstraints:\n\n\t1 <= a.length, b.length <= 104\n\ta and b consist&nbsp;only of '0' or '1' characters.\n\tEach string does not contain leading zeros except for the zero itself.",
        "solutions": [
            {
                "id": 24488,
                "title": "short-ac-solution-in-java-with-explanation",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sb = new StringBuilder();\\n            int i = a.length() - 1, j = b.length() -1, carry = 0;\\n            while (i >= 0 || j >= 0) {\\n                int sum = carry;\\n                if (j >= 0) sum += b.charAt(j--) - '0';\\n                if (i >= 0) sum += a.charAt(i--) - '0';\\n                sb.append(sum % 2);\\n                carry = sum / 2;\\n            }\\n            if (carry != 0) sb.append(carry);\\n            return sb.reverse().toString();\\n        }\\n    }\\n\\nComputation from string usually can be simplified by using a carry as such.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sb = new StringBuilder();\\n            int i = a.length() - 1, j = b.length() -1, carry = 0;\\n            while (i >= 0 || j >= 0) {\\n                int sum = carry;\\n                if (j >= 0) sum += b.charAt(j--) - '0';\\n                if (i >= 0) sum += a.charAt(i--) - '0';\\n                sb.append(sum % 2);\\n                carry = sum / 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1679423,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT INFO FOR YOU\\n```\\n* If, you are preperaing for `FACEBOOK interview` or will prepare. Then according to `LeetCode premium` it is no.4 most asked Question by **Facebook** as per now.\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\n`What question saying is, Given two binary strings a and b, return their sum as a binary string.`\\n\\n**Approach Explained :**\\n\\n**Summary of Below Explanation :**\\n\\n*The overall idea is to make up the short two strings with 00 to make the two strings have the same length, and then traverse and calculate from the end to get the final result.*\\n\\nLet\\'s understand with an **example** : Addition of **1 and 1** will lead to **carry 1** and **print 0** , Addition of **1 and 0** give us **1 as carry** will lead **print 0** , Addition of last remaning **carry 1** with no body will lead to **print 1** , So, we get something like **\"1 0 0\"** as answer\\nOne **key point** total addition will be 3 then print 1 and carry will remain 1\\n\\n**Detailed Explaination :**\\n\\nSo, first do we understand how do we perform **binary addition**. **Take an example**, given two numbers **\"11\" + \"1\"** where **\"11\"** is representing **\"3\"** & **\"1\"** is **\"1\"**, in decimal form. \\nNow let\\'s perform **binary addition** it\\'s very **similar to the decimal addition** that we do. In decimal what we do we add 2 numbers & if it goes beyond 9 we **take a carry**. And here also we have a **number in range 0 - 1**, **2 values over here** & in **Decimal range is 0 - 9**, **10 values** are there. So, in binary what it means is if result more **than 1**, there **is a carry** otherwise **no carry**.\\nLet me show you in diagram:\\n![image](https://assets.leetcode.com/users/images/fcd956d9-2703-41fe-90ad-57c49e227799_1641778567.285665.png)\\n\\n\\n* So, what\\'s going in diagram is **intially carry is \"0\"** we **add 1 + 1** we **get 2** which is more **then 1**, so there is a **carry of 1** and **result is 0**. Now we have **carry of 1**, **again 1 + 1 is 0**, and still left with **carry of 1**. And the **last carry** one will be **return as it is**. \\n* So, if you see this binary number it is **[2^2 * 1 + 2^1 * 0 + 2^0 * 0]** and this is the decimal coversion of **[1 0 0]** which **is 4**. \\n\\n![image](https://assets.leetcode.com/users/images/b12c2264-ddf0-4709-a761-4bfa3becdd95_1641779179.1482372.png)\\n\\n**Hope you got the point **\\n\\n*Now, let\\'s code it up:*\\n**code, each lne explained :** `Similar for C++, Java, Python` **{Only synatx difference}** approach is same\\n\\n* Step 1:\\n```\\n{\\n// First, create result name string and intially it is empty & in the end we gonna return it as our aswer\\n        StringBuilder res = new StringBuilder(); \\n        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left \\n        int j = b.length() - 1; // similar pointer j for string b\\n        int carry = 0; // we create a carry, as we have to consider it as well\\n```\\n* Step 2:\\n```\\n// iterate over the loop until the both condition become false\\n        while(i >= 0 || j >= 0){ \\n            int sum = carry; // intialise our sum with carry;\\n            \\n            // Now, we subtract by \\'0\\' to convert the numbers from a char type into an int, so we can perform operations on the numbers\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            // taking carry;\\n            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 \\n\\t\\t\\t// if sum is 0 res is 1 & then carry would be 0;\\n            // if sum is 1 res is 1 & carry would be 0\\n            // if sum is 2 res is 0 & carry would be 1\\n            // if sum is 3 res is 1 & carry would be 1\\n            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result\\n        }\\n```\\n* Final Step:\\n```\\nif(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;\\n        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;\\n```\\n* Let\\'s combine each line of code\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder res = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res.append(sum % 2);\\n        }\\n        if(carry != 0) res.append(carry);\\n        return res.reverse().toString();\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res += to_string(sum % 2);\\n        }\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = \"\"\\n        i, j, carry = len(a) - 1, len(b) - 1, 0\\n        while i >= 0 or j >= 0:\\n            sum = carry;\\n            if i >= 0 : sum += ord(a[i]) - ord(\\'0\\') # ord is use to get value of ASCII character\\n            if j >= 0 : sum += ord(b[j]) - ord(\\'0\\')\\n            i, j = i - 1, j - 1\\n            carry = 1 if sum > 1 else 0;\\n            res += str(sum % 2)\\n\\n        if carry != 0 : res += str(carry);\\n        return res[::-1]\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(max(M, N)), M & N is the length of string a, b;\\n\\n* **Space Complexity :-** BigO(max(M, N)), which is the size of \"res\" object\\n\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F**\\n`If you have some \\uD83E\\uDD14 doubts feel free to bug me`",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT INFO FOR YOU\\n```\n```\\n{\\n// First, create result name string and intially it is empty & in the end we gonna return it as our aswer\\n        StringBuilder res = new StringBuilder(); \\n        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left \\n        int j = b.length() - 1; // similar pointer j for string b\\n        int carry = 0; // we create a carry, as we have to consider it as well\\n```\n```\\n// iterate over the loop until the both condition become false\\n        while(i >= 0 || j >= 0){ \\n            int sum = carry; // intialise our sum with carry;\\n            \\n            // Now, we subtract by \\'0\\' to convert the numbers from a char type into an int, so we can perform operations on the numbers\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            // taking carry;\\n            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 \\n\\t\\t\\t// if sum is 0 res is 1 & then carry would be 0;\\n            // if sum is 1 res is 1 & carry would be 0\\n            // if sum is 2 res is 0 & carry would be 1\\n            // if sum is 3 res is 1 & carry would be 1\\n            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result\\n        }\\n```\n```\\nif(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;\\n        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;\\n```\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder res = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res.append(sum % 2);\\n        }\\n        if(carry != 0) res.append(carry);\\n        return res.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res += to_string(sum % 2);\\n        }\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = \"\"\\n        i, j, carry = len(a) - 1, len(b) - 1, 0\\n        while i >= 0 or j >= 0:\\n            sum = carry;\\n            if i >= 0 : sum += ord(a[i]) - ord(\\'0\\') # ord is use to get value of ASCII character\\n            if j >= 0 : sum += ord(b[j]) - ord(\\'0\\')\\n            i, j = i - 1, j - 1\\n            carry = 1 if sum > 1 else 0;\\n            res += str(sum % 2)\\n\\n        if carry != 0 : res += str(carry);\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24475,
                "title": "short-code-by-c",
                "content": "    class Solution\\n    {\\n    public:\\n        string addBinary(string a, string b)\\n        {\\n            string s = \"\";\\n            \\n            int c = 0, i = a.size() - 1, j = b.size() - 1;\\n            while(i >= 0 || j >= 0 || c == 1)\\n            {\\n                c += i >= 0 ? a[i --] - '0' : 0;\\n                c += j >= 0 ? b[j --] - '0' : 0;\\n                s = char(c % 2 + '0') + s;\\n                c /= 2;\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        string addBinary(string a, string b)\\n        {\\n            string s = \"\";\\n            \\n            int c = 0, i = a.size() - 1, j = b.size() - 1;\\n            while(i >= 0 || j >= 0 || c == 1)\\n            {\\n                c += i >= 0 ? a[i --] - '0' : 0;\\n                c += j >= 0 ? b[j --] - '0' : 0;\\n                s = char(c % 2 + '0') + s;\\n                c /= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3183205,
                "title": "1ms-beats-100-full-explanation-append-reverse-c-java-python3",
                "content": "# Intuition :\\n- We have to add two binary numbers (made up of 0\\'s and 1\\'s) and returns the result in binary.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- We start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string. \\n- Now we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.\\n- If there is any carry-over value after adding all the digits,  append it to the end of the new string. \\n- Finally, the new string is reversed and returned as the sum of the two binary numbers.\\n<!-- Describe your approach to solving the problem. -->\\n# Explanation to Approach :\\n- Suppose we want to add two binary numbers - \"1010\" and \"1101\". \\n- To add these two numbers, we can use the given function as follows:\\n- First, we initialize a StringBuilder object to store the sum and two integer variables \\'carry\\' and \\'i\\' to keep track of the carry-over value and the current position in the first binary number (a), respectively. \\n- We also initialize another integer variable \\'j\\' to keep track of the current position in the second binary number (b). Here is how the code initializes these variables:\\n```\\nStringBuilder sb = new StringBuilder();\\nint carry = 0;\\nint i = a.length() - 1;\\nint j = b.length() - 1;\\n\\n```\\n- Next, we enter a while loop that iterates until we have processed all digits in both binary numbers and there is no more carry-over value left. In each iteration, we add the digits from both numbers at the current position and the carry-over value (if any), and append the result to the StringBuilder object. \\n- We also update the carry-over value based on the sum of the digits. Here is the code for this step:\\n```\\nwhile (i >= 0 || j >= 0 || carry == 1) {\\n    if (i >= 0) {\\n        carry += a.charAt(i--) - \\'0\\';\\n    }\\n    if (j >= 0) {\\n        carry += b.charAt(j--) - \\'0\\';\\n    }\\n    sb.append(carry % 2);\\n    carry /= 2;\\n}\\n\\n```\\n- In each iteration, the current position in each binary number is moved one digit to the left (if there are any digits left to process) by decrementing the value of i and j. \\n- If there is a carry-over value from the previous iteration or the addition of the two digits produces a carry-over value, we set the value of \\'carry\\' to 1; otherwise, we set it to 0. \\n- We also append the sum of the digits to the StringBuilder object by computing the remainder of \\'carry\\' divided by 2 (which is either 0 or 1). \\n- Finally, we update the value of \\'carry\\' by dividing it by 2 (which gives either 0 or 1) so that we can carry over any remaining value to the next iteration.\\n- After the while loop completes, we reverse the StringBuilder object and convert it to a string using the toString() method. \\n- This gives us the sum of the two binary numbers in binary format. Here is the final code:\\n```\\nreturn sb.reverse().toString();\\n\\n```\\n# Example : the sum of \"1010\" and \"1101\\n```\\n     1010\\n    +1101\\n    ______\\n    10111\\n```\\n\\n# Complexity\\n- Time complexity : O(max|a|,|b|)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(max|a|,|b|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] \\n```C++ []\\nclass Solution {\\n public:\\n  string addBinary(string a, string b) {\\n    string ans;\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry) {\\n      if (i >= 0)\\n        carry += a[i--] - \\'0\\';\\n      if (j >= 0)\\n        carry += b[j--] - \\'0\\';\\n      ans += carry % 2 + \\'0\\';\\n      carry /= 2;\\n    }\\n\\n    reverse(begin(ans), end(ans));\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution \\n{\\n  public String addBinary(String a, String b) \\n  {\\n    StringBuilder sb = new StringBuilder();\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry == 1) \\n    {\\n      if(i >= 0)\\n        carry += a.charAt(i--) - \\'0\\';\\n      if(j >= 0)\\n        carry += b.charAt(j--) - \\'0\\';\\n      sb.append(carry % 2);\\n      carry /= 2;\\n    }\\n    return sb.reverse().toString();\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def addBinary(self, a: str, b: str) -> str:\\n    s = []\\n    carry = 0\\n    i = len(a) - 1\\n    j = len(b) - 1\\n\\n    while i >= 0 or j >= 0 or carry:\\n      if i >= 0:\\n        carry += int(a[i])\\n        i -= 1\\n      if j >= 0:\\n        carry += int(b[j])\\n        j -= 1\\n      s.append(str(carry % 2))\\n      carry //= 2\\n\\n    return \\'\\'.join(reversed(s))\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/fe5d77d5-39f2-4839-9fcf-41c50106b04f_1676347139.1033723.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nStringBuilder sb = new StringBuilder();\\nint carry = 0;\\nint i = a.length() - 1;\\nint j = b.length() - 1;\\n\\n```\n```\\nwhile (i >= 0 || j >= 0 || carry == 1) {\\n    if (i >= 0) {\\n        carry += a.charAt(i--) - \\'0\\';\\n    }\\n    if (j >= 0) {\\n        carry += b.charAt(j--) - \\'0\\';\\n    }\\n    sb.append(carry % 2);\\n    carry /= 2;\\n}\\n\\n```\n```\\nreturn sb.reverse().toString();\\n\\n```\n```\\n     1010\\n    +1101\\n    ______\\n    10111\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  string addBinary(string a, string b) {\\n    string ans;\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry) {\\n      if (i >= 0)\\n        carry += a[i--] - \\'0\\';\\n      if (j >= 0)\\n        carry += b[j--] - \\'0\\';\\n      ans += carry % 2 + \\'0\\';\\n      carry /= 2;\\n    }\\n\\n    reverse(begin(ans), end(ans));\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution \\n{\\n  public String addBinary(String a, String b) \\n  {\\n    StringBuilder sb = new StringBuilder();\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry == 1) \\n    {\\n      if(i >= 0)\\n        carry += a.charAt(i--) - \\'0\\';\\n      if(j >= 0)\\n        carry += b.charAt(j--) - \\'0\\';\\n      sb.append(carry % 2);\\n      carry /= 2;\\n    }\\n    return sb.reverse().toString();\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def addBinary(self, a: str, b: str) -> str:\\n    s = []\\n    carry = 0\\n    i = len(a) - 1\\n    j = len(b) - 1\\n\\n    while i >= 0 or j >= 0 or carry:\\n      if i >= 0:\\n        carry += int(a[i])\\n        i -= 1\\n      if j >= 0:\\n        carry += int(b[j])\\n        j -= 1\\n      s.append(str(carry % 2))\\n      carry //= 2\\n\\n    return \\'\\'.join(reversed(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279879,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \\'\\'\\n\\n        a = list(a)\\n        b = list(b)\\n\\n        while a or b or carry:\\n            if a:\\n                carry += int(a.pop())\\n            if b:\\n                carry += int(b.pop())\\n\\n            result += str(carry %2)\\n            carry //= 2\\n\\n        return result[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \\'\\'\\n\\n        a = list(a)\\n        b = list(b)\\n\\n        while a or b or carry:\\n            if a:\\n                carry += int(a.pop())\\n            if b:\\n                carry += int(b.pop())\\n\\n            result += str(carry %2)\\n            carry //= 2\\n\\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680021,
                "title": "very-simple-o-n-c-solution",
                "content": "**Adding 2 binary bits :\\n0 + 0 = 0\\n1 + 0 = 1\\n0 + 1 = 1\\n1 + 1 = 10**\\n```\\nstring addBinary(string a, string b) {\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry = carry/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```\\n\\n\\n**Important point to note:**    (Reference - [here](http://codeforces.com/blog/entry/66660))\\n- `a = a + \"xy\"`\\xA0is O(N) while\\xA0`a += \"xy\"`\\xA0is O(1) (amortized).\\n    \\n    `a = a + \"xy\"`\\xA0creates a\\xA0`copy of a`, appends \"xy\" and then assigns it back to\\xA0`a`.\\n    \\n    `a += \"xy\"`\\xA0just appends \"xy\" to\\xA0`a`.\\n\\t\\nTherefore the time complexity of this approach is O(n).\\n\\n***Please Upvote, if you find the solution helpful!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring addBinary(string a, string b) {\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry = carry/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24500,
                "title": "an-accepted-concise-python-recursive-solution-10-lines",
                "content": "#add two binary from back to front, I think it is very self explained, when 1+1 we need a carry.\\n\\t#The time complex is O(m+n+c)\\uFF0Cit\\'s linear, where m=len(a)\\uFF0Cn=len(b) and c=\"count of carries, which is less than min(m,n)\".\\n\\n\\n       class Solution:\\n            def addBinary(self, a, b):\\n                if len(a)==0: return b\\n                if len(b)==0: return a\\n                if a[-1] == \\'1\\' and b[-1] == \\'1\\':\\n                    return self.addBinary(self.addBinary(a[0:-1],b[0:-1]),\\'1\\')+\\'0\\'\\n                if a[-1] == \\'0\\' and b[-1] == \\'0\\':\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'0\\'\\n                else:\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'1\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "#add two binary from back to front, I think it is very self explained, when 1+1 we need a carry.\\n\\t#The time complex is O(m+n+c)\\uFF0Cit\\'s linear, where m=len(a)\\uFF0Cn=len(b) and c=\"count of carries, which is less than min(m,n)\".\\n\\n\\n       class Solution:\\n            def addBinary(self, a, b):\\n                if len(a)==0: return b\\n                if len(b)==0: return a\\n                if a[-1] == \\'1\\' and b[-1] == \\'1\\':\\n                    return self.addBinary(self.addBinary(a[0:-1],b[0:-1]),\\'1\\')+\\'0\\'\\n                if a[-1] == \\'0\\' and b[-1] == \\'0\\':\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'0\\'\\n                else:\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'1\\'",
                "codeTag": "Java"
            },
            {
                "id": 3183091,
                "title": "c-explained-beginner-friendly-approach-self-explanatory-clean-code",
                "content": "\\n\\n# Code\\n\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n\\n\\n**The Approach goes same as like how we add two binary numbers manually firstly we have to make sizes of both the strings equal ie. the smaller sized one is to be made equal by adding zeroes at its left. then we have to handle all the caes ie. ( 11, 10, 01, 00), and we will also require a carry that will store the carry, at every step we add the values at the positions along with carry using the boolean algebra, and store carry accordingly, finally if carry is \"1\", then obviously the sum that we are getting is one bit larger than the numbers we had earlier, finally return the string**\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string addBinary(string a, string b) {\\n        \\n        \\n        if(b.size() > a.size()) swap(a,b);\\n        \\n        \\n        while(b.size() < a.size()) b = \"0\" + b;\\n\\n        int carry = 0;\\n\\n        string res = \"\";\\n\\n        for(int i = b.size()-1; i >= 0 ; --i)\\n        {\\n             \\n             if(b[i] == \\'1\\' && a[i]==\\'1\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                \\n                else res = \"1\" + res;\\n                    \\n                carry = 1;\\n             }\\n\\n             else if(b[i] ==\\'0\\' && a[i] ==\\'0\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                 \\n                else\\n                {\\n                    res = \"1\" + res;\\n                    carry = 0;\\n                }\\n             }\\n\\n             else if((b[i]==\\'0\\' && a[i]==\\'1\\') || (b[i]==\\'1\\' && a[i] == \\'0\\'))\\n             {\\n                 \\n                if(carry == 0) res = \"1\" + res;\\n                 \\n                else res = \"0\" + res;\\n                 \\n             }\\n             \\n        }\\n        \\n        if(carry == 1) res = \"1\" + res;\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/98b7adbc-5abf-45f7-9b5b-538574194654_1676344687.6513524.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string addBinary(string a, string b) {\\n        \\n        \\n        if(b.size() > a.size()) swap(a,b);\\n        \\n        \\n        while(b.size() < a.size()) b = \"0\" + b;\\n\\n        int carry = 0;\\n\\n        string res = \"\";\\n\\n        for(int i = b.size()-1; i >= 0 ; --i)\\n        {\\n             \\n             if(b[i] == \\'1\\' && a[i]==\\'1\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                \\n                else res = \"1\" + res;\\n                    \\n                carry = 1;\\n             }\\n\\n             else if(b[i] ==\\'0\\' && a[i] ==\\'0\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                 \\n                else\\n                {\\n                    res = \"1\" + res;\\n                    carry = 0;\\n                }\\n             }\\n\\n             else if((b[i]==\\'0\\' && a[i]==\\'1\\') || (b[i]==\\'1\\' && a[i] == \\'0\\'))\\n             {\\n                 \\n                if(carry == 0) res = \"1\" + res;\\n                 \\n                else res = \"0\" + res;\\n                 \\n             }\\n             \\n        }\\n        \\n        if(carry == 1) res = \"1\" + res;\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385148,
                "title": "simple-javascript-solution-using-bigint",
                "content": "Greetings comrades:\\n\\nBelow is my boring but clear solution, using the proposed [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) object.\\n\\nThe idea is to use inputs, `a` and `b` to build two binary literals.  Calculating the sum is done by calling the `BigInt` function on our binary literals, adding them together and returning the sum with a call to the `toString` method with 2 as the argument, since we are working with binary numbers.\\n\\n```javascript\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  const aBin = `0b${a}`\\n  const bBin = `0b${b}`\\n  const sum = BigInt(aBin) + BigInt(bBin)\\n  return sum.toString(2)\\n};\\n```\\n\\nThanks for looking at my solution.  Comments/feedback is appreciated. :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  const aBin = `0b${a}`\\n  const bBin = `0b${b}`\\n  const sum = BigInt(aBin) + BigInt(bBin)\\n  return sum.toString(2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24524,
                "title": "simple-accepted-java-solution",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            if(a == null || a.isEmpty()) {\\n                return b;\\n            }\\n            if(b == null || b.isEmpty()) {\\n                return a;\\n            }\\n            char[] aArray = a.toCharArray();\\n            char[] bArray = b.toCharArray();\\n            StringBuilder stb = new StringBuilder();\\n    \\n            int i = aArray.length - 1;\\n            int j = bArray.length - 1;\\n            int aByte;\\n            int bByte;\\n            int carry = 0;\\n            int result;\\n    \\n            while(i > -1 || j > -1 || carry == 1) {\\n                aByte = (i > -1) ? Character.getNumericValue(aArray[i--]) : 0;\\n                bByte = (j > -1) ? Character.getNumericValue(bArray[j--]) : 0;\\n                result = aByte ^ bByte ^ carry;\\n                carry = ((aByte + bByte + carry) >= 2) ? 1 : 0;\\n                stb.append(result);\\n            }\\n            return stb.reverse().toString();\\n        }\\n    }\\n\\nAddition bits are calculated by xor. Carry bit is calculated as simple integer addition.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            if(a == null || a.isEmpty()) {\\n                return b;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3182882,
                "title": "super-easy-solution-full-explanation-c-python3-java-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\nLet\\'s understand with an example : Addition of 1 and 1 will lead to carry 1 and print 0 , Addition of 1 and 0 give us 1 as carry will lead print 0 , Addition of last remaning carry 1 with no body will lead to print 1 , So, we get something like \"1 0 0\" as answer\\nOne key point total addition will be 3 then print 1 and carry will remain 1.\\n\\n**Adding 2 binary bits :**\\n        0 + 0 = 0\\n        1 + 0 = 1\\n        0 + 1 = 1\\n        1 + 1 = 10\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Example :**\\n- So, what\\'s going in diagram is intially **carry is \"0\"** we **add 1 + 1** we **get 2** which is **more then 1**, so there is a **carry of 1 and result is 0**. Now we have **carry of 1, again 1 + 1 is 0**, and **still left with carry of 1**. And the last carry one will be **return as it is**.\\n- So, if you see this binary number it is **[2^2 * 1 + 2^1 * 0 + 2^0 * 0]** and this is the decimal coversion of **[1 0 0] which is 4.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(max(n, m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(n, m))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider\\uD83D\\uDC4D\\n                            Thanks for visiting\\uD83D\\uDE0A\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Function to add two binary numbers represented as strings\\n    string addBinary(string a, string b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while(i >= 0 || j >= 0 || carry) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if(i >= 0) {\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if(j >= 0) {\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans += (carry % 2 + \\'0\\');\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    \\n    # Function to add two binary numbers represented as strings\\n    def addBinary(self, a, b):\\n        # List to store the result\\n        result = []\\n        # Variable to store the carry-over value\\n        carry = 0\\n        \\n        # Initialize two pointers to traverse the binary strings from right to left\\n        i, j = len(a)-1, len(b)-1\\n        \\n        # Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while i >= 0 or j >= 0 or carry:\\n            total = carry\\n            \\n            # Add the current binary digit in string a, if the pointer is still within bounds\\n            if i >= 0:\\n                total += int(a[i])\\n                i -= 1\\n            \\n            # Add the current binary digit in string b, if the pointer is still within bounds\\n            if j >= 0:\\n                total += int(b[j])\\n                j -= 1\\n            \\n            # Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            result.append(str(total % 2))\\n            \\n            # Calculate the next carry-over value by dividing the sum by 2\\n            carry = total // 2\\n            \\n        # Reverse the result and join the elements to form a single string\\n        return \\'\\'.join(reversed(result))\\n\\n```\\n```Java []\\nclass Solution {\\n    // Function to add two binary numbers represented as strings\\n    public String addBinary(String a, String b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder ans = new StringBuilder();\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if (i >= 0) {\\n                carry += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if (j >= 0) {\\n                carry += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans.append(carry % 2);\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        return ans.reverse().toString();\\n    }\\n}\\n\\n```\\n\\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Function to add two binary numbers represented as strings\\n    string addBinary(string a, string b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while(i >= 0 || j >= 0 || carry) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if(i >= 0) {\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if(j >= 0) {\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans += (carry % 2 + \\'0\\');\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    \\n    # Function to add two binary numbers represented as strings\\n    def addBinary(self, a, b):\\n        # List to store the result\\n        result = []\\n        # Variable to store the carry-over value\\n        carry = 0\\n        \\n        # Initialize two pointers to traverse the binary strings from right to left\\n        i, j = len(a)-1, len(b)-1\\n        \\n        # Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while i >= 0 or j >= 0 or carry:\\n            total = carry\\n            \\n            # Add the current binary digit in string a, if the pointer is still within bounds\\n            if i >= 0:\\n                total += int(a[i])\\n                i -= 1\\n            \\n            # Add the current binary digit in string b, if the pointer is still within bounds\\n            if j >= 0:\\n                total += int(b[j])\\n                j -= 1\\n            \\n            # Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            result.append(str(total % 2))\\n            \\n            # Calculate the next carry-over value by dividing the sum by 2\\n            carry = total // 2\\n            \\n        # Reverse the result and join the elements to form a single string\\n        return \\'\\'.join(reversed(result))\\n\\n```\n```Java []\\nclass Solution {\\n    // Function to add two binary numbers represented as strings\\n    public String addBinary(String a, String b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder ans = new StringBuilder();\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if (i >= 0) {\\n                carry += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if (j >= 0) {\\n                carry += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans.append(carry % 2);\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        return ans.reverse().toString();\\n    }\\n}\\n\\n```\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017596,
                "title": "detail-explanation-easy-single-line-97-faster",
                "content": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(\"0b\"+a) + BigInt(\"0b\"+b)).toString(2);\\n}\\n```\\n**BigInt is used to represent Integers greater than 2^53 -1.**\\n(2^53) - 1 is the Maximum Number Primitive which can be safely represented using JavaScript.\\nThis is represented by MAX_SAFE_INTEGER.\\n**We coule use parseInt(\"number\", base)** to convert the arguments \\'a\\' and \\'b\\' from binary base to decimal base and then add them together.\\nBut the **problem** here is, if we have integers, i.e a or b\\'s **binary value to be huge** (that is if the numbers passed to a or b is really big which is more than 2^52 -1), then **javascript can not process it as the max Number primitive it can work with safely is 2^53 -1 or lesser.**\\n\\nTherefore, we make use of BigInt to represent all kind of numbers, small to large Integers.\\nThe **BigInt object takes a String Integer literal** as argument and then **returns** us a number which is of the**BigInt datatype**.\\n\\nSo, here we need to pass the string (which should be an Integer Literal), as whichever base it is currently represented as.\\nIn our case we have \\'a\\' and \\'b\\' as binary numbers(strings).\\nWe need to tell **BigInt() that \\'a\\' and \\'b\\' are Binary numbers, so we append \\'0b\\' to the beginning of \\'a\\' and \\'b\\' and then pass them to BigInt().**\\nSimilarly, if we have Hexadecimal number we prefix \\'0x\\' and for Octal numbers we prefix \\'0o\\'.\\n\\nOnce we have converted our binary numbers \\'a\\' and \\'b\\' to BigInt datatype, we add them using normal addition (+) operator.\\n\\nNow, we use the **toString method to convert our BigInt number (sum calculated) to String which is a Binary, by passing the base we want to convert our argument to.**\\nstr.toString(2) converts the str string to Binary (base 2).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(\"0b\"+a) + BigInt(\"0b\"+b)).toString(2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743698,
                "title": "python-8-lines-neat-solution-explained",
                "content": "What we need to do in this problem is just add two numbers given in binary representation. How we can do it? Using usual schoolbook \\u0441olumnar addition of course! So, we need to start from the last column and add two digits and also not to forget about `carry`. We need to stop when we reached beginning of both numbers. `d1` and `d2` are current processed digits. We form `summ` string, adding element to the end and in the end we reverse it.\\n\\n**Complexity**: time complexity is `O(n + m)`, where `n` and `m` are lengths of numbers, space complexity is `O(max(m,n))`, because result will have this length.\\n\\n```\\nclass Solution:\\n    def addBinary(self, a, b):\\n        i, j, summ, carry = len(a) - 1, len(b) - 1, [], 0\\n        while i >= 0 or j >= 0 or carry:\\n            d1 = int(a[i]) if i >= 0 else 0\\n            d2 = int(b[j]) if j >= 0 else 0\\n            summ += [str((d1 + d2 + carry) % 2)]\\n            carry = (d1 + d2 + carry) // 2\\n            i, j = i-1, j-1 \\n        return \"\".join(summ[::-1])\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a, b):\\n        i, j, summ, carry = len(a) - 1, len(b) - 1, [], 0\\n        while i >= 0 or j >= 0 or carry:\\n            d1 = int(a[i]) if i >= 0 else 0\\n            d2 = int(b[j]) if j >= 0 else 0\\n            summ += [str((d1 + d2 + carry) % 2)]\\n            carry = (d1 + d2 + carry) // 2\\n            i, j = i-1, j-1 \\n        return \"\".join(summ[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24756,
                "title": "very-concise-c-solution-without-calculating-longest-string",
                "content": "I am not sure if this can be made even more concise (possibly yes), but I believe this is sufficiently concise without sacrificing readability.\\n\\n    string addBinary(string a, string b) \\n    {\\n        string result = \"\";\\n        int apos = a.size() - 1;\\n        int bpos = b.size() - 1;\\n        int adigit, bdigit, carry = 0;\\n        \\n        while (apos >= 0 || bpos >= 0 || carry == 1)\\n        {\\n            adigit = bdigit = 0;\\n            \\n            if (apos >= 0) adigit = a[apos--] == '1';\\n            if (bpos >= 0) bdigit = b[bpos--] == '1';\\n            \\n            // Another way: the digit is 1 if adigit + bdigit + carry == 1 or == 3, but I noticed that\\n            // XOR is more concise:\\n            result = static_cast<char>(adigit ^ bdigit ^ carry + '0') + result; \\n            carry = adigit + bdigit + carry >= 2;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "I am not sure if this can be made even more concise (possibly yes), but I believe this is sufficiently concise without sacrificing readability.\\n\\n    string addBinary(string a, string b) \\n    {\\n        string result = \"\";\\n        int apos = a.size() - 1;\\n        int bpos = b.size() - 1;\\n        int adigit, bdigit, carry = 0;\\n        \\n        while (apos >= 0 || bpos >= 0 || carry == 1)\\n        {\\n            adigit = bdigit = 0;\\n            \\n            if (apos >= 0) adigit = a[apos--] == '1';\\n            if (bpos >= 0) bdigit = b[bpos--] == '1';\\n            \\n            // Another way: the digit is 1 if adigit + bdigit + carry == 1 or == 3, but I noticed that\\n            // XOR is more concise:\\n            result = static_cast<char>(adigit ^ bdigit ^ carry + '0') + result; \\n            carry = adigit + bdigit + carry >= 2;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24759,
                "title": "tiny-clean-c-solution-quite-readable",
                "content": "    class Solution {\\n    public:\\n            string addBinary(string a, string b) {\\n                    string ret = \"\";\\n                    int carry = 0;\\n                    for (int i = a.size() - 1, j = b.size() - 1; i >= 0 || j >= 0; i--, j--) {\\n                            int m = (i >= 0 && a[i] == '1');\\n                            int n = (j >= 0 && b[j] == '1');\\n                            ret = to_string((m + n + carry) & 0x1) + ret;\\n                            carry = (m + n + carry) >> 1;\\n                    }\\n                    return carry ? '1' + ret : ret;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n            string addBinary(string a, string b) {\\n                    string ret = \"\";\\n                    int carry = 0;\\n                    for (int i = a.size() - 1, j = b.size() - 1; i >= 0 || j >= 0; i--, j--) {\\n                            int m = (i >= 0 && a[i] == '1');\\n                            int n = (j >= 0 && b[j] == '1');\\n                            ret = to_string((m + n + carry) & 0x1) + ret;\\n                            carry = (m + n + carry) >> 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 24752,
                "title": "c-simple-solution",
                "content": "        \\n    string addBinary(string a, string b) {\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        string ret = \"\";\\n        while (i >= 0 || j >= 0 || carry!=0) {\\n            if (i >= 0) {\\n                carry += a[i]=='0'?0:1;\\n                i--;\\n            }\\n            if (j >= 0) {\\n                carry += b[j]=='0'?0:1;\\n                j--;\\n            }\\n            ret = ((carry%2)==0?\"0\":\"1\") + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    string addBinary(string a, string b) {\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        string ret = \"\";\\n        while (i >= 0 || j >= 0 || carry!=0) {\\n            if (i >= 0) {\\n                carry += a[i]=='0'?0:1;\\n                i--;\\n            }\\n            if (j >= 0) {\\n                carry += b[j]=='0'?0:1;\\n                j--;\\n            }\\n            ret = ((carry%2)==0?\"0\":\"1\") + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2783480,
                "title": "one-liner-in-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses the BigInteger class to add two binary numbers.\\n\\n# Complexity \\n- Time complexity: $$O(n)$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\nreturn new java.math.BigInteger(a, 2).add(new java.math.BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```\\n### If you like the solution then please upvote me...........",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\nreturn new java.math.BigInteger(a, 2).add(new java.math.BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679429,
                "title": "python3-binary-addition-explained",
                "content": "To calculate the final result we use binary addition rules. For every bit:\\n> `0 + 0 = 0`\\n\\t`1 + 0 = 1`\\n\\t`1 + 1 = 0 (carry 1)`\\n\\t`1 + 1 + (carry 1) = 1 (carry 1)`\\n\\nTo simplify logic, there are couple of tricks here:\\n* The resulting bit is equal to `(aBit + bBit + carry) % 2`. That works because the bit becomes `1` only if the sum `(aBit + bBit + carry)` is greater than 2. Example: `1+1+1 = 3 => 3%2 = 1`\\n* Carry can be calculated as `(aBit + bBit + carry) // 2` (the result of division floor rounded). Example: `1+1+1 = 3 => carry = 3//2 = 1`\\n* Use negative index `i` here to iterate from the end (`list[-1]` gives the last element of the list). That allows us to have just one single index for both strings.\\n\\nSo we just iterate over characters of input strings and using addition rules calculater the result\\n\\nTime: **O(n)** - for scan\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 32 ms, faster than **80.60%** of Python3 online submissions for Add Binary.\\nMemory Usage: 14.3 MB, less than **55.41%** of Python3 online submissions for Add Binary.\\n\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        aL, bL = -len(a), -len(b)\\n        i, carry, res = -1, 0, \"\"\\n\\n        while i >= aL or i >= bL:\\n            aBit = int(a[i]) if i >= aL else 0\\n            bBit = int(b[i]) if i >= bL else 0\\n            \\n            sum = aBit + bBit + carry\\n            res = str(sum % 2) + res\\n            carry = sum // 2\\n\\n            i -= 1\\n            \\n        return \"1\" + res if carry else res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        aL, bL = -len(a), -len(b)\\n        i, carry, res = -1, 0, \"\"\\n\\n        while i >= aL or i >= bL:\\n            aBit = int(a[i]) if i >= aL else 0\\n            bBit = int(b[i]) if i >= bL else 0\\n            \\n            sum = aBit + bBit + carry\\n            res = str(sum % 2) + res\\n            carry = sum // 2\\n\\n            i -= 1\\n            \\n        return \"1\" + res if carry else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580924,
                "title": "clean-simple-c-solution-100-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        auto output = \"\"s;\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        while (i >= 0 || j >= 0 || carry) {\\n            if (i >= 0 && a[i--] == \\'1\\') ++carry;\\n            if (j >= 0 && b[j--] == \\'1\\') ++carry;\\n            output.insert(0, carry % 2 == 1 ? \"1\" : \"0\");\\n            carry /= 2;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        auto output = \"\"s;\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        while (i >= 0 || j >= 0 || carry) {\\n            if (i >= 0 && a[i--] == \\'1\\') ++carry;\\n            if (j >= 0 && b[j--] == \\'1\\') ++carry;\\n            output.insert(0, carry % 2 == 1 ? \"1\" : \"0\");\\n            carry /= 2;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24726,
                "title": "my-python-solution",
                "content": "\\n\\n    def addBinary(self, a, b):\\n        res, carry = '', 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry:\\n            curval = (i >= 0 and a[i] == '1') + (j >= 0 and b[j] == '1')\\n            carry, rem = divmod(curval + carry, 2)\\n            res = `rem` + res\\n            i -= 1\\n            j -= 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    def addBinary(self, a, b):\\n        res, carry = '', 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry:\\n            curval = (i >= 0 and a[i] == '1') + (j >= 0 and b[j] == '1')\\n            carry, rem = divmod(curval + carry, 2)\\n            res = `rem` + res\\n            i -= 1\\n            j -= 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 577148,
                "title": "simple-javascript-solution",
                "content": "```\\nlet addBinary = (a, b) => {\\n  // Truth Table\\n  // 1st + 2nd + carry = sum, new carry, decimal sum\\n  //   0 +  0  + 0 = 0, 0 (0)\\n  //   0 +  0  + 1 = 1, 0 (1)\\n  //   0 +  1  + 1 = 0, 1 (2)\\n  //   1 +  1  + 1 = 1, 1 (3)\\n\\n  let carry = 0;\\n  let result = \\'\\';\\n\\n  let len1 = a.length - 1;\\n  let len2 = b.length - 1;\\n\\n  for (; len1 >= 0 || len2 >= 0 || carry > 0; len1--, len2--) {\\n    let sum = (+a[len1] || 0) + (+b[len2] || 0) + carry;\\n    if (sum > 1) {\\n      sum = sum % 2;\\n      carry = 1;\\n    } else {\\n      carry = 0;\\n    }\\n    result = `${sum}${result}`;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet addBinary = (a, b) => {\\n  // Truth Table\\n  // 1st + 2nd + carry = sum, new carry, decimal sum\\n  //   0 +  0  + 0 = 0, 0 (0)\\n  //   0 +  0  + 1 = 1, 0 (1)\\n  //   0 +  1  + 1 = 0, 1 (2)\\n  //   1 +  1  + 1 = 1, 1 (3)\\n\\n  let carry = 0;\\n  let result = \\'\\';\\n\\n  let len1 = a.length - 1;\\n  let len2 = b.length - 1;\\n\\n  for (; len1 >= 0 || len2 >= 0 || carry > 0; len1--, len2--) {\\n    let sum = (+a[len1] || 0) + (+b[len2] || 0) + carry;\\n    if (sum > 1) {\\n      sum = sum % 2;\\n      carry = 1;\\n    } else {\\n      carry = 0;\\n    }\\n    result = `${sum}${result}`;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24562,
                "title": "one-line-python-solution",
                "content": "    class Solution:\\n        def addBinary(self, a, b):\\n            return bin(eval('0b' + a) + eval('0b' + b))[2:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def addBinary(self, a, b):\\n            return bin(eval('0b' + a) + eval('0b' + b))[2:]",
                "codeTag": "Java"
            },
            {
                "id": 24667,
                "title": "13-lines-easy-java-solution-simple-and-elegant",
                "content": "    public String addBinary(String a, String b) {\\n        int lena = a.length();\\n        int lenb = b.length();\\n        int i =0, carry = 0;\\n        String res = \"\";\\n        while(i<lena || i<lenb || carry!=0){\\n            int x = (i<lena) ? Character.getNumericValue(a.charAt(lena - 1 - i)) : 0;\\n            int y = (i<lenb) ? Character.getNumericValue(b.charAt(lenb - 1 - i)) : 0;\\n            res = (x + y + carry)%2 + res;\\n            carry = (x + y + carry)/2;\\n            i++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public String addBinary(String a, String b) {\\n        int lena = a.length();\\n        int lenb = b.length();\\n        int i =0, carry = 0;\\n        String res = \"\";\\n        while(i<lena || i<lenb || carry!=0){\\n            int x = (i<lena) ? Character.getNumericValue(a.charAt(lena - 1 - i)) : 0;\\n            int y = (i<lenb) ? Character.getNumericValue(b.charAt(lenb - 1 - i)) : 0;\\n            res = (x + y + carry)%2 + res;\\n            carry = (x + y + carry)/2;\\n            i++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 743586,
                "title": "self-explanatory-detailed-steps-2-solution-java-1-liner-using-biginteger",
                "content": "\\n**Approach:**\\n1. Intialize i & j index for a and from last character index of a & b\\n2. Loop over for both index until anyone reach 0, add last bit of both string along with carry intilized with 0. reminder from 2 is the new bit and divide by 2 is carry.\\n3. check if i >= 0 repeat for string a\\n4. check if j >= 0 repeat for string b\\n5. check if carry != 0 - add carry in sb.\\n6. return reverse of sb.\\n\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int sum = 0;\\n        while(i >= 0 && j >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(i >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(j >= 0) {\\n            sum = b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        if(carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n********\\n\\nWe can also combine 3 while loops used in above code into 1 like below.\\n\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        \\n        while (i >= 0 || j >= 0) {\\n            int sum = carry;\\n            if (i >= 0) sum += a.charAt(i--) - \\'0\\';\\n\\t\\t\\tif (j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        if (carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n********\\n**1-Liner with BigInteger**\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```\\n\\n********\\nIf you have any doubt and question ask in comment. If you like solution upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int sum = 0;\\n        while(i >= 0 && j >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(i >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(j >= 0) {\\n            sum = b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        if(carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        \\n        while (i >= 0 || j >= 0) {\\n            int sum = carry;\\n            if (i >= 0) sum += a.charAt(i--) - \\'0\\';\\n\\t\\t\\tif (j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        if (carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307335,
                "title": "javascript-super-easy-to-understand-and-beat-92",
                "content": "```\\nvar addBinary = function(a, b) {\\n    a = a.split(\"\").reverse().join(\"\");\\n    b = b.split(\"\").reverse().join(\"\");\\n    len = a.length > b.length ? a.length : b.length;\\n    result = [];\\n    for(let i = 0; i < len; i += 1){\\n        num1 = Number(a[i] || 0);\\n        num2 = Number(b[i]) || 0;\\n        curr = Number(result[i]||0) + num1 + num2\\n        if(curr >= 2){\\n            result[i] = curr%2;\\n            result.push(1)\\n        }\\n        else{\\n            result[i] = curr\\n        }\\n    }\\n    return result.reverse().join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    a = a.split(\"\").reverse().join(\"\");\\n    b = b.split(\"\").reverse().join(\"\");\\n    len = a.length > b.length ? a.length : b.length;\\n    result = [];\\n    for(let i = 0; i < len; i += 1){\\n        num1 = Number(a[i] || 0);\\n        num2 = Number(b[i]) || 0;\\n        curr = Number(result[i]||0) + num1 + num2\\n        if(curr >= 2){\\n            result[i] = curr%2;\\n            result.push(1)\\n        }\\n        else{\\n            result[i] = curr\\n        }\\n    }\\n    return result.reverse().join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236550,
                "title": "my-c-solution",
                "content": "```\\nchar* addBinary(char* a, char* b)\\n{\\n    int i, j, k, c = 0;\\n    char *res;\\n    \\n    i = strlen(a);\\n    j = strlen(b);\\n    k = i > j ? i : j;\\n    k += 2;\\n\\n    res = malloc(k * sizeof(char));\\n    \\n    i--;\\n    j--;\\n    res[--k] = \\'\\\\0\\';\\n    \\n    while (--k >= 0) {\\n        c += i >= 0 ? a[i--] - \\'0\\': 0;\\n        c += j >= 0 ? b[j--] - \\'0\\': 0;\\n        \\n        res[k] = c % 2 + \\'0\\';\\n        c /= 2;\\n    }\\n    \\n    if (res[0] == \\'0\\')\\n       memmove(res, res + 1, strlen(res) * sizeof(char));\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* addBinary(char* a, char* b)\\n{\\n    int i, j, k, c = 0;\\n    char *res;\\n    \\n    i = strlen(a);\\n    j = strlen(b);\\n    k = i > j ? i : j;\\n    k += 2;\\n\\n    res = malloc(k * sizeof(char));\\n    \\n    i--;\\n    j--;\\n    res[--k] = \\'\\\\0\\';\\n    \\n    while (--k >= 0) {\\n        c += i >= 0 ? a[i--] - \\'0\\': 0;\\n        c += j >= 0 ? b[j--] - \\'0\\': 0;\\n        \\n        res[k] = c % 2 + \\'0\\';\\n        c /= 2;\\n    }\\n    \\n    if (res[0] == \\'0\\')\\n       memmove(res, res + 1, strlen(res) * sizeof(char));\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798567,
                "title": "short-and-simple-logic-with-explanation-beats-100-c",
                "content": "```\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        while(i>=0 || j>=0)\\n        {\\n            int x = (i>=0)?a[i--]-\\'0\\':0; // subtract with 0, to convert it to int\\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            s.append(to_string(sum%2)); // 1+1 = 2, 2%2=0, this is enough to explain %2\\n            carry = sum/2;// 1+1=2, 2/2=1, carry is one, OR 1+0=1,1/2=0,carry = 0\\n        }\\n        if(carry>0)\\n               s.append(to_string(1));//if carry generated by last two digits is > 0, append in RESULT\\n        reverse(s.begin() , s.end()); //if you use insert() then reverse is not necessary\\n        return s;   \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        while(i>=0 || j>=0)\\n        {\\n            int x = (i>=0)?a[i--]-\\'0\\':0; // subtract with 0, to convert it to int\\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            s.append(to_string(sum%2)); // 1+1 = 2, 2%2=0, this is enough to explain %2\\n            carry = sum/2;// 1+1=2, 2/2=1, carry is one, OR 1+0=1,1/2=0,carry = 0\\n        }\\n        if(carry>0)\\n               s.append(to_string(1));//if carry generated by last two digits is > 0, append in RESULT\\n        reverse(s.begin() , s.end()); //if you use insert() then reverse is not necessary\\n        return s;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057915,
                "title": "fast-javascript-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    // we used BigInt() to convert binary to Integer. Syntax is BigInt(0b11) here `0b` is prefix and `11` is binary number\\n    let sum = BigInt(`0b${a}`) + BigInt(`0b${b}`);\\n    // sum is converted back to string using toString(2), here 2 is radix argument, so toString(2) converts to binary\\n    return sum.toString(2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    // we used BigInt() to convert binary to Integer. Syntax is BigInt(0b11) here `0b` is prefix and `11` is binary number\\n    let sum = BigInt(`0b${a}`) + BigInt(`0b${b}`);\\n    // sum is converted back to string using toString(2), here 2 is radix argument, so toString(2) converts to binary\\n    return sum.toString(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24659,
                "title": "simple-python-solution-76ms",
                "content": "I assume using `int` and `str` is okay, I think this is easy to understand.\\n\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = int(num_a) + int(num_b) + int(carry)\\n            result = str(val % 2) + result\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n\\n================== update ===============\\n\\nNo `int` and `str` version.\\n\\n    class Solution:\\n    # @param a, a string\\n    # @param b, a string\\n    # @return a string\\n    # 75ms\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry)\\n            result = \"%s%s\" % (val % 2, result)\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n    \\n    def to_int(self, c):\\n        if c == '1':\\n            return 1\\n        elif c == '0':\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "I assume using `int` and `str` is okay, I think this is easy to understand.\\n\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = int(num_a) + int(num_b) + int(carry)\\n            result = str(val % 2) + result\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n\\n================== update ===============\\n\\nNo `int` and `str` version.\\n\\n    class Solution:\\n    # @param a, a string\\n    # @param b, a string\\n    # @return a string\\n    # 75ms\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry)\\n            result = \"%s%s\" % (val % 2, result)\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n    \\n    def to_int(self, c):\\n        if c == '1':\\n            return 1\\n        elif c == '0':\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 3183112,
                "title": "day-45-c-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nThe intuition behind the given code is to perform binary addition by converting the binary strings to their integer equivalent and then adding them.\\n\\nThe given code first reverses the input binary strings \\'a\\' and \\'b\\' so that the least significant bit is at index 0, making it easier to calculate the corresponding decimal value of each bit using powers of 2. It then iterates over each bit of the reversed \\'a\\' and \\'b\\' and calculates the decimal value of each bit.\\n\\nIt does this by taking the integer equivalent of each binary digit (0 or 1), multiplying it by the corresponding power of 2 (2 raised to the index of the digit), and adding this to the running sum. The running sum is then added together to get the decimal value of the two binary strings.\\n\\nThe decimal sum is then converted back into a binary string by performing repeated division by 2 and recording the remainders in reverse order until the sum becomes zero. The binary string is then reversed and returned as the final output.\\n\\nWhile this approach can work for smaller binary numbers, it may not be suitable for larger binary strings as it can result in overflow errors due to the use of integer variables.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty string called result to store the binary sum of the two input strings.\\n2. Initialize a variable called carry to store the carry generated during the binary addition.\\n3. Start from the last digit of both input strings and move towards the left.\\n4. In each iteration, add the current digits of both strings and the carry generated in the previous iteration.\\n5. Compute the sum modulo 2 and append the result to the result string.\\n6. Compute the carry as the integer division of the sum by 2.\\n7. Repeat steps 4-6 until there are no more digits in both input strings and the carry is zero.\\n8. Reverse the result string and return it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string result = \"\";\\n        int carry = 0;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        while (i >= 0 || j >= 0 || carry) {\\n            int sum = carry;\\n            if (i >= 0) {\\n              sum += a[i] - \\'0\\';\\n              i--;\\n            }\\n            if (j >= 0) {\\n              sum += b[j] - \\'0\\';\\n              j--;\\n            }\\n            carry = sum / 2;\\n            result += to_string(sum % 2);\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        String result = \"\";\\n        int carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            int sum = carry;\\n            if (i >= 0) {\\n                sum += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            if (j >= 0) {\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            carry = sum / 2;\\n            result = (sum % 2) + result;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        result = \"\"\\n        carry = 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry != 0:\\n            sum = carry\\n            if i >= 0:\\n                sum += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                sum += int(b[j])\\n                j -= 1\\n            carry = sum // 2\\n            result = str(sum % 2) + result\\n        return result\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(max(n,m))** where n and m are the lengths of the input strings a and b respectively. We need to perform at most max(n,m) iterations to add the two strings.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(max(n,m))** for storing the result string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string result = \"\";\\n        int carry = 0;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        while (i >= 0 || j >= 0 || carry) {\\n            int sum = carry;\\n            if (i >= 0) {\\n              sum += a[i] - \\'0\\';\\n              i--;\\n            }\\n            if (j >= 0) {\\n              sum += b[j] - \\'0\\';\\n              j--;\\n            }\\n            carry = sum / 2;\\n            result += to_string(sum % 2);\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        String result = \"\";\\n        int carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            int sum = carry;\\n            if (i >= 0) {\\n                sum += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            if (j >= 0) {\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            carry = sum / 2;\\n            result = (sum % 2) + result;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        result = \"\"\\n        carry = 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry != 0:\\n            sum = carry\\n            if i >= 0:\\n                sum += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                sum += int(b[j])\\n                j -= 1\\n            carry = sum // 2\\n            result = str(sum % 2) + result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680441,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        x=int(a,2)\\n        y=int(b,2)\\n        return bin(x+y)[2:]\\n```\\n\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        x=int(a,2)\\n        y=int(b,2)\\n        return bin(x+y)[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201676,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n\\t\\t\\tvar sb = new StringBuilder();\\n            var t = 0;\\n            for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0 || t > 0; i--, j--)\\n            {\\n                var av = i < 0 || a[i] == \\'0\\' ? 0 : 1;\\n                var bv = j < 0 || b[j] == \\'0\\' ? 0 : 1;\\n                sb.Insert(0, (av + bv + t) % 2);\\n                t = (av + bv + t) / 2;\\n            }\\n\\n            return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n\\t\\t\\tvar sb = new StringBuilder();\\n            var t = 0;\\n            for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0 || t > 0; i--, j--)\\n            {\\n                var av = i < 0 || a[i] == \\'0\\' ? 0 : 1;\\n                var bv = j < 0 || b[j] == \\'0\\' ? 0 : 1;\\n                sb.Insert(0, (av + bv + t) % 2);\\n                t = (av + bv + t) / 2;\\n            }\\n\\n            return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24770,
                "title": "python-easy-to-understand-solution-with-two-pointer",
                "content": "\\n    def addBinary(self, a, b):\\n        i, j, carry, res = len(a)-1, len(b)-1, 0, \"\"\\n        while i >= 0 or j >= 0 or carry:\\n            if i >= 0:\\n                carry += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                carry += int(b[j])\\n                j -= 1\\n            res = str(carry%2) + res\\n            carry //= 2\\n        return res",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def addBinary(self, a, b):\\n        i, j, carry, res = len(a)-1, len(b)-1, 0, \"\"\\n        while i >= 0 or j >= 0 or carry:\\n            if i >= 0:\\n                carry += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                carry += int(b[j])\\n                j -= 1\\n            res = str(carry%2) + res\\n            carry //= 2\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2061593,
                "title": "c-beginner-friendly",
                "content": "```\\nchar * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }\\n        if(sizeB > 0) {\\n            sum += b[--sizeB] - \\'0\\';\\n        }\\n        output[--sizeOutput] = sum % 2 + \\'0\\';\\n        sum /= 2;\\n    }\\n    return output + sizeOutput;   \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }\\n        if(sizeB > 0) {\\n            sum += b[--sizeB] - \\'0\\';\\n        }\\n        output[--sizeOutput] = sum % 2 + \\'0\\';\\n        sum /= 2;\\n    }\\n    return output + sizeOutput;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915690,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-n-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n + m), where n is the length of the a and m is the length of the b.\\n    //   - space: O(n + m), where n is the length of the a and m is the length of the b.\\n\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        guard !a.isEmpty else { return b }\\n        guard !b.isEmpty else { return a }\\n\\n        var carry = 0\\n        let a = Array(a)\\n        let b = Array(b)\\n        var i = a.count - 1\\n        var j = b.count - 1\\n        var ans = [Int]()\\n\\n        while i >= 0 || j >= 0 || carry != 0 {\\n            var sum = carry\\n            if i >= 0, a[i] == \"1\" { sum += 1 }\\n            if j >= 0, b[j] == \"1\" { sum += 1 }\\n\\n            let digit = sum % 2\\n            carry = sum / 2\\n            ans.append(digit)\\n\\n            i -= 1\\n            j -= 1\\n        }\\n\\n        return ans.map { String($0) }.reversed().joined()\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n + m), where n is the length of the a and m is the length of the b.\\n    //   - space: O(n + m), where n is the length of the a and m is the length of the b.\\n\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        guard !a.isEmpty else { return b }\\n        guard !b.isEmpty else { return a }\\n\\n        var carry = 0\\n        let a = Array(a)\\n        let b = Array(b)\\n        var i = a.count - 1\\n        var j = b.count - 1\\n        var ans = [Int]()\\n\\n        while i >= 0 || j >= 0 || carry != 0 {\\n            var sum = carry\\n            if i >= 0, a[i] == \"1\" { sum += 1 }\\n            if j >= 0, b[j] == \"1\" { sum += 1 }\\n\\n            let digit = sum % 2\\n            carry = sum / 2\\n            ans.append(digit)\\n\\n            i -= 1\\n            j -= 1\\n        }\\n\\n        return ans.map { String($0) }.reversed().joined()\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633397,
                "title": "simple-easy-c-solution",
                "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n         \\n       string res;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0) {\\n            sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            res += to_string(sum % 2);  \\n\\t\\t\\t                                         \\n            carry = sum / 2;\\n            \\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\n\\n// if you like this solution please do upvote me //\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n         \\n       string res;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0) {\\n            sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            res += to_string(sum % 2);  \\n\\t\\t\\t                                         \\n            carry = sum / 2;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 538786,
                "title": "js-single-line-98-using-template-strings",
                "content": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(`0b${a}`) + BigInt(`0b${b}`)).toString(2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(`0b${a}`) + BigInt(`0b${b}`)).toString(2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24708,
                "title": "another-simple-java",
                "content": "    public String addBinary(String a, String b) {\\n        if(a == null || b ==null)\\n            return a == null? b: a;\\n            \\n        int carry =0;\\n        StringBuilder sb = new StringBuilder();        \\n        \\n        for(int i = a.length()-1, j = b.length() -1;  i >=0 || j >=0 || carry >0 ; i --, j --){\\n            int sum = 0;\\n            sum += (i >=0) ? a.charAt(i) - '0' : 0;\\n            sum += (j >=0) ? b.charAt(j) - '0' : 0;\\n            sum += carry;\\n            \\n            carry = sum /2;\\n            sum %=2;\\n            sb.append(sum);\\n        }\\n        \\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String addBinary(String a, String b) {\\n        if(a == null || b ==null)\\n            return a == null? b: a;\\n            \\n        int carry =0;\\n        StringBuilder sb = new StringBuilder();        \\n        \\n        for(int i = a.length()-1, j = b.length() -1;  i >=0 || j >=0 || carry >0 ; i --, j --){\\n            int sum = 0;\\n            sum += (i >=0) ? a.charAt(i) - '0' : 0;\\n            sum += (j >=0) ? b.charAt(j) - '0' : 0;\\n            sum += carry;\\n            \\n            carry = sum /2;\\n            sum %=2;\\n            sb.append(sum);\\n        }\\n        \\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24783,
                "title": "simple-c-code-implementing-a-full-adder",
                "content": "    char* addBinary(char* a, char* b) {\\n    int la = strlen(a);\\n    int lb = strlen(b);\\n    int lr = la > lb ? la : lb;\\n    int carry = 0;\\n    char *res = (char*)calloc(lr + 2, sizeof(char));\\n    res[lr + 1] = '\\\\0';\\n    la--; lb--;\\n    while (la >= 0 || lb >= 0) {\\n        int ba = la >= 0 ? a[la--] - '0' : 0;\\n        int bb = lb >= 0 ? b[lb--] - '0' : 0;\\n        int br = ba ^ bb ^ carry;\\n        carry = (ba & bb) | (carry & (ba ^ bb));\\n        res[lr--] = br + '0';\\n    }\\n    if (!carry) return res + 1;\\n    res[0] = '1';\\n    return res;\\n}",
                "solutionTags": [],
                "code": "    char* addBinary(char* a, char* b) {\\n    int la = strlen(a);\\n    int lb = strlen(b);\\n    int lr = la > lb ? la : lb;\\n    int carry = 0;\\n    char *res = (char*)calloc(lr + 2, sizeof(char));\\n    res[lr + 1] = '\\\\0';\\n    la--; lb--;\\n    while (la >= 0 || lb >= 0) {\\n        int ba = la >= 0 ? a[la--] - '0' : 0;\\n        int bb = lb >= 0 ? b[lb--] - '0' : 0;\\n        int br = ba ^ bb ^ carry;\\n        carry = (ba & bb) | (carry & (ba ^ bb));\\n        res[lr--] = br + '0';\\n    }\\n    if (!carry) return res + 1;\\n    res[0] = '1';\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3519981,
                "title": "c-java-python-javascript-detailed-explanation-easy-to-understand",
                "content": "# Intuition:\\nThe problem is to add two binary numbers represented as strings, i.e., \"101\" + \"110\" should give \"1011\". We can start by aligning the two binary numbers by adding leading zeros to the shorter string so that both strings have equal lengths. Then we can add the digits from right to left and keep track of any carry generated. Finally, we add the carry to the leftmost position if any.\\n\\n# Approach:\\n1. Calculate the lengths of the two input strings.\\n2. If the length of string a is greater than that of string b, add leading zeros to string b to make its length equal to that of string a. Otherwise, add leading zeros to string a to make its length equal to that of string b.\\n3. Initialize carry to 0 and an empty string ans.\\n4. Traverse the two input strings from right to left, one character at a time.\\n5. For each character, add its value with the corresponding character from the other string and the carry.\\n6. Determine the value of the current bit and the carry generated.\\n7. Add the current bit to the left end of the ans string.\\n8. Finally, if there is any carry left, add it to the leftmost position of the ans string.\\n9. Return the ans string.\\n\\n# Complexity:\\n- Time Complexity: The algorithm has a time complexity of O(N), where N is the length of the longer input string. This is because we traverse the input strings once from right to left, which takes O(N) time. \\n- Space Complexity: The algorithm has a space complexity of O(N), where N is the length of the longer input string. This is because we store the result in an ans string which can have a maximum length of N+1.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int l1=a.length();\\n        int l2=b.length();\\n        if(a.length()>b.length()){\\n            int diff=(a.length()-b.length());\\n            for(int i=0;i<diff;i++){\\n                b=\"0\"+b;\\n            }\\n        }\\n        if(a.length()<b.length()){\\n            int diff=(b.length()-a.length());\\n            for(int i=0;i<diff;i++){\\n                a=\"0\"+a;\\n            }\\n        }\\n        int carry=0;\\n        string ans=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            cout<<a[i]<<\"+\"<<b[i]<<\"+\"<<carry<<endl;\\n            if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"0\"+ans;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n        }\\n        if(carry==1){\\n            ans=\"1\"+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# JAVA\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int l1 = a.length();\\n        int l2 = b.length();\\n        if (a.length() > b.length()) {\\n            int diff = a.length() - b.length();\\n            for (int i = 0; i < diff; i++) {\\n                b = \"0\" + b;\\n            }\\n        }\\n        if (a.length() < b.length()) {\\n            int diff = b.length() - a.length();\\n            for (int i = 0; i < diff; i++) {\\n                a = \"0\" + a;\\n            }\\n        }\\n        int carry = 0;\\n        String ans = \"\";\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n            if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            }\\n        }\\n        if (carry == 1) {\\n            ans = \"1\" + ans;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        l1 = len(a)\\n        l2 = len(b)\\n        if len(a) > len(b):\\n            diff = len(a) - len(b)\\n            for i in range(diff):\\n                b = \"0\" + b\\n        if len(a) < len(b):\\n            diff = len(b) - len(a)\\n            for i in range(diff):\\n                a = \"0\" + a\\n        carry = 0\\n        ans = \"\"\\n        for i in range(len(a) - 1, -1, -1):\\n            if a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"0\" + ans\\n            elif a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n        if carry == 1:\\n            ans = \"1\" + ans\\n        return ans\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```\\nvar addBinary = function(a, b) {\\n    let l1 = a.length;\\n    let l2 = b.length;\\n    if (a.length > b.length) {\\n        let diff = a.length - b.length;\\n        for (let i = 0; i < diff; i++) {\\n            b = \"0\" + b;\\n        }\\n    }\\n    if (a.length < b.length) {\\n        let diff = b.length - a.length;\\n        for (let i = 0; i < diff; i++) {\\n            a = \"0\" + a;\\n        }\\n    }\\n    let carry = 0;\\n    let ans = \"\";\\n    for (let i = a.length - 1; i >= 0; i--) {\\n        if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        }\\n    }\\n    if (carry === 1) {\\n        ans = \"1\" + ans;\\n    }\\n    return ans; \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int l1=a.length();\\n        int l2=b.length();\\n        if(a.length()>b.length()){\\n            int diff=(a.length()-b.length());\\n            for(int i=0;i<diff;i++){\\n                b=\"0\"+b;\\n            }\\n        }\\n        if(a.length()<b.length()){\\n            int diff=(b.length()-a.length());\\n            for(int i=0;i<diff;i++){\\n                a=\"0\"+a;\\n            }\\n        }\\n        int carry=0;\\n        string ans=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            cout<<a[i]<<\"+\"<<b[i]<<\"+\"<<carry<<endl;\\n            if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"0\"+ans;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n        }\\n        if(carry==1){\\n            ans=\"1\"+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int l1 = a.length();\\n        int l2 = b.length();\\n        if (a.length() > b.length()) {\\n            int diff = a.length() - b.length();\\n            for (int i = 0; i < diff; i++) {\\n                b = \"0\" + b;\\n            }\\n        }\\n        if (a.length() < b.length()) {\\n            int diff = b.length() - a.length();\\n            for (int i = 0; i < diff; i++) {\\n                a = \"0\" + a;\\n            }\\n        }\\n        int carry = 0;\\n        String ans = \"\";\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n            if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            }\\n        }\\n        if (carry == 1) {\\n            ans = \"1\" + ans;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        l1 = len(a)\\n        l2 = len(b)\\n        if len(a) > len(b):\\n            diff = len(a) - len(b)\\n            for i in range(diff):\\n                b = \"0\" + b\\n        if len(a) < len(b):\\n            diff = len(b) - len(a)\\n            for i in range(diff):\\n                a = \"0\" + a\\n        carry = 0\\n        ans = \"\"\\n        for i in range(len(a) - 1, -1, -1):\\n            if a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"0\" + ans\\n            elif a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n        if carry == 1:\\n            ans = \"1\" + ans\\n        return ans\\n\\n```\n```\\nvar addBinary = function(a, b) {\\n    let l1 = a.length;\\n    let l2 = b.length;\\n    if (a.length > b.length) {\\n        let diff = a.length - b.length;\\n        for (let i = 0; i < diff; i++) {\\n            b = \"0\" + b;\\n        }\\n    }\\n    if (a.length < b.length) {\\n        let diff = b.length - a.length;\\n        for (let i = 0; i < diff; i++) {\\n            a = \"0\" + a;\\n        }\\n    }\\n    let carry = 0;\\n    let ans = \"\";\\n    for (let i = a.length - 1; i >= 0; i--) {\\n        if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        }\\n    }\\n    if (carry === 1) {\\n        ans = \"1\" + ans;\\n    }\\n    return ans; \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3183207,
                "title": "java-easy-solution-with-detailed-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We have to find the `sum` so we need to start from the **right** end of both the numbers.\\n- To start iterating from the right end of the strings we first calculated the last indices `indexA` & `indexB`\\n- To store the digits sum we initialized `digitSum=0`\\n- To store the carry we initialized `carry=0`\\n- Then we keep a check if `a` & `b` is non-Empty if yes we increase the `digitSum`\\n- To keep check of the `carry`, we check if `digitSum > 1`. If yes, that means there is a `carry` and it needs to be considered.\\n\\n- At last, we insert the calculated digit at the start of the StringBuilder.\\n- And then return the sum after converting it to String via `toString()`. \\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please give this an UPVOTE if you find it useful!\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sum= new StringBuilder(\"\");\\n        int indexA= a.length()-1;\\n        int indexB =b.length()-1;\\n        int carry=0;\\n        int digitSum=0;\\n        while(indexA >= 0 || indexB >= 0 || carry > 0 ){\\n            digitSum = carry;\\n            if(indexA >= 0) digitSum += a.charAt(indexA--)-\\'0\\';\\n            if(indexB >= 0) digitSum += b.charAt(indexB--)-\\'0\\';\\n            if(digitSum >1) carry=1;\\n            else carry=0;\\n            sum.insert(0, digitSum%2);\\n        }\\n        return sum.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sum= new StringBuilder(\"\");\\n        int indexA= a.length()-1;\\n        int indexB =b.length()-1;\\n        int carry=0;\\n        int digitSum=0;\\n        while(indexA >= 0 || indexB >= 0 || carry > 0 ){\\n            digitSum = carry;\\n            if(indexA >= 0) digitSum += a.charAt(indexA--)-\\'0\\';\\n            if(indexB >= 0) digitSum += b.charAt(indexB--)-\\'0\\';\\n            if(digitSum >1) carry=1;\\n            else carry=0;\\n            sum.insert(0, digitSum%2);\\n        }\\n        return sum.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372361,
                "title": "java-1ms-100-100-simple-explanation-without-converting-char-in-one-loop",
                "content": "```java\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        boolean carry = false;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\t\\t// Create a buffer with length equal to the bigger input String  + 1 to carry overflow\\n\\t\\t// Result of \\'11\\' + \\'1\\' = \\'100\\', so length(\\'11\\') + 1 = 3\\n        StringBuilder result = new StringBuilder(((i > j) ? i : j) + 1); \\n        \\n        while (i >= 0 || j >= 0) {\\n\\t\\t\\t// if one of the input is shorter, use \\'0\\' as operand. \\'11\\' + \\'1\\' = \\'11\\' + \\'01\\'\\n            char charA = (i >= 0) ? a.charAt(i--) : \\'0\\'; \\n            char charB = (j >= 0) ? b.charAt(j--) : \\'0\\';\\n            \\n\\t\\t\\t// Cases when adding Binary\\t\\t\\t\\n\\t\\t\\t// 0 + 0 = 0 \\n\\t\\t\\t// 1 + 0 = 1\\n\\t\\t\\t// 1 + 1 = 10 \\n\\t\\t\\t// 1 + 1 + 1 = 11\\n            if (charA == \\'1\\' && charB == \\'1\\') { // 1 + 1\\n\\t\\t\\t\\tresult = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 11 or 10 ?\\n\\t\\t\\t\\tcarry = true;\\n            } else if (charA == \\'0\\' && charB == \\'0\\') { // 0 + 0\\n                result = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 1 or 0 ?\\n                carry = false;\\n            } else { // 1 + 0 or 0 + 1\\n                result = (carry) ? result.append(\\'0\\') : result.append(\\'1\\'); // result is 10 or 1 ?\\n            }\\n        }\\n        \\n\\t\\t// carry overflow : \\'11\\' + \\'1\\' = \\'00\\' + 1 overflow = \\'001\\'\\n        if (carry) result.append(\\'1\\');\\n        \\n\\t\\t// reverse the result string : \\'11\\' + \\'1\\' = \\'001\\' , so reverse it to obtain \\'100\\'\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        boolean carry = false;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\t\\t// Create a buffer with length equal to the bigger input String  + 1 to carry overflow\\n\\t\\t// Result of \\'11\\' + \\'1\\' = \\'100\\', so length(\\'11\\') + 1 = 3\\n        StringBuilder result = new StringBuilder(((i > j) ? i : j) + 1); \\n        \\n        while (i >= 0 || j >= 0) {\\n\\t\\t\\t// if one of the input is shorter, use \\'0\\' as operand. \\'11\\' + \\'1\\' = \\'11\\' + \\'01\\'\\n            char charA = (i >= 0) ? a.charAt(i--) : \\'0\\'; \\n            char charB = (j >= 0) ? b.charAt(j--) : \\'0\\';\\n            \\n\\t\\t\\t// Cases when adding Binary\\t\\t\\t\\n\\t\\t\\t// 0 + 0 = 0 \\n\\t\\t\\t// 1 + 0 = 1\\n\\t\\t\\t// 1 + 1 = 10 \\n\\t\\t\\t// 1 + 1 + 1 = 11\\n            if (charA == \\'1\\' && charB == \\'1\\') { // 1 + 1\\n\\t\\t\\t\\tresult = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 11 or 10 ?\\n\\t\\t\\t\\tcarry = true;\\n            } else if (charA == \\'0\\' && charB == \\'0\\') { // 0 + 0\\n                result = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 1 or 0 ?\\n                carry = false;\\n            } else { // 1 + 0 or 0 + 1\\n                result = (carry) ? result.append(\\'0\\') : result.append(\\'1\\'); // result is 10 or 1 ?\\n            }\\n        }\\n        \\n\\t\\t// carry overflow : \\'11\\' + \\'1\\' = \\'00\\' + 1 overflow = \\'001\\'\\n        if (carry) result.append(\\'1\\');\\n        \\n\\t\\t// reverse the result string : \\'11\\' + \\'1\\' = \\'001\\' , so reverse it to obtain \\'100\\'\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24476,
                "title": "super-short-java-code",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sum = new StringBuilder();\\n            int i = a.length() - 1;\\n            int j = b.length() - 1;\\n            int carry = 0;\\n            while (i >= 0 || j >= 0 || carry == 1) {\\n                int digitA = i < 0 ? 0 : a.charAt(i--) - '0';\\n                int digitB = j < 0 ? 0 : b.charAt(j--) - '0';\\n                sum.insert(0, (digitA + digitB + carry) % 2);\\n                carry = (digitA + digitB + carry) / 2;\\n            }\\n            return sum.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sum = new StringBuilder();\\n            int i = a.length() - 1;\\n            int j = b.length() - 1;\\n            int carry = 0;\\n            while (i >= 0 || j >= 0 || carry == 1) {\\n                int digitA = i < 0 ? 0 : a.charAt(i--) - '0';\\n                int digitB = j < 0 ? 0 : b.charAt(j--) - '0';\\n                sum.insert(0, (digitA + digitB + carry) % 2);\\n                carry = (digitA + digitB + carry) / 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 294845,
                "title": "one-line-java-solution",
                "content": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203758,
                "title": "very-simple-swift-solution",
                "content": "```\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        var a = a, b = b\\n        var carry = 0\\n        var result = \"\"\\n        while !a.isEmpty || !b.isEmpty || carry > 0 {\\n            let x = Int(a.isEmpty ? \"0\" : String(a.removeLast()))!\\n            let y = Int(b.isEmpty ? \"0\" : String(b.removeLast()))!\\n            let sum = x + y + carry\\n            result = String(sum % 2) + result\\n            carry = sum / 2\\n        }        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        var a = a, b = b\\n        var carry = 0\\n        var result = \"\"\\n        while !a.isEmpty || !b.isEmpty || carry > 0 {\\n            let x = Int(a.isEmpty ? \"0\" : String(a.removeLast()))!\\n            let y = Int(b.isEmpty ? \"0\" : String(b.removeLast()))!\\n            let sum = x + y + carry\\n            result = String(sum % 2) + result\\n            carry = sum / 2\\n        }        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24788,
                "title": "short-o-n-time-o-1-space-c-solution",
                "content": "I just write the sum into the longer one of the inputs. Don't worry about modifying them, as getting `string` means we're getting copies. The \"O(1) space\" of course refers to the space I use in addition to input and output. If the output doesn't need to be longer than the longer input, I even only use O(1) space in addition to only the input.\\n\\n    struct Solution {\\n        string addBinary(string a, string b) {\\n            if (a.size() < b.size())\\n                swap(a, b);\\n            int i = a.size(), j = b.size();\\n            while (i--) {\\n                if (j) a[i] += b[--j] & 1;\\n                if (a[i] > '1') {\\n                    a[i] -= 2;\\n                    if (i) a[i-1]++; else a = '1' + a;\\n                }\\n            }\\n            return a;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "I just write the sum into the longer one of the inputs. Don't worry about modifying them, as getting `string` means we're getting copies. The \"O(1) space\" of course refers to the space I use in addition to input and output. If the output doesn't need to be longer than the longer input, I even only use O(1) space in addition to only the input.\\n\\n    struct Solution {\\n        string addBinary(string a, string b) {\\n            if (a.size() < b.size())\\n                swap(a, b);\\n            int i = a.size(), j = b.size();\\n            while (i--) {\\n                if (j) a[i] += b[--j] & 1;\\n                if (a[i] > '1') {\\n                    a[i] -= 2;\\n                    if (i) a[i-1]++; else a = '1' + a;\\n                }\\n            }\\n            return a;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3182944,
                "title": "python-3-one-lines-of-code-time-95-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is a simple implementation of converting binary numbers to integers, adding them, and then converting the sum back to binary. The conversion of binary to integer is done using the int() method with a base of 2, which means that it will treat the string as a binary number and return the equivalent integer. After adding the integers,\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a , 2) + int(b,2))[2:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a , 2) + int(b,2))[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637606,
                "title": "c-easy-to-understand-o-n-m-diagrammatic-representation",
                "content": "**Approach**\\n![image](https://assets.leetcode.com/users/images/ed94d72f-379a-4868-910b-ae5c2ac3606c_1664435071.5181186.png)\\n\\n``` \\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) \\n    {\\n        int n = a.size(), m = b.size();\\n        int i = n-1 , j = m-1;\\n        int carry = 0;\\n        string ans = \"\";\\n        while(i >= 0 || j >= 0)\\n        {\\n            int val1 = (i >= 0) ? a[i]-\\'0\\' : 0 ;\\n            int val2 = (j >= 0) ? b[j]-\\'0\\' : 0 ;\\n            \\n            int total = val1 + val2 + carry ;\\n            ans = to_string(total % 2) + ans ;\\n\\t\\t\\t/*\\n\\t\\t\\tif total = 3 means ans will be 1 since 1 + 1 + 1 = 1 with carry 1.\\n\\t\\t\\tif total = 2 then ans will be 0 since 1 + 1 = 0 with carry 1.\\n\\t\\t\\tif total = 1 means ans will be 1 since 0 + 1 = 1 with carry 0.\\n\\t\\t\\t*/\\n            carry = total/2 ;\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry)\\n        {\\n            ans = \\'1\\' + ans ;\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\n**Time Complexity = O(N+M)**\\n**Space Comlexity = O(M)**\\n\\n**If you understood the approach then please do upvote!**\\n**Happy Coding!\\u2764\\uFE0F**",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) \\n    {\\n        int n = a.size(), m = b.size();\\n        int i = n-1 , j = m-1;\\n        int carry = 0;\\n        string ans = \"\";\\n        while(i >= 0 || j >= 0)\\n        {\\n            int val1 = (i >= 0) ? a[i]-\\'0\\' : 0 ;\\n            int val2 = (j >= 0) ? b[j]-\\'0\\' : 0 ;\\n            \\n            int total = val1 + val2 + carry ;\\n            ans = to_string(total % 2) + ans ;\\n\\t\\t\\t/*\\n\\t\\t\\tif total = 3 means ans will be 1 since 1 + 1 + 1 = 1 with carry 1.\\n\\t\\t\\tif total = 2 then ans will be 0 since 1 + 1 = 0 with carry 1.\\n\\t\\t\\tif total = 1 means ans will be 1 since 0 + 1 = 1 with carry 0.\\n\\t\\t\\t*/\\n            carry = total/2 ;\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry)\\n        {\\n            ans = \\'1\\' + ans ;\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421832,
                "title": "python3-self-understandable",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        while len(b)<len(a):\\n            b=\\'0\\'+b\\n        while len(a)<len(b):\\n            a=\\'0\\'+a\\n        carry=0\\n        a=[int(i) for i in a]\\n        b=[int(i) for i in b]\\n        ans=\\'\\'\\n        for i in range(len(a)-1,-1,-1):\\n            val=a[i]+b[i]+carry\\n            if val==3:\\n                carry=1\\n                ans=\\'1\\'+ans\\n            elif val==2:\\n                carry=1\\n                ans=\\'0\\'+ans\\n            elif val==1:\\n                ans=\\'1\\'+ans\\n                carry=0\\n            else:\\n                ans=\\'0\\'+ans\\n        return str(carry)+ans if carry else ans\\n```\\n\\n***Do upvote if you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        while len(b)<len(a):\\n            b=\\'0\\'+b\\n        while len(a)<len(b):\\n            a=\\'0\\'+a\\n        carry=0\\n        a=[int(i) for i in a]\\n        b=[int(i) for i in b]\\n        ans=\\'\\'\\n        for i in range(len(a)-1,-1,-1):\\n            val=a[i]+b[i]+carry\\n            if val==3:\\n                carry=1\\n                ans=\\'1\\'+ans\\n            elif val==2:\\n                carry=1\\n                ans=\\'0\\'+ans\\n            elif val==1:\\n                ans=\\'1\\'+ans\\n                carry=0\\n            else:\\n                ans=\\'0\\'+ans\\n        return str(carry)+ans if carry else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061502,
                "title": "rust-one-liner",
                "content": "Just for fun seeing some Python solutions wanted to find out how terse this could be done in Rust. Behold:\\n\\n```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        format!(\"{:b}\", u128::from_str_radix(&a, 2).unwrap() + u128::from_str_radix(&b, 2).unwrap())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        format!(\"{:b}\", u128::from_str_radix(&a, 2).unwrap() + u128::from_str_radix(&b, 2).unwrap())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24671,
                "title": "my-0ms-c-solution-15-lines",
                "content": "    char* addBinary(char* a, char* b) {\\n    int lena = strlen(a), lenb = strlen(b), carry = 0;\\n    int lenc = lena > lenb?lena:lenb;\\n    char * c = malloc(lenc+2);\\n    c[lenc+1] = '\\\\0';\\n    while(lena || lenb ){\\n        if(lena) carry += (a[--lena]-'0');\\n        if(lenb) carry += (b[--lenb]-'0');\\n        c[lenc--] = (carry&1)+'0';\\n        carry >>= 1;\\n    }\\n    c[0] = carry+'0';\\n    return c+(carry^1);\\n    // for(int i = -1, j = 0;c[j] && !carry;c[++i] = c[++j]);\\n    // return c;\\n    }",
                "solutionTags": [],
                "code": "    char* addBinary(char* a, char* b) {\\n    int lena = strlen(a), lenb = strlen(b), carry = 0;\\n    int lenc = lena > lenb?lena:lenb;\\n    char * c = malloc(lenc+2);\\n    c[lenc+1] = '\\\\0';\\n    while(lena || lenb ){\\n        if(lena) carry += (a[--lena]-'0');\\n        if(lenb) carry += (b[--lenb]-'0');\\n        c[lenc--] = (carry&1)+'0';\\n        carry >>= 1;\\n    }\\n    c[0] = carry+'0';\\n    return c+(carry^1);\\n    // for(int i = -1, j = 0;c[j] && !carry;c[++i] = c[++j]);\\n    // return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24585,
                "title": "my-simple-4ms-java-solution-clean-and-consice",
                "content": "      public String addBinary(String a, String b) {\\n        int aLength = a.length();\\n        int bLength = b.length();\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        while(Math.max(aLength, bLength) > 0) {\\n          int aNum = aLength > 0 ? (a.charAt(aLength---1) - '0') : 0;\\n          int bNum = bLength > 0 ? (b.charAt(bLength---1) - '0') : 0;\\n          int cNum = aNum + bNum + carry;\\n          sb.append(cNum%2);\\n          carry = cNum / 2;\\n        }\\n        return (carry == 1)?sb.append(1).reverse().toString():sb.reverse().toString();\\n      }",
                "solutionTags": [
                    "Java"
                ],
                "code": "      public String addBinary(String a, String b) {\\n        int aLength = a.length();\\n        int bLength = b.length();\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        while(Math.max(aLength, bLength) > 0) {\\n          int aNum = aLength > 0 ? (a.charAt(aLength---1) - '0') : 0;\\n          int bNum = bLength > 0 ? (b.charAt(bLength---1) - '0') : 0;\\n          int cNum = aNum + bNum + carry;\\n          sb.append(cNum%2);\\n          carry = cNum / 2;\\n        }\\n        return (carry == 1)?sb.append(1).reverse().toString():sb.reverse().toString();\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 3059554,
                "title": "very-straightforward-c-solution",
                "content": "# Approach\\nStarting from the end of numbers `a` and `b`, sum the digits one by one in a loop while keeping track of a carry on each step. If one of the numbers ends, use a zero instead of a digit. In the end, reverse the result list and concatenate all digits to get the final number. That\\'s it!\\n\\n# Complexity\\n- Time complexity: $$O(Max(n,m))$$\\n\\n- Space complexity: $$O(Max(n,m))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var sum = new List<int>();\\n        for (int i = a.Length - 1, j = b.Length - 1, carry = 0; i >= 0 || j >= 0 || carry > 0;)\\n        {\\n            var firstDigit = i >= 0 ? a[i--] - \\'0\\' : 0;\\n            var secondDigit = j >= 0 ? b[j--] - \\'0\\' : 0;\\n            var sumDigit = firstDigit + secondDigit + carry;\\n            carry = sumDigit / 2;\\n            sum.Add(sumDigit % 2);\\n        }\\n        sum.Reverse();\\n        return String.Concat(sum);\\n    }\\n}\\n```\\n\\nPlease, upvote if the solution was useful for you!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var sum = new List<int>();\\n        for (int i = a.Length - 1, j = b.Length - 1, carry = 0; i >= 0 || j >= 0 || carry > 0;)\\n        {\\n            var firstDigit = i >= 0 ? a[i--] - \\'0\\' : 0;\\n            var secondDigit = j >= 0 ? b[j--] - \\'0\\' : 0;\\n            var sumDigit = firstDigit + secondDigit + carry;\\n            carry = sumDigit / 2;\\n            sum.Add(sumDigit % 2);\\n        }\\n        sum.Reverse();\\n        return String.Concat(sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243244,
                "title": "c-100-faster-0-ms-clean-code",
                "content": "***\\u2714C++ Implementation :***\\n\\n```\\n\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int carry = 0;\\n        string ans=\"\";\\n        int i=0;\\n        while(i<a.length() && i<b.length()){\\n            int sum = carry + (a[i] - \\'0\\') + (b[i]-\\'0\\');\\n            carry = sum>=2 ? 1 : 0;\\n            ans += (sum%2) + \\'0\\';\\n            i++;\\n        }\\n        \\n\\n            if(i<a.length()){\\n                while(i<a.length()){\\n                    int sum = carry + (a[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }else{\\n                while(i<b.length()){\\n                    int sum = carry + (b[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }\\n        \\n        if(carry) ans += carry + \\'0\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\t\\n```\\n\\nHope you liked it , kindly upvote :)\\n\\n## Happy Coding Fellas \\uD83E\\uDD17\\u270C\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int carry = 0;\\n        string ans=\"\";\\n        int i=0;\\n        while(i<a.length() && i<b.length()){\\n            int sum = carry + (a[i] - \\'0\\') + (b[i]-\\'0\\');\\n            carry = sum>=2 ? 1 : 0;\\n            ans += (sum%2) + \\'0\\';\\n            i++;\\n        }\\n        \\n\\n            if(i<a.length()){\\n                while(i<a.length()){\\n                    int sum = carry + (a[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }else{\\n                while(i<b.length()){\\n                    int sum = carry + (b[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }\\n        \\n        if(carry) ans += carry + \\'0\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218664,
                "title": "java-bit-manipulation-xor-and-100-explanations",
                "content": "**1. What are the inputs ?**\\n- 3 numbers : `n1`, `n2`, `c(carry)`, are used to form a new number, denoted as `n`\\n\\n**2. What remains as output(in one digit)?**\\n- The least significant digit of n.\\n\\n**3. What gets to shift to more significant bits?**\\n- The most significant digit of n (since n can have at most two digits here, the highest digit).  \\n\\n\\n**4. Patterns of the least significant digit (denoted as `lowest`)**\\n- `lowest` = 0 if:\\n\\t-  any two of n1, n2, and carry are 1 OR\\n\\t-  all three are 0, \\n\\t-  which means an even number of 1s is needed to form a 0. \\n- `lowest` = 1 if :\\n\\t-  any one of n1, n2 and carry is 1 OR\\n\\t-  all three are 1\\n\\t-  which means an odd number of 1s is needed to form a 1. \\n- This leads us to the **XOR** operation. \\n\\t- 0 ^ 0 ^ 0 = 0\\n\\t- 0 ^ 0 ^ 1 = 1\\n\\t- 0 ^ 1 ^ 0 = 1\\n\\t- 0 ^ 1 ^ 1 = 0\\n\\t- 1 ^ 0 ^ 0  = 1\\n\\t- 1 ^ 0 ^ 1 = 0 \\n\\t- 1 ^ 1 ^ 0 = 0\\n\\t- 1 ^ 1 ^ 1 = 1 \\n\\n**5. Patterns of the most siginificant digit (denoted as `highest`) :**\\nLet\\'s go back to elementary arithmetic and think about :\\n- What is a carry? \\n\\t-  Carry is a number being transferred from a lower digit to a higher one.  \\n- Why do we need a carry ? \\n\\t- A number is too large for the lower digits to represent. \\n- Specifically, when do we need a carry in the binary system\\uFF1F\\n\\t- When a number is **larger than or equal to 2**. \\n- How to make sure the number `n` is at least two? \\n\\t- n is at least two = at least two components, n1, n2, and carry have values of 1. \\n\\t- Make use of the **&** operator. \\n\\t- Because only 1 & 1 = 1, all other cases 1 & 0, 0 & 0, 0 & 1 are 0. \\n```\\npublic String addBinary(String a, String b) {\\n\\tint pa = a.length() - 1, pb = b.length() - 1; \\n\\tint carry = 0;\\n\\tStringBuilder builder = new StringBuilder(); \\n\\n\\tint na, nb; \\n\\twhile (pa >= 0 || pb >= 0 || carry != 0) {\\n\\t\\tna = pa >= 0 ? a.charAt(pa) - \\'0\\' : 0;\\n\\t\\tnb = pb >= 0 ? b.charAt(pb) - \\'0\\' : 0;\\n\\t\\tbuilder.append(na ^ nb ^ carry);  // add lowest to output\\n\\t\\tcarry = (na & nb) | (na & carry) | (nb & carry);  // keeps highest as next carry \\n\\t\\tpa--;\\n\\t\\tpb--;\\n\\t}\\n\\n\\treturn builder.reverse().toString(); \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic String addBinary(String a, String b) {\\n\\tint pa = a.length() - 1, pb = b.length() - 1; \\n\\tint carry = 0;\\n\\tStringBuilder builder = new StringBuilder(); \\n\\n\\tint na, nb; \\n\\twhile (pa >= 0 || pb >= 0 || carry != 0) {\\n\\t\\tna = pa >= 0 ? a.charAt(pa) - \\'0\\' : 0;\\n\\t\\tnb = pb >= 0 ? b.charAt(pb) - \\'0\\' : 0;\\n\\t\\tbuilder.append(na ^ nb ^ carry);  // add lowest to output\\n\\t\\tcarry = (na & nb) | (na & carry) | (nb & carry);  // keeps highest as next carry \\n\\t\\tpa--;\\n\\t\\tpb--;\\n\\t}\\n\\n\\treturn builder.reverse().toString(); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3186596,
                "title": "have-you-thought-this-way-beats-100-self-explanatory-code",
                "content": "![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/19cd7464-9788-4e2b-b03c-92c42adf55eb_1676405483.184702.png)\\n\\nVery easy indeed. But have you thought this way?\\n\\n# Approach\\nYou probably know that from decimal to binary:\\n0 -> 0\\n1 -> 1\\n2 -> 10\\n3 -> 11\\n\\nHow about we split them as sums of 1 and 0\\'s:\\n\\n| carry | ch1 | ch2 | sum | decimal value |\\n|-------|-----|-----|-----|-----|\\n| 0 | 0 | 0 | 0| 0 |\\n|0 | 0 | 1 | 1 | 1 |\\n|0 | 1 | 0 | 10 | 2 |\\n|1 | 1 | 1 | 11 | 3 |\\n\\nWe need to first distinguish the larger and smaller strings. For our solution, we will always determine **a** as smaller and **b** as larger. If they are not, we will swap them.\\n\\nThen, we will iterate the loop until the larger value >= 0. \\n- If the smaller value is < 0, we will assign ch1 = 0;\\n- Then we will sum all of them. Remind to sum the carry. At first the carry is 0.\\n- If the sum is either 0 or 1, carry will be 0.\\n- But if the sum is 2 or 3, the carry will be 1.\\n- The string appended will be 0 for sum = 2\\nand 1 for sum = 3.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\nWe declare a new StringBuilder and also a new temp variable while swapping the strings. These will require extra space. The size is dependent on the input length. That\\'s why O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int smaller = a.length()-1, larger = b.length()-1;\\n        if(smaller>larger){\\n            int tmp = smaller;\\n            smaller = larger;\\n            larger = tmp;\\n            String temp = a;\\n            a = b;\\n            b = temp;\\n        }\\n        int carry = 0;\\n        while(larger>=0){\\n            int ch1 = (smaller>=0)?a.charAt(smaller)-\\'0\\':0;\\n            int ch2 = b.charAt(larger)-\\'0\\';\\n            int sum = ch1 + ch2 + carry;\\n            // 2 = 10\\n            if(sum == 2){\\n                carry = 1;\\n                sb.append(\"0\");\\n            }\\n            // 3 = 11\\n            else if(sum == 3){\\n                carry = 1;\\n                sb.append(\"1\");\\n            }\\n            // 1 = 1, or, 0 = 0\\n            else{\\n                carry = 0;\\n                char ch = (char)(sum+\\'0\\');\\n                sb.append(ch);\\n            }\\n            smaller--;\\n            larger--;\\n        }\\n        // if there\\'s still one carry left!\\n        if(carry == 1){\\n            sb.append(\"1\");\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/a1a61be1-eb3e-4e69-8d8a-49ce68f4a13b_1676405549.70167.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int smaller = a.length()-1, larger = b.length()-1;\\n        if(smaller>larger){\\n            int tmp = smaller;\\n            smaller = larger;\\n            larger = tmp;\\n            String temp = a;\\n            a = b;\\n            b = temp;\\n        }\\n        int carry = 0;\\n        while(larger>=0){\\n            int ch1 = (smaller>=0)?a.charAt(smaller)-\\'0\\':0;\\n            int ch2 = b.charAt(larger)-\\'0\\';\\n            int sum = ch1 + ch2 + carry;\\n            // 2 = 10\\n            if(sum == 2){\\n                carry = 1;\\n                sb.append(\"0\");\\n            }\\n            // 3 = 11\\n            else if(sum == 3){\\n                carry = 1;\\n                sb.append(\"1\");\\n            }\\n            // 1 = 1, or, 0 = 0\\n            else{\\n                carry = 0;\\n                char ch = (char)(sum+\\'0\\');\\n                sb.append(ch);\\n            }\\n            smaller--;\\n            larger--;\\n        }\\n        // if there\\'s still one carry left!\\n        if(carry == 1){\\n            sb.append(\"1\");\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329387,
                "title": "solution-swift-add-binary",
                "content": "```swift\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        let arrA = Array(a), arrB = Array(b)\\n        var result = \"\", carry = 0, idx1 = arrA.count - 1, idx2 = arrB.count - 1\\n        \\n        while idx1 >= 0 || idx2 >= 0 || carry > 0 {\\n            var sum = carry\\n            idx1 >= 0 ? (sum += Int(\"\\\\(arrA[idx1])\")!, idx1 -= 1) : nil\\n            idx2 >= 0 ? (sum += Int(\"\\\\(arrB[idx2])\")!, idx2 -= 1) : nil\\n            result = \"\\\\(sum % 2)\" + result\\n            carry = sum / 2\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.016 (0.018) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.addBinary(\"11\", \"1\")\\n        XCTAssertEqual(value, \"100\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.addBinary(\"1010\", \"1011\")\\n        XCTAssertEqual(value, \"10101\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        let arrA = Array(a), arrB = Array(b)\\n        var result = \"\", carry = 0, idx1 = arrA.count - 1, idx2 = arrB.count - 1\\n        \\n        while idx1 >= 0 || idx2 >= 0 || carry > 0 {\\n            var sum = carry\\n            idx1 >= 0 ? (sum += Int(\"\\\\(arrA[idx1])\")!, idx1 -= 1) : nil\\n            idx2 >= 0 ? (sum += Int(\"\\\\(arrB[idx2])\")!, idx2 -= 1) : nil\\n            result = \"\\\\(sum % 2)\" + result\\n            carry = sum / 2\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.addBinary(\"11\", \"1\")\\n        XCTAssertEqual(value, \"100\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.addBinary(\"1010\", \"1011\")\\n        XCTAssertEqual(value, \"10101\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695976,
                "title": "c-2-solutions-easy-to-understand-bit-manipulation-and-bit-by-bit-addition",
                "content": "**Addition Operation**\\n\\nStraight-forward solution where you add up the bits one at a time.\\n\\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] : \\'0\\';\\n            var c2 = n2 >= 0 ? b[n2] : \\'0\\';\\n            \\n            var sum = carry + (c1-\\'0\\') + (c2-\\'0\\');\\n            if(sum > 1) {\\n                carry = 1;\\n                sum = sum - 2;\\n            } else {\\n                carry = 0;\\n            }\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```\\n\\n**Bit Manipulation**\\n\\nA follow-up to this question is to solve this problem without using addition operation. We can use bit manipulation instead. The intuition is that to calculate carry, at least 2 of the 3 bits (carry, bit from string a, bit from string b) have to be 1. Therefore, you can do:\\n`carry = (c1 | carry ) & (c2 | carry) & (c1 | c2);`\\n\\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] - \\'0\\' : 0;\\n            var c2 = n2 >= 0 ? b[n2] - \\'0\\' : 0;\\n            \\n            var sum = (c1 ^ c2 ^ carry);\\n            carry = (c1 | carry ) & (c2 | carry) & (c1 | c2);\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n\\n        return result.ToString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] : \\'0\\';\\n            var c2 = n2 >= 0 ? b[n2] : \\'0\\';\\n            \\n            var sum = carry + (c1-\\'0\\') + (c2-\\'0\\');\\n            if(sum > 1) {\\n                carry = 1;\\n                sum = sum - 2;\\n            } else {\\n                carry = 0;\\n            }\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] - \\'0\\' : 0;\\n            var c2 = n2 >= 0 ? b[n2] - \\'0\\' : 0;\\n            \\n            var sum = (c1 ^ c2 ^ carry);\\n            carry = (c1 | carry ) & (c2 | carry) & (c1 | c2);\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n\\n        return result.ToString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198691,
                "title": "java-one-liner",
                "content": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190723,
                "title": "5ms-java-solution-with-explanation-of-code-and-binary-adding",
                "content": "I didn\\u2019t like the other Java solutions posted, they seem to either use \\u201Ctricks\\u201D or don\\u2019t explain what\\u2019s going on. So first of all I\\u2019ll start by saying that if you haven\\u2019t noticed, it\\u2019s a lot harder to solve this problem concisely in Java than it is in Python or C++. Below is a 5ms solution, so only faster than 25% of solutions. I purposely haven\\u2019t optimized it to its max potential to keep it legible, but hopefully you can find a faster way of doing it.\\n\\n\\n\\\\\\n\\\\\\n***Arithmetic***  \\n\\\\\\nTo solve the problem, you need to know how arithmetic works for any base. Humans use base 10, so our number system is composed of the combination of numbers from 0-9. Think of the base as the amount of unique digits you can represent a number with, but make sure to include 0. Right now we are trying to make an adder for base 2, a.k.a binary.\\n\\nYou should already know how adding works, you start by adding two values from right to left. Let\\u2019s call this value the *sum*. If the *sum* exceeds the highest single integer you can represent them with ( for base 10: 9, binary: 1), you subtract the base from the *sum*  *n* amount of times, where *n* is the number of times you had to subtract base from *sum* be within the range of the integers you can represent. You then \\u201Ccarry over\\u201D the value of *n*, to be added to the next pair of integers.\\n\\n\\n\\\\\\n\\\\\\nA base 10 example:\\n\\nFor 27 + 27, you add 7+7 to get 14, which is greater than 9. So you subtract 10 once from 14, and now you have a carry of 1 and a final sum of 4. You now add one, two, and two to get 5. So your final answer is 54.\\n\\n\\\\\\nSo for binary a = \\u201C11\\u201D, b = \\u201C1\\u201D\\na: 11\\nb: 01\\n\\nFirst we add 1+1, which equals 2. Since 2 > 1, our highest integer, we set the value of the first place to to 2 - 2 (0), and carry over the base * 1 to the next addition. So our result right now is **0**, and we have a carry of 1 (our base times 1.)\\n\\nSo 1+0 is 0, but our carry is also 1. We add the carry to this sum, and now the value is 2 (1 + 0 + 1.) We do the same thing as last time, and set the sum to 2-2, and carry over the base*I, the amount of time we had to subtract 2 to get the value to be less than 2, yet again. Our result right now is **00**.\\n\\nWe are out of numbers to add, but we still have a carry of base, so we simply add that to the end. Our final result is then **100**.\\n\\n\\n\\n\\n\\nBy now you probably have a good idea of how to solve this problem, but there\\u2019s one case you have to watch out for: when the carry is greater than 1.\\n\\\\\\n\\\\\\nSo for binary a = \\u201C110\\u201D, b = \\u201C111\\u201D\\na: 110\\nb: 111\\n\\nFirst we add 0 + 1, and no carry, so our result is **1**\\nThen we add 1 + 1, since 2 > 1, we set our sum to 0 and carry over 1. Our result is now **01**\\n\\nNow we do 1+1 again, except with a carry of 1, so the real sum is 3. Since 3 > 1, we have to subtract 2 from it just once, but now the final sum is 1, not 0. Most people will try to implement a binary adder where you simply set the final value to 0 when the final sum is greater than 1, but that\\u2019s too naive of an approach. \\n\\nCheck out how I implemented it, after writing this I think I\\u2019ve found 10 new ways of making this more efficient, but I\\u2019ll let you have at it.\\n\\\\\\n\\\\\\n***Code***  \\n\\n` \\n\\n    public String addBinary(String a, String b) {\\n    // As another user pointed out, iterating across char arrays is faster than using\\n    // charAt(); So split into them and iterate with a single pointer.\\n    char[] aArray = a.toCharArray();\\n    int aLen = aArray.length;\\n\\t\\n    char[] bArray = b.toCharArray();\\n    int bLen = bArray.length;\\n\\n    int ptr = 0;\\n\\n    int carry=0;\\n    int aVal=0;\\n    int bVal=0;\\n    String strToReturn=\\u201C\\u201D;\\n\\n    while(ptr < aLen || ptr < bLen) {\\n      aVal=0; bVal=0; // Reset values after every pointer iteration.\\n      if(ptr < aLen)\\n        aVal = (aArray[aLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0; // Converts from char to integer\\n      if(ptr <bLen)\\n        bVal = (bArray[bLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0;\\n\\n      int finalVal = aVal +bVal + carry; // total after adding carry.\\n      if(finalVal > 1) {\\n        carry=finalVal-1;\\n        if(carry > 1) {finalVal = 1; carry=1; }\\n        else finalVal=0;\\n\\n      }\\n      else\\n          carry=0; // If either 0 or 1 after adding carry, just reset carry.\\n\\n      strToReturn=finalVal+\\u201D\\u201D+strToReturn; // Add to front of string.\\n      ptr++;\\n    }\\n    if(carry > 0) strToReturn=\\u201C1\\u201D+strToReturn; // If any leftover carry at the end, just append a \\u201C1\\u201D to the start.\\n    return strToReturn;\\n    }\\n`\\n\\n\\n",
                "solutionTags": [],
                "code": "I didn\\u2019t like the other Java solutions posted, they seem to either use \\u201Ctricks\\u201D or don\\u2019t explain what\\u2019s going on. So first of all I\\u2019ll start by saying that if you haven\\u2019t noticed, it\\u2019s a lot harder to solve this problem concisely in Java than it is in Python or C++. Below is a 5ms solution, so only faster than 25% of solutions. I purposely haven\\u2019t optimized it to its max potential to keep it legible, but hopefully you can find a faster way of doing it.\\n\\n\\n\\\\\\n\\\\\\n***Arithmetic***  \\n\\\\\\nTo solve the problem, you need to know how arithmetic works for any base. Humans use base 10, so our number system is composed of the combination of numbers from 0-9. Think of the base as the amount of unique digits you can represent a number with, but make sure to include 0. Right now we are trying to make an adder for base 2, a.k.a binary.\\n\\nYou should already know how adding works, you start by adding two values from right to left. Let\\u2019s call this value the *sum*. If the *sum* exceeds the highest single integer you can represent them with ( for base 10: 9, binary: 1), you subtract the base from the *sum*  *n* amount of times, where *n* is the number of times you had to subtract base from *sum* be within the range of the integers you can represent. You then \\u201Ccarry over\\u201D the value of *n*, to be added to the next pair of integers.\\n\\n\\n\\\\\\n\\\\\\nA base 10 example:\\n\\nFor 27 + 27, you add 7+7 to get 14, which is greater than 9. So you subtract 10 once from 14, and now you have a carry of 1 and a final sum of 4. You now add one, two, and two to get 5. So your final answer is 54.\\n\\n\\\\\\nSo for binary a = \\u201C11\\u201D, b = \\u201C1\\u201D\\na: 11\\nb: 01\\n\\nFirst we add 1+1, which equals 2. Since 2 > 1, our highest integer, we set the value of the first place to to 2 - 2 (0), and carry over the base * 1 to the next addition. So our result right now is **0**, and we have a carry of 1 (our base times 1.)\\n\\nSo 1+0 is 0, but our carry is also 1. We add the carry to this sum, and now the value is 2 (1 + 0 + 1.) We do the same thing as last time, and set the sum to 2-2, and carry over the base*I, the amount of time we had to subtract 2 to get the value to be less than 2, yet again. Our result right now is **00**.\\n\\nWe are out of numbers to add, but we still have a carry of base, so we simply add that to the end. Our final result is then **100**.\\n\\n\\n\\n\\n\\nBy now you probably have a good idea of how to solve this problem, but there\\u2019s one case you have to watch out for: when the carry is greater than 1.\\n\\\\\\n\\\\\\nSo for binary a = \\u201C110\\u201D, b = \\u201C111\\u201D\\na: 110\\nb: 111\\n\\nFirst we add 0 + 1, and no carry, so our result is **1**\\nThen we add 1 + 1, since 2 > 1, we set our sum to 0 and carry over 1. Our result is now **01**\\n\\nNow we do 1+1 again, except with a carry of 1, so the real sum is 3. Since 3 > 1, we have to subtract 2 from it just once, but now the final sum is 1, not 0. Most people will try to implement a binary adder where you simply set the final value to 0 when the final sum is greater than 1, but that\\u2019s too naive of an approach. \\n\\nCheck out how I implemented it, after writing this I think I\\u2019ve found 10 new ways of making this more efficient, but I\\u2019ll let you have at it.\\n\\\\\\n\\\\\\n***Code***  \\n\\n` \\n\\n    public String addBinary(String a, String b) {\\n    // As another user pointed out, iterating across char arrays is faster than using\\n    // charAt(); So split into them and iterate with a single pointer.\\n    char[] aArray = a.toCharArray();\\n    int aLen = aArray.length;\\n\\t\\n    char[] bArray = b.toCharArray();\\n    int bLen = bArray.length;\\n\\n    int ptr = 0;\\n\\n    int carry=0;\\n    int aVal=0;\\n    int bVal=0;\\n    String strToReturn=\\u201C\\u201D;\\n\\n    while(ptr < aLen || ptr < bLen) {\\n      aVal=0; bVal=0; // Reset values after every pointer iteration.\\n      if(ptr < aLen)\\n        aVal = (aArray[aLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0; // Converts from char to integer\\n      if(ptr <bLen)\\n        bVal = (bArray[bLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0;\\n\\n      int finalVal = aVal +bVal + carry; // total after adding carry.\\n      if(finalVal > 1) {\\n        carry=finalVal-1;\\n        if(carry > 1) {finalVal = 1; carry=1; }\\n        else finalVal=0;\\n\\n      }\\n      else\\n          carry=0; // If either 0 or 1 after adding carry, just reset carry.\\n\\n      strToReturn=finalVal+\\u201D\\u201D+strToReturn; // Add to front of string.\\n      ptr++;\\n    }\\n    if(carry > 0) strToReturn=\\u201C1\\u201D+strToReturn; // If any leftover carry at the end, just append a \\u201C1\\u201D to the start.\\n    return strToReturn;\\n    }\\n`\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 24656,
                "title": "7-line-7ms-c-code-probably-shortest",
                "content": "it's important to write concise code\\n\\n    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            string res;\\n            int i = a.size(), j = b.size(), cur = 0;\\n            while(i || j || cur) {\\n                cur += (i ? a[(i--)-1] -'0' : 0) + (j ? b[(j--)-1] -'0' : 0);\\n                res = char(cur%2 + '0') + res;\\n                cur /= 2;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            string res;\\n            int i = a.size(), j = b.size(), cur = 0;\\n            while(i || j || cur) {\\n                cur += (i ? a[(i--)-1] -'0' : 0) + (j ? b[(j--)-1] -'0' : 0);\\n                res = char(cur%2 + '0') + res;\\n                cur /= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24838,
                "title": "a-straightforward-c-solution",
                "content": "  \\n\\n      string addBinary(string a, string b) {\\n            string result = \"\";\\n            int ia = a.size() - 1;\\n            int ib = b.size() - 1;\\n            int sum = 0;\\n            while (ia >= 0 || ib >= 0) {\\n                int va = 0, vb = 0;\\n                if (ia >= 0) {\\n                    va = a[ia] - '0'; ia --;\\n                }\\n                if (ib >= 0) {\\n                    vb = b[ib] - '0'; ib --;\\n                }\\n                sum = sum + va + vb;\\n                // possible values of sum: 0 ~ 3\\n                result = (sum % 2 == 0 ? \"0\" : \"1\") + result;\\n                sum = sum / 2;\\n            }\\n            if (sum == 1) result = \"1\" + result;\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "  \\n\\n      string addBinary(string a, string b) {\\n            string result = \"\";\\n            int ia = a.size() - 1;\\n            int ib = b.size() - 1;\\n            int sum = 0;\\n            while (ia >= 0 || ib >= 0) {\\n                int va = 0, vb = 0;\\n                if (ia >= 0) {\\n                    va = a[ia] - '0'; ia --;\\n                }\\n                if (ib >= 0) {\\n                    vb = b[ib] - '0'; ib --;\\n                }\\n                sum = sum + va + vb;\\n                // possible values of sum: 0 ~ 3\\n                result = (sum % 2 == 0 ? \"0\" : \"1\") + result;\\n                sum = sum / 2;\\n            }\\n            if (sum == 1) result = \"1\" + result;\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 24808,
                "title": "python-one-liner-solution",
                "content": "    class Solution:\\n        # @param {string} a\\n        # @param {string} b\\n        # @return {string}\\n        def addBinary(self, a, b):\\n            return bin(int(a,2) + int(b,2))[2:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 24797,
                "title": "213ms-java-solution-use-two-pointer-to-calculate-o-n-times",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder str = new StringBuilder();\\n            int aPtr = a.length() - 1;\\n            int bPtr = b.length() - 1;\\n            int carry = 0;\\n            int count = 0;\\n            while(aPtr >= 0 || bPtr >= 0) {\\n                if(aPtr >= 0) {\\n                    if(a.charAt(aPtr) == '1') {\\n                        count ++;\\n                    }\\n                }\\n                if(bPtr >= 0) {\\n                    if(b.charAt(bPtr) == '1') {\\n                        count ++;\\n                    }\\n                }\\n                if(carry == 1) {\\n                    count++;\\n                }\\n                carry = (count > 1 ? 1 : 0);\\n                str.insert(0, ((count == 0 || count == 2)? '0' : '1'));\\n                count = 0;\\n                aPtr--;\\n                bPtr--;\\n            }\\n            if(carry == 1) {\\n                str.insert(0, '1');\\n            }\\n            return str.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder str = new StringBuilder();\\n            int aPtr = a.length() - 1;\\n            int bPtr = b.length() - 1;\\n            int carry = 0;\\n            int count = 0;\\n            while(aPtr >= 0 || bPtr >= 0) {\\n                if(aPtr >= 0) {\\n                    if(a.charAt(aPtr) == '1') {\\n                        count ++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3967679,
                "title": "two-simple-java-solutions-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n   public static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length());\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n        output.append(sum % 2); // Append the remainder of the sum\\n        carry = sum / 2; // Update the carry\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n\\n\\n}\\n```\\n\\n# code 2 \\n\\n```\\nclass Solution {\\npublic static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length()); // Use Math.max to get the maximum length\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n\\n        if (sum > 1) {\\n            carry = 1;\\n            output.append(sum % 2); // Append the remainder of the sum\\n        } else {\\n            carry = 0;\\n            output.append(sum);\\n        }\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n}\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/50f0b47b-f4a3-435a-a546-d93f75633914_1693145096.446008.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length());\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n        output.append(sum % 2); // Append the remainder of the sum\\n        carry = sum / 2; // Update the carry\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n\\n\\n}\\n```\n```\\nclass Solution {\\npublic static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length()); // Use Math.max to get the maximum length\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n\\n        if (sum > 1) {\\n            carry = 1;\\n            output.append(sum % 2); // Append the remainder of the sum\\n        } else {\\n            carry = 0;\\n            output.append(sum);\\n        }\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183184,
                "title": "clean-and-easy-c-code",
                "content": "\\n# Code \\uD83D\\uDE80\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n\\n        string ans;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n\\n            if(i>=0) sum += a[i--]-\\'0\\';\\n            if(j>=0) sum += b[j--]-\\'0\\';\\n            \\n            //update carry for next round\\n            carry = sum>1 ? 1 : 0;\\n            ans += to_string(sum%2);\\n        }\\n\\n        if(carry) ans += to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n# Please, Do Upvote if you find the solution helpful!\\nHappy coding :)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n\\n        string ans;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n\\n            if(i>=0) sum += a[i--]-\\'0\\';\\n            if(j>=0) sum += b[j--]-\\'0\\';\\n            \\n            //update carry for next round\\n            carry = sum>1 ? 1 : 0;\\n            ans += to_string(sum%2);\\n        }\\n\\n        if(carry) ans += to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945235,
                "title": "java-oneline-solutioin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger m=new BigInteger(a,2);\\n        BigInteger n=m.add(new BigInteger(b,2));\\n        \\n        \\n        return n.toString(2);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger m=new BigInteger(a,2);\\n        BigInteger n=m.add(new BigInteger(b,2));\\n        \\n        \\n        return n.toString(2);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765135,
                "title": "it-s-one-liner-baby",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104551,
                "title": "c-simple-solution-0ms-96-beat-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry=0;\\n        \\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string ans;\\n        while(i>=0 && j>=0){\\n            \\n            if(carry==0){\\n                if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                        carry=1;\\n                    }\\n                }\\n            }\\n            else{\\n                 if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                        carry=0;\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n            }\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i>=0){\\n            if(carry==0){\\n                ans+=a[i];\\n            }\\n            else{\\n                if(a[i]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            i--;\\n        }\\n        while(j>=0){\\n            if(carry==0){\\n                ans+=b[j];\\n            }\\n            else{\\n                if(b[j]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            j--;\\n        }\\n        if(carry==1)\\n            ans+=\\'1\\';\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry=0;\\n        \\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string ans;\\n        while(i>=0 && j>=0){\\n            \\n            if(carry==0){\\n                if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                        carry=1;\\n                    }\\n                }\\n            }\\n            else{\\n                 if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                        carry=0;\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n            }\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i>=0){\\n            if(carry==0){\\n                ans+=a[i];\\n            }\\n            else{\\n                if(a[i]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            i--;\\n        }\\n        while(j>=0){\\n            if(carry==0){\\n                ans+=b[j];\\n            }\\n            else{\\n                if(b[j]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            j--;\\n        }\\n        if(carry==1)\\n            ans+=\\'1\\';\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794830,
                "title": "python3-using-bin-and-int-simple",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        summ = bin(int(a, 2) + int(b, 2))\\n        return summ[2:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        summ = bin(int(a, 2) + int(b, 2))\\n        return summ[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845910,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string str=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            str=to_string(sum%2)+str;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               str=to_string(1)+str;\\n        return str;\\n        \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string str=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            str=to_string(sum%2)+str;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               str=to_string(1)+str;\\n        return str;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441283,
                "title": "simple-and-elegant-golang-solution-0-ms-faster-than-100-00",
                "content": "```go\\nfunc addBinary(a string, b string) string {\\n    if len(a) < len(b) {\\n        a, b = b, a\\n    }\\n    ans := make([]byte, len(a) + 1)\\n\\tvar carry byte\\n\\tfor i, j := len(a), len(b); i >= 1 || j >= 1; {\\n\\t\\ti, j = i - 1, j - 1\\n\\t\\tvar a2Digit, b2Digit byte\\n\\t\\tif (i >= 0) {\\n\\t\\t\\ta2Digit = a[i] - \\'0\\'\\n\\t\\t}\\n\\t\\tif (j >= 0) {\\n\\t\\t\\tb2Digit = b[j] - \\'0\\'\\n\\t\\t}\\n        // sum and carry of full adder\\n\\t\\tsum := a2Digit ^ b2Digit ^ carry\\n\\t\\tcarry = a2Digit & b2Digit | carry & (a2Digit ^ b2Digit)\\n        ans[i+1] = sum + \\'0\\'\\n\\t}\\n\\tif carry == 1 {\\n\\t\\tans[0] = \\'1\\'\\n        return string(ans)\\n\\t}\\n    return string(ans[1:])\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc addBinary(a string, b string) string {\\n    if len(a) < len(b) {\\n        a, b = b, a\\n    }\\n    ans := make([]byte, len(a) + 1)\\n\\tvar carry byte\\n\\tfor i, j := len(a), len(b); i >= 1 || j >= 1; {\\n\\t\\ti, j = i - 1, j - 1\\n\\t\\tvar a2Digit, b2Digit byte\\n\\t\\tif (i >= 0) {\\n\\t\\t\\ta2Digit = a[i] - \\'0\\'\\n\\t\\t}\\n\\t\\tif (j >= 0) {\\n\\t\\t\\tb2Digit = b[j] - \\'0\\'\\n\\t\\t}\\n        // sum and carry of full adder\\n\\t\\tsum := a2Digit ^ b2Digit ^ carry\\n\\t\\tcarry = a2Digit & b2Digit | carry & (a2Digit ^ b2Digit)\\n        ans[i+1] = sum + \\'0\\'\\n\\t}\\n\\tif carry == 1 {\\n\\t\\tans[0] = \\'1\\'\\n        return string(ans)\\n\\t}\\n    return string(ans[1:])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24593,
                "title": "javascript-solution-beats-96",
                "content": "```\\nvar addBinary = function(a, b) {\\n    var result = \"\";\\n    var i = a.length - 1;\\n    var j = b.length - 1;\\n    var carry = 0;\\n    while (i >= 0 || j >= 0 || carry > 0) {\\n        carry += i >= 0 ? parseInt(a[i--]) : 0;\\n        carry += j >= 0 ? parseInt(b[j--]) : 0;\\n        result = carry % 2 + result;\\n        carry = parseInt(carry / 2);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addBinary = function(a, b) {\\n    var result = \"\";\\n    var i = a.length - 1;\\n    var j = b.length - 1;\\n    var carry = 0;\\n    while (i >= 0 || j >= 0 || carry > 0) {\\n        carry += i >= 0 ? parseInt(a[i--]) : 0;\\n        carry += j >= 0 ? parseInt(b[j--]) : 0;\\n        result = carry % 2 + result;\\n        carry = parseInt(carry / 2);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24776,
                "title": "a-8-line-c-solution-to-have-all-languages-here",
                "content": "    public string AddBinary(string a, string b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0; i--, j--){\\n            int total= ((i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0)) + carry;\\n            sb.Insert(0, total == 2 || total == 0 ? '0' : '1');\\n            carry = total > 1 ? 1 : 0;\\n        }\\n        return carry == 1 ? sb.Insert(0, 1).ToString() : sb.ToString();\\n    }",
                "solutionTags": [],
                "code": "    public string AddBinary(string a, string b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0; i--, j--){\\n            int total= ((i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0)) + carry;\\n            sb.Insert(0, total == 2 || total == 0 ? '0' : '1');\\n            carry = total > 1 ? 1 : 0;\\n        }\\n        return carry == 1 ? sb.Insert(0, 1).ToString() : sb.ToString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3129097,
                "title": "js-fully-loop-through-strings-perform-binary-addition",
                "content": "# Intuition\\nUse `parseInt(x,2)` to get the values of the strings as integers, add them, then convert back to a bianry string. This doesn\\'t work due to a binary number with length 10^4 not fitting into an integer. Second approach was to loop through the strings and impelment binary addition.\\n\\n# Approach\\nLoop through both strings, continuing through the longest. We could trim off the front of the longest to save a few loops, but we\\'d need to account for any carry over from the last addition. To keep it simple, we\\'ll just loop through and let the addition do its job.\\n\\nWhile our loop index will increase, we\\'ll add from the end of the strings. Indexing from 0 for the loop allows us to keep processing the strings consistently, even if they are different lengths.\\n\\nSince we are processing through the longest string, we need to check that the other string still has values with a length check. If not, we treat that as a 0.\\n\\nFor the actual addition, we\\'ll parse a single character into an integer. An improvement here could be to take multiple characters, but we\\'d still have to deal with the complexity putting the slices back together without hitting out integer limits.\\n\\nSince we are performing one character at a time, we simply add the two values, plus any carryover from previous calcualtions. If the result is 0 or 1, that\\'s our result. Greater that 1 we\\'ll need to remove our carryover and our result is the remained. In this case,carry over is always 1, and out result in sum mod 2, since binary representations of 2 and 3 are 10 and 11 respectively. We can never have a value higher than 3. Once we have our result we add it to the front of our string. \\n\\nWhen we complete the loop, we may still have a carryover. This problem does not allow for a leading zero. We can\\'t just loop an extra iteration. If carry is zero, that would add a leading zero to our string. After the loop, we add a 1 if we have a carryover.\\n\\n# Test Cases\\n - Either or both numbers are 0\\n - Cases to verify all our possible outcomes of addition (0,1,2,3)\\n   - 0 + 1\\n   - 1 + 1\\n   - 1 + 11\\n   - 10 + 11\\n   - 11 + 11\\n - Leading 0 vs Leading 1\\n   - 1 + 1000\\n   - 1000 + 1000\\n- Numbers greater than or whos sum is greater than Number.MAX_SAFE_INTEGER\\n\\n# Code\\n```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n\\n    let result = \"\";\\n    let carry = 0;\\n    let index = 0;\\n\\n    while (index < Math.max(a.length,b.length)) {\\n        let x = 0;\\n        let y = 0;\\n\\n        if(a.length-1-index >= 0) {\\n            x = parseInt(a[a.length-1-index],2);\\n        }\\n\\n        if(b.length-1-index >= 0) {\\n            y = parseInt(b[b.length-1-index],2);\\n        }\\n        \\n        let sum = carry + x + y;\\n\\n        if(sum <= 1) {\\n            result = `${sum}${result}`;\\n            carry = 0;\\n        } else {\\n            result = `${sum%2}${result}`;\\n            carry = 1;\\n        }\\n\\n        index++;\\n    }\\n\\n    if (carry === 1) {\\n        result = `${carry}${result}`;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n\\n    let result = \"\";\\n    let carry = 0;\\n    let index = 0;\\n\\n    while (index < Math.max(a.length,b.length)) {\\n        let x = 0;\\n        let y = 0;\\n\\n        if(a.length-1-index >= 0) {\\n            x = parseInt(a[a.length-1-index],2);\\n        }\\n\\n        if(b.length-1-index >= 0) {\\n            y = parseInt(b[b.length-1-index],2);\\n        }\\n        \\n        let sum = carry + x + y;\\n\\n        if(sum <= 1) {\\n            result = `${sum}${result}`;\\n            carry = 0;\\n        } else {\\n            result = `${sum%2}${result}`;\\n            carry = 1;\\n        }\\n\\n        index++;\\n    }\\n\\n    if (carry === 1) {\\n        result = `${carry}${result}`;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086336,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //110101001\\n    //1101\\n    string addBinary(string a, string b) { \\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int i=0,j=0;\\n        string c=\"0\";\\n        string ans=\"\";\\n        while(i<a.length() && j<b.length())\\n        {\\n            if(a[i]==\\'0\\' && b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else if(a[i]==\\'1\\' && b[j]==\\'1\\')\\n            {\\n                ans+=c;\\n                c=\"1\";\\n            }\\n            else\\n            {\\n                if(c==\"1\")\\n                {\\n                    ans+=\"0\";\\n                    c=\"1\";\\n                }\\n                else\\n                {\\n                    ans+=\"1\";\\n                    c=\"0\";\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        while(i<a.length())\\n        {\\n            if(a[i]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=a[i];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            i++;\\n        }\\n        while(j<b.length())\\n        {\\n            if(b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=b[j];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            j++;\\n        }\\n        if(c==\"1\")\\n        ans+=c;\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //110101001\\n    //1101\\n    string addBinary(string a, string b) { \\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int i=0,j=0;\\n        string c=\"0\";\\n        string ans=\"\";\\n        while(i<a.length() && j<b.length())\\n        {\\n            if(a[i]==\\'0\\' && b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else if(a[i]==\\'1\\' && b[j]==\\'1\\')\\n            {\\n                ans+=c;\\n                c=\"1\";\\n            }\\n            else\\n            {\\n                if(c==\"1\")\\n                {\\n                    ans+=\"0\";\\n                    c=\"1\";\\n                }\\n                else\\n                {\\n                    ans+=\"1\";\\n                    c=\"0\";\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        while(i<a.length())\\n        {\\n            if(a[i]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=a[i];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            i++;\\n        }\\n        while(j<b.length())\\n        {\\n            if(b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=b[j];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            j++;\\n        }\\n        if(c==\"1\")\\n        ans+=c;\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121434,
                "title": "python-concise-solution-with-divmod",
                "content": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        \\n        la, lb = len(a), len(b)\\n        \\n        if la < lb:\\n            a = \\'0\\' * (lb - la) + a\\n        else:\\n            b = \\'0\\' * (la - lb) + b\\n        \\n        a = [int(c) for c in a]\\n        b = [int(c) for c in b]\\n        \\n        carry = 0\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            \\n            carry, a[i] = divmod(a[i]+b[i]+carry,2)\\n        \\n        if carry:\\n             a = [carry] + a\\n        \\n        return \\'\\'.join([str(d) for d in a])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        \\n        la, lb = len(a), len(b)\\n        \\n        if la < lb:\\n            a = \\'0\\' * (lb - la) + a\\n        else:\\n            b = \\'0\\' * (la - lb) + b\\n        \\n        a = [int(c) for c in a]\\n        b = [int(c) for c in b]\\n        \\n        carry = 0\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            \\n            carry, a[i] = divmod(a[i]+b[i]+carry,2)\\n        \\n        if carry:\\n             a = [carry] + a\\n        \\n        return \\'\\'.join([str(d) for d in a])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1174486,
                "title": "python-single-line-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2) + int(b,2))[2:]\\n```\\n\\nHere, first we convert the given strings(a and b) into their binary equivalents.\\nThis is done by ```int(a,2)``` and ```int(b,2)```. If we simply give ```int(a)```, the string will be converted to its decimal equivalent. So we need to specify to which base we need to convert the string into, which is 2 in our case.\\n\\nNow we need to carry out binary addition. To tell the system that we intend to carry out a binary operation and require the result in binary format, we enclose ```int(a,2) + int(b,2)``` with the ```bin()``` function. If we simply write ```int(a,2) + int(b,2)```, we will get the answer in decimal form.\\n\\nNow we will get the binary result with ```bin(int(a,2) + int(b,2))```. But by convention, the value of ```bin()``` is stored as a string starting with \\'0b\\', and then the result. For example if the actual answer for the binary addition is \\'100\\', the string returned by ```bin()``` will be \\'0b100\\'. This is to denote that the string represents a binary number.\\n\\nBut we do not need the extra \\'0b\\' in front of our answer. So we slice the string to ignore the first two characters, i.e. by [2:]. So the final answer is reached.\\n\\n```bin(int(a,2) + int(b,2))[2:]```\\n\\nNow just return it.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2) + int(b,2))[2:]\\n```\n```int(a,2)```\n```int(b,2)```\n```int(a)```\n```int(a,2) + int(b,2)```\n```bin()```\n```int(a,2) + int(b,2)```\n```bin(int(a,2) + int(b,2))```\n```bin()```\n```bin()```\n```bin(int(a,2) + int(b,2))[2:]```",
                "codeTag": "Java"
            },
            {
                "id": 1012869,
                "title": "0ms-golang-solution-use-math-big-package-very-simple",
                "content": "```\\nfunc addBinary(a string, b string) string {\\n\\taInt,bInt,sum:=new(big.Int),new(big.Int),new(big.Int)\\n\\taInt.SetString(a,2)\\n\\tbInt.SetString(b,2)\\n\\tsum.Add(aInt,bInt)\\n\\treturn sum.Text(2)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc addBinary(a string, b string) string {\\n\\taInt,bInt,sum:=new(big.Int),new(big.Int),new(big.Int)\\n\\taInt.SetString(a,2)\\n\\tbInt.SetString(b,2)\\n\\tsum.Add(aInt,bInt)\\n\\treturn sum.Text(2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865910,
                "title": "javascript-bit-manipulation",
                "content": "```\\nvar addBinary = function(a, b) {\\n  let binaryA = BigInt(\"0b\" + a);\\n  let binaryB = BigInt(\"0b\" + b);\\n  let sum;\\n  let carry;\\n  while (binaryB || carry === undefined) {\\n    sum = binaryA ^ binaryB;\\n    carry = (binaryA & binaryB) << BigInt(\"0b1\");\\n    binaryA = sum\\n    binaryB = carry\\n  }\\n  return sum.toString(2);\\n};\\n```\\nDoes it make sense ?",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n  let binaryA = BigInt(\"0b\" + a);\\n  let binaryB = BigInt(\"0b\" + b);\\n  let sum;\\n  let carry;\\n  while (binaryB || carry === undefined) {\\n    sum = binaryA ^ binaryB;\\n    carry = (binaryA & binaryB) << BigInt(\"0b1\");\\n    binaryA = sum\\n    binaryB = carry\\n  }\\n  return sum.toString(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847720,
                "title": "super-simple-python-solution-1-line",
                "content": "The idea behind the code is pretty simple.\\n\\nFirst, convert the given binary strings into base 10 integers. Then add them.\\nFinally, return the binary value of the answer.\\n\\n```\\ndef addBinary(self, a: str, b: str) -> str:\\n# Convert the given strings to int and add them. Then return bin value of result.\\n        return bin(int(a,2)+int(b,2))[2:]\\n\\t\\t\\n\\t\\t\\n\\t\\t# [2:] is taken because python returns the bin value starting with \"0b\" which we do not need.\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n# Convert the given strings to int and add them. Then return bin value of result.\\n        return bin(int(a,2)+int(b,2))[2:]\\n\\t\\t\\n\\t\\t\\n\\t\\t# [2:] is taken because python returns the bin value starting with \"0b\" which we do not need.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 613270,
                "title": "javascript",
                "content": "```\\nvar addBinary = function(a, b) {\\n    let index1 = a.length;\\n    let index2 = b.length;\\n    let result = \\'\\';\\n    let carry = 0;\\n    while (index1 || index2) {\\n        let sum = (index1 > 0 ? +a[--index1] : 0) + (index2 > 0 ? +b[--index2] : 0) + carry;\\n        result = (sum % 2) + result;\\n        carry = sum > 1 ? 1 : 0;\\n    };\\n    return carry ? carry + result : result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addBinary = function(a, b) {\\n    let index1 = a.length;\\n    let index2 = b.length;\\n    let result = \\'\\';\\n    let carry = 0;\\n    while (index1 || index2) {\\n        let sum = (index1 > 0 ? +a[--index1] : 0) + (index2 > 0 ? +b[--index2] : 0) + carry;\\n        result = (sum % 2) + result;\\n        carry = sum > 1 ? 1 : 0;\\n    };\\n    return carry ? carry + result : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24699,
                "title": "3ms-java-simple-solution-using-stringbuilder",
                "content": "    class Solution {\\n        public String addBinary(String a, String b) {\\n            int c = 0;\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0;){\\n                if(i >= 0) c += a.charAt(i--) - '0';\\n                if(j >= 0) c += b.charAt(j--) - '0';\\n                sb.insert(0, (char)((c % 2) + '0'));\\n                c /= 2;\\n            }\\n            if(c == 1) sb.insert(0, \"1\");\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            int c = 0;\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0;){\\n                if(i >= 0) c += a.charAt(i--) - '0';\\n                if(j >= 0) c += b.charAt(j--) - '0';\\n                sb.insert(0, (char)((c % 2) + '0'));\\n                c /= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24748,
                "title": "short-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            bool carry = false;\\n            int i = a.length() - 1, j = b.length()-1;\\n            string res(max(i,j)+1, '0');\\n            while(i >= 0 || j >= 0) {\\n                int cur = (i >= 0? a[i--]-'0' : 0) + (j >= 0 ? b[j--]-'0' : 0 ) + carry;\\n                res[max(i,j)+1] = (cur % 2) + '0';\\n                carry = (cur > 1);\\n            }\\n            if (carry) \\n                res = \"1\" + res;\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            bool carry = false;\\n            int i = a.length() - 1, j = b.length()-1;\\n            string res(max(i,j)+1, '0');\\n            while(i >= 0 || j >= 0) {\\n                int cur = (i >= 0? a[i--]-'0' : 0) + (j >= 0 ? b[j--]-'0' : 0 ) + carry;\\n                res[max(i,j)+1] = (cur % 2) + '0';\\n                carry = (cur > 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24768,
                "title": "ac-clean-java-solution",
                "content": "    public String addBinary(String s1, String s2) {\\n        int i = s1.length() - 1, j = s2.length() - 1, c = 0;\\n        String s = \"\";\\n        \\n        while (i >= 0 || j >= 0 || c == 1) {\\n            int a = (i < 0) ? 0 : s1.charAt(i--) - '0';\\n            int b = (j < 0) ? 0 : s2.charAt(j--) - '0';\\n            \\n            s = (char)('0' + a ^ b ^ c) + s;\\n            c = (a + b + c) >> 1;\\n        }\\n        \\n        return s;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String addBinary(String s1, String s2) {\\n        int i = s1.length() - 1, j = s2.length() - 1, c = 0;\\n        String s = \"\";\\n        \\n        while (i >= 0 || j >= 0 || c == 1) {\\n            int a = (i < 0) ? 0 : s1.charAt(i--) - '0';\\n            int b = (j < 0) ? 0 : s2.charAt(j--) - '0';\\n            \\n            s = (char)('0' + a ^ b ^ c) + s;\\n            c = (a + b + c) >> 1;\\n        }\\n        \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24773,
                "title": "c-vanilla",
                "content": "The idea is to use two pointers initialied at the end of the two binary numbers and add from back to forth.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int m = a.size(), n = b.size(), carry = 0;\\n        for (int i = m - 1, j = n - 1; i >= 0 || j >= 0 || carry; i--, j--) {\\n            int x = i >= 0 ? a[i] - \\'0\\' : 0;\\n            int y = j >= 0 ? b[j] - \\'0\\' : 0;\\n            int sum = x ^ y ^ carry;\\n            carry = (x & y) | (x & carry) | (y & carry);\\n            ans = to_string(sum) + ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int m = a.size(), n = b.size(), carry = 0;\\n        for (int i = m - 1, j = n - 1; i >= 0 || j >= 0 || carry; i--, j--) {\\n            int x = i >= 0 ? a[i] - \\'0\\' : 0;\\n            int y = j >= 0 ? b[j] - \\'0\\' : 0;\\n            int sum = x ^ y ^ carry;\\n            carry = (x & y) | (x & carry) | (y & carry);\\n            ans = to_string(sum) + ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859464,
                "title": "simple-and-clean-code-c-optimized",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n\\n//facebook\\'s top 4 question:::\\n\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            //changing again to string for storing\\n            res += to_string(sum % 2);\\n        }\\n        //bilkull end me agar still koi carry aata hai to\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\n   \\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n\\n//facebook\\'s top 4 question:::\\n\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            //changing again to string for storing\\n            res += to_string(sum % 2);\\n        }\\n        //bilkull end me agar still koi carry aata hai to\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073488,
                "title": "python-one-liner-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just convert a binary number into a decimal and do a summation and return it as a binary number using \"bin\" and \"int\" functions of python. Here, by default we got 0b in answer as a prifix because of the \"bin\" function. That\\'s why we slice that final answer by doing [2:]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2)+int(b,2))[2:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2)+int(b,2))[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571449,
                "title": "javascript-solution-in-one-line",
                "content": "```\\nvar addBinary = function (a, b) {\\n  return (BigInt(\\'0b\\' + a) + BigInt(\\'0b\\' + b)).toString(2);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function (a, b) {\\n  return (BigInt(\\'0b\\' + a) + BigInt(\\'0b\\' + b)).toString(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355068,
                "title": "c-solution-faster-than-100-easy-to-understand",
                "content": "Be clear with concepts of string and integer and their conversion.\\n\\nHere\\'s the code:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string result;\\n        int carry=0;\\n        while(i>=0||j>=0)\\n        {    \\n            int sum = carry;\\n            if(i>=0)\\n            sum+=a[i--] - \\'0\\';\\n            if(j>=0)\\n            sum+=b[j--] - \\'0\\';\\n            carry=sum > 1 ? 1:0;\\n            result+=to_string(sum%2);\\n        }\\n        if(carry)\\n            result+=to_string(carry);\\n            reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```\\n\\nFor eg:\\nAdd 101 and 11\\nfrom last adding 1 and 1 ,initial carry is 0 , adding all we get 2\\n2>1 , so carry is 1 for next string.\\nresult is\\' 0\\'+\\'(2%2)\\'=\\'0\\';\\nnow add 0+1+1(carry)=2;\\nsum>1 =>carry =1 for next;\\nresult=\\'0\\'+\\'(2%2)\\'=\\'00\\'\\nnow add 1+1(carry)\\nsum>1 =carry =1;\\nresult=\\'00\\'+\\'(2%2)=\\'000\\'\\nboth strings end, append leftover carry by converting to string \\nresult = \\'000\\'+\\'1\\'=\\'0001\\';\\nreverse for final result=\\'1000\\'\\n101 (5) + 11 (3) = 1000  (8).\\n\\nHope you understood.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string result;\\n        int carry=0;\\n        while(i>=0||j>=0)\\n        {    \\n            int sum = carry;\\n            if(i>=0)\\n            sum+=a[i--] - \\'0\\';\\n            if(j>=0)\\n            sum+=b[j--] - \\'0\\';\\n            carry=sum > 1 ? 1:0;\\n            result+=to_string(sum%2);\\n        }\\n        if(carry)\\n            result+=to_string(carry);\\n            reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324370,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        use std::iter;\\n        let mut carry = 0;\\n        let mut cur_sum = 0;\\n        let mut char_vec = a\\n            .as_bytes()\\n            .iter()\\n            .rev()\\n            .chain(iter::repeat(&b\\'0\\'))\\n            .zip(b.as_bytes().iter().rev().chain(iter::repeat(&b\\'0\\')))\\n            .take(a.len().max(b.len()))\\n            .map(|(ac, bc)| {\\n                cur_sum = (*ac - b\\'0\\') + (*bc - b\\'0\\') + carry;\\n                carry = cur_sum / 2;\\n                match cur_sum % 2 {\\n                    1 => \\'1\\',\\n                    _ => \\'0\\',\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n\\n        if carry == 1 {\\n            char_vec.push(\\'1\\');\\n        }\\n\\n        char_vec.iter().rev().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        use std::iter;\\n        let mut carry = 0;\\n        let mut cur_sum = 0;\\n        let mut char_vec = a\\n            .as_bytes()\\n            .iter()\\n            .rev()\\n            .chain(iter::repeat(&b\\'0\\'))\\n            .zip(b.as_bytes().iter().rev().chain(iter::repeat(&b\\'0\\')))\\n            .take(a.len().max(b.len()))\\n            .map(|(ac, bc)| {\\n                cur_sum = (*ac - b\\'0\\') + (*bc - b\\'0\\') + carry;\\n                carry = cur_sum / 2;\\n                match cur_sum % 2 {\\n                    1 => \\'1\\',\\n                    _ => \\'0\\',\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n\\n        if carry == 1 {\\n            char_vec.push(\\'1\\');\\n        }\\n\\n        char_vec.iter().rev().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840448,
                "title": "js-98",
                "content": "```js\\nvar addBinary = function(a, b) {\\n  let i = a.length - 1, \\n      j = b.length - 1,\\n      carry = 0, \\n      result = [];\\n  while(i >= 0 || j >= 0) {\\n    let n1 = +a[i] || 0;\\n    let n2 = +b[j] || 0;\\n    let sum = n1 + n2 + carry;\\n    if(sum === 0) {\\n      result.unshift(0);\\n      carry = 0;\\n    } else if(sum === 1) {\\n      result.unshift(1);\\n       carry = 0;\\n    } else if(sum === 2) {\\n      result.unshift(0);\\n      carry = 1;\\n    } else if(sum === 3) {\\n      result.unshift(1);\\n      carry = 1;\\n    }\\n    i--;\\n    j--; \\n  }\\n  if(carry) {\\n    result.unshift(1);\\n  }\\n  return result.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar addBinary = function(a, b) {\\n  let i = a.length - 1, \\n      j = b.length - 1,\\n      carry = 0, \\n      result = [];\\n  while(i >= 0 || j >= 0) {\\n    let n1 = +a[i] || 0;\\n    let n2 = +b[j] || 0;\\n    let sum = n1 + n2 + carry;\\n    if(sum === 0) {\\n      result.unshift(0);\\n      carry = 0;\\n    } else if(sum === 1) {\\n      result.unshift(1);\\n       carry = 0;\\n    } else if(sum === 2) {\\n      result.unshift(0);\\n      carry = 1;\\n    } else if(sum === 3) {\\n      result.unshift(1);\\n      carry = 1;\\n    }\\n    i--;\\n    j--; \\n  }\\n  if(carry) {\\n    result.unshift(1);\\n  }\\n  return result.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726796,
                "title": "python-one-liner",
                "content": "Approach:\\n1. The problem can be solved by first **converting both binary values to decimals.** \\n2. **Compute sum** by adding the two decimal values.\\n3. Return the **binary value of the sum** in string format. \\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a, 2) + int (b, 2)))[2:]\\n```\\nIn python, a binary number ```n``` can be converted to its decimal form by using the ```int(n,2)```.\\nThus the operation ``` int(a, 2) + int(b, 2) ```will add the decimals after conversion. This sum is then converted back to binary using ```bin()```. The binary is converted to type string and returned.\\n\\n**NOTE:** The string is returned from [2:] because, in python, the first two characters in the binary form are \"0b\" followed by the actual binary value. \\n\\nFor example,\\nLet ```a = \"11\", b = \"1\"```\\nAfter running ```str(bin(int(a,2) + int(b,2)))``` the result would be ```\"0b100\"```. Thus when returning the string, the first two characters are omitted and hence the term **[2:]**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a, 2) + int (b, 2)))[2:]\\n```\n```n```\n```int(n,2)```\n``` int(a, 2) + int(b, 2) ```\n```bin()```\n```a = \"11\", b = \"1\"```\n```str(bin(int(a,2) + int(b,2)))```\n```\"0b100\"```",
                "codeTag": "Java"
            },
            {
                "id": 167114,
                "title": "javascript-solution-with-2-pointers",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  let i = a.length-1;\\n  let j = b.length-1;\\n  let carry = 0;\\n  let result = \\'\\';\\n  while (i >= 0 || j >= 0) {\\n      let aDigit = a[i] || \\'0\\';\\n      let bDigit = b[j] || \\'0\\';\\n      let temp = parseInt(aDigit) + parseInt(bDigit) + carry;\\n      let digit = temp % 2;\\n      carry = Math.floor(temp / 2);\\n      result = digit + result;\\n      i--;\\n      j--;\\n   }\\n  if (carry !== 0) result = carry + result;\\n  return result;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  let i = a.length-1;\\n  let j = b.length-1;\\n  let carry = 0;\\n  let result = \\'\\';\\n  while (i >= 0 || j >= 0) {\\n      let aDigit = a[i] || \\'0\\';\\n      let bDigit = b[j] || \\'0\\';\\n      let temp = parseInt(aDigit) + parseInt(bDigit) + carry;\\n      let digit = temp % 2;\\n      carry = Math.floor(temp / 2);\\n      result = digit + result;\\n      i--;\\n      j--;\\n   }\\n  if (carry !== 0) result = carry + result;\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24684,
                "title": "java-simple-solution",
                "content": "        \\n    public String addBinary(String a, String b) {\\n        if (a == null || a == \"\")\\n            return b;\\n        if (b == null || b == \"\")\\n            return a;\\n        int carry = 0;\\n        String ret = \"\";\\n        int l1 = a.length()-1;\\n        int l2 = b.length()-1;\\n        while (l1 >= 0 || l2 >= 0 || carry == 1) {\\n            if (l1 >= 0) {\\n                carry += Integer.parseInt(a.charAt(l1)+\"\");\\n                l1--;\\n            }\\n            if (l2 >= 0) {\\n                carry += Integer.parseInt(b.charAt(l2)+\"\");\\n                l2--;\\n            }\\n            ret = String.valueOf(carry%2) + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public String addBinary(String a, String b) {\\n        if (a == null || a == \"\")\\n            return b;\\n        if (b == null || b == \"\")\\n            return a;\\n        int carry = 0;\\n        String ret = \"\";\\n        int l1 = a.length()-1;\\n        int l2 = b.length()-1;\\n        while (l1 >= 0 || l2 >= 0 || carry == 1) {\\n            if (l1 >= 0) {\\n                carry += Integer.parseInt(a.charAt(l1)+\"\");\\n                l1--;\\n            }\\n            if (l2 >= 0) {\\n                carry += Integer.parseInt(b.charAt(l2)+\"\");\\n                l2--;\\n            }\\n            ret = String.valueOf(carry%2) + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3738124,
                "title": "sol-using-python-just-2-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = str(bin(int(a, 2) + int(b, 2)))\\n        return res[2:]\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = str(bin(int(a, 2) + int(b, 2)))\\n        return res[2:]\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415431,
                "title": "easy-c-solution-with-if-else-which-beats-60-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdding each bit of the string individually.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterating through both the string simultaneously and adding the result in the resultant string according to the iterators current values.\\n\\n# Complexity\\n- Time complexity: O(max(a,b))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(a,b))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string s;\\n        std::string::iterator itr1=a.end()-1,itr2=b.end()-1;\\n        bool carry=0;\\n        while(itr1>=a.begin()&&itr2>=b.begin())\\n        {\\n            if(*itr1==\\'1\\'&&*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                    carry=1;\\n                }\\n            }\\n            else if((*itr1==\\'1\\'&&*itr2==\\'0\\')||(*itr1==\\'0\\'&&*itr2==\\'1\\'))\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n            itr1--;itr2--;\\n        }\\n        for(;itr1>=a.begin();itr1--)\\n        {\\n            if(*itr1==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }}\\n            for(;itr2>=b.begin();itr2--)\\n        {\\n            if(*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n        }\\n        if(carry==1)\\n        {\\n            s=\\'1\\'+s;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string s;\\n        std::string::iterator itr1=a.end()-1,itr2=b.end()-1;\\n        bool carry=0;\\n        while(itr1>=a.begin()&&itr2>=b.begin())\\n        {\\n            if(*itr1==\\'1\\'&&*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                    carry=1;\\n                }\\n            }\\n            else if((*itr1==\\'1\\'&&*itr2==\\'0\\')||(*itr1==\\'0\\'&&*itr2==\\'1\\'))\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n            itr1--;itr2--;\\n        }\\n        for(;itr1>=a.begin();itr1--)\\n        {\\n            if(*itr1==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }}\\n            for(;itr2>=b.begin();itr2--)\\n        {\\n            if(*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n        }\\n        if(carry==1)\\n        {\\n            s=\\'1\\'+s;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184413,
                "title": "c-beginner-friendly-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA little bit lengthy but easy to understand. \\nWe just have to handle all the cases like for carry and sum of a[i] and b[i].  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) --> not considering ans string \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i=0;\\n        int carry=0;\\n        reverse(begin(a),end(a));\\n        reverse(begin(b),end(b));\\n        while(i<a.size() and i<b.size()){\\n            ans+=((a[i]!=b[i] and !carry) or (a[i]==b[i] and carry))?\\'1\\':\\'0\\';\\n            carry= ((a[i]==\\'1\\' and b[i]==\\'1\\') or (a[i]!=b[i] and carry));\\n            i++;\\n        }\\n        while(i<a.size()){\\n            ans+=((a[i]==\\'1\\' and carry) or (a[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(a[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n         while(i<b.size()){\\n            ans+=((b[i]==\\'1\\' and carry) or (b[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(b[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n        if(carry)ans+=\\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i=0;\\n        int carry=0;\\n        reverse(begin(a),end(a));\\n        reverse(begin(b),end(b));\\n        while(i<a.size() and i<b.size()){\\n            ans+=((a[i]!=b[i] and !carry) or (a[i]==b[i] and carry))?\\'1\\':\\'0\\';\\n            carry= ((a[i]==\\'1\\' and b[i]==\\'1\\') or (a[i]!=b[i] and carry));\\n            i++;\\n        }\\n        while(i<a.size()){\\n            ans+=((a[i]==\\'1\\' and carry) or (a[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(a[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n         while(i<b.size()){\\n            ans+=((b[i]==\\'1\\' and carry) or (b[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(b[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n        if(carry)ans+=\\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183290,
                "title": "beginner-friendly-solution-easy-simple-iteration",
                "content": "# Intuition\\nSimplpy iterating strings\\n\\n# Approach\\n- take carry, value as 0 and an empty string\\n- take a while loop in which iterate both the string and a condition in which carry is not equal to zero\\n- take index A-i-1(A size of string a) of a and B-i-1(B size of string b) of b and add these values at these indexes with carry and mod the value\\n- convert the values to string and add to ans string\\n- increment i\\n- after the loop return string ans\\n\\n# Complexity\\n- Time complexity:\\nO(size  of string a) or O(size of string b)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n       int i=0,carry=0;\\n        string ans=\"\";\\n        int A=a.size();\\n        int B=b.size();\\n       while(i<A||i<B||carry!=0){\\n           int x=0;\\n           if(i<A &&a[A-i-1]==\\'1\\'){\\n               x=1;\\n           }\\n           int y=0;\\n           if(i<B &&b[B-i-1]==\\'1\\'){\\n               y=1;\\n           }\\n           ans=to_string((x+y+carry)%2)+ans;\\n           carry=(x+y+carry)/2;\\n           i+=1;\\n       }\\n        return ans;\\n    }\\n};\\n```\\n# Code in python\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        i=0\\n        ans=\"\"\\n        carry=0\\n        while(i<len(a) or i<len(b) or carry!=0):\\n            x=0\\n            if(i<len(a) and a[len(a)-i-1]==\\'1\\'):\\n                x=1\\n            y=0\\n            if(i<len(b) and b[len(b)-i-1]==\\'1\\'):\\n                y=1\\n            ans=str((x+y+carry)%2)+ans\\n            carry=(x+y+carry)//2\\n            i+=1\\n        return ans\\n        \\n    pyt\\n```\\n\\n# DON\\'T FORGET TO UPVOTE !",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n       int i=0,carry=0;\\n        string ans=\"\";\\n        int A=a.size();\\n        int B=b.size();\\n       while(i<A||i<B||carry!=0){\\n           int x=0;\\n           if(i<A &&a[A-i-1]==\\'1\\'){\\n               x=1;\\n           }\\n           int y=0;\\n           if(i<B &&b[B-i-1]==\\'1\\'){\\n               y=1;\\n           }\\n           ans=to_string((x+y+carry)%2)+ans;\\n           carry=(x+y+carry)/2;\\n           i+=1;\\n       }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        i=0\\n        ans=\"\"\\n        carry=0\\n        while(i<len(a) or i<len(b) or carry!=0):\\n            x=0\\n            if(i<len(a) and a[len(a)-i-1]==\\'1\\'):\\n                x=1\\n            y=0\\n            if(i<len(b) and b[len(b)-i-1]==\\'1\\'):\\n                y=1\\n            ans=str((x+y+carry)%2)+ans\\n            carry=(x+y+carry)//2\\n            i+=1\\n        return ans\\n        \\n    pyt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182731,
                "title": "daily-leetcoding-challenge-february-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3172276,
                "title": "easy-to-understand-python-o-n-tc-solution",
                "content": "# Intuition\\nUse basic rules of binary addition but remember to consider carry Rules could be mapped with this approach:\\n1. if we have 3 \\'1\\' w.r.t a[i] , b[j] and carry then \\ncarry = 1 and  ( addtion of a[i] , b[j] and carry = 1 )\\n\\n2. if we have 2 \\'1\\' w.r.t a[i], b[j] and carry then\\ncarry = 1 and ( addtion of a[i] , b[j] and carry = 0 )\\n\\n3. if we have 1 \\'1\\' w.r.t a[i] , b[j] and carry then \\ncarry = 0 and ( addtion of a[i] , b[j] and carry = 1 )\\n\\n4. if we have 0 \\'1\\' w.r.t a[i] , b[j] and carry then\\ncarry = 0 and ( addtion of a[i] , b[j] and carry = 0 )\\n\\n# Approach\\n\\nsimple iterate the string a and string b and carry is not empty\\nwith carry not empty I mean not zero\\n\\nIterate in reverse order for addition\\n\\nEvery time we initialize ones with 0 and if we see a \\'1\\' we increment the count of ones\\n\\nand rest is mapping based on the intuition \\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1) -- if we don\\'t consider ans string else O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        ans = \"\"\\n        i = len(a) - 1\\n        j = len(b) - 1\\n        carry = 0\\n\\n        while i >= 0 or j >= 0 or carry:\\n            ones = 0\\n            if i >= 0 and a[i] == \\'1\\':\\n                ones += 1 \\n            if j >= 0 and b[j] == \\'1\\':\\n                ones += 1 \\n            if carry == 1:\\n                ones += 1 \\n            \\n            if ones == 0:\\n                ans = ans + \"0\"\\n            elif ones == 1:\\n                ans = ans + \\'1\\'\\n                carry = 0\\n            elif ones == 2:\\n                ans = ans + \\'0\\'\\n                carry = 1\\n            else:\\n                ans = ans + \\'1\\'\\n                carry = 1\\n\\n            i -= 1 \\n            j -= 1 \\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        ans = \"\"\\n        i = len(a) - 1\\n        j = len(b) - 1\\n        carry = 0\\n\\n        while i >= 0 or j >= 0 or carry:\\n            ones = 0\\n            if i >= 0 and a[i] == \\'1\\':\\n                ones += 1 \\n            if j >= 0 and b[j] == \\'1\\':\\n                ones += 1 \\n            if carry == 1:\\n                ones += 1 \\n            \\n            if ones == 0:\\n                ans = ans + \"0\"\\n            elif ones == 1:\\n                ans = ans + \\'1\\'\\n                carry = 0\\n            elif ones == 2:\\n                ans = ans + \\'0\\'\\n                carry = 1\\n            else:\\n                ans = ans + \\'1\\'\\n                carry = 1\\n\\n            i -= 1 \\n            j -= 1 \\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792541,
                "title": "1-line-kotlin-solution-with-80-space-complexity",
                "content": "# Complexity\\n- Time complexity: Runtime 76.33%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 80%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun addBinary(a: String, b: String): String {\\n        return (a.toBigInteger(2) + b.toBigInteger(2)).toString(2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun addBinary(a: String, b: String): String {\\n        return (a.toBigInteger(2) + b.toBigInteger(2)).toString(2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707115,
                "title": "python-two-line-solution-very-easy-to-understand-o-n-100",
                "content": "Firstly we convert string into int using python function.\\nThen add both the numbers.\\nAt last Converting back int to string and returning them.\\n\\n```\\n    def addBinary(self, a, b):\\n        x,y = int(a,2) , int (b,2)\\n        return str(bin(x+y).replace(\"0b\",\"\"))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def addBinary(self, a, b):\\n        x,y = int(a,2) , int (b,2)\\n        return str(bin(x+y).replace(\"0b\",\"\"))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2378436,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "```java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int i= a.length() -1;\\n        int j= b.length() -1;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0)\\n                sum+=a.charAt(i--)-\\'0\\'; // -\\'0\\' is just to convert char in integer\\n            if(j>=0)\\n                sum+=b.charAt(j--)-\\'0\\';\\n            sb.append(sum%2);   // If we have sum = 1  1  then = 2 % 2 = 0 and 0  1 = 1 % 2 = 1\\n            carry = sum /2;\\n        }\\n        if(carry>0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n```javascript []\\nvar addBinary = function(a, b) {\\n    let i = a.length-1, j = b.length-1, carry = 0\\n    let s =[]\\n    while(i >= 0 || j >= 0){\\n        let sum = carry\\n        if(i >= 0)  sum += a[i--].charCodeAt() - 48\\n        if(j >= 0)  sum += b[j--].charCodeAt() - 48\\n        s.unshift(sum % 2)\\n        carry = ~~(sum/2)\\n    }\\n    return carry > 0 ? \"1\" + s.join(\"\") : s.join(\"\")\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        i, j, carry = len(a)-1, len(b)-1, 0\\n        s = []\\n        while i >= 0 or j >= 0:\\n            sm = carry\\n            if i >= 0:\\n                sm += ord(a[i]) - 48\\n                i -= 1\\n            if j >= 0:\\n                sm += ord(b[j]) - 48\\n                j -= 1\\n            s.insert(0, (sm % 2))\\n            carry = sm/2\\n        return \\'1\\' + \\'\\'.join(map(str, s)) if carry > 0 else \\'\\'.join(map(str, s))\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int i= a.length() -1;\\n        int j= b.length() -1;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0)\\n                sum+=a.charAt(i--)-\\'0\\'; // -\\'0\\' is just to convert char in integer\\n            if(j>=0)\\n                sum+=b.charAt(j--)-\\'0\\';\\n            sb.append(sum%2);   // If we have sum = 1  1  then = 2 % 2 = 0 and 0  1 = 1 % 2 = 1\\n            carry = sum /2;\\n        }\\n        if(carry>0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```javascript []\\nvar addBinary = function(a, b) {\\n    let i = a.length-1, j = b.length-1, carry = 0\\n    let s =[]\\n    while(i >= 0 || j >= 0){\\n        let sum = carry\\n        if(i >= 0)  sum += a[i--].charCodeAt() - 48\\n        if(j >= 0)  sum += b[j--].charCodeAt() - 48\\n        s.unshift(sum % 2)\\n        carry = ~~(sum/2)\\n    }\\n    return carry > 0 ? \"1\" + s.join(\"\") : s.join(\"\")\\n};\\n```\n```python []\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        i, j, carry = len(a)-1, len(b)-1, 0\\n        s = []\\n        while i >= 0 or j >= 0:\\n            sm = carry\\n            if i >= 0:\\n                sm += ord(a[i]) - 48\\n                i -= 1\\n            if j >= 0:\\n                sm += ord(b[j]) - 48\\n                j -= 1\\n            s.insert(0, (sm % 2))\\n            carry = sm/2\\n        return \\'1\\' + \\'\\'.join(map(str, s)) if carry > 0 else \\'\\'.join(map(str, s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368240,
                "title": "runtime-0ms-faster-than-100-00-of-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string str=\"\";\\n        int carry=0;      \\n        while(a.size()!=0 || b.size()!=0)\\n        {     \\n            char al;        \\n            char bl;\\n            (a.size()!=0)? al=a.back():al=\\'0\\';         \\n            (b.size()!=0)? bl=b.back():bl=\\'0\\';\\n           \\n            if((al==\\'1\\' && bl==\\'0\\')||(al==\\'0\\' && bl==\\'1\\'))\\n            {\\n                if(carry==0)\\n                {\\n                    str+=\\'1\\';\\n                }\\n                else\\n                { \\n                    str+=\\'0\\';\\n                    carry=1;\\n                }\\n            }\\n            else if(al==\\'1\\' && bl==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    str+=\\'1\\';carry=1;\\n                }\\n                else\\n                {\\n                    str+=\\'0\\';carry=1;\\n                }\\n            }\\n            else if(al==\\'0\\'&& bl==\\'0\\')\\n            {\\n                if(carry==0)str+=\\'0\\';\\n                else\\n                { \\n                    str+=\\'1\\';\\n                    carry=0;\\n                }\\n            }\\n            if(a.size()!=0)a.pop_back();\\n            if(b.size()!=0)b.pop_back();\\n        }\\n        if(carry==1)str+=\\'1\\';\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string str=\"\";\\n        int carry=0;      \\n        while(a.size()!=0 || b.size()!=0)\\n        {     \\n            char al;        \\n            char bl;\\n            (a.size()!=0)? al=a.back():al=\\'0\\';         \\n            (b.size()!=0)? bl=b.back():bl=\\'0\\';\\n           \\n            if((al==\\'1\\' && bl==\\'0\\')||(al==\\'0\\' && bl==\\'1\\'))\\n            {\\n                if(carry==0)\\n                {\\n                    str+=\\'1\\';\\n                }\\n                else\\n                { \\n                    str+=\\'0\\';\\n                    carry=1;\\n                }\\n            }\\n            else if(al==\\'1\\' && bl==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    str+=\\'1\\';carry=1;\\n                }\\n                else\\n                {\\n                    str+=\\'0\\';carry=1;\\n                }\\n            }\\n            else if(al==\\'0\\'&& bl==\\'0\\')\\n            {\\n                if(carry==0)str+=\\'0\\';\\n                else\\n                { \\n                    str+=\\'1\\';\\n                    carry=0;\\n                }\\n            }\\n            if(a.size()!=0)a.pop_back();\\n            if(b.size()!=0)b.pop_back();\\n        }\\n        if(carry==1)str+=\\'1\\';\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890638,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction addBinary(a: string, b: string): string {\\n  let result = \"\"\\n  let carry = 0\\n  let length = Math.max(a.length, b.length)\\n  let i = 1\\n  const its = []\\n\\n  while (i <= length) {\\n    let x = Number(a[a.length - i] || 0)\\n    let y = Number(b[b.length - i] || 0)\\n    let sum = x + y + carry\\n\\n    carry = sum > 1 ? 1 : 0\\n    result = (sum % 2) + result\\n\\n    its.push({ i, x, y, carry, sum, result })\\n    i++\\n  }\\n\\n  if (carry) { result = carry.toString(2) + result }\\n  return result\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction addBinary(a: string, b: string): string {\\n  let result = \"\"\\n  let carry = 0\\n  let length = Math.max(a.length, b.length)\\n  let i = 1\\n  const its = []\\n\\n  while (i <= length) {\\n    let x = Number(a[a.length - i] || 0)\\n    let y = Number(b[b.length - i] || 0)\\n    let sum = x + y + carry\\n\\n    carry = sum > 1 ? 1 : 0\\n    result = (sum % 2) + result\\n\\n    its.push({ i, x, y, carry, sum, result })\\n    i++\\n  }\\n\\n  if (carry) { result = carry.toString(2) + result }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679490,
                "title": "c-binary-addition-with-three-different-approach-s",
                "content": "> Given two binary strings a and b, return their sum as a binary string.\\n***\\n**Intuition:-**\\nThere will be many different intuitions in this question \\n* **Easy but long way** is to convert `a` and `b` to decimal then add them and convert the result back to binary and return the result .\\n* **A optimized approach** can be to simply do the `binary addition` in a `result` variable and return the result .\\n* **A well optimized approach** can be that we just write the sum into the longer one of the inputs and return that as result. In this case space complexity will become O(1) .\\n***\\n**Algorithm :-**\\n* Intialize i & j index for a and b from last character index of a & b .\\n* Now loop till the both index reaches 0 and add last bit of both the string along wtih their carry.\\n* Reminder from 2 is the new bit we are dicussing and divide by 2 gives us our carry\\n***\\n**Optimized Code:-**\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string result=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            result=to_string(sum%2)+result;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               result=to_string(1)+result;\\n        return result;\\n        \\n    }\\n};\\n```\\n**Time Complexity :** *`O(n)`*\\n**Space Complexity :** *`O(n)`*\\n***\\n**Well Space Optimized Code:-**\\n```\\nclass Solution {\\npublic:\\n     string addBinary(string a, string b) {\\n        //making \\'a\\' as larger by swaping\\n        if(a.size() < b.size()) swap(a, b); \\n        int i = a.size(), j = b.size();\\n        //Traversing the whole \"a\"\\n        while (i--) {\\n            if(j) a[i] += b[--j] & 1;\\n            if(a[i] > \\'1\\') {\\n                a[i] -= 2;\\n                if(i) \\n                    a[i-1]++; else a = \\'1\\' + a;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(n^2) `*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string result=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            result=to_string(sum%2)+result;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               result=to_string(1)+result;\\n        return result;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     string addBinary(string a, string b) {\\n        //making \\'a\\' as larger by swaping\\n        if(a.size() < b.size()) swap(a, b); \\n        int i = a.size(), j = b.size();\\n        //Traversing the whole \"a\"\\n        while (i--) {\\n            if(j) a[i] += b[--j] & 1;\\n            if(a[i] > \\'1\\') {\\n                a[i] -= 2;\\n                if(i) \\n                    a[i-1]++; else a = \\'1\\' + a;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506359,
                "title": "c-simple-clean-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.size()-1, bi = b.size()-1, carry = 0, curr;\\n        string res = \"\";\\n        \\n        for (; ai >= 0 || bi >= 0; ai--, bi--) {\\n            curr = (ai >= 0) ? a[ai]-\\'0\\' : 0;\\n            curr += (bi >= 0) ? b[bi]-\\'0\\' : 0;\\n            curr += carry;\\n            \\n            carry = curr >= 2;\\n            curr %= 2;\\n            \\n            res = to_string(curr) + res;\\n        }\\n        \\n        return carry ? \"1\" + res : res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.size()-1, bi = b.size()-1, carry = 0, curr;\\n        string res = \"\";\\n        \\n        for (; ai >= 0 || bi >= 0; ai--, bi--) {\\n            curr = (ai >= 0) ? a[ai]-\\'0\\' : 0;\\n            curr += (bi >= 0) ? b[bi]-\\'0\\' : 0;\\n            curr += carry;\\n            \\n            carry = curr >= 2;\\n            curr %= 2;\\n            \\n            res = to_string(curr) + res;\\n        }\\n        \\n        return carry ? \"1\" + res : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485094,
                "title": "c-0-ms-faster-than-100-00",
                "content": "```\\nstring addBinary(string a, string b) {\\n    int sum=0;\\n    string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        while(i>=0 && j>=0){\\n            sum=(a[i--]-\\'0\\')+(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        while(i>=0){\\n             sum=(a[i--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n         while(j>=0){\\n             sum=(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        if(carry==1){\\n            std::string s1 = std::to_string(carry);\\n            s+=s1;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring addBinary(string a, string b) {\\n    int sum=0;\\n    string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        while(i>=0 && j>=0){\\n            sum=(a[i--]-\\'0\\')+(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        while(i>=0){\\n             sum=(a[i--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n         while(j>=0){\\n             sum=(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        if(carry==1){\\n            std::string s1 = std::to_string(carry);\\n            s+=s1;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337965,
                "title": "simple-code-of-c-100-faster-and-0ms",
                "content": "```\\n string addBinary(string a, string b) {\\n        int p = a.length() - 1;\\n        int q = b.length() - 1;\\n        int carry = 0;\\n        string r = \"\";\\n        while (p >= 0 || q >= 0 || carry )\\n        {\\n            carry += (p >= 0) ? a[p--] - \\'0\\' : 0;\\n            carry += (q >= 0) ? b[q--] - \\'0\\': 0;\\n            r = char(carry % 2+ \\'0\\') + r;\\n            carry /= 2;\\n        }\\n        return r;\\n       \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string addBinary(string a, string b) {\\n        int p = a.length() - 1;\\n        int q = b.length() - 1;\\n        int carry = 0;\\n        string r = \"\";\\n        while (p >= 0 || q >= 0 || carry )\\n        {\\n            carry += (p >= 0) ? a[p--] - \\'0\\' : 0;\\n            carry += (q >= 0) ? b[q--] - \\'0\\': 0;\\n            r = char(carry % 2+ \\'0\\') + r;\\n            carry /= 2;\\n        }\\n        return r;\\n       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039251,
                "title": "my-long-way-javascript-97-93",
                "content": "```\\nvar addBinary = function(a, b) {\\n    if (a === \"0\" && b === \"0\") return \"0\";\\n    \\n    let output = \"\";\\n    let carry = 0;\\n    let i = a.length - 1;\\n    let j = b.length - 1;\\n    while (i >= 0 || j >= 0) {\\n        const num1 = a[i] === undefined ? 0 : +a[i];\\n        const num2 = b[j] === undefined ? 0 : +b[j];\\n        if (num1 + num2 + carry < 2) {\\n            output = (num1 + num2 + carry).toString() + output;\\n            carry = 0;\\n        } else if (num1 + num2 + carry >= 2) {\\n            output = (num1 + num2 + carry - 2).toString() + output;\\n            carry = 0;\\n            carry++;\\n        }\\n        i--, j--;\\n    }\\n    return `${carry || \"\"}${output}`;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    if (a === \"0\" && b === \"0\") return \"0\";\\n    \\n    let output = \"\";\\n    let carry = 0;\\n    let i = a.length - 1;\\n    let j = b.length - 1;\\n    while (i >= 0 || j >= 0) {\\n        const num1 = a[i] === undefined ? 0 : +a[i];\\n        const num2 = b[j] === undefined ? 0 : +b[j];\\n        if (num1 + num2 + carry < 2) {\\n            output = (num1 + num2 + carry).toString() + output;\\n            carry = 0;\\n        } else if (num1 + num2 + carry >= 2) {\\n            output = (num1 + num2 + carry - 2).toString() + output;\\n            carry = 0;\\n            carry++;\\n        }\\n        i--, j--;\\n    }\\n    return `${carry || \"\"}${output}`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 977474,
                "title": "100-faster-simple-code-with-proper-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans=\"\";\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        \\n        while(i>=0 || j>=0)\\n        {\\n            int temp=carry;\\n            if(i>=0) temp+=(a[i]-\\'0\\'); // converting string into integer\\n            if(j>=0) temp+=(b[j]-\\'0\\');\\n            ans+=to_string(temp%2); // if both digit is 1 then append 0\\n            carry=temp/2; // if sum is 2 then carry 1\\n            i--,j--;\\n        }\\n        if(carry!=0) ans+=to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans=\"\";\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        \\n        while(i>=0 || j>=0)\\n        {\\n            int temp=carry;\\n            if(i>=0) temp+=(a[i]-\\'0\\'); // converting string into integer\\n            if(j>=0) temp+=(b[j]-\\'0\\');\\n            ans+=to_string(temp%2); // if both digit is 1 then append 0\\n            carry=temp/2; // if sum is 2 then carry 1\\n            i--,j--;\\n        }\\n        if(carry!=0) ans+=to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745334,
                "title": "easy-clear-java-solution",
                "content": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        StringBuffer sb = new StringBuffer();\\n        while(i>=0 || j>=0){\\n            int sum = 0;\\n            if(i >= 0){\\n                sum += a.charAt(i) - \\'0\\';// -\\'0\\' to convert a char to int\\n                i--;    \\n            }\\n            if(j>=0){\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;    \\n            }\\n                sum += carry;\\n                sb.append(sum%2);\\n                carry = sum/2;\\n        }\\n        if(carry > 0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        StringBuffer sb = new StringBuffer();\\n        while(i>=0 || j>=0){\\n            int sum = 0;\\n            if(i >= 0){\\n                sum += a.charAt(i) - \\'0\\';// -\\'0\\' to convert a char to int\\n                i--;    \\n            }\\n            if(j>=0){\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;    \\n            }\\n                sum += carry;\\n                sb.append(sum%2);\\n                carry = sum/2;\\n        }\\n        if(carry > 0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500315,
                "title": "simple-go-solution",
                "content": "```\\nfunc addBinary(a string, b string) string {\\n    s := 0\\n    carry := 0\\n    res := \"\"\\n    la := len(a) - 1\\n    lb := len(b) - 1\\n    for la >= 0 || lb >= 0 || carry != 0{\\n        s = carry\\n        if la >= 0 {\\n            s += int(a[la] - \\'0\\')\\n            la -- \\n        }\\n        if lb >= 0 {\\n            s += int(b[lb] - \\'0\\')\\n            lb --\\n        }\\n        carry = s / 2\\n        res = string(s % 2 + \\'0\\') + res\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc addBinary(a string, b string) string {\\n    s := 0\\n    carry := 0\\n    res := \"\"\\n    la := len(a) - 1\\n    lb := len(b) - 1\\n    for la >= 0 || lb >= 0 || carry != 0{\\n        s = carry\\n        if la >= 0 {\\n            s += int(a[la] - \\'0\\')\\n            la -- \\n        }\\n        if lb >= 0 {\\n            s += int(b[lb] - \\'0\\')\\n            lb --\\n        }\\n        carry = s / 2\\n        res = string(s % 2 + \\'0\\') + res\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358445,
                "title": "easy-to-understand-python-solution-32ms-beats-97",
                "content": "The idea is similar to https://leetcode.com/problems/add-two-numbers/ -- iterate backwards and build the result from the back by adding two last digits while keeping carry in mind. In the end, if carry is non-zero we append it to the front.\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \"\"\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0:\\n            a_digit = int(a[i]) if i >= 0 else 0\\n            b_digit = int(b[j]) if j >= 0 else 0\\n            _sum = a_digit + b_digit + carry\\n            digit = _sum % 2\\n            carry = _sum // 2\\n            result = str(digit) + result\\n            i -= 1\\n            j -= 1\\n        if carry:\\n            result = str(carry) + result\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \"\"\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0:\\n            a_digit = int(a[i]) if i >= 0 else 0\\n            b_digit = int(b[j]) if j >= 0 else 0\\n            _sum = a_digit + b_digit + carry\\n            digit = _sum % 2\\n            carry = _sum // 2\\n            result = str(digit) + result\\n            i -= 1\\n            j -= 1\\n        if carry:\\n            result = str(carry) + result\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186022,
                "title": "java-use-xor-and-displacement",
                "content": "```\\nclass Solution {\\n   public String addBinary(String astr, String bstr) {\\n        StringBuilder res = new StringBuilder();\\n        int inc=0;\\n        char[] as = astr.toCharArray();\\n        char[] bs = bstr.toCharArray();\\n        int i=astr.length()-1,j=bstr.length()-1;\\n        while(i>=0||j>=0||inc>0){\\n            int a = i>=0?as[i]-\\'0\\':0;\\n            int b = j>=0?bs[j]-\\'0\\':0;\\n            res.append(a^b^inc);\\n            inc = (a&b)|(a&inc)|(b&inc);\\n            i--;j--;\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public String addBinary(String astr, String bstr) {\\n        StringBuilder res = new StringBuilder();\\n        int inc=0;\\n        char[] as = astr.toCharArray();\\n        char[] bs = bstr.toCharArray();\\n        int i=astr.length()-1,j=bstr.length()-1;\\n        while(i>=0||j>=0||inc>0){\\n            int a = i>=0?as[i]-\\'0\\':0;\\n            int b = j>=0?bs[j]-\\'0\\':0;\\n            res.append(a^b^inc);\\n            inc = (a&b)|(a&inc)|(b&inc);\\n            i--;j--;\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24645,
                "title": "my-java-neat-and-clean-solution-using-bit-manipulation",
                "content": "Hello everyone,\\n\\nI am sharing my Java solution using bit manipulation with a very neat and clean code, easy to understand:\\n\\n```\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int sum = 0, carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        \\n        // start from the end\\n        while(i >= 0 || j >= 0){\\n            // take the bits\\n            int bit1 = (i >= 0) ? Integer.parseInt(String.valueOf(a.charAt(i))) : 0;\\n            int bit2 = (j >= 0) ? Integer.parseInt(String.valueOf(b.charAt(j))) : 0;\\n            \\n            // calculate the sum and the carry\\n            sum = carry ^ bit1 ^ bit2;\\n            carry = (carry & bit1) | (carry & bit2) | (bit1 & bit2);\\n            \\n            result.append(String.valueOf(sum));\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry > 0)\\n            result.append(String.valueOf(carry));\\n            \\n        return result.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int sum = 0, carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        \\n        // start from the end\\n        while(i >= 0 || j >= 0){\\n            // take the bits\\n            int bit1 = (i >= 0) ? Integer.parseInt(String.valueOf(a.charAt(i))) : 0;\\n            int bit2 = (j >= 0) ? Integer.parseInt(String.valueOf(b.charAt(j))) : 0;\\n            \\n            // calculate the sum and the carry\\n            sum = carry ^ bit1 ^ bit2;\\n            carry = (carry & bit1) | (carry & bit2) | (bit1 & bit2);\\n            \\n            result.append(String.valueOf(sum));\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry > 0)\\n            result.append(String.valueOf(carry));\\n            \\n        return result.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24762,
                "title": "consise-java-solution-11-lines",
                "content": "    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for(int i=a.length()-1,j=b.length()-1;i>=0 || j>=0;i--,j--){\\n            int v1 = (i<0)?0:a.charAt(i)-'0';\\n            int v2 = (j<0)?0:b.charAt(j)-'0';\\n            int val = (v1+v2+carry)%2;\\n            carry = (v1+v2+carry)/2;\\n            sb.insert(0,(char)(val+'0'));\\n        }\\n        if(carry == 1) sb.insert(0,'1');\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for(int i=a.length()-1,j=b.length()-1;i>=0 || j>=0;i--,j--){\\n            int v1 = (i<0)?0:a.charAt(i)-'0';\\n            int v2 = (j<0)?0:b.charAt(j)-'0';\\n            int val = (v1+v2+carry)%2;\\n            carry = (v1+v2+carry)/2;\\n            sb.insert(0,(char)(val+'0'));\\n        }\\n        if(carry == 1) sb.insert(0,'1');\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3836500,
                "title": "easy-readable-and-concise-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint sum_funct(int a,int b){\\n    if (a==1 && b==1)return 10;\\n    return a+b;\\n}\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        string ans;\\n        int n= a.size(); int m= b.size();\\n        int i=0; int j=0;\\n        int carry=0;\\n        while (i<n && j<m){\\n            int sum= sum_funct(a[i]-\\'0\\',b[j]-\\'0\\');\\n            sum= sum_funct(sum,carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++; j++;\\n        }\\n        while (i<n){\\n            int sum= sum_funct(a[i]-\\'0\\',carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++;\\n        }\\n        while (j<m){\\n            int sum= sum_funct(carry,b[j]-\\'0\\');\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            j++;\\n        }\\n        if (carry==1)ans+= \\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint sum_funct(int a,int b){\\n    if (a==1 && b==1)return 10;\\n    return a+b;\\n}\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        string ans;\\n        int n= a.size(); int m= b.size();\\n        int i=0; int j=0;\\n        int carry=0;\\n        while (i<n && j<m){\\n            int sum= sum_funct(a[i]-\\'0\\',b[j]-\\'0\\');\\n            sum= sum_funct(sum,carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++; j++;\\n        }\\n        while (i<n){\\n            int sum= sum_funct(a[i]-\\'0\\',carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++;\\n        }\\n        while (j<m){\\n            int sum= sum_funct(carry,b[j]-\\'0\\');\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            j++;\\n        }\\n        if (carry==1)ans+= \\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718779,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to add two binary numbers (made up of 0\\'s and 1\\'s) and returns the result in binary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n->We start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string.\\n->Now we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.\\n->If there is any carry-over value after adding all the digits, append it to the end of the new string.\\n->Finally, the new string is reversed and returned as the sum of the two binary numbers.\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int carry = 0;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\n        while(i>=0 || j>=0 || carry==1){\\n            if(i>=0){\\n                carry += a.charAt(i--) -\\'0\\';\\n            }\\n            if(j>=0){\\n                carry += b.charAt(j--) - \\'0\\';\\n            }\\n            result.append(carry%2);\\n            carry /= 2;\\n        }\\n\\n        return result.reverse().toString();\\n\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/9bf324f7-cdd3-46f7-b072-451013fd616b_1688494785.9285524.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int carry = 0;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\n        while(i>=0 || j>=0 || carry==1){\\n            if(i>=0){\\n                carry += a.charAt(i--) -\\'0\\';\\n            }\\n            if(j>=0){\\n                carry += b.charAt(j--) - \\'0\\';\\n            }\\n            result.append(carry%2);\\n            carry /= 2;\\n        }\\n\\n        return result.reverse().toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183131,
                "title": "c-0ms-solution-optimal-solution-easy-to-understand-clean-and-concise",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        if(a.size()>b.size()){\\n            while(b.size()<a.size()){\\n                b+=\"0\";\\n            }\\n        }\\n        else if(b.size()>a.size()){\\n            while(a.size()<b.size()){\\n                a+=\"0\";\\n            }\\n        }\\n        string ans=\"\";\\n        int c=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==0){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==1){\\n                ans+=\"1\";\\n                c=1;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==0){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==1){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'0\\' and b[i]==\\'0\\' and c==0){\\n                ans+=\"0\";\\n                c=0;\\n            }\\n            else if(a[i]==\\'0\\' and a[i]==\\'0\\' and c==1){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n        }\\n        if(c==1){\\n            ans+=\"1\";\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        if(a.size()>b.size()){\\n            while(b.size()<a.size()){\\n                b+=\"0\";\\n            }\\n        }\\n        else if(b.size()>a.size()){\\n            while(a.size()<b.size()){\\n                a+=\"0\";\\n            }\\n        }\\n        string ans=\"\";\\n        int c=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==0){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==1){\\n                ans+=\"1\";\\n                c=1;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==0){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==1){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'0\\' and b[i]==\\'0\\' and c==0){\\n                ans+=\"0\";\\n                c=0;\\n            }\\n            else if(a[i]==\\'0\\' and a[i]==\\'0\\' and c==1){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n        }\\n        if(c==1){\\n            ans+=\"1\";\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742895,
                "title": "python-one-line-solution-easy",
                "content": "````\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        #int(a,2) a represents str, 2 represents base\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        #int(a,2) a represents str, 2 represents base\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b",
                "codeTag": "Java"
            },
            {
                "id": 2635764,
                "title": "explaination-solution-java-90",
                "content": "Explaination : add two binary (given in the form of string ) and return the sum as a return\\n1+1 = 0  , 1 + 0 = 1 (binary sum)\\nApproach : \\n1. Used String Builder to use method like reverse , append \\n2. add last digits of binary and add the last digit of sum into new stringBuilder\\n3. also add the carry to next sum\\n4. atlast reverse the string \\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length()-1 , j = b.length()-1, carry = 0;\\n        while (i>=0||j>=0){\\n            int sum = carry;\\n            if(i>=0)sum += a.charAt(i--) - \\'0\\'; ////we subtract \\'0\\' to get the int value of the char from the ascii\\n            if(j>=0)sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum%2);\\n            carry = sum/2;\\n        }\\n        if(carry!=0) sb.append(carry); //adding remaining carry to sum\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length()-1 , j = b.length()-1, carry = 0;\\n        while (i>=0||j>=0){\\n            int sum = carry;\\n            if(i>=0)sum += a.charAt(i--) - \\'0\\'; ////we subtract \\'0\\' to get the int value of the char from the ascii\\n            if(j>=0)sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum%2);\\n            carry = sum/2;\\n        }\\n        if(carry!=0) sb.append(carry); //adding remaining carry to sum\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529905,
                "title": "c-solution-add-binary",
                "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        \\n        string result;\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0){\\n                sum += a[i--] -\\'0\\'; \\n            }\\n            if(j >= 0){\\n                sum += b[j--] - \\'0\\';\\n            }\\n            carry = sum > 1 ? 1 : 0;\\n            result += to_string(sum%2);\\n        }\\n        if(carry) result += to_string(carry);\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        \\n        string result;\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0){\\n                sum += a[i--] -\\'0\\'; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2524346,
                "title": "easy-approach-100-fast",
                "content": "```\\npublic String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int i = a.length() -1 ;\\n        int j = b.length() -1 ;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0) sum+= a.charAt(i--) - \\'0\\';\\n            if(j>=0) sum+= b.charAt(j--) - \\'0\\';\\n            carry = sum >1 ? 1:0;\\n            result.append(sum%2);\\n        }\\n        if(carry!=0) result.append(carry);\\n        return result.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int i = a.length() -1 ;\\n        int j = b.length() -1 ;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0) sum+= a.charAt(i--) - \\'0\\';\\n            if(j>=0) sum+= b.charAt(j--) - \\'0\\';\\n            carry = sum >1 ? 1:0;\\n            result.append(sum%2);\\n        }\\n        if(carry!=0) result.append(carry);\\n        return result.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506833,
                "title": "0ms-easily-understandable-c-solution-single-for-loop",
                "content": "![image](https://assets.leetcode.com/users/images/8697268a-6131-4691-a90c-b6eebe3655a2_1661892025.0757692.png)\\n\\n**Question** (*read it after going through the code*): You will wonder, if we reversed the strings just to push back and then also reversed the final string at the end, then can\\'t we insert everything at the beginning so to save 3 reverse operations? \\n**Answer**: Try it yourself and drop in comments if you get the way! I would be impressed.\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(), a.end());                        //Reversing both strings (if you get this, then you got the code very well)\\n        reverse(b.begin(), b.end());\\n        \\n        if(a.size()>b.size()){                              //These two conditions are for making both strings equal sized by adding \\'0\\' to smaller string\\n            for(int i=b.size(); i<a.size(); i++){           //We need to add \\'0\\' to front so not to affect the sum, that\\'s why we first reversed the string and then pushed back ;)\\n                b.push_back(\\'0\\');\\n            }\\n        }\\n        else if(a.size()<b.size()){\\n            for(int i=a.size(); i<b.size(); i++){\\n                a.push_back(\\'0\\');\\n            }\\n        }\\n        \\n        string res;                                         //Result string\\n        char carry=\\'0\\';                                     //Carry\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==\\'1\\'&&b[i]==\\'1\\'){\\n                res.push_back(carry);\\n                carry=\\'1\\';\\n            }\\n            else if((a[i]==\\'1\\' || b[i]==\\'1\\')){\\n                if(carry==\\'1\\') res.push_back(\\'0\\');\\n                else res.push_back(\\'1\\');\\n            }\\n            else{\\n                res.push_back(carry);\\n                if(carry==\\'1\\') carry=\\'0\\';\\n            }\\n        }\\n        if(carry==\\'1\\') res.push_back(\\'1\\');                  //if carry is present after looping, add it at the end (remember, we first reversed strings. So everything we need to add to the front, we will push back)\\n            \\n        reverse(res.begin(), res.end());                    //Reverse again to get the final string\\n        return res;   \\n    }\\n};\\n```\\n**Plz Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(), a.end());                        //Reversing both strings (if you get this, then you got the code very well)\\n        reverse(b.begin(), b.end());\\n        \\n        if(a.size()>b.size()){                              //These two conditions are for making both strings equal sized by adding \\'0\\' to smaller string\\n            for(int i=b.size(); i<a.size(); i++){           //We need to add \\'0\\' to front so not to affect the sum, that\\'s why we first reversed the string and then pushed back ;)\\n                b.push_back(\\'0\\');\\n            }\\n        }\\n        else if(a.size()<b.size()){\\n            for(int i=a.size(); i<b.size(); i++){\\n                a.push_back(\\'0\\');\\n            }\\n        }\\n        \\n        string res;                                         //Result string\\n        char carry=\\'0\\';                                     //Carry\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==\\'1\\'&&b[i]==\\'1\\'){\\n                res.push_back(carry);\\n                carry=\\'1\\';\\n            }\\n            else if((a[i]==\\'1\\' || b[i]==\\'1\\')){\\n                if(carry==\\'1\\') res.push_back(\\'0\\');\\n                else res.push_back(\\'1\\');\\n            }\\n            else{\\n                res.push_back(carry);\\n                if(carry==\\'1\\') carry=\\'0\\';\\n            }\\n        }\\n        if(carry==\\'1\\') res.push_back(\\'1\\');                  //if carry is present after looping, add it at the end (remember, we first reversed strings. So everything we need to add to the front, we will push back)\\n            \\n        reverse(res.begin(), res.end());                    //Reverse again to get the final string\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379284,
                "title": "c-solution-3ms-fast-than-89",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i = a.length()-1, j = b.length()-1;\\n        int carry = 0;\\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry/=2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i = a.length()-1, j = b.length()-1;\\n        int carry = 0;\\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry/=2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883447,
                "title": "add-binary",
                "content": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder s = new StringBuilder();\\n        int sum = 0;\\n        while(i >= 0 || j >= 0){\\n            sum = sum/2;\\n            if(i >= 0) \\n                sum = sum + a.charAt(i) - \\'0\\';\\n            if(j >= 0) \\n                sum = sum + b.charAt(j) - \\'0\\';\\n            s.append(sum % 2);\\n            i--;\\n            j--;\\n        }\\n        if(sum / 2 != 0) \\n            s.append(1);\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder s = new StringBuilder();\\n        int sum = 0;\\n        while(i >= 0 || j >= 0){\\n            sum = sum/2;\\n            if(i >= 0) \\n                sum = sum + a.charAt(i) - \\'0\\';\\n            if(j >= 0) \\n                sum = sum + b.charAt(j) - \\'0\\';\\n            s.append(sum % 2);\\n            i--;\\n            j--;\\n        }\\n        if(sum / 2 != 0) \\n            s.append(1);\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714533,
                "title": "easy-python-1-liner",
                "content": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        return (bin(int(a,2) + int(b,2)))[2:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        return (bin(int(a,2) + int(b,2)))[2:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1686352,
                "title": "javascript-o-max-n-m-time-complexity-o-1-space-complexity",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    let aLen = a.length - 1;\\n    let bLen = b.length - 1;\\n\\n    let binaryCount = \"\";\\n    let hasCarry = false;\\n\\n    while(aLen >= 0 || bLen >= 0) {\\n        let num1 = (aLen >= 0 ? Number.parseInt(a[aLen]) : 0);\\n        let num2 = (bLen >= 0 ? Number.parseInt(b[bLen]) : 0);\\n\\n        let value = hasCarry ? 1 ^ (num1 ^ num2) : (num1 ^ num2);\\n\\n        binaryCount = value.toString().concat(binaryCount);\\n\\n        hasCarry = num1 === num2 && num1 === 1 || hasCarry && (num1 === 1 || num2 === 1);\\n\\n        aLen--;\\n        bLen--;\\n    }\\n\\n    return hasCarry ? \"1\".concat(binaryCount) : binaryCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    let aLen = a.length - 1;\\n    let bLen = b.length - 1;\\n\\n    let binaryCount = \"\";\\n    let hasCarry = false;\\n\\n    while(aLen >= 0 || bLen >= 0) {\\n        let num1 = (aLen >= 0 ? Number.parseInt(a[aLen]) : 0);\\n        let num2 = (bLen >= 0 ? Number.parseInt(b[bLen]) : 0);\\n\\n        let value = hasCarry ? 1 ^ (num1 ^ num2) : (num1 ^ num2);\\n\\n        binaryCount = value.toString().concat(binaryCount);\\n\\n        hasCarry = num1 === num2 && num1 === 1 || hasCarry && (num1 === 1 || num2 === 1);\\n\\n        aLen--;\\n        bLen--;\\n    }\\n\\n    return hasCarry ? \"1\".concat(binaryCount) : binaryCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680413,
                "title": "short-and-easy-python-solution",
                "content": "Modify string values so you can convert them into integers with the int() function, then add them and return the result in binary format as a string without the \\'0b\\' at the start.\\n```\\ndef addBinary(self, a: str, b: str) -> str:\\n        a = \"0b\" + a\\n        b = \"0b\" + b\\n        \\n        result = int(a, 2) + int(b, 2)\\n        \\n        return str(bin(result))[2:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        a = \"0b\" + a\\n        b = \"0b\" + b\\n        \\n        result = int(a, 2) + int(b, 2)\\n        \\n        return str(bin(result))[2:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1679607,
                "title": "cpp-solution-can-we-optimize-it-further",
                "content": "Can i do better than this solution ?\\n\\n\\n    string addBinary(string a, string b) {\\n        int i = a.length()-1;\\n    int j = b.length() -1 ;\\n\\n    int carry  = 0;\\n    string ans = \"\";\\n    while(carry || j>=0 || i>=0){\\n        int sum = 0;\\n        if(i>=0){\\n            sum += a[i] - \\'0\\';\\n            i--;\\n        }if(j>=0){\\n            sum += b[j] - \\'0\\';\\n            j--;\\n        }\\n        sum += carry;\\n        ans = ans + to_string(sum % 2) ;\\n        carry = sum /2 ;\\n        \\n    }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "Can i do better than this solution ?\\n\\n\\n    string addBinary(string a, string b) {\\n        int i = a.length()-1;\\n    int j = b.length() -1 ;\\n\\n    int carry  = 0;\\n    string ans = \"\";\\n    while(carry || j>=0 || i>=0){\\n        int sum = 0;\\n        if(i>=0){\\n            sum += a[i] - \\'0\\';\\n            i--;\\n        }if(j>=0){\\n            sum += b[j] - \\'0\\';\\n            j--;\\n        }\\n        sum += carry;\\n        ans = ans + to_string(sum % 2) ;\\n        carry = sum /2 ;\\n        \\n    }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1617150,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nconst addBinary = (a, b) => {\\n  const arrA = a.split(\"\").reverse();\\n  const arrB = b.split(\"\").reverse();\\n  let carry = 0;\\n  let answer = [];\\n  let idx = 0;\\n  const len = a.length > b.length ? a.length : b.length;\\n\\n  while (idx < len) {\\n    const x = arrA[idx] ? +arrA[idx] : 0;\\n    const y = arrB[idx] ? +arrB[idx] : 0;\\n    const sum = carry + x + y;\\n    carry = Math.floor(sum / 2);\\n    answer.unshift(sum % 2);\\n    idx++;\\n  }\\n\\n  if (carry > 0) answer.unshift(carry);\\n\\n  return answer.join(\"\");\\n};\\n```\\nRuntime: 72 ms, faster than 94.73% of JavaScript online submissions for Add Binary.\\nMemory Usage: 40.8 MB, less than 55.11% of JavaScript online submissions for Add Binary.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nconst addBinary = (a, b) => {\\n  const arrA = a.split(\"\").reverse();\\n  const arrB = b.split(\"\").reverse();\\n  let carry = 0;\\n  let answer = [];\\n  let idx = 0;\\n  const len = a.length > b.length ? a.length : b.length;\\n\\n  while (idx < len) {\\n    const x = arrA[idx] ? +arrA[idx] : 0;\\n    const y = arrB[idx] ? +arrB[idx] : 0;\\n    const sum = carry + x + y;\\n    carry = Math.floor(sum / 2);\\n    answer.unshift(sum % 2);\\n    idx++;\\n  }\\n\\n  if (carry > 0) answer.unshift(carry);\\n\\n  return answer.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395977,
                "title": "python-simple-solution-one-liner-faster-than-97",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a, 2)+int(b, 2))[2:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a, 2)+int(b, 2))[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132526,
                "title": "c-0-ms-solution-bit-by-bit-calculation",
                "content": "Gist : \\n* Get last index of both string.\\n* calculate each position sum & carry bit by bit (Similar to adding two numbers in link list)\\n* Since it\\'s base 2 number, at each position value should be saved after modulo 2.\\n* Carry is 1 if sum at that position is greater than two else 0.\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.length() - 1;\\n        int bi = b.length() - 1;\\n        string ans{};\\n        int carry = 0;\\n        while(ai >= 0 || bi >= 0){\\n            if(ai >= 0){\\n                carry += a[ai] - \\'0\\';\\n                --ai;\\n            }\\n            if(bi >= 0){\\n                carry += b[bi]- \\'0\\';\\n                --bi;\\n            }\\n            ans.push_back((carry % 2) + \\'0\\');\\n            if(carry > 1)\\n                carry = 1;\\n            else\\n                carry = 0;\\n        }\\n        if(carry)\\n            ans.push_back((carry % 2) + \\'0\\');\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.length() - 1;\\n        int bi = b.length() - 1;\\n        string ans{};\\n        int carry = 0;\\n        while(ai >= 0 || bi >= 0){\\n            if(ai >= 0){\\n                carry += a[ai] - \\'0\\';\\n                --ai;\\n            }\\n            if(bi >= 0){\\n                carry += b[bi]- \\'0\\';\\n                --bi;\\n            }\\n            ans.push_back((carry % 2) + \\'0\\');\\n            if(carry > 1)\\n                carry = 1;\\n            else\\n                carry = 0;\\n        }\\n        if(carry)\\n            ans.push_back((carry % 2) + \\'0\\');\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089002,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuffer sb = new StringBuffer();\\n        int aIndex = a.length()-1;\\n        int bIndex = b.length()-1;\\n        \\n        int add = 0;\\n        while(aIndex >= 0 || bIndex >= 0) {\\n            int val1 = aIndex < 0 ? 0 : a.charAt(aIndex)-\\'0\\';\\n            int val2 = bIndex < 0 ? 0 : b.charAt(bIndex)-\\'0\\';\\n            int sum = val1 + val2 + add;\\n            if(sum >= 2) {\\n                add = 1;\\n                sum = sum - 2;\\n            } else {\\n                add = 0;\\n            }\\n            sb.append(sum);\\n            aIndex--;\\n            bIndex--;\\n        }\\n        if(add == 1) sb.append(add);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuffer sb = new StringBuffer();\\n        int aIndex = a.length()-1;\\n        int bIndex = b.length()-1;\\n        \\n        int add = 0;\\n        while(aIndex >= 0 || bIndex >= 0) {\\n            int val1 = aIndex < 0 ? 0 : a.charAt(aIndex)-\\'0\\';\\n            int val2 = bIndex < 0 ? 0 : b.charAt(bIndex)-\\'0\\';\\n            int sum = val1 + val2 + add;\\n            if(sum >= 2) {\\n                add = 1;\\n                sum = sum - 2;\\n            } else {\\n                add = 0;\\n            }\\n            sb.append(sum);\\n            aIndex--;\\n            bIndex--;\\n        }\\n        if(add == 1) sb.append(add);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977822,
                "title": "python-one-liner",
                "content": "``` \\nreturn format(int(a, 2) + int(b,2), \"b\")",
                "solutionTags": [],
                "code": "``` \\nreturn format(int(a, 2) + int(b,2), \"b\")",
                "codeTag": "Unknown"
            },
            {
                "id": 921110,
                "title": "python-3-intuitive-24-ms",
                "content": "~~~\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        llen = max(len(a), len(b))\\n        diff = abs(len(a) - len(b))\\n        carry = 0\\n        result = \"\"\\n        if len(a) > len(b):\\n            b = \\'\\'.join((\\'0\\'*(diff), b)) # Insert \\'0\\' at the beginning of the string\\n        elif len(a) < len(b):\\n            a = \\'\\'.join((\\'0\\'*(diff), a))\\n        for i in range((llen-1), -1, -1):\\n            if (int(a[i]) + int(b[i]) + carry) == 2:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 3:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 1:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 0\\n            elif (int(a[i]) + int(b[i]) + carry) == 0:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 0\\n        if carry == 1:\\n            result = \\'\\'.join((\\'1\\', result))\\n        return result if len(result) else \"0\"\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "~~~\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        llen = max(len(a), len(b))\\n        diff = abs(len(a) - len(b))\\n        carry = 0\\n        result = \"\"\\n        if len(a) > len(b):\\n            b = \\'\\'.join((\\'0\\'*(diff), b)) # Insert \\'0\\' at the beginning of the string\\n        elif len(a) < len(b):\\n            a = \\'\\'.join((\\'0\\'*(diff), a))\\n        for i in range((llen-1), -1, -1):\\n            if (int(a[i]) + int(b[i]) + carry) == 2:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 3:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 1:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 0\\n            elif (int(a[i]) + int(b[i]) + carry) == 0:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 0\\n        if carry == 1:\\n            result = \\'\\'.join((\\'1\\', result))\\n        return result if len(result) else \"0\"\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 744625,
                "title": "swift-minimalistic-solution-with-complexity",
                "content": "Time: O(n + c), Space: O(n + c) where n is the length of the longer string, and c is the carry (0 or 1)\\n```\\nfunc addBinary(_ a: String, _ b: String) -> String {\\n\\tlet arrayA = Array(a)\\n\\tlet arrayB = Array(b)\\n\\tvar i = arrayA.count - 1\\n\\tvar j = arrayB.count - 1\\n\\n\\tvar result = \"\"\\n\\tvar carry = 0\\n\\n\\twhile i >= 0 || j >= 0 || carry > 0 {\\n\\t\\tvar sum = carry\\n\\n\\t\\tif i >= 0 {\\n\\t\\t\\tsum += Int(String(arrayA[i]))!\\n\\t\\t\\ti -= 1\\n\\t\\t}\\n\\n\\t\\tif j >= 0 {\\n\\t\\t\\tsum += Int(String(arrayB[j]))!\\n\\t\\t\\tj -= 1\\n\\t\\t}\\n\\n\\t\\tresult = \"\\\\(sum % 2)\" + result\\n\\t\\tcarry = sum / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc addBinary(_ a: String, _ b: String) -> String {\\n\\tlet arrayA = Array(a)\\n\\tlet arrayB = Array(b)\\n\\tvar i = arrayA.count - 1\\n\\tvar j = arrayB.count - 1\\n\\n\\tvar result = \"\"\\n\\tvar carry = 0\\n\\n\\twhile i >= 0 || j >= 0 || carry > 0 {\\n\\t\\tvar sum = carry\\n\\n\\t\\tif i >= 0 {\\n\\t\\t\\tsum += Int(String(arrayA[i]))!\\n\\t\\t\\ti -= 1\\n\\t\\t}\\n\\n\\t\\tif j >= 0 {\\n\\t\\t\\tsum += Int(String(arrayB[j]))!\\n\\t\\t\\tj -= 1\\n\\t\\t}\\n\\n\\t\\tresult = \"\\\\(sum % 2)\" + result\\n\\t\\tcarry = sum / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615989,
                "title": "c-o-n-solution",
                "content": "```\\n/*\\n    Time: O(n) where n = max(a.Length, b.Length)\\n    Space: O(n) where n = max(a.Length, b.Length), since StringBuilder tracks the result.\\n*/\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = a.Length - 1, j = b.Length - 1, carry = 0;\\n        \\n        while(i >= 0 || j >= 0 || carry > 0)\\n        {\\n            int valA = i < 0? 0 : a[i] - \\'0\\';\\n            int valB = j < 0? 0 : b[j] - \\'0\\';\\n            \\n            int sum = valA + valB + carry;\\n            sb.Insert(0, sum % 2);\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Time: O(n) where n = max(a.Length, b.Length)\\n    Space: O(n) where n = max(a.Length, b.Length), since StringBuilder tracks the result.\\n*/\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = a.Length - 1, j = b.Length - 1, carry = 0;\\n        \\n        while(i >= 0 || j >= 0 || carry > 0)\\n        {\\n            int valA = i < 0? 0 : a[i] - \\'0\\';\\n            int valB = j < 0? 0 : b[j] - \\'0\\';\\n            \\n            int sum = valA + valB + carry;\\n            sb.Insert(0, sum % 2);\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611983,
                "title": "easy-to-understand-java-solution",
                "content": "```\\npublic String addBinary(String a, String b) {\\n       StringBuffer sb = new StringBuffer();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0){\\n                sum += a.charAt(i--)-\\'0\\';\\n            }\\n            if(j>=0){\\n                sum += b.charAt(j--)-\\'0\\';\\n            }\\n            sb.insert(0,sum%2);\\n            carry = sum/2;\\n         }\\n        if(carry!=0){\\n            sb.insert(0,carry);\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic String addBinary(String a, String b) {\\n       StringBuffer sb = new StringBuffer();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0){\\n                sum += a.charAt(i--)-\\'0\\';\\n            }\\n            if(j>=0){\\n                sum += b.charAt(j--)-\\'0\\';\\n            }\\n            sb.insert(0,sum%2);\\n            carry = sum/2;\\n         }\\n        if(carry!=0){\\n            sb.insert(0,carry);\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158430,
                "title": "java-beat-100",
                "content": "```\\n public String addBinary(String a, String b) {\\n        char[] result = new char[Math.max(a.length(), b.length())];\\n        int carryBit = 0;\\n        for (int a1 = a.length() - 1, a2 = b.length() - 1; a1 >= 0 || a2 >= 0; --a1, --a2) {\\n            int c1 = a1 < 0 ? 0 : (a.charAt(a1) - \\'0\\');\\n            int c2 = a2 < 0 ? 0 : (b.charAt(a2) - \\'0\\');\\n            result[Math.max(a1, a2)] = (char) ((c1 + c2 + carryBit) % 2 + (int) \\'0\\');\\n\\n            if ((c1 + c2 + carryBit) / 2 > 0) carryBit = 1;\\n            else carryBit = 0;\\n        }\\n        return (carryBit > 0 ? \"1\" : \"\") + new String(result);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public String addBinary(String a, String b) {\\n        char[] result = new char[Math.max(a.length(), b.length())];\\n        int carryBit = 0;\\n        for (int a1 = a.length() - 1, a2 = b.length() - 1; a1 >= 0 || a2 >= 0; --a1, --a2) {\\n            int c1 = a1 < 0 ? 0 : (a.charAt(a1) - \\'0\\');\\n            int c2 = a2 < 0 ? 0 : (b.charAt(a2) - \\'0\\');\\n            result[Math.max(a1, a2)] = (char) ((c1 + c2 + carryBit) % 2 + (int) \\'0\\');\\n\\n            if ((c1 + c2 + carryBit) / 2 > 0) carryBit = 1;\\n            else carryBit = 0;\\n        }\\n        return (carryBit > 0 ? \"1\" : \"\") + new String(result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24551,
                "title": "clean-c-3ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s = \"\";\\n        int i = a.size() - 1;\\n        int j = b.size() - 1;\\n        while(i >= 0 || j >= 0 || carry){\\n            int num1 = i < 0 ? 0 : a[i] - '0';\\n            int num2 = j < 0 ? 0 : b[j] - '0';\\n            int sum = num1 + num2 + carry;\\n            s.push_back(sum % 2 + '0');\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n***\\nShorter version.\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        string s = \"\";\\n        while(i >= 0 || j >= 0 || carry){\\n            int sum = (i < 0 ? 0 : a[i--] - '0') + (j < 0 ? 0 : b[j--] - '0') + carry;\\n            s = to_string(sum % 2) + s;\\n            carry = sum / 2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s = \"\";\\n        int i = a.size() - 1;\\n        int j = b.size() - 1;\\n        while(i >= 0 || j >= 0 || carry){\\n            int num1 = i < 0 ? 0 : a[i] - '0';\\n            int num2 = j < 0 ? 0 : b[j] - '0';\\n            int sum = num1 + num2 + carry;\\n            s.push_back(sum % 2 + '0');\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        string s = \"\";\\n        while(i >= 0 || j >= 0 || carry){\\n            int sum = (i < 0 ? 0 : a[i--] - '0') + (j < 0 ? 0 : b[j--] - '0') + carry;\\n            s = to_string(sum % 2) + s;\\n            carry = sum / 2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24608,
                "title": "share-my-2ms-java-solution-beats-96",
                "content": "    public String addBinary(String a, String b) {\\n    \\tchar[] aArray = a.toCharArray();\\n    \\tchar[] bArray = b.toCharArray();\\n        char[] sumArray = new char[Math.max(a.length(), b.length()) + 1];\\n        int index = sumArray.length - 1, carry = 0;\\n        for(int aIndex = a.length()-1, bIndex = b.length()-1; aIndex >=0 || bIndex >= 0; aIndex--, bIndex--){\\n            int aNum = aIndex < 0 ? 0 : aArray[aIndex] - '0';\\n            int bNum = bIndex < 0 ? 0 : bArray[bIndex] - '0';\\n            int sum = aNum + bNum + carry;\\n            sumArray[index--] = (char)('0' + (sum % 2));\\n            carry = sum / 2;\\n        }\\n        sumArray[0] = (char)('0' + carry);\\n        return carry == 0 ? new String(sumArray, 1, sumArray.length - 1): new String(sumArray);\\n    }",
                "solutionTags": [],
                "code": "    public String addBinary(String a, String b) {\\n    \\tchar[] aArray = a.toCharArray();\\n    \\tchar[] bArray = b.toCharArray();\\n        char[] sumArray = new char[Math.max(a.length(), b.length()) + 1];\\n        int index = sumArray.length - 1, carry = 0;\\n        for(int aIndex = a.length()-1, bIndex = b.length()-1; aIndex >=0 || bIndex >= 0; aIndex--, bIndex--){\\n            int aNum = aIndex < 0 ? 0 : aArray[aIndex] - '0';\\n            int bNum = bIndex < 0 ? 0 : bArray[bIndex] - '0';\\n            int sum = aNum + bNum + carry;\\n            sumArray[index--] = (char)('0' + (sum % 2));\\n            carry = sum / 2;\\n        }\\n        sumArray[0] = (char)('0' + carry);\\n        return carry == 0 ? new String(sumArray, 1, sumArray.length - 1): new String(sumArray);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24690,
                "title": "short-and-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            if(b.size() > a.size())\\n                return addBinary(b, a);\\n            \\n            int x = 0, y = 0, carry = 0;\\n            for(int i = a.size() - 1; i >= 0; i--){\\n                int ib = b.size() - a.size() + i;\\n                y = ib >= 0 ? b[ib] - '0' : 0;\\n                x = a[i] - '0';\\n                a[i] = (x + y + carry) % 2 + '0';\\n                carry = x + y + carry >= 2 ? 1 : 0;\\n            }\\n            \\n            if(carry) a = \"1\" + a;\\n            return a;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            if(b.size() > a.size())\\n                return addBinary(b, a);\\n            \\n            int x = 0, y = 0, carry = 0;\\n            for(int i = a.size() - 1; i >= 0; i--){\\n                int ib = b.size() - a.size() + i;\\n                y = ib >= 0 ? b[ib] - '0' : 0;\\n                x = a[i] - '0';\\n                a[i] = (x + y + carry) % 2 + '0';\\n                carry = x + y + carry >= 2 ? 1 : 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24715,
                "title": "c-4ms-very-simple-logic",
                "content": "    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            /* make strings the same length, by padding one in front with 0s */\\n            if(a.size() > b.size()) while(a.size() > b.size()) b = \"0\" + b;\\n            else if(b.size() > a.size()) while(b.size() > a.size()) a = \"0\" + a;\\n\\n            int i = a.size()-1;\\n            string sum = \"\";\\n            int carry = 0;\\n            \\n            while(i >= 0) {\\n                if(carry == 1) {\\n                    if(a[i] == '0' && b[i] == '0') {\\n                        sum = \"1\" + sum;\\n                        carry = 0;\\n                    }\\n                    else if((a[i] == '0' && b[i] == '1') || (a[i] == '1' && b[i] == '0')) {\\n                        sum = \"0\" + sum;\\n                    }\\n                    else { /* we're adding three 1s here */\\n                        sum = \"1\" + sum;\\n                    }\\n                }\\n                else {\\n                    if(a[i] == '0' && b[i] == '0') {\\n                        sum = \"0\" + sum;\\n                    }\\n                    else if((a[i] == '0' && b[i] == '1') || (a[i] == '1' && b[i] == '0')) {\\n                        sum = \"1\" + sum;\\n                    }\\n                    else { /* we're adding two 1s here */\\n                        sum = \"0\" + sum;\\n                        carry = 1;\\n                    }\\n                }\\n                \\n                i--;\\n            }\\n            \\n            if(carry == 1) sum = \"1\" + sum;\\n            \\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            /* make strings the same length, by padding one in front with 0s */\\n            if(a.size() > b.size()) while(a.size() > b.size()) b = \"0\" + b;\\n            else if(b.size() > a.size()) while(b.size() > a.size()) a = \"0\" + a;\\n\\n            int i = a.size()-1;\\n            string sum = \"\";\\n            int carry = 0;\\n            \\n            while(i >= 0) {\\n                if(carry == 1) {\\n                    if(a[i] == '0' && b[i] == '0') {\\n                        sum = \"1\" + sum;\\n                        carry = 0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 24779,
                "title": "c-4ms-solution-inspired-by-hardware-full-adder-circuit",
                "content": "This solution computes the stage value (sum) and carry-out using Boolean expressions of the [full adder circuit][1] <br> The circuit for the full adder is below.\\n![Full Adder circuit][2]\\n<br>\\nThe expressions are.\\n\\n                 S     = A xor B xor C_in\\n                 C_out = A.B + C_in. (A xor B)\\n\\nThe inputs are padded to the same size to emulate a hardware-adder with inputs of the same size.\\n\\n    string addBinary(string a, string b) {\\n        // Pad to same length\\n        if (a.size()> b.size())\\n                 b.insert(b.begin(), a.size()-b.size(), '0');\\n        else\\n                 a.insert(a.begin(), b.size()-a.size(), '0');\\n        int len = a.size();\\n        bool carry_out= false, sum= false;\\n        string res(len, '0'); // all zero\\n        for (int i=len-1; i>=0 ; --i) {\\n                bool ai = a[i]-'0'== 1; \\n                bool bi = b[i]-'0'== 1;\\n                // Full adder sum = (A xor B xor C_in)\\n                sum = ai != bi != carry_out ;\\n                // Full adder C_out =  (A.B + C_in. (A xor B))\\n                carry_out =  ai && bi || (carry_out && (ai != bi)) ; \\n                if (sum) res[i] = '1';\\n        }\\n        if (carry_out)  // carry over at end\\n                res= \"1\" + res;\\n        return res;\\n    }\\n\\nNote I have used boolean xor operator (i.e. != operator) instead of bit-wise xor ( ^ operator)\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Adder_%28electronics%29#Full_adder\\n  [2]: http://www.cs.iit.edu/~cs561/cs350/ADDER/full_adder.jpg",
                "solutionTags": [
                    "C++"
                ],
                "code": "This solution computes the stage value (sum) and carry-out using Boolean expressions of the [full adder circuit][1] <br> The circuit for the full adder is below.\\n![Full Adder circuit][2]\\n<br>\\nThe expressions are.\\n\\n                 S     = A xor B xor C_in\\n                 C_out = A.B + C_in. (A xor B)\\n\\nThe inputs are padded to the same size to emulate a hardware-adder with inputs of the same size.\\n\\n    string addBinary(string a, string b) {\\n        // Pad to same length\\n        if (a.size()> b.size())\\n                 b.insert(b.begin(), a.size()-b.size(), '0');\\n        else\\n                 a.insert(a.begin(), b.size()-a.size(), '0');\\n        int len = a.size();\\n        bool carry_out= false, sum= false;\\n        string res(len, '0'); // all zero\\n        for (int i=len-1; i>=0 ; --i) {\\n                bool ai = a[i]-'0'== 1; \\n                bool bi = b[i]-'0'== 1;\\n                // Full adder sum = (A xor B xor C_in)\\n                sum = ai != bi != carry_out ;\\n                // Full adder C_out =  (A.B + C_in. (A xor B))\\n                carry_out =  ai && bi || (carry_out && (ai != bi)) ; \\n                if (sum) res[i] = '1';\\n        }\\n        if (carry_out)  // carry over at end\\n                res= \"1\" + res;\\n        return res;\\n    }\\n\\nNote I have used boolean xor operator (i.e. != operator) instead of bit-wise xor ( ^ operator)\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Adder_%28electronics%29#Full_adder\\n  [2]: http://www.cs.iit.edu/~cs561/cs350/ADDER/full_adder.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 3979776,
                "title": "using-big-integer-in-java",
                "content": "# * Using Big Integer\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a1, String b1) {\\n        BigInteger c=new BigInteger(a1,2);\\n        BigInteger d=new BigInteger(b1,2);\\n        BigInteger p=c.add(d);        \\n         String o = p.toString(2);\\n        return o;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a1, String b1) {\\n        BigInteger c=new BigInteger(a1,2);\\n        BigInteger d=new BigInteger(b1,2);\\n        BigInteger p=c.add(d);        \\n         String o = p.toString(2);\\n        return o;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332248,
                "title": "java-biginteger",
                "content": "\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186288,
                "title": "python-explained-solutions-good-to-know-one-liner-solution",
                "content": "# Solution 1 - O(N), O(N)\\n\\n# Intuition\\nUnderstand carry.\\n\\nAdding all possible 2 binary bits :\\n0 + 0 = 0, carry = 0\\n1 + 0 = 1, carry = 0\\n0 + 1 = 1 carry = 0\\n1 + 1 = 2, carry = 1\\n**-> Carry is simply the sum // 2**\\n\\n\\nTherefore only when the Addition of 1 and 1 happens we get a carry 1.\\n\\n\\n# Approach\\n1. Define carry = 0 and empty answer string \"\"\\n2. Find the one with the largest count of bits. This will help us to make the other of same length by appending zeros in the front.\\n2. Reverse both the string so we can start adding from the right most bit.\\n3. Find sum and add any previous carry\\n4. Find carry and append the summation\\n5. Repeat 4 and 5 until loop ends\\n6. If we get any carry form them addition on left most bits, add \"1\"\\n7. Revese the answer and return\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(N)$$ -> answer string\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        answer = \"\"\\n        carry = 0\\n        len_diff = abs(len(a)-len(b))\\n        if len(a) >= len(b):\\n            b = \"0\" * len_diff + b\\n        else:\\n            a = \"0\" * len_diff + a\\n\\n        for i,j in zip(reversed(a), reversed(b)):\\n            summation = int(i) + int(j) + carry\\n            \\n            carry = summation // 2\\n            answer += str(summation % 2)\\n\\n        if carry == 1:\\n            answer += \"1\"\\n        return answer[::-1]\\n            \\n        \\n```\\n\\n\\n# Solution 2 - O(N), O(1) - Python One-liner\\n(Not recommended in a technical interview; but good to know :p)\\n\\n# Intuition\\nConvert string to integer and add as usual. Return the binary converted string of the answer.\\n\\n# Approach:\\n1. `int(a,2)`: this function converts the a into the needed base `2`\\n2. `format(sum, \"b\")`: converts the integer back into binary without \"0b\"\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$ -> int() and format() -> involves arithmetics and are optimized to O(N)\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return format(int(a,2) + int(b,2), \"b\")\\n        \\n```\\n\\n[]()\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        answer = \"\"\\n        carry = 0\\n        len_diff = abs(len(a)-len(b))\\n        if len(a) >= len(b):\\n            b = \"0\" * len_diff + b\\n        else:\\n            a = \"0\" * len_diff + a\\n\\n        for i,j in zip(reversed(a), reversed(b)):\\n            summation = int(i) + int(j) + carry\\n            \\n            carry = summation // 2\\n            answer += str(summation % 2)\\n\\n        if carry == 1:\\n            answer += \"1\"\\n        return answer[::-1]\\n            \\n        \\n```\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return format(int(a,2) + int(b,2), \"b\")\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1693882,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574456,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800157,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800274,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800317,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1782417,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574409,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1570139,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1565221,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1571988,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1693882,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574456,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800157,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800274,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800317,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1782417,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574409,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1570139,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1565221,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1571988,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800587,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1910197,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1800376,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1800528,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1800683,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1574044,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1575034,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 2016873,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1950604,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1924374,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1847074,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1801289,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1801215,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1800935,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1800086,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1800019,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1573637,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1572055,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1576277,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 2075604,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 2074249,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2068623,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2067698,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2065679,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2063022,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2030029,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2026211,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1998802,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1994963,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1988403,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1968682,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1950846,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1913583,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1912528,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1900010,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1897924,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1870908,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1847430,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1840271,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1827585,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1814336,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1808400,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1802479,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1802298,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1801941,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1801149,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800911,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800889,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800873,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800598,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800576,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800562,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800529,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800515,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800372,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800347,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800324,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800321,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800298,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800280,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800102,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800055,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800027,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800022,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800021,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800018,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1785662,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1775331,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1740096,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1739448,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Sum II - Input Array Is Sorted",
        "question_content": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;&nbsp;numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 51249,
                "title": "python-different-solutions-two-pointer-dictionary-binary-search",
                "content": "        \\n    # two-pointer\\n    def twoSum1(self, numbers, target):\\n        l, r = 0, len(numbers)-1\\n        while l < r:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n     \\n    # dictionary           \\n    def twoSum2(self, numbers, target):\\n        dic = {}\\n        for i, num in enumerate(numbers):\\n            if target-num in dic:\\n                return [dic[target-num]+1, i+1]\\n            dic[num] = i\\n     \\n    # binary search        \\n    def twoSum(self, numbers, target):\\n        for i in xrange(len(numbers)):\\n            l, r = i+1, len(numbers)-1\\n            tmp = target - numbers[i]\\n            while l <= r:\\n                mid = l + (r-l)//2\\n                if numbers[mid] == tmp:\\n                    return [i+1, mid+1]\\n                elif numbers[mid] < tmp:\\n                    l = mid+1\\n                else:\\n                    r = mid-1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "        \\n    # two-pointer\\n    def twoSum1(self, numbers, target):\\n        l, r = 0, len(numbers)-1\\n        while l < r:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n     \\n    # dictionary           \\n    def twoSum2(self, numbers, target):\\n        dic = {}\\n        for i, num in enumerate(numbers):\\n            if target-num in dic:\\n                return [dic[target-num]+1, i+1]\\n            dic[num] = i\\n     \\n    # binary search        \\n    def twoSum(self, numbers, target):\\n        for i in xrange(len(numbers)):\\n            l, r = i+1, len(numbers)-1\\n            tmp = target - numbers[i]\\n            while l <= r:\\n                mid = l + (r-l)//2\\n                if numbers[mid] == tmp:\\n                    return [i+1, mid+1]\\n                elif numbers[mid] < tmp:\\n                    l = mid+1\\n                else:\\n                    r = mid-1",
                "codeTag": "Python3"
            },
            {
                "id": 51239,
                "title": "share-my-java-ac-solution",
                "content": "Without HashMap, just have two pointers, A points to index 0, B points to index len - 1, shrink the scope based on the value and target comparison.\\n\\n    public int[] twoSum(int[] num, int target) {\\n        int[] indice = new int[2];\\n        if (num == null || num.length < 2) return indice;\\n        int left = 0, right = num.length - 1;\\n        while (left < right) {\\n            int v = num[left] + num[right];\\n            if (v == target) {\\n                indice[0] = left + 1;\\n                indice[1] = right + 1;\\n                break;\\n            } else if (v > target) {\\n                right --;\\n            } else {\\n                left ++;\\n            }\\n        }\\n        return indice;\\n    }",
                "solutionTags": [],
                "code": "Without HashMap, just have two pointers, A points to index 0, B points to index len - 1, shrink the scope based on the value and target comparison.\\n\\n    public int[] twoSum(int[] num, int target) {\\n        int[] indice = new int[2];\\n        if (num == null || num.length < 2) return indice;\\n        int left = 0, right = num.length - 1;\\n        while (left < right) {\\n            int v = num[left] + num[right];\\n            if (v == target) {\\n                indice[0] = left + 1;\\n                indice[1] = right + 1;\\n                break;\\n            } else if (v > target) {\\n                right --;\\n            } else {\\n                left ++;\\n            }\\n        }\\n        return indice;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2128501,
                "title": "two-pointers-visual-explanation-java",
                "content": "### Logic:\\nThe approach to this question differs to that of the classic Two Sum problem in that we have some direction with how we want to search for our target.\\n\\nSince the array is sorted, we can make some general observations:\\n* Smaller sums would come from the left half of the array\\n* Larger sums would come from the right half of the array\\n\\nTherefore, using two pointers starting at the end points of the array, we can choose to increase or decrease our current sum however we like. Pay attention to the example below:\\n\\n![image](https://assets.leetcode.com/users/images/d0fa6c55-4e51-4c81-9fca-9a98df8fe949_1654734113.3015687.jpeg)\\n\\nThe basic idea is that:\\n> If our current sum is too small, move closer to the right.\\n> If our current sum is too large, move closer to the left.\\n\\nThat\\'s really all there is to it! Since the array is sorted and we\\'re guarranteed that there exists an answer, we have everything we need to start coding :)\\n___\\n### How would I come up with this during an interview?\\nIn an interview, whenever you\\'re given a question where the input array is sorted, here are some super useful things to consider:\\n* Binary Search\\n* Two (or three) pointers\\n* A sliding window \\n* Traversing from the right\\n\\nMake sure to write down a couple examples and try experimenting with these approaches. Even understanding that these approaches may aid in finding an answer with a sorted array, you\\'re showing your interviewer that you have a good understanding of the array datastructure. Be mindful of negative values and duplicates as you\\'re experimenting! \\n\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n\\tint l = 0, r = nums.length - 1;\\n\\t\\n\\twhile (nums[l] + nums[r] != target) {\\n\\t\\tif (nums[l] + nums[r] < target) l++;\\n\\t\\telse r--;\\n\\t}\\n\\n\\treturn new int[] {l+1, r+1};\\n}\\n```\\n**Time Complexity:** `O(n)` \\n**Space Complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[] twoSum(int[] nums, int target) {\\n\\tint l = 0, r = nums.length - 1;\\n\\t\\n\\twhile (nums[l] + nums[r] != target) {\\n\\t\\tif (nums[l] + nums[r] < target) l++;\\n\\t\\telse r--;\\n\\t}\\n\\n\\treturn new int[] {l+1, r+1};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51253,
                "title": "a-simple-o-n-solution",
                "content": "We only have to shrink the range to find the pair:\\n\\nclass Solution {\\n\\npublic:\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int lo=0, hi=numbers.size()-1;\\n        while (numbers[lo]+numbers[hi]!=target){\\n            if (numbers[lo]+numbers[hi]<target){\\n                lo++;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        return vector<int>({lo+1,hi+1});\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int lo=0, hi=numbers.size()-1;\\n        while (numbers[lo]+numbers[hi]!=target){\\n            if (numbers[lo]+numbers[hi]<target){\\n                lo++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51303,
                "title": "c-solution-simple-and-sweet",
                "content": "\\n\\t vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int l = 0;\\n        int r = numbers.size() -1;\\n       \\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target){\\n               \\n                return {l+1,r+1};;\\n            }\\n            else if(numbers[l] + numbers[r] > target){\\n                r--;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n\\t\\treturn {};\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\t vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int l = 0;\\n        int r = numbers.size() -1;\\n       \\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target){\\n               \\n                return {l+1,r+1};;\\n            }\\n            else if(numbers[l] + numbers[r] > target){\\n                r--;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n\\t\\treturn {};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51282,
                "title": "simple-8-line-java-solution-with-explanation-o-n",
                "content": "    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length - 1;\\n        while (numbers[l] + numbers[r] != target) {\\n            if (numbers[l] + numbers[r] > target) r--;\\n            else l++;\\n        }\\n        return new int[]{l + 1, r + 1};\\n    }\\n\\nwe use `l` and `r` to denote the first index and second index respectively. \\n\\nWhen the sum is:<br>\\n1. smaller than the target:<br>\\n    we move `l` to the right by 1. we can't make `r` smaller because that's gonna make the sum even smaller.<br>\\n2. bigger than target:<br>\\n    move `r` to the left by 1. we can't make `l` bigger because that's gonna make the sum even bigger.<br>\\n3. equal to the target:<br>\\n    we found the answer and return.\\n\\nSince the question said there is EXACTLY one solution and didn't provide any info about when there is no valid answer, so we can always assume there is one and only one answer, which means `l` and `r` never across each other.\\n\\nAnother thing to notice is that this array is sorted.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length - 1;\\n        while (numbers[l] + numbers[r] != target) {\\n            if (numbers[l] + numbers[r] > target) r--;\\n            else l++;\\n        }\\n        return new int[]{l + 1, r + 1};\\n    }\\n\\nwe use `l` and `r` to denote the first index and second index respectively. \\n\\nWhen the sum is:<br>\\n1. smaller than the target:<br>\\n    we move `l` to the right by 1. we can't make `r` smaller because that's gonna make the sum even smaller.<br>\\n2. bigger than target:<br>\\n    move `r` to the left by 1. we can't make `l` bigger because that's gonna make the sum even bigger.<br>\\n3. equal to the target:<br>\\n    we found the answer and return.\\n\\nSince the question said there is EXACTLY one solution and didn't provide any info about when there is no valid answer, so we can always assume there is one and only one answer, which means `l` and `r` never across each other.\\n\\nAnother thing to notice is that this array is sorted.",
                "codeTag": "Unknown"
            },
            {
                "id": 261140,
                "title": "c-with-explanation-clear-simple",
                "content": "There are two good approaches to solve this problem.\\n**Hint:** As given array is **sorted**, we might use two pointer technique / binary search.\\n\\n**Two pointer technique**.\\nWe can exploit the sorted property of an array.\\nLet\\'s say for indices ``i`` & ``j`` such that ``i<j``, \\nif sum of elements ``A[i]+A[j] == target``, then we are done\\nelse check whether ``A[i]+A[j] > target``, then last element has to be removed to reduce the value of sum (``j--``).\\nsimilarly if ``A[i]+A[j] < target``, we have to add little to increase the sum (``i++``).\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // not found\\n    }\\n};\\n```\\ntime complexity: O(N)\\nspace complexity: O(1)\\n\\n___________________________________________________________________________________________________________________________\\n**Using Binary Search.** Consider each element and find is ``(target-nums[i])`` exist in array range ``[i+1,N-1]``? (If yes, we are done), else increment one step, then again search the element exist in array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1};\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // not found\\n    }\\n};\\n```\\n\\ntime complexity: O(NlogN) in worst (if elements are together in right extreme)\\nspace complexity: O(1)\\nNote: This is Template II Binary search, for further info go to [Explore](https://leetcode.com/explore/).\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // not found\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1};\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580496,
                "title": "python-short-two-pointer-solution-with-explanation",
                "content": "#### Explanation: \\n* The array is sorted in increasing order.\\n* So, incresing left index gives bigger number and decresing right index gives smaller number.\\n* We start with left index as the 1st index and right index as the last index of the array.\\n* Calculate the sum of the two elements at the two indices.\\n* If it is greater than the target, that means we have to decrese the sum. So, we decrement the right index.\\n* If it is lesser than the target, that means we have to increse the sum. So, we inrement the left index.\\n* Continue this process untill the sum is equal to the target.\\n\\n\\n```\\nclass Solution:\\n    def two_sum(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target: return (l + 1,  r + 1)\\n            if nums[l] + nums[r] > target: r -= 1\\n            else: l += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def two_sum(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target: return (l + 1,  r + 1)\\n            if nums[l] + nums[r] > target: r -= 1\\n            else: l += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128459,
                "title": "python-easy-o-1-space",
                "content": "This problem is an extension to [Two Sum](https://leetcode.com/problems/two-sum/) problem. In the two-sum problem, the input array is unsorted and hence we have to use a hashmap to solve the problem in **O(n)** time. But that completely changes, once the input is sorted. \\nThe algorithm is:\\n1. Initialize two pointers `i` and `j` which points first and last element respectively.\\n2. Add elements pointed by `i` and `j` and then compare with `target`. \\n3. If `target` is smaller, it means you have added a larger element and it needs to be cut off. So we decrement `j`.\\n4. If `target` is larger, it means you have added a smaller value and we need to pick next big value. So we increment \\'i`.\\n5. We repeat `2.` and `3.` until `i>=j` or a match is found.\\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\\n[Al_Dan](https://leetcode.com/Al_Dan/) pointed out that the solution can be made a bit more concise as the problem description states the following constraint:\\n>The tests are generated such that there is exactly one solution.\\n\\n\\nSo instead of  `i<j` check, we can do `numbers[i] + numbers[j]!=target`.\\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while numbers[i] + numbers[j]!=target:\\n            s = numbers[i] + numbers[j]        \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return [i + 1 , j + 1]\\n```\\n\\n\\n**Time - O(n)**\\n**Space - O(1)**\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while numbers[i] + numbers[j]!=target:\\n            s = numbers[i] + numbers[j]        \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return [i + 1 , j + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128516,
                "title": "4-approaches-brute-force-hashmap-binary-search-two-pointers",
                "content": "[Leetcode](https://leetcode.com/) [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/).\\n\\nHere shows **4** Approaches to slove this problem: Brute Force, HashMap, Binary Search, Two Pointers.\\n\\n# Brute Force\\n\\nIt\\'s easy to use **Brute Force** to find the answer, however, the time complexity is $O(n^2)$, so the BF solution will **Time Limit Exceeded**!\\n\\n```java\\n    public static int[] twoSum_bf(int[] numbers, int target) {\\n        int len = numbers.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (numbers[i] + numbers[j] == target) {\\n                    return new int[]{i + 1, j + 1};\\n                }\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(1)$.\\n\\n# HashMap\\n\\nWe can use a extra $\\\\texttt{HashMap}$ to record the element we traversalled.\\n\\n```java\\n    public static int[] twoSum_hash(int[] numbers, int target) {\\n        int len = numbers.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(target - numbers[i])) {\\n                return new int[]{map.get(target - numbers[i]), i + 1};\\n            }\\n\\n            map.putIfAbsent(numbers[i], i + 1);\\n        }\\n\\n        return new int[0];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n# Binary Search \\n\\nSince the array is already **sorted**, so we can use the **binary search**. In case of duplicated answer, we search only on the right of the left element.\\n\\n```java\\n    public int[] twoSum_bs(int[] numbers, int target) {\\n        for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n            int high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] == target - numbers[i]) {\\n                    return new int[]{i + 1, mid + 1};\\n                } else if (numbers[mid] > target - numbers[i]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$.\\n- **Space Complexity**: $O(1)$.\\n\\n# Two Pointers\\n\\n1. Let the two pointers point to the position of the first element and the position of the last element;\\n2. Each time the sum of the two elements pointed to by the two pointers is calculated and compared with the target value.\\n3. A unique solution is found if the sum of the two elements equals the target value. \\n4. If the sum of the two elements is less than the target, move the left pointer to the right one place; If the sum of the two elements is greater than the target, move the right pointer to the left by one. \\n5. Repeat until you find the answer.\\n\\n```java\\n    public static int[] twoSum_tp(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                return new int[]{left + 1, right + 1};\\n            }\\n        }\\n\\n        return new int[]{-1, -1};\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(1)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```java\\n    public static int[] twoSum_bf(int[] numbers, int target) {\\n        int len = numbers.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (numbers[i] + numbers[j] == target) {\\n                    return new int[]{i + 1, j + 1};\\n                }\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n```\n```java\\n    public static int[] twoSum_hash(int[] numbers, int target) {\\n        int len = numbers.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(target - numbers[i])) {\\n                return new int[]{map.get(target - numbers[i]), i + 1};\\n            }\\n\\n            map.putIfAbsent(numbers[i], i + 1);\\n        }\\n\\n        return new int[0];\\n    }\\n```\n```java\\n    public int[] twoSum_bs(int[] numbers, int target) {\\n        for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n            int high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] == target - numbers[i]) {\\n                    return new int[]{i + 1, mid + 1};\\n                } else if (numbers[mid] > target - numbers[i]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n```\n```java\\n    public static int[] twoSum_tp(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                return new int[]{left + 1, right + 1};\\n            }\\n        }\\n\\n        return new int[]{-1, -1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376245,
                "title": "cleanest-js",
                "content": "```\\nconst twoSum = (numbers, target) => {\\n    let p1 = 0\\n    let p2 = numbers.length - 1\\n    \\n    while (numbers[p1] + numbers[p2] !== target) {\\n        if (numbers[p1] + numbers[p2] > target) {\\n            p2--\\n        } else {\\n            p1++\\n        }\\n    }\\n    \\n    return [p1 + 1, p2 + 1]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst twoSum = (numbers, target) => {\\n    let p1 = 0\\n    let p2 = numbers.length - 1\\n    \\n    while (numbers[p1] + numbers[p2] !== target) {\\n        if (numbers[p1] + numbers[p2] > target) {\\n            p2--\\n        } else {\\n            p1++\\n        }\\n    }\\n    \\n    return [p1 + 1, p2 + 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51268,
                "title": "a-less-efficient-way-binary-search",
                "content": "I know that the best solution is using two pointers like what is done in the previous solution sharing. However, I see the tag contains \"binary search\". I do not know if I misunderstand but is binary search a less efficient way for this problem.\\n\\nSay, fix the first element A[0] and do binary search on the remaining n-1 elements. If cannot find any element which equals target-A[0], Try A[1]. That is, fix A[1] and do binary search on A[2]~A[n-1]. Continue this process until we have the last two elements A[n-2] and A[n-1]. \\n\\nDoes this gives a time complexity lg(n-1) + lg(n-2) + ... + lg(1) ~ O(lg(n!)) ~ O(nlgn). So it is less efficient than the O(n) solution. Am I missing something here?\\n\\nThe code also passes OJ.\\n\\n    vector<int> twoSum(vector<int> &numbers, int target) {\\n        if(numbers.empty()) return {};\\n        for(int i=0; i<numbers.size()-1; i++) {\\n            int start=i+1, end=numbers.size()-1, gap=target-numbers[i];\\n            while(start <= end) {\\n                int m = start+(end-start)/2;\\n                if(numbers[m] == gap) return {i+1,m+1};\\n                else if(numbers[m] > gap) end=m-1;\\n                else start=m+1;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "I know that the best solution is using two pointers like what is done in the previous solution sharing. However, I see the tag contains \"binary search\". I do not know if I misunderstand but is binary search a less efficient way for this problem.\\n\\nSay, fix the first element A[0] and do binary search on the remaining n-1 elements. If cannot find any element which equals target-A[0], Try A[1]. That is, fix A[1] and do binary search on A[2]~A[n-1]. Continue this process until we have the last two elements A[n-2] and A[n-1]. \\n\\nDoes this gives a time complexity lg(n-1) + lg(n-2) + ... + lg(1) ~ O(lg(n!)) ~ O(nlgn). So it is less efficient than the O(n) solution. Am I missing something here?\\n\\nThe code also passes OJ.\\n\\n    vector<int> twoSum(vector<int> &numbers, int target) {\\n        if(numbers.empty()) return {};\\n        for(int i=0; i<numbers.size()-1; i++) {\\n            int start=i+1, end=numbers.size()-1, gap=target-numbers[i];\\n            while(start <= end) {\\n                int m = start+(end-start)/2;\\n                if(numbers[m] == gap) return {i+1,m+1};\\n                else if(numbers[m] > gap) end=m-1;\\n                else start=m+1;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51251,
                "title": "a-o-logn-binary-search-java-solution-0ms-beat-98",
                "content": "```\\n    public int[] twoSum(int[] numbers, int target) {\\n        if (numbers == null || numbers.length == 0) {\\n            return new int[2];\\n        }\\n        int start = 0;\\n        int end = numbers.length - 1;\\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[]{start + 1, end + 1};\\n            } else if (numbers[start] + numbers[end] > target) {\\n                // move end forward to the last value that numbers[end] <= target - numbers[start]\\n                end = largestSmallerOrLastEqual(numbers, start, end, target - numbers[start]);\\n            } else {\\n                // move start backword to the first value that numbers[start] >= target - numbers[end]\\n                start = smallestLargerOrFirstEqual(numbers, start, end, target - numbers[end]);\\n            }\\n        }\\n        return new int[2];\\n    }\\n    private int largestSmallerOrLastEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    private int smallestLargerOrFirstEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] twoSum(int[] numbers, int target) {\\n        if (numbers == null || numbers.length == 0) {\\n            return new int[2];\\n        }\\n        int start = 0;\\n        int end = numbers.length - 1;\\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[]{start + 1, end + 1};\\n            } else if (numbers[start] + numbers[end] > target) {\\n                // move end forward to the last value that numbers[end] <= target - numbers[start]\\n                end = largestSmallerOrLastEqual(numbers, start, end, target - numbers[start]);\\n            } else {\\n                // move start backword to the first value that numbers[start] >= target - numbers[end]\\n                start = smallestLargerOrFirstEqual(numbers, start, end, target - numbers[end]);\\n            }\\n        }\\n        return new int[2];\\n    }\\n    private int largestSmallerOrLastEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    private int smallestLargerOrFirstEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51386,
                "title": "java-7-line-simple-solution",
                "content": "    public int[] twoSum(int[] numbers, int target) {\\n            int start = 0, end = numbers.length - 1;\\n            while(start < end){\\n                if(numbers[start] + numbers[end] == target) break;\\n                if(numbers[start] + numbers[end] < target) start++;\\n                else end--;\\n            }\\n            return new int[]{start + 1, end + 1};\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] twoSum(int[] numbers, int target) {\\n            int start = 0, end = numbers.length - 1;\\n            while(start < end){\\n                if(numbers[start] + numbers[end] == target) break;\\n                if(numbers[start] + numbers[end] < target) start++;\\n                else end--;\\n            }\\n            return new int[]{start + 1, end + 1};\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3276269,
                "title": "easy-to-understand-beats-99",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstant\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int p1 = 0;\\n        int p2 = nums.length-1;\\n        int[] ans = new int[2];\\n        \\n        while(p1 < p2){\\n            int sum = nums[p1]+nums[p2];     \\n            if(sum == target){\\n                ans[0] = p1+1;\\n                ans[1] = p2+1;\\n                break;\\n            }\\n            else if(sum > target){\\n                p2--;\\n            }\\n            else{\\n                p1++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nPlease upvote if find helpful, and feel free to ask if you have any doubt regarding approach and code in the comment section.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg\" alt = \"\">\\n</p>",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int p1 = 0;\\n        int p2 = nums.length-1;\\n        int[] ans = new int[2];\\n        \\n        while(p1 < p2){\\n            int sum = nums[p1]+nums[p2];     \\n            if(sum == target){\\n                ans[0] = p1+1;\\n                ans[1] = p2+1;\\n                break;\\n            }\\n            else if(sum > target){\\n                p2--;\\n            }\\n            else{\\n                p1++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131167,
                "title": "java-4-approaches-explained-in-detail-easy-to-understand-code",
                "content": "**Two pointer Approach(Fastest)  -->**\\n**Logic**\\nWe take two pointers one pointing at the start and other at the end of the array\\nWe iterate till the two pointers meet in a logic that no sum is found out\\nWe check that wether array[pt1]+array[pt2]>target then pt2--\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tarray[pt1]+array[pt2]<target then pt++\\nIf dosent satisfy then sum is found out then we return the array index\\'s\\n\\n**Complexity**\\nTC - O(n)\\nSC - O(1)\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int i=0;\\n        int j=len-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                return new int[]{i+1,j+1};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```\\n**Binary Search Approach**\\n**Logic**\\nWe iterate through the entire array and initialise the high and low value\\nWe initialise the mid value if low index is lesser than the higher one or vice-versa\\nThen we check whether array[i]+arr[mid] == target or not\\n\\n**Complexity**\\nTC - O(nlogn)\\nSC - O(1)\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n         for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n\\t\\t\\tint high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] +numbers[i] == target)\\n                    return new int[]{i + 1, mid + 1};\\n                else if (numbers[mid] + numbers[i] > target) \\n                    high = mid - 1;\\n                else \\n                    low = mid + 1;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```\\n**HashMap Approach**\\n**Logic**\\nWe define a HashMap and then check whether the sum is available in the array or not by travesing through the sorted array\\n\\n**Complexity**\\nTC - O(n)\\nSC - O(n)\\n\\n**Code  -->**\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int len = numbers.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(target - numbers[i])) \\n                return new int[]{map.get(target - numbers[i]), i + 1};\\n            map.putIfAbsent(numbers[i], i + 1);\\n        }\\n        return new int[0];\\n    }\\n}\\n\\n**BruteForce Approach**\\n**Logic**\\nWe iterate through two loops and check whether the summation of ith element and jth element is equal to the target or not\\n\\n**Complexity**\\nTC - O(n^2)\\nSC - O(1)\\n\\n**Upvote if this helped**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int i=0;\\n        int j=len-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                return new int[]{i+1,j+1};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n         for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n\\t\\t\\tint high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] +numbers[i] == target)\\n                    return new int[]{i + 1, mid + 1};\\n                else if (numbers[mid] + numbers[i] > target) \\n                    high = mid - 1;\\n                else \\n                    low = mid + 1;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51287,
                "title": "javascript-simple-solution",
                "content": "The idea is to have a pointer from the beginning and one from the end.\\n\\nOn each iteration, move the lower pointer to the right if the sum is too small, or the upper pointer down if it is too big.\\n\\nBe careful to return the indexes with an additional 1 because we are manipulating 0-based indexes.\\n\\n```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  while (numbers[i]+numbers[j] !== target) {\\n    numbers[i]+numbers[j] < target ? i++ : j--;\\n  }\\n  return [i+1, j+1];\\n};\\n```\\n\\nA minor optimization is to compute the sum only once on every iteration by putting it in a variable:\\n\\n```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  var sum = numbers[i]+numbers[j];\\n  while (sum !== target) {\\n    sum < target ? i++ : j--;\\n    sum = numbers[i]+numbers[j];\\n  }\\n  return [i+1, j+1];\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  while (numbers[i]+numbers[j] !== target) {\\n    numbers[i]+numbers[j] < target ? i++ : j--;\\n  }\\n  return [i+1, j+1];\\n};\\n```\n```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  var sum = numbers[i]+numbers[j];\\n  while (sum !== target) {\\n    sum < target ? i++ : j--;\\n    sum = numbers[i]+numbers[j];\\n  }\\n  return [i+1, j+1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159553,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l = 0\\n        r = len(numbers) - 1\\n        while l < r:\\n            if numbers[l] + numbers[r] == target:\\n                return [l+1, r+1]\\n            elif numbers[l] + numbers[r] < target:\\n                l += 1\\n            else:\\n                r -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l = 0\\n        r = len(numbers) - 1\\n        while l < r:\\n            if numbers[l] + numbers[r] == target:\\n                return [l+1, r+1]\\n            elif numbers[l] + numbers[r] < target:\\n                l += 1\\n            else:\\n                r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942235,
                "title": "c-two-pointers-o-n-and-binary-search-o-n-log-n",
                "content": "Two Pointer | O(n)\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0, high = numbers.size()-1;\\n        vector<int> sum;\\n        while(low < high)\\n        {\\n            if(numbers[low] + numbers[high] == target)\\n            {\\n                sum.push_back(low+1);\\n                sum.push_back(high+1);   // alternative: sum = {low+1, high+1};\\n                return sum;\\n            }\\n            else if(numbers[low] + numbers[high] > target)\\n                high--;\\n            else\\n                low++; \\n        }\\n        return sum;\\n    }\\n};\\n```\\nBinary Search | O(n log n)\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> sum;\\n        for(int x = 0; x < numbers.size(); x++)\\n        {\\n            int low = 0, high = numbers.size()-1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(numbers[mid] == target - numbers[x])\\n                {\\n                    if(mid == x)\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;  // moves low to next value in case the original value is the difference to be added\\n                    else\\n                    {\\n                        sum = {x+1, mid+1};\\n                        return sum;\\n                    }\\n                }\\n                else if(numbers[mid] < target - numbers[x])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;      \\n            }\\n        }\\n       return sum;\\n    }\\n};\\n```\\nUpvote if it helped out any at all. Drop any questions and suggestions if it didn\\'t. :)",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0, high = numbers.size()-1;\\n        vector<int> sum;\\n        while(low < high)\\n        {\\n            if(numbers[low] + numbers[high] == target)\\n            {\\n                sum.push_back(low+1);\\n                sum.push_back(high+1);   // alternative: sum = {low+1, high+1};\\n                return sum;\\n            }\\n            else if(numbers[low] + numbers[high] > target)\\n                high--;\\n            else\\n                low++; \\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> sum;\\n        for(int x = 0; x < numbers.size(); x++)\\n        {\\n            int low = 0, high = numbers.size()-1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(numbers[mid] == target - numbers[x])\\n                {\\n                    if(mid == x)\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;  // moves low to next value in case the original value is the difference to be added\\n                    else\\n                    {\\n                        sum = {x+1, mid+1};\\n                        return sum;\\n                    }\\n                }\\n                else if(numbers[mid] < target - numbers[x])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;      \\n            }\\n        }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520736,
                "title": "concise-javascript-o-1-space-solution",
                "content": "```\\nfunction twoSum(numbers, target) {\\n    for(let start = 0, end = numbers.length-1; start < end;){\\n        let sum = numbers[start] + numbers[end]\\n        if(sum === target)return [++start, ++end]\\n        else sum > target ? end-- : start++\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction twoSum(numbers, target) {\\n    for(let start = 0, end = numbers.length-1; start < end;){\\n        let sum = numbers[start] + numbers[end]\\n        if(sum === target)return [++start, ++end]\\n        else sum > target ? end-- : start++\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507300,
                "title": "c-solution-4-ms-faster-than-87-56-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint i = 0;\\n\\tint j = numbers.size() - 1;\\n\\tvector<int> res;\\n\\twhile(i < j)\\n\\t{\\n\\t\\tif(numbers[i] + numbers[j] < target)\\n\\t\\t\\t++i;\\n\\n\\t\\telse if(numbers[i] + numbers[j] > target)\\n\\t\\t\\t--j;\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres.push_back(i + 1);\\n\\t\\t\\tres.push_back(j + 1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\\n\\tleft = 0\\n\\tright = len(nums) - 1\\n\\n\\twhile left < right:\\n\\t\\tif nums[left] + nums[right] < target:\\n\\t\\t\\tleft += 1\\n\\n\\t\\telif nums[left] + nums[right] > target:\\n\\t\\t\\tright -= 1\\n\\n\\t\\telse:\\n\\t\\t\\treturn [left + 1, right + 1]\\n```\\n\\n**Like it ? please upvote!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint i = 0;\\n\\tint j = numbers.size() - 1;\\n\\tvector<int> res;\\n\\twhile(i < j)\\n\\t{\\n\\t\\tif(numbers[i] + numbers[j] < target)\\n\\t\\t\\t++i;\\n\\n\\t\\telse if(numbers[i] + numbers[j] > target)\\n\\t\\t\\t--j;\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres.push_back(i + 1);\\n\\t\\t\\tres.push_back(j + 1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\\n\\tleft = 0\\n\\tright = len(nums) - 1\\n\\n\\twhile left < right:\\n\\t\\tif nums[left] + nums[right] < target:\\n\\t\\t\\tleft += 1\\n\\n\\t\\telif nums[left] + nums[right] > target:\\n\\t\\t\\tright -= 1\\n\\n\\t\\telse:\\n\\t\\t\\treturn [left + 1, right + 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2128769,
                "title": "c-two-pointers-binary-search",
                "content": "**Please upvote the post if you like it :)**\\n\\n**Intuition:** The given array is `sorted`, which means we can use two techniques: `Two Pointers/Binary-Search`\\n\\n**Two Pointers:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```\\n**Time Complexity : O(N)**\\n**Space Complexity : O(1)**\\n****\\n**Binary Search:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1}; // returning the indices\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```\\n**Time Complexity : O(NlogN)**\\n**Space Complexity : O(1)**",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1}; // returning the indices\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610905,
                "title": "two-pointers-fast-simple-c",
                "content": "##### **Approach:**\\n1. Intinilize The **i from 0** and **j from n-1**\\n2. we are going to check each time that what number at i and number at j makes up\\n3. if it is less than target we **increment i**\\n4. if it is greater than target we **decrement j**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        vector <int> ans; // Answer Array\\n        int i = 0, j = nums.size() - 1; // Initilize Two Pointers\\n        while (i < j) {\\n            if (nums[i] + nums[j] < target) ++i;\\n            else if (nums[i] + nums[j] > target) --j;\\n            else {\\n                ans.push_back(i+1);\\n                ans.push_back(j+1);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nif you got the solution, please consider up voting\\nif you didn\\'t feel free to comment",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        vector <int> ans; // Answer Array\\n        int i = 0, j = nums.size() - 1; // Initilize Two Pointers\\n        while (i < j) {\\n            if (nums[i] + nums[j] < target) ++i;\\n            else if (nums[i] + nums[j] > target) --j;\\n            else {\\n                ans.push_back(i+1);\\n                ans.push_back(j+1);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737095,
                "title": "sum-megapost-python3-solution-with-a-detailed-explanation",
                "content": "If you\\'re a newbie and sometimes have a hard time understanding the logic. Don\\'t worry, you\\'ll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It\\'d help. I\\'ve compiled a bunch on `sum` problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck. \\n\\nIn general, `sum` problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a `target`, or 2) you need to return indices of numbers that sum up to a (or close to) a `target` value.  Note that when the problem is looking for a indices, `sort`ing the array is probably NOT a good idea. \\n\\n\\n **[Two Sum:](https://leetcode.com/problems/two-sum/)**  \\n \\n This is the second type of the problems where we\\'re looking for indices, so sorting is not necessary. What you\\'d want to do is to go over the array, and try to find two integers that sum up to  a `target` value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you\\'ve observations in a dictionary and use it once you get to the results. \\n\\nNote: try to be comfortable to use `enumerate` as it\\'s sometime out of comfort zone for newbies. `enumerate` comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn\\'t comfortable with at the start and have found them super helpful, I\\'d probably say `enumerate`, `zip` and `set`. \\n \\nSolution: In this problem, you initialize a dictionary (`seen`). This dictionary will keep track of numbers (as `key`) and indices (as `value`). So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in array. As an example, let\\'s do `nums = [2,3,1]` and `target = 3`. Let\\'s say you\\'re at index `i = 0` and `value = 2`, ok? you need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. Since `remaining + value = target`, you\\'re done once you found it, right? So when going through the array, you calculate the `remaining` and check to see whether `remaining` is in the `seen` dictionary (line `#3`). If it is, you\\'re done! you\\'re current number and the remaining from `seen` would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) since it\\'s going to be a `remaining` for (probably) a number you\\'ll see in the future assuming that there is at least one instance of answer.  \\n \\n \\n ```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\\n \\n \\n\\n **[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**  \\n\\nFor this, you can do exactly as the previous. The only change I made below was to change the order of line `#4`. In the previous example, the order didn\\'t matter. But, here the problem asks for asending order and since the values/indicess in `seen` has always lower indices than your current number, it should come first.  Also, note that the problem says it\\'s not zero based, meaning that indices don\\'t start from zero, that\\'s why I added 1 to both of them. \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\\n\\nAnother approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you\\'d need three pointers as you\\'ll see in the future examples). One pointer move from `left` and one from `right`. Let\\'s say you `numbers = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, and  `right` points to 9. There are three possibilities. If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). If `temp_sum` is your target, you\\'r done! You\\'re return it (line `#9`). If it\\'s more than your `target`, it means that `right` is poiting to a very large value (line `#5`) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line `#6`)  by adding one to the index . If the `temp_sum` is less than `target` (line `#7`), then you need to move your `left` to a little bit larger value by adding one to the index (line `#9`). This way, you try to narrow down the range in which you\\'re looking at and will eventually find a couple of number that sum to `target`, then, you\\'ll return this in line `#9`. In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to `target`, you can\\'t simply return the first instace and you need to collect all the possibilities and return the list altogether (you\\'ll see something like this in the next example). \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\\n\\n\\n\\n\\n[**3Sum**](https://leetcode.com/problems/3sum/)\\n\\nThis is similar to the previous example except that it\\'s looking for three numbers. There are some minor differences in the problem statement. It\\'s looking for all combinations (not just one) of solutions returned as a list. And second, it\\'s looking for unique combination, repeatation is not allowed. \\n\\nHere, instead of looping (line `#1`) to `len(nums) -1`, we loop to `len(nums) -2` since we\\'re looking for three numbers. Since we\\'re returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, you cannot reducing `right` pointer or increasing `left` pointer easily, makes sense? \\n\\nSo, first you `sort` the array and define `res = []` to collect your outputs. In line `#2`, we check wether two consecutive elements are equal or not because if they are, we don\\'t want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that `i > 0`. This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. If we didn\\'t have `i > 0`, then we\\'d skip the only correct solution and would return `[]` as our answer which is wrong (correct answer is `[[1,1,1]]`.  \\n\\nWe define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. For example, if `nums = [-2,-1,0,1,2]`, all the points in the case of `i=1` are looking at: `i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. There is only one change with respect to the previous example here between lines `#5` and `#10`.  If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? However, we\\'re not done yet. For a fixed `i`, we still need to check and see whether there are other combinations by just changing `left` and `right` pointers. That\\'s what we are doing in lines `#6, 7, 8`. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it are not the same, we move `left` one index to right (line `#6`). Similarly, if `nums[right]` and the value to left of it is not the same, we move `right` one index to left. This way for a fixed `i`, we get rid of repeative cases. For example, if `nums = [-3, 1,1, 3,5]` and `target = 3`, one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don\\'t want the `left` variable to look at it simply because it\\'d again return `[-3,1,5]`, right? So, we move `left` one index. Finally, if the repeating elements don\\'t exists, lines `#6` to `#8` won\\'t get activated. In this case we still need to move forward by adding 1 to `left` and extracting 1 from `right` (lines `#9, 10`). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\\n\\nAnother way to solve this problem is to change it into a two sum problem. Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to find two numbers `a` and `b` that are equal to `-c`, right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it\\'d return indices and not numbers. Also, we need to re-arrage this problem in a way that we have `nums` and `target`. This code is not a good code and can be optimipized but you got the idea. For a better version of this, check [this](https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\\n\\n[**4Sum**](https://leetcode.com/problems/4sum/)\\n\\nYou should have gotten the idea, and what you\\'ve seen so far can be generalized to `nSum`. Here, I write the generic code using the same ideas as before. What I\\'ll do is to break down each case to a `2Sum II` problem, and solve them recursively using the approach in `2Sum II` example above. \\n\\nFirst sort `nums`, then I\\'m using two extra functions, `helper` and `twoSum`. The `twoSum` is similar to the `2sum II` example with some modifications. It doesn\\'t return the first instance of results, it check every possible combinations and return all of them now. Basically, now it\\'s more similar to the `3Sum` solution. Understanding this function shouldn\\'t be difficult as it\\'s very similar to `3Sum`. As for `helper` function, it first tries to check for cases that don\\'t work (line `#1`). And later, if the `N` we need to sum to get to a `target` is 2 (line `#2`), then runs the `twoSum` function. For the more than two numbers, it recursively breaks them down to two sum (line `#3`). There are some cases like line `#4` that we don\\'t need to proceed with the algorithm anymore and we can `break`. These cases include if multiplying the lowest number in the list by `N` is more than `target`. Since its sorted array, if this happens, we can\\'t find any result. Also, if the largest array (`nums[-1]`) multiplied by `N` would be less than `target`, we can\\'t find any solution. So, `break`. \\n\\n\\nFor other cases, we run the `helper` function again with new inputs, and we keep doing it until we get to `N=2` in which we use `twoSum` function, and add the results to get the final output. \\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\\n[**Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nI don\\'t post combination sum here since it\\'s basically this problem a little bit easier. \\nCombination questions can be solved with `dfs` most of the time. if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \\n\\nRead my older post first [here](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation). This should give you a better idea of what\\'s going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the `dfs` function where it doesn\\'t need the `index` parameter anymore. This is taken care of by `candidates[i+1:]` in line `#3`. Note that we had `candidates` here in the previous post. \\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```\\n\\n\\nThe only differences are lines `#1, 2, 3`. The difference in problem statement in this one and `combinations` problem of my previous post is >>>candidates must be used once<<< and lines `#1` and `2` are here to take care of this.  Line `#1` has two components where first `i > 0` and second `candidates[i] == candidates[i-1]`. The second component `candidates[i] == candidates[i-1]` is to take care of duplicates in the `candidates` variable as was instructed in the problem statement. Basically, if the next number in `candidates` is the same as the previous one, it means that it has already been taken care of, so `continue`. The first component takes care of cases like an input  `candidates = [1]` with `target = 1` (try to remove this component and submit your solution. You\\'ll see what I mean). The rest is similar to the previous [post](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation)\\n\\n================================================================\\nFinal note: Please let me know if you found any typo/error/ect. I\\'ll try to fix them.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128629,
                "title": "c-o-1-space-o-n-time-good-explanation",
                "content": "\\n#                                                                    TWO POINTER APPROACH\\nUsing the two-pointer approach, first create two pointers one to start off at the 0th index and the other to start from the end of the array.We create a while loop that will keep running provided the first pointer, pointer1, is less than the second pointer,pointer2. Inside this while loop, we find the sum of the elements at the respective pointer positions. If the sum is equal to the target, return those two indices, otherwise, if the sum is less than the target, increase the first pointer position by one and if the sum is greater than the target, reduce the second pointer by 1.\\n\\n**Time Complexity : O(n)   (for traversing array using two pointers)\\nSpace Complexity : O(1)  (the vector to be returned is always having 2 values)**\\n\\n![image](https://assets.leetcode.com/users/images/7347585f-87d3-43bd-ba07-4b0c2c9b8256_1654750949.8383505.png)\\n\\n```\\n     int i =0,j = numbers.size()-1;\\n        \\n        while(i<j){\\n            int k = numbers[i]+numbers[j];\\n            \\n            if(k==target){\\n               vector<int> ans{i+1,j+1}; \\n              return ans;\\n            }\\n            \\n            if(k<target){\\n                \\n                i++;\\n                continue;\\n            }\\n            \\n            if(k>target){\\n                j--;\\n                continue;\\n            }\\n        }\\n        \\n        return numbers;    // won\\'t be reached due to constraints\\n```",
                "solutionTags": [],
                "code": "```\\n     int i =0,j = numbers.size()-1;\\n        \\n        while(i<j){\\n            int k = numbers[i]+numbers[j];\\n            \\n            if(k==target){\\n               vector<int> ans{i+1,j+1}; \\n              return ans;\\n            }\\n            \\n            if(k<target){\\n                \\n                i++;\\n                continue;\\n            }\\n            \\n            if(k>target){\\n                j--;\\n                continue;\\n            }\\n        }\\n        \\n        return numbers;    // won\\'t be reached due to constraints\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748931,
                "title": "java-binary-search-map-two-pointer-solutions",
                "content": "Solution 1 : BinarySearch\\nTime : O(nlogn)\\nspace : O(1)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        for(int i=0;i<n-1;i++){\\n           int pos = Arrays.binarySearch(numbers,i+1,n,target-numbers[i]);\\n           if(pos>0) return new int[]{i+1,pos+1};\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n\\n\\nSolution 2: HashMap\\nTime : O(n)\\nspace : O(n)\\n\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        Map<Integer,Integer> seen = new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<n;i++) seen.put(numbers[i],i);\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n           if(seen.containsKey(target-numbers[i]))\\n               return new int[]{i+1,seen.get(target-numbers[i])+1};\\n        \\n        return null;\\n    }\\n}\\n```\\n\\nSolution 3 : Two pointers\\nTime : O(n)\\nspace : O(1)\\n\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length,i=0,j=n-1;\\n        while(i<j){\\n            int sum = numbers[i] + numbers[j];\\n            if(sum == target) return new int[]{i+1,j+1};\\n            if(sum > target) j--;\\n            else i++;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        for(int i=0;i<n-1;i++){\\n           int pos = Arrays.binarySearch(numbers,i+1,n,target-numbers[i]);\\n           if(pos>0) return new int[]{i+1,pos+1};\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        Map<Integer,Integer> seen = new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<n;i++) seen.put(numbers[i],i);\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n           if(seen.containsKey(target-numbers[i]))\\n               return new int[]{i+1,seen.get(target-numbers[i])+1};\\n        \\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length,i=0,j=n-1;\\n        while(i<j){\\n            int sum = numbers[i] + numbers[j];\\n            if(sum == target) return new int[]{i+1,j+1};\\n            if(sum > target) j--;\\n            else i++;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328900,
                "title": "binary-search-and-hash-table-concept",
                "content": "# 1. Binary Search With Cute Approach : O(NLogN)\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        list1=[]\\n        for i,n in enumerate(numbers):\\n            left,right=i+1,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if (numbers[mid]+n)==target:\\n                    return i+1,mid+1\\n                if (numbers[mid]+n)<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            \\n```\\n# 2. Binary Search----->O(NLogN)\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        for i in range(len(numbers)):\\n            left,right=0,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                n=numbers[i]+numbers[mid]\\n                if n==target:\\n                    if i+1==mid+1:\\n                        return i+1,mid+2\\n                    return i+1,mid+1\\n                if n<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n        \\n```\\n# 2. Hash Table Concept---->O(N)\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        dic={}\\n        for key,val in enumerate(nums):\\n            if val in dic:\\n                return dic[val],key\\n            else:\\n                dic[target-val]=key\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        list1=[]\\n        for i,n in enumerate(numbers):\\n            left,right=i+1,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if (numbers[mid]+n)==target:\\n                    return i+1,mid+1\\n                if (numbers[mid]+n)<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        for i in range(len(numbers)):\\n            left,right=0,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                n=numbers[i]+numbers[mid]\\n                if n==target:\\n                    if i+1==mid+1:\\n                        return i+1,mid+2\\n                    return i+1,mid+1\\n                if n<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n        \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        dic={}\\n        for key,val in enumerate(nums):\\n            if val in dic:\\n                return dic[val],key\\n            else:\\n                dic[target-val]=key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063164,
                "title": "c-simple-solution-explained-properly",
                "content": "\\n# Approach\\nPick any two indices in the array and check the sum of their values.\\n **There may arise three possibilities regarding the sum of those two values:**\\n\\n 1. **The sum is equal to target**: In this case, we are lucky enough and will return the two selected indices.\\n1. **The sum is less than target:** In this case, we would want to increase the sum. Since the array is sorted, we can increase the sum by moving one of the indices towards right,so increasing low by one index.\\n1. **The sum is greater than target**: In this case, we would want to decrease the sum. This can be done by moving one of the indices towards the left,so decreasing high by one index.\\n\\nSo, the idea is to initially have pointers on the leftmost and the rightmost indices of the array. We will be using the left pointer to increase the sum and the right pointer to decrease the sum whenever needed. Therefore, the left pointer will move towards the right and the right pointer will move towards the left till one of the following conditions get satisfied:\\n\\nThe sum of the values pointed by the left and the right pointers is equal to target.\\nThe two pointers cross each other. In this case, no valid pair exists in the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n),where n is size of array or vector.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector<int>ans;\\n        int n=numbers.size(),low=0,high=n-1;\\n        while(low<high)\\n        {\\n           int sum=numbers[low]+numbers[high];\\n           if(sum==target)\\n           {\\n               ans.push_back(low+1);\\n               ans.push_back(high+1);\\n               break;\\n           }\\n           else if(sum>target)\\n           high--;\\n           else\\n           low++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if this solution is helpful for you and for any doubt feel free to discuss and comment below.\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector<int>ans;\\n        int n=numbers.size(),low=0,high=n-1;\\n        while(low<high)\\n        {\\n           int sum=numbers[low]+numbers[high];\\n           if(sum==target)\\n           {\\n               ans.push_back(low+1);\\n               ans.push_back(high+1);\\n               break;\\n           }\\n           else if(sum>target)\\n           high--;\\n           else\\n           low++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799628,
                "title": "easy-clear-and-classic-javascript-solution-two-sum-ii-input-array-is-sorted",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar twoSum = function(numbers, target) {\\n  \\n    let left = 0, right = numbers.length -1;\\n\\n    while(left < right) {\\n       let sum = numbers[left] + numbers[right];\\n       if(sum === target) {\\n           return [left+1, right +1]\\n       }else if( sum > target) {\\n           right--\\n       }else {\\n           left++\\n       }\\n    }\\n    return [-1,-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar twoSum = function(numbers, target) {\\n  \\n    let left = 0, right = numbers.length -1;\\n\\n    while(left < right) {\\n       let sum = numbers[left] + numbers[right];\\n       if(sum === target) {\\n           return [left+1, right +1]\\n       }else if( sum > target) {\\n           right--\\n       }else {\\n           left++\\n       }\\n    }\\n    return [-1,-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368501,
                "title": "python-solution-o-1-memory",
                "content": "```python\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        low, high = 0, len(numbers) - 1\\n        while low < high:\\n            sum = numbers[low] + numbers[high]\\n            if sum > target:\\n                high -= 1\\n            elif sum == target:\\n                return [low + 1, high + 1]\\n            else:\\n                low += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        low, high = 0, len(numbers) - 1\\n        while low < high:\\n            sum = numbers[low] + numbers[high]\\n            if sum > target:\\n                high -= 1\\n            elif sum == target:\\n                return [low + 1, high + 1]\\n            else:\\n                low += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267705,
                "title": "c-o-n-2-pointers-beats-90",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int start = 0 ; \\n        int end = numbers.size() - 1 ; \\n\\n        while ((start <= end) && (numbers[start] + numbers[end] != target))\\n        {\\n            if (numbers[start] + numbers[end] < target)\\n            {\\n                start ++ ;  \\n            }\\n            else \\n            {\\n                end -- ; \\n            }\\n        }\\n        return {start + 1 ,end + 1} ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/e7392589-94ab-4736-9fca-a113abfb4d2e_1678175028.7162287.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int start = 0 ; \\n        int end = numbers.size() - 1 ; \\n\\n        while ((start <= end) && (numbers[start] + numbers[end] != target))\\n        {\\n            if (numbers[start] + numbers[end] < target)\\n            {\\n                start ++ ;  \\n            }\\n            else \\n            {\\n                end -- ; \\n            }\\n        }\\n        return {start + 1 ,end + 1} ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741413,
                "title": "java-easy-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0;\\n        int high = numbers.length - 1;\\n        \\n        while(low < high){\\n            int sum = numbers[low] + numbers[high];\\n            if(sum == target)\\n                return new int[]{low+1, high+1};\\n            \\n            else if(sum < target)\\n                low++;\\n            \\n            else\\n                high--;\\n        }\\n        \\n        return new int[]{-1};\\n    }\\n}\\n```\\n\\n***UP-VOTE IF HELPFUL***",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0;\\n        int high = numbers.length - 1;\\n        \\n        while(low < high){\\n            int sum = numbers[low] + numbers[high];\\n            if(sum == target)\\n                return new int[]{low+1, high+1};\\n            \\n            else if(sum < target)\\n                low++;\\n            \\n            else\\n                high--;\\n        }\\n        \\n        return new int[]{-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642733,
                "title": "python-two-simple-approaches-binary-search-two-pointers",
                "content": "\\t# Two Pointers Solution\\n\\t# Time O(n)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tstrt = 0\\n\\t\\t\\tend = len(arr)-1\\n\\t\\t\\twhile strt <= end:\\n\\t\\t\\t\\tsum = arr[strt]+arr[end]\\n\\t\\t\\t\\tif sum == target:\\n\\t\\t\\t\\t\\treturn [strt+1, end+1]\\n\\t\\t\\t\\telif sum < target:\\n\\t\\t\\t\\t\\tstrt += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend -= 1\\n\\n\\n\\t# Binary Search Solution\\n\\t# Time: O(nlogn)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tfor idx in range(len(arr)):  # O(n)\\n\\t\\t\\t\\tnew_target = target-arr[idx]\\n\\t\\t\\t\\tlft, rght = idx+1, len(arr)-1\\n\\t\\t\\t\\twhile lft <= rght:  # O(logn)\\n\\t\\t\\t\\t\\tmid = lft+(rght-lft)//2\\n\\t\\t\\t\\t\\tif arr[mid] == new_target:\\n\\t\\t\\t\\t\\t\\treturn [idx+1, mid+1]\\n\\t\\t\\t\\t\\telif arr[mid] > new_target:\\n\\t\\t\\t\\t\\t\\trght = mid-1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tlft = mid+1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "\\t# Two Pointers Solution\\n\\t# Time O(n)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tstrt = 0\\n\\t\\t\\tend = len(arr)-1\\n\\t\\t\\twhile strt <= end:\\n\\t\\t\\t\\tsum = arr[strt]+arr[end]\\n\\t\\t\\t\\tif sum == target:\\n\\t\\t\\t\\t\\treturn [strt+1, end+1]\\n\\t\\t\\t\\telif sum < target:\\n\\t\\t\\t\\t\\tstrt += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend -= 1\\n\\n\\n\\t# Binary Search Solution\\n\\t# Time: O(nlogn)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tfor idx in range(len(arr)):  # O(n)\\n\\t\\t\\t\\tnew_target = target-arr[idx]\\n\\t\\t\\t\\tlft, rght = idx+1, len(arr)-1\\n\\t\\t\\t\\twhile lft <= rght:  # O(logn)\\n\\t\\t\\t\\t\\tmid = lft+(rght-lft)//2\\n\\t\\t\\t\\t\\tif arr[mid] == new_target:\\n\\t\\t\\t\\t\\t\\treturn [idx+1, mid+1]\\n\\t\\t\\t\\t\\telif arr[mid] > new_target:\\n\\t\\t\\t\\t\\t\\trght = mid-1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tlft = mid+1",
                "codeTag": "Java"
            },
            {
                "id": 51324,
                "title": "0ms-java-solution-binary-search-with-detailed-comment-share-you-opinion",
                "content": "```\\npublic class Solution {\\n    /*\\n     Idea: keep updating boundaries using binary search.\\n     \\n     Method: \\n     1) fix lower number and find the target upper number\\n        e.g. intilize lower = numbers[0], then our goal is to find the \"right\" index of upper bound which value \\n        is <= (target - lower)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign the \"upper\" number to numbers[right], go to step 2;\\n     2) fix the upper number and find the target lower number \\n        e.g. lower = target - upper, our goal is to find the \"left\" index of lower bound which value is >= (target - upper)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign lower to the number[left], repeat step 1 and 2, because we are guranteed to have an answer\\n    \\n    remark:\\n        Every time we update the upper value, it will be smaller than its previous value\\n        Every time we update the lower value, it will be bigger than its previous value\\n        Since this array is sorted in ascending order, the range of binary search is getting smaller each time.\\n        \\n    performance: O(logn)\\n                 real time: 0 ms\\n     */\\n    public int[] twoSum(int[] numbers, int target) {\\n        boolean isSmall = false;\\n        long small = numbers[0];\\n        long big = target - small;\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (true) {\\n            if (isSmall) {\\n                isSmall = false;\\n                left = binarySearch(numbers, left, right - 1, small);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    small = numbers[++left];\\n                    big = target - small;\\n                }\\n            } else {\\n                isSmall = true;\\n                right = binarySearch(numbers, left + 1, right, big);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    big = numbers[right];\\n                    small = target - big;\\n                }\\n            }\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n    \\n    public int binarySearch(int[] nums, int l, int r, long target) {\\n        int left = l;\\n        int right = r;\\n        while (left < right) {\\n            int mid = right + (left - right) / 2;\\n            if (nums[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /*\\n     Idea: keep updating boundaries using binary search.\\n     \\n     Method: \\n     1) fix lower number and find the target upper number\\n        e.g. intilize lower = numbers[0], then our goal is to find the \"right\" index of upper bound which value \\n        is <= (target - lower)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign the \"upper\" number to numbers[right], go to step 2;\\n     2) fix the upper number and find the target lower number \\n        e.g. lower = target - upper, our goal is to find the \"left\" index of lower bound which value is >= (target - upper)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign lower to the number[left], repeat step 1 and 2, because we are guranteed to have an answer\\n    \\n    remark:\\n        Every time we update the upper value, it will be smaller than its previous value\\n        Every time we update the lower value, it will be bigger than its previous value\\n        Since this array is sorted in ascending order, the range of binary search is getting smaller each time.\\n        \\n    performance: O(logn)\\n                 real time: 0 ms\\n     */\\n    public int[] twoSum(int[] numbers, int target) {\\n        boolean isSmall = false;\\n        long small = numbers[0];\\n        long big = target - small;\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (true) {\\n            if (isSmall) {\\n                isSmall = false;\\n                left = binarySearch(numbers, left, right - 1, small);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    small = numbers[++left];\\n                    big = target - small;\\n                }\\n            } else {\\n                isSmall = true;\\n                right = binarySearch(numbers, left + 1, right, big);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    big = numbers[right];\\n                    small = target - big;\\n                }\\n            }\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n    \\n    public int binarySearch(int[] nums, int l, int r, long target) {\\n        int left = l;\\n        int right = r;\\n        while (left < right) {\\n            int mid = right + (left - right) / 2;\\n            if (nums[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51383,
                "title": "java-hashmap-and-two-pointer-solution",
                "content": "        \\n    public int[] twoSum1(int[] numbers, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] ret = new int[2];\\n        for (int i = 0; i < numbers.length; i++) {\\n            if (map.containsKey(target-numbers[i])) {\\n                ret[0] = map.get(target-numbers[i]) + 1;\\n                ret[1] = i+1;\\n                break;\\n            }\\n            map.put(numbers[i], i);\\n        }\\n        return ret;\\n    }\\n    \\n    // two-pointer method\\n    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length-1;\\n        int[] ret = new int[2];\\n        while (l < r) {\\n            int sum = numbers[l] + numbers[r];\\n            if (sum > target) \\n                r--;\\n            else if (sum < target) \\n                l++;\\n            else {\\n                ret[0] = l+1;\\n                ret[1] = r+1;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        \\n    public int[] twoSum1(int[] numbers, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] ret = new int[2];\\n        for (int i = 0; i < numbers.length; i++) {\\n            if (map.containsKey(target-numbers[i])) {\\n                ret[0] = map.get(target-numbers[i]) + 1;\\n                ret[1] = i+1;\\n                break;\\n            }\\n            map.put(numbers[i], i);\\n        }\\n        return ret;\\n    }\\n    \\n    // two-pointer method\\n    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length-1;\\n        int[] ret = new int[2];\\n        while (l < r) {\\n            int sum = numbers[l] + numbers[r];\\n            if (sum > target) \\n                r--;\\n            else if (sum < target) \\n                l++;\\n            else {\\n                ret[0] = l+1;\\n                ret[1] = r+1;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3338300,
                "title": "three-unique-approaches-using-binary-search-two-pointers-hashmap",
                "content": "# Using HashMap\\n```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(N)\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        unordered_map<int,pair<int,bool>>check;//pair.first=index,pair.second=existence\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(check[nums[i]].second)\\n            {\\n                return {check[nums[i]].first+1,i+1};\\n            }\\n            else\\n            {\\n                check[target-nums[i]].second=true;\\n                check[target-nums[i]].first=i;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\\n# Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    //TC:-O(NLOGN),SC:-O(1)\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n            {\\n                return {i+1,j+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\\n# Using Two-Pointers\\n```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(1)\\n    vector<int>twoSum(vector<int>&numbers,int target) \\n    {\\n        int left=0,right=numbers.size()-1;\\n        while(left<=right)   \\n        {\\n            if((numbers[left]+numbers[right])>target)\\n            {\\n                right--;\\n            }\\n            else if((numbers[left]+numbers[right])<target)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                return {left+1,right+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(N)\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        unordered_map<int,pair<int,bool>>check;//pair.first=index,pair.second=existence\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(check[nums[i]].second)\\n            {\\n                return {check[nums[i]].first+1,i+1};\\n            }\\n            else\\n            {\\n                check[target-nums[i]].second=true;\\n                check[target-nums[i]].first=i;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //TC:-O(NLOGN),SC:-O(1)\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n            {\\n                return {i+1,j+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(1)\\n    vector<int>twoSum(vector<int>&numbers,int target) \\n    {\\n        int left=0,right=numbers.size()-1;\\n        while(left<=right)   \\n        {\\n            if((numbers[left]+numbers[right])>target)\\n            {\\n                right--;\\n            }\\n            else if((numbers[left]+numbers[right])<target)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                return {left+1,right+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131110,
                "title": "c-easy-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target)\\n    {\\n        int n = numbers.size();\\n        int i=0;\\n\\t\\tint j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)   \\n                return vector<int>{i+1,j+1};\\n            else if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return vector<int>{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target)\\n    {\\n        int n = numbers.size();\\n        int i=0;\\n\\t\\tint j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)   \\n                return vector<int>{i+1,j+1};\\n            else if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return vector<int>{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674602,
                "title": "java-simple-code-to-find-two-sum-ii-input-array-is-sorted-beats-99",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i = 0, j = numbers.length - 1;\\n        while(i <  j){\\n            if(numbers[i] + numbers[j] == target){\\n                return new int[]{i + 1, j + 1};\\n            }else if(numbers[i] + numbers[j] > target){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return new int [] {-1,-1};\\n    }\\n}\\n```\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i = 0, j = numbers.length - 1;\\n        while(i <  j){\\n            if(numbers[i] + numbers[j] == target){\\n                return new int[]{i + 1, j + 1};\\n            }else if(numbers[i] + numbers[j] > target){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return new int [] {-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437444,
                "title": "simple-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe solution provided uses a two-pointer approach where a `low` pointer and a `high` pointer are initialized at the start and end of the array respectively. \\n\\nThen, a while loop is used to iterate through the array, and in each iteration, the `sum` of the values at the `low` and `high` pointers is computed. If the `sum` is equal to the `target`, the indices of the numbers are returned as an integer array. If the `sum` is less than the `target`, the `low` pointer is incremented to move towards larger values, and if the `sum` is greater than the `target`, the `high` pointer is decremented to move towards smaller values.\\n\\nThis approach works because the array is sorted, and by moving the `low` and `high` pointers based on the `sum` of their values, we can find the two numbers that add up to the `target`. Since the problem statement guarantees that there is exactly one solution, the while loop will always terminate with the correct indices being returned.\\n\\n# Complexity\\nThis solution has a *time complexity* of $$O(n)$$ since we only make a single pass through the array, and a *space complexity* of $$O(1)$$ since we are only using a constant amount of extra space to store the `low` and `high` pointers.\\n\\n# Code\\n```swift\\nclass Solution {\\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        var low = 0\\n        var high = numbers.count - 1\\n\\n        while low <= high {\\n            var sum = numbers[low] + numbers[high]\\n            if sum == target {\\n                return [low + 1, high + 1]\\n            } else if sum < target {\\n                low += 1\\n            } else {\\n                high -= 1\\n            }\\n        }\\n\\n        return []\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/f546f2e6-a477-40fa-9e19-41d654a3259f_1681980418.1320105.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        var low = 0\\n        var high = numbers.count - 1\\n\\n        while low <= high {\\n            var sum = numbers[low] + numbers[high]\\n            if sum == target {\\n                return [low + 1, high + 1]\\n            } else if sum < target {\\n                low += 1\\n            } else {\\n                high -= 1\\n            }\\n        }\\n\\n        return []\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712770,
                "title": "java-easy-99-o-n-solution-w-o-1-space-with-example",
                "content": "//Time complexity: O(n). The input array is traversed at most once.\\n//Space complexity: O(1). We use constant space to store two indices and the sum.\\n//Brute force would be O(n^2) but taking adavantage of the sorting, we know that lowest value will be leftmost and highest will be rightmost.\\n\\n\\nclass Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int left=0,right=numbers.length-1;\\n        \\n        while(left<right)\\n        {\\n            int sum=numbers[left]+numbers[right];\\n            if(sum==target)\\n                return new int[]{left+1,right+1};\\n            else if(sum>target)\\n                right--;\\n            else if(sum<target)\\n                left++;\\n        }\\n        return new int[]{};\\n    }\\n}\\n\\n\\n\\n//Example here:\\n\\n    1   3   4   5   7   11\\n    L                   R           sum = 1+11=12  > 9, so R--.\\n    If we increase L, we will get 3+11 which is much greater than target(9) so that would be wrong.\\n    Hence, we have to go backwards, i.e. R--, to decrease sum.\\n\\n    1   3   4   5   7   11\\n    L               R               sum=1+7=8  < 9, so L++. (Because we need to increase sum)\\n\\n    1   3   4   5   7   11\\n        L           R               sum=3+7=10  > 9, R--.  \\n\\n    1   3   4   5   7   11\\n        L       R                   sum=3+5=8  < 9, L++.\\n\\n    1   3   4   5   7   11\\n            L   R                   sum=4+5=9  == 9, Return.\\n\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int left=0,right=numbers.length-1;\\n        \\n        while(left<right)\\n        {\\n            int sum=numbers[left]+numbers[right];\\n            if(sum==target)\\n                return new int[]{left+1,right+1}",
                "codeTag": "Java"
            },
            {
                "id": 2130001,
                "title": "c-two-pointers-approach-o-n-time-constant-space",
                "content": "Just take 2 pointers , one at starting index of the array , another at the end index of the array.\\nNow check - \\n\\t\\t~~ if the two numbers at both index sums up target or not. If yes then return (both indexes+1)[as array is 1-indexed]\\n\\t\\t~~ If it is more than the target then decrease the last pointer. \\n\\t\\t~~ If it is less than the target then increase the first pointer.\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0;\\n        int j=numbers.size()-1;\\n        vector<int>satwik;\\n        \\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target) j--;\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else\\n            {\\n                satwik.push_back(i+1);\\n                satwik.push_back(j+1);\\n                break;\\n            }\\n        }\\n        \\n        return satwik;\\n    }\\n};\\n\\n```\\n\\nDO UPVOTE IF YOU LIKE IT :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0;\\n        int j=numbers.size()-1;\\n        vector<int>satwik;\\n        \\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target) j--;\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else\\n            {\\n                satwik.push_back(i+1);\\n                satwik.push_back(j+1);\\n                break;\\n            }\\n        }\\n        \\n        return satwik;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709242,
                "title": "java-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] result = new int[2];\\n        int start = 0, end = numbers.length - 1;\\n        while(start < end) {\\n            if(numbers[start] + numbers[end] == target) {\\n                result[0] = start + 1;\\n                result[1] = end + 1;\\n                break;\\n            } else if(numbers[start] + numbers[end] > target)\\n                end--;\\n            else\\n                start++;\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] result = new int[2];\\n        int start = 0, end = numbers.length - 1;\\n        while(start < end) {\\n            if(numbers[start] + numbers[end] == target) {\\n                result[0] = start + 1;\\n                result[1] = end + 1;\\n                break;\\n            } else if(numbers[start] + numbers[end] > target)\\n                end--;\\n            else\\n                start++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464747,
                "title": "javascript-two-pointers-approach",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n\\n    let left = 0;\\n    let right = numbers.length - 1;\\n\\n    while (left < right) {\\n        let sum = numbers[left] + numbers[right];\\n        if (sum === target) {\\n            return [left + 1, right + 1];\\n        } else if (sum > target) {\\n            right--;\\n        } else {\\n            left++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n\\n    let left = 0;\\n    let right = numbers.length - 1;\\n\\n    while (left < right) {\\n        let sum = numbers[left] + numbers[right];\\n        if (sum === target) {\\n            return [left + 1, right + 1];\\n        } else if (sum > target) {\\n            right--;\\n        } else {\\n            left++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082998,
                "title": "python-multiple-solutions-for-beginners-with-explanation-brute-dictionary-2-pointers",
                "content": "This question is quite similar to question 1 of leet code . The noticiable differences are that this array is sorted whereas the array in question 1 was not. \\n\\n```\\n\\n# Brute force - This solution did not work for me due to max time met. This will work on a simple/smaller array but not on a 1000 number array. And hence the timeout during code submission.  \\n\\nclass Solution(object):\\n    def twoSum(self, nums, target):        \\n        for i in range(len(nums)): # First traversal loop\\n            for j in range(i+1, len(nums)): # Starting 2nd loop with i+1 since numbers in the array are unique per the conditions \\n                if (nums[i]+nums[j]) == target: \\n                    return[i+1,j+1] # Adding 1 to each variable since the return type is 1 indexed instead of 0 indexed. \\n\\n# Using Dictionary / map - What I am doing is trying to create a dictionary such that at one point one of the numbers in nums will add upto target when added to dictionary element. If nums is [1,2,3,4,5] and target is 6, then d will become d {1:0} on first iteration and d {1:0, 2:1} on second and so on. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        d = {} # Defining a null dictionary which we will build with each iteration\\n        for i in range(len(nums)): # I found it easier and more understandable to use range instead of enumerate since this is an easy question. \\n            m = target - nums[i] \\n            if m in d:\\n                return [d[m]+1, i+1] # Adding 1 since its 1 indexed instead of default 0 indexed\\n            else:\\n                d[nums[i]] = i # Building up the dictionary\\n\\n\\n# Using 2 pointers - In this approach, I am basically taking 1st and last number of the array and adding them to see if it equals the target. If the sum is bigger than target, then I need to reduce the sum. This is only possible by reducing the last number as the array is sorted. If the sum is smaller then target, then i need to increase the sum. THis is only possible by increasing the first number as the array is sorted. I keep doing so until my lower number is less than upper number. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        l = 0\\n        r = len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target:\\n                return [l+1, r+1]\\n            if nums[l] + nums[r] > target:\\n                r = r - 1\\n            if nums[l] + nums[r] < target:\\n                l = l + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\n\\n# Brute force - This solution did not work for me due to max time met. This will work on a simple/smaller array but not on a 1000 number array. And hence the timeout during code submission.  \\n\\nclass Solution(object):\\n    def twoSum(self, nums, target):        \\n        for i in range(len(nums)): # First traversal loop\\n            for j in range(i+1, len(nums)): # Starting 2nd loop with i+1 since numbers in the array are unique per the conditions \\n                if (nums[i]+nums[j]) == target: \\n                    return[i+1,j+1] # Adding 1 to each variable since the return type is 1 indexed instead of 0 indexed. \\n\\n# Using Dictionary / map - What I am doing is trying to create a dictionary such that at one point one of the numbers in nums will add upto target when added to dictionary element. If nums is [1,2,3,4,5] and target is 6, then d will become d {1:0} on first iteration and d {1:0, 2:1} on second and so on. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        d = {} # Defining a null dictionary which we will build with each iteration\\n        for i in range(len(nums)): # I found it easier and more understandable to use range instead of enumerate since this is an easy question. \\n            m = target - nums[i] \\n            if m in d:\\n                return [d[m]+1, i+1] # Adding 1 since its 1 indexed instead of default 0 indexed\\n            else:\\n                d[nums[i]] = i # Building up the dictionary\\n\\n\\n# Using 2 pointers - In this approach, I am basically taking 1st and last number of the array and adding them to see if it equals the target. If the sum is bigger than target, then I need to reduce the sum. This is only possible by reducing the last number as the array is sorted. If the sum is smaller then target, then i need to increase the sum. THis is only possible by increasing the first number as the array is sorted. I keep doing so until my lower number is less than upper number. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        l = 0\\n        r = len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target:\\n                return [l+1, r+1]\\n            if nums[l] + nums[r] > target:\\n                r = r - 1\\n            if nums[l] + nums[r] < target:\\n                l = l + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249291,
                "title": "two-pointer-beat-100",
                "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        p1 = 0\\n        p2 = len(numbers) - 1\\n        while p2 > p1:\\n            if numbers[p1] + numbers[p2] < target:\\n                p1 += 1\\n            elif numbers[p1] + numbers[p2] > target:\\n                p2 -= 1\\n            elif numbers[p1] + numbers[p2] == target:\\n                return [p1 + 1, p2 + 1]\\n        else:\\n            return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        p1 = 0\\n        p2 = len(numbers) - 1\\n        while p2 > p1:\\n            if numbers[p1] + numbers[p2] < target:\\n                p1 += 1\\n            elif numbers[p1] + numbers[p2] > target:\\n                p2 -= 1\\n            elif numbers[p1] + numbers[p2] == target:\\n                return [p1 + 1, p2 + 1]\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244738,
                "title": "go-faster-than-100-memory-less-than-100",
                "content": "```go\\nfunc twoSum(numbers []int, target int) []int {\\n    i, j := 0, len(numbers) - 1\\n    sum := numbers[i] + numbers[j]\\n    \\n    for sum != target {\\n        if sum < target {\\n            i++\\n        } else {\\n            j--\\n        }\\n        \\n        sum = numbers[i] + numbers[j]\\n    }\\n    \\n    return []int{i + 1, j + 1}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc twoSum(numbers []int, target int) []int {\\n    i, j := 0, len(numbers) - 1\\n    sum := numbers[i] + numbers[j]\\n    \\n    for sum != target {\\n        if sum < target {\\n            i++\\n        } else {\\n            j--\\n        }\\n        \\n        sum = numbers[i] + numbers[j]\\n    }\\n    \\n    return []int{i + 1, j + 1}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51250,
                "title": "real-binary-search-approach-with-one-loop",
                "content": "Some existing posts only used binary search for one value, and their algorithm could be described as following: \\n```\\nfor(i = 0; i < nums; i++)\\n   num1 = nums[i]; \\n   num2 = target - num1;\\n   binary search num2 in nums[i:], if found, return the index of num1, num2\\n```\\nTheir approach actually takes O(nlogn) time. The worst case is num1 and num2 is the center. It takes log(n-1)+log(n-2)+..log(n/2) ~ nlogn\\n\\nMy idea only used one loop. The worst case is: \\n- the input arry contains same values, or\\n- num1 and num2 is in the center\\nso every time we move the cursor by 1, which takes O(n).In other cases my approach is faster than linear scan.\\n\\nWe could start with left = 0, right = nums.size()-1, and mid = (left+right)/2. \\nSince the input vector is sorted, we know nums[left] < nums[mid] < nums[right], so that\\uff1a  **nums[left] + nums[mid] < nums[left] + nums[right] < nums[mid] + nums[right].** \\n\\nIf nums[left] + nums[mid] > target, the 2 number we are looking for must be within nums[left:mid-1]. Similarly, if nums[right] + nums[mid] < target, the 2 number we are looking for must be within nums[mid+1:right]. \\n\\nFollowing is an accepted C++ implemetaion. \\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int left = 0, right = numbers.size()-1; \\n        vector<int> ret; \\n        while (left < right){\\n            int mid = left + (right-left)/2; \\n            int sum = numbers[left] + numbers[right]; \\n            if (sum == target){\\n                ret.push_back(left+1); \\n                ret.push_back(right+1); \\n                break; \\n            }\\n            else if (sum < target){\\n                left = (numbers[mid] + numbers[right] < target)?mid:left+1;\\n            }else{\\n                right = (numbers[mid] + numbers[left] > target)?mid:right-1;\\n            }\\n           \\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nfor(i = 0; i < nums; i++)\\n   num1 = nums[i]; \\n   num2 = target - num1;\\n   binary search num2 in nums[i:], if found, return the index of num1, num2\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int left = 0, right = numbers.size()-1; \\n        vector<int> ret; \\n        while (left < right){\\n            int mid = left + (right-left)/2; \\n            int sum = numbers[left] + numbers[right]; \\n            if (sum == target){\\n                ret.push_back(left+1); \\n                ret.push_back(right+1); \\n                break; \\n            }\\n            else if (sum < target){\\n                left = (numbers[mid] + numbers[right] < target)?mid:left+1;\\n            }else{\\n                right = (numbers[mid] + numbers[left] > target)?mid:right-1;\\n            }\\n           \\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162858,
                "title": "c-easy-beginner-friendly-solution",
                "content": "# Intuition\\nFirstly, we will deduce that the number of searching steps should not be too large, as it will give TLE.\\n\\n# Approach\\n- We will use two pointers, to travere the array.\\n- First pointer will be placed at first element and the second pointer will be placed at the last element.\\n- If sum of two numbers is greater than the target value then decrease the second pointer and if value is smaller then increase the first pointer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i = 0;\\n        int j = numbers.size()-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            if(numbers[i]+numbers[j]==target)\\n                return {i+1,j+1};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i = 0;\\n        int j = numbers.size()-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            if(numbers[i]+numbers[j]==target)\\n                return {i+1,j+1};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030492,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> I used two pointers right and left to solve this problem.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int right = numbers.size() - 1;\\n        int left = 0;\\n        while (left < right){\\n            if(numbers[right] + numbers[left] == target){\\n                return {left + 1,right + 1};\\n            }\\n            else if(numbers[right] + numbers[left] < target){\\n                left++;\\n            }\\n            else{\\n                right--;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int right = numbers.size() - 1;\\n        int left = 0;\\n        while (left < right){\\n            if(numbers[right] + numbers[left] == target){\\n                return {left + 1,right + 1};\\n            }\\n            else if(numbers[right] + numbers[left] < target){\\n                left++;\\n            }\\n            else{\\n                right--;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834204,
                "title": "c-different-solutions-brute-force-hash-map-binary-search-2pointer-approach",
                "content": "```\\n//Sorry for interrupting.....please please upvote if you feel its worth giving \\uD83D\\uDC3C\\n//\\uD83D\\uDE42\\n//Always know the Brute-Force Approach............rest will get a lot easier\\uD83D\\uDE0A\\u270C\\uFE0F...\\n//brute-force approach......................................\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) \\n    {\\n```\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]+nums[j]==target)\\n                {\\n                    return {i,j};\\n                }\\n            }\\n        }\\n    return {};\\n        \\n    }\\n`};`\\n\\n```\\n//Map solution simple.......................................\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& arr, int t) {\\n        unordered_map<int,int> mp;\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(t-arr[i]))\\n            {\\n                ans.push_back(mp[t-arr[i]]+1);\\n                ans.push_back(i+1);\\n            }\\n            else\\n                mp[arr[i]]=i;\\n        }\\n    return ans;      \\n    }\\n};\\n```\\n\\n```\\n// 2 pointer approach for sorted array.......................\\n vector<int> twoSum(vector<int>& arr, int target) {\\n```\\n    \\n    int l = 0;\\n    int r = arr.size() -1;\\n   \\n    while(l < r){\\n        if(arr[l] + arr[r] == target){\\n           \\n            return {l+1,r+1};;\\n        }\\n        else if(arr[l] + arr[r] > target){\\n            r--;\\n        }\\n        else{\\n            l++;\\n        }\\n    }\\n\\treturn {};\\n}\\n\\n```\\n// binary-search approach.............................\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int i, int key) \\n    {\\n        int l=i+1,mid,h=arr.size()-1;\\n```\\n        \\n        while(l<=h)\\n        {\\n            mid=(l+h)/2;//[l+(h-l)]/2\\n            if(key==arr[mid])\\n                return mid;\\n            else if(key<arr[mid])\\n                h=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>& arr, int t) \\n    {\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(search(arr,i, t-arr[i])!=-1)\\n            {\\n                ans.push_back(i+1);\\n                ans.push_back(search(arr,i, t-arr[i])+1);\\n                break;\\n            }\\n            \\n        }\\n        if(ans.size()==1)\\n            return {-1};\\n    return ans;      \\n    }\\n`};`\\n```\\n//2 sum is a good level question. It covers a lot of concepts. \\n//Hope you got a good vibe\\uD83C\\uDF41\\uD83C\\uDF42\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n//Sorry for interrupting.....please please upvote if you feel its worth giving \\uD83D\\uDC3C\\n//\\uD83D\\uDE42\\n//Always know the Brute-Force Approach............rest will get a lot easier\\uD83D\\uDE0A\\u270C\\uFE0F...\\n//brute-force approach......................................\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) \\n    {\\n```\n```\\n//Map solution simple.......................................\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& arr, int t) {\\n        unordered_map<int,int> mp;\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(t-arr[i]))\\n            {\\n                ans.push_back(mp[t-arr[i]]+1);\\n                ans.push_back(i+1);\\n            }\\n            else\\n                mp[arr[i]]=i;\\n        }\\n    return ans;      \\n    }\\n};\\n```\n```\\n// 2 pointer approach for sorted array.......................\\n vector<int> twoSum(vector<int>& arr, int target) {\\n```\n```\\n// binary-search approach.............................\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int i, int key) \\n    {\\n        int l=i+1,mid,h=arr.size()-1;\\n```\n```\\n//2 sum is a good level question. It covers a lot of concepts. \\n//Hope you got a good vibe\\uD83C\\uDF41\\uD83C\\uDF42\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627937,
                "title": "simple-java-solution-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0,j=numbers.length-1;\\n        while(i<j){\\n            int sum = numbers[i]+numbers[j];\\n            if(sum==target)\\n               return new int[]{i+1,j+1};\\n            else if(sum<target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return new int[2];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0,j=numbers.length-1;\\n        while(i<j){\\n            int sum = numbers[i]+numbers[j];\\n            if(sum==target)\\n               return new int[]{i+1,j+1}",
                "codeTag": "Java"
            },
            {
                "id": 1456219,
                "title": "java-binary-search-with-explanation-o-logn",
                "content": "I followed what @samuelkanezhao2 said [here](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51268/A-less-efficient-way-(binary-search)/255594)\\n\\nFirst, set the two pointers `i` to index `0` and `j` to index `length - 1` respectively.\\nIf the sum of `i + j` is greater than the target, find the biggest number that is smaller than ```target - numbers[left]```\\n1. \\tFirst, check if the number on the left of the right pointer is smaller than ```target - numbers[left]```. If it is, then move the right pointer one to the left.\\n2. \\tHowever, if it is not, then use binary search to find the biggest number smaller than ```target - numbers[left]```.\\n\\nOn the other hand, if the sum is smaller than the target, then find the smallest number that is larger than ```target - nums[right]```\\n1. Check if the number on the right of the left pointer is greater than ```target - nums[right]```. If it is, move the left pointer one to the right.\\n2.  However, if it is not, then use binary search to find the smallest number that is larger than ```target - nums[right]```.\\n\\nIn this way, the average case would be O(logn), since we divide by half every time. However, the worst case scenario would be O(n), if the pointers have to move by 1 every single time. \\n\\n**Note** that it is not doing binary search for *every* move, but only for moves where the number to the left of the right pointer OR the number to the right of the left pointer do not fulfill the condition.\\n \\nIf you didn\\'t understand, maybe checking [@samuelkanezhao2\\'s explanation](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51268/A-less-efficient-way-(binary-search)/255594) might help\\n\\n```\\npublic int[] twoSum(int[] numbers, int target) {\\n    int l = 0, r = numbers.length - 1;\\n    while (numbers[l] + numbers[r] != target) {\\n        if (numbers[l] + numbers[r] > target) {\\n            if (numbers[r - 1] > target - numbers[l])\\n                r = binarySearch(numbers, l + 1, r - 1, target - numbers[l]);\\n            else\\n                r--;\\n        } \\n\\t\\telse {\\n            if (numbers[l + 1] < target - numbers[r])\\n                l = binarySearch(numbers, l + 1, r - 1, target - numbers[r]);\\n            else\\n                l++;\\n        }\\n    }\\n    return new int[] { l + 1, r + 1 };\\n}\\n\\nprivate int binarySearch(int[] nums, int lo, int hi, int target) {\\n    int mid = (lo + hi) / 2;\\n    if (hi <= lo)\\n        return mid;\\n    if (nums[mid] == target)\\n        return mid;\\n    else if (nums[mid] > target)\\n        return binarySearch(nums, lo, (mid - 1), target);\\n    else if (nums[mid] < target)\\n        return binarySearch(nums, (mid + 1), hi, target);\\n    return mid;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```target - numbers[left]```\n```target - numbers[left]```\n```target - numbers[left]```\n```target - nums[right]```\n```target - nums[right]```\n```target - nums[right]```\n```\\npublic int[] twoSum(int[] numbers, int target) {\\n    int l = 0, r = numbers.length - 1;\\n    while (numbers[l] + numbers[r] != target) {\\n        if (numbers[l] + numbers[r] > target) {\\n            if (numbers[r - 1] > target - numbers[l])\\n                r = binarySearch(numbers, l + 1, r - 1, target - numbers[l]);\\n            else\\n                r--;\\n        } \\n\\t\\telse {\\n            if (numbers[l + 1] < target - numbers[r])\\n                l = binarySearch(numbers, l + 1, r - 1, target - numbers[r]);\\n            else\\n                l++;\\n        }\\n    }\\n    return new int[] { l + 1, r + 1 };\\n}\\n\\nprivate int binarySearch(int[] nums, int lo, int hi, int target) {\\n    int mid = (lo + hi) / 2;\\n    if (hi <= lo)\\n        return mid;\\n    if (nums[mid] == target)\\n        return mid;\\n    else if (nums[mid] > target)\\n        return binarySearch(nums, lo, (mid - 1), target);\\n    else if (nums[mid] < target)\\n        return binarySearch(nums, (mid + 1), hi, target);\\n    return mid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 147238,
                "title": "python-two-pointer-beats-99-56",
                "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        i = 0\\n        j = len(numbers)-1\\n        while i<j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i+1,j+1]\\n            elif numbers[i] + numbers[j] > target:\\n                j-= 1\\n            else:\\n                i += 1\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        i = 0\\n        j = len(numbers)-1\\n        while i<j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i+1,j+1]\\n            elif numbers[i] + numbers[j] > target:\\n                j-= 1\\n            else:\\n                i += 1\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576789,
                "title": "simple-java-solution-runtime-1ms-beats-99",
                "content": "# Approach\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. The code defines a class called `Solution` with a single method `twoSum`, which takes an array of integers `numbers` and a target integer `target` as input, and returns an array of two integers.\\n\\n2. Two integer variables `x` and `y` are declared and initialized. `x` is set to 0 (representing the start of the array), and `y` is set to the last index of the `numbers` array (representing the end of the array).\\n\\n3. The code enters a `while` loop that continues until `x` becomes greater than or equal to `y`. This loop is used to search for a pair of numbers in the array that add up to the target value.\\n\\n4. Inside the loop, it retrieves the integers at the `x`th and `y`th positions of the `numbers` array, and stores them in the variables `head` and `tail`, respectively.\\n\\n5. It checks if the sum of `head` and `tail` is equal to the target value. If it is, it means the current pair of numbers satisfies the condition, and the loop is exited using the `break` statement.\\n\\n6. If the sum of `head` and `tail` is greater than the target value, it means the current pair of numbers is too large. In this case, the variable `y` is decremented (moving to a smaller number), and the loop continues to the next iteration using the `continue` statement.\\n\\n7. If the sum of `head` and `tail` is less than the target value, it means the current pair of numbers is too small. In this case, the variable `x` is incremented (moving to a larger number).\\n\\n8. Once the loop ends, it means a pair of numbers that add up to the target value has been found, or the pointers `x` and `y` have crossed each other without finding a suitable pair.\\n\\n9. The code creates a new array with the two indices (`x` and `y`) increased by 1, and returns this array as the result. The indices are incremented by 1 because the problem statement assumes the indices are 1-based, while the code uses 0-based indices.\\n\\nIn simpler terms, the code searches for a pair of numbers in an array that add up to a given target value. It uses two pointers, one at the beginning and one at the end of the array, and adjusts the pointers based on the sum of the current pair of numbers compared to the target. If a suitable pair is found, it returns their indices incremented by 1.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int x = 0, y = numbers.length-1;\\n\\n        while (x<y){\\n            int head = numbers[x];\\n            int tail = numbers[y];\\n            if (head+tail == target){\\n                break;\\n            } else if (head+tail > target) {\\n                y--;\\n                continue;\\n            }\\n            else {\\n                x++;\\n            }\\n        }\\n        return new int[] {x+1, y+1};\\n    }\\n}\\n```\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int x = 0, y = numbers.length-1;\\n\\n        while (x<y){\\n            int head = numbers[x];\\n            int tail = numbers[y];\\n            if (head+tail == target){\\n                break;\\n            } else if (head+tail > target) {\\n                y--;\\n                continue;\\n            }\\n            else {\\n                x++;\\n            }\\n        }\\n        return new int[] {x+1, y+1};\\n    }\\n}\\n```\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208849,
                "title": "167-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach here is to use two pointers to keep track of the two numbers in the array that add up to the target. We start with the left pointer at the beginning of the array and the right pointer at the end of the array. We then calculate the sum of the two numbers at the left and right pointers, and check if it is equal to the target. If it is, we return the indices of the two numbers (adding 1 to each index since the array is 1-indexed). If the sum is less than the target, we move the left pointer to the right to try a larger number. If the sum is greater than the target, we move the right pointer to the left to try a smaller number. We continue this process until we find the two numbers that add up to the target, or until the left pointer passes the right pointer, in which case there is no solution and we return [-1, -1]. Since we are only using constant extra space (just two pointers), this solution satisfies the space requirements of the problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n    left, right = 0, len(numbers) - 1\\n    while left < right:\\n        current_sum = numbers[left] + numbers[right]\\n        if current_sum == target:\\n            return [left+1, right+1]\\n        elif current_sum < target:\\n            left += 1\\n        else:\\n            right -= 1\\n    return [-1, -1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n  def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n    left, right = 0, len(numbers) - 1\\n    while left < right:\\n        current_sum = numbers[left] + numbers[right]\\n        if current_sum == target:\\n            return [left+1, right+1]\\n        elif current_sum < target:\\n            left += 1\\n        else:\\n            right -= 1\\n    return [-1, -1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190625,
                "title": "python-clean-simple-two-pointer-o-n-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Two Pointer Approach :\\n```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        left, right = 0, len(arr) - 1\\n\\n        while left < right:\\n            curr_sum = arr[left] + arr[right] \\n            if curr_sum == target:\\n                return [left + 1, right + 1]\\n            elif curr_sum < target:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n```\\n## Using dictionary :\\n```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        dic = {}\\n        for i in range(len(arr)):\\n            if target - arr[i] in dic:\\n                return [dic[target - arr[i]] + 1, i + 1]\\n            dic[arr[i]] = i\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        left, right = 0, len(arr) - 1\\n\\n        while left < right:\\n            curr_sum = arr[left] + arr[right] \\n            if curr_sum == target:\\n                return [left + 1, right + 1]\\n            elif curr_sum < target:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n```\n```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        dic = {}\\n        for i in range(len(arr)):\\n            if target - arr[i] in dic:\\n                return [dic[target - arr[i]] + 1, i + 1]\\n            dic[arr[i]] = i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720660,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    \\n    int left=0,right=numbers.length-1;\\n    \\n    while(left<right)\\n    {\\n        int sum=numbers[left]+numbers[right];\\n        if(sum==target)\\n            return new int[]{left+1,right+1};\\n        else if(sum>target)\\n            right--;\\n        else if(sum<target)\\n            left++;\\n    }\\n    return new int[]{};\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    \\n    int left=0,right=numbers.length-1;\\n    \\n    while(left<right)\\n    {\\n        int sum=numbers[left]+numbers[right];\\n        if(sum==target)\\n            return new int[]{left+1,right+1};\\n        else if(sum>target)\\n            right--;\\n        else if(sum<target)\\n            left++;\\n    }\\n    return new int[]{};\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645664,
                "title": "c-5-lines-of-code-easy-one-faster-than-98",
                "content": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int min = 0, max = numbers.Length - 1, temp = 0;\\n        while((numbers[min] + numbers[max]) != target)\\n            if((numbers[min] + numbers[max]) > target) max--;\\n            else min++;            \\n        return new int[]{min +1, max+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int min = 0, max = numbers.Length - 1, temp = 0;\\n        while((numbers[min] + numbers[max]) != target)\\n            if((numbers[min] + numbers[max]) > target) max--;\\n            else min++;            \\n        return new int[]{min +1, max+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865262,
                "title": "python-easy-solution-99-faster-solution",
                "content": "**Runtime**: 40 ms, faster than 99.20% of Python online submissions for Two Sum II - Input array is sorted.\\n**Memory Usage**: 13.5 MB, less than 5.23% of Python online submissions for Two Sum II - Input array is sorted.\\n\\n\\n```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dict = {}\\n        for i, e in enumerate(numbers):\\n            if e in dict: return (dict[e], i+1)\\n            dict[(target - e)] = i+1\\n        return list(dict)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dict = {}\\n        for i, e in enumerate(numbers):\\n            if e in dict: return (dict[e], i+1)\\n            dict[(target - e)] = i+1\\n        return list(dict)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625985,
                "title": "python-binary-search",
                "content": "Going from left to right, binary search to get the complement number. For example:\\n[2,7,11,15], target = 9. \\nWhen num =2, left index = 0. We binary seach the interval [7,11,15] with target = 7 (9 -2). Resulting index: right = 1.\\nIncrement both index for the answer.\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        def binarySearch(l, r, target):\\n            while l <= r:\\n                m = (l + r)//2\\n                if numbers[m] == target:\\n                    return m\\n                elif numbers[m] < target:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n            return -1\\n        \\n        for left, num in enumerate(numbers):\\n            right = binarySearch(left + 1, len(numbers)-1, target - num)\\n            if right != -1:\\n                return [left + 1, right + 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        def binarySearch(l, r, target):\\n            while l <= r:\\n                m = (l + r)//2\\n                if numbers[m] == target:\\n                    return m\\n                elif numbers[m] < target:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n            return -1\\n        \\n        for left, num in enumerate(numbers):\\n            right = binarySearch(left + 1, len(numbers)-1, target - num)\\n            if right != -1:\\n                return [left + 1, right + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278978,
                "title": "java-solution-0ms-beats-100-of-java-solutions-two-pointer",
                "content": "```\\npublic int[] twoSum(int[] numbers, int target) {\\n\\t\\tint left = 0, right = numbers.length - 1;\\n\\t\\twhile(left < right) {\\n\\t\\t\\tif(numbers[left] + numbers[right] == target)\\n\\t\\t\\t\\treturn new int[] {left + 1, right + 1};\\n\\t\\t\\telse if(numbers[left] + numbers[right] > target) right--;\\n\\t\\t\\telse left++;\\n\\t\\t}\\n\\t\\treturn new int[] {};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] twoSum(int[] numbers, int target) {\\n\\t\\tint left = 0, right = numbers.length - 1;\\n\\t\\twhile(left < right) {\\n\\t\\t\\tif(numbers[left] + numbers[right] == target)\\n\\t\\t\\t\\treturn new int[] {left + 1, right + 1};\\n\\t\\t\\telse if(numbers[left] + numbers[right] > target) right--;\\n\\t\\t\\telse left++;\\n\\t\\t}\\n\\t\\treturn new int[] {};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417849,
                "title": "deep-and-easy-cheers",
                "content": "# Intuition\\nWe want to find two numbers in the input array that add up to the target value. We can use a two-pointer approach to iteratively narrow down the search range until we find a pair that adds up to the target.\\n\\n# Approach\\n1. Initialize two pointers \\'p1\\' and \\'p2\\' to point to the start and end of the input array, respectively.\\n2. While \\'p1\\' is less than \\'p2\\', calculate the sum of the two numbers at \\'p1\\' and \\'p2\\'.\\n3. If the sum is equal to the target, return the indices of the two numbers as an array.\\n4. If the sum is greater than the target, decrement \\'p2\\' to consider a smaller number at the end of the array.\\n5. If the sum is less than the target, increment \\'p1\\' to consider a larger number at the start of the array.\\n6. If no two numbers are found that add up to the target, return an empty array.\\n\\n# Complexity\\n- Time complexity: O(N), where N is the length of the input array \\'numbers\\'. The algorithm iterates at most N times through the while loop.\\n- Space complexity: O(1), since the algorithm uses only a constant amount of extra space for the two pointers \\'p1\\' and \\'p2\\'.\\n</br>\\n</br>\\n\\n> Please upvote\\u2B06\\uFE0F if find helpful, and feel free to ask if you have any doubt regarding approach and code in the comment section.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\n\\nvar twoSum = function (numbers, target) {\\n    let p1 = 0;\\n    let p2 = numbers.length - 1;\\n\\n    while (p1 < p2) {\\n        let sum = numbers[p1] + numbers[p2];\\n        if (sum === target) {\\n            return [p1 + 1, p2 + 1];\\n        } else if (sum > target) {\\n            p2--;\\n        } else {\\n            p1++;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\n\\nvar twoSum = function (numbers, target) {\\n    let p1 = 0;\\n    let p2 = numbers.length - 1;\\n\\n    while (p1 < p2) {\\n        let sum = numbers[p1] + numbers[p2];\\n        if (sum === target) {\\n            return [p1 + 1, p2 + 1];\\n        } else if (sum > target) {\\n            p2--;\\n        } else {\\n            p1++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3194241,
                "title": "very-simple-solution-detailed-explanation-time-o-n-c",
                "content": "# Intuition\\nAs array is already sorted, we can solve this using 2 pointer approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We know this array is already sorted so we can use 2 pointer approach.\\n1. Using 2 pointer approach. keep left pointer at start of the array and right pointer at the end of the array.\\n2. When we get 2 numbers which sum up to target, return them as an array by incrementing both left and right by 1.\\n3. If we don\\'t get the target then\\n    - If sum is less than target, then move the left pointer towards right. As array is already sorted, by moving the left pointer towards right we are increasing the sum value.\\n    - If sum is more than target, then move the right pointer towards left. So it will decrease the sum.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nSupport by upvoting the answer ! Thank you.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.Length-1;\\n        while(left < right){\\n            int sum = numbers[left] + numbers[right];\\n            if(sum == target) break;\\n            if(sum < target) left++;\\n            if(sum > target) right--;\\n        }\\n        return new int[] {left+1, right+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.Length-1;\\n        while(left < right){\\n            int sum = numbers[left] + numbers[right];\\n            if(sum == target) break;\\n            if(sum < target) left++;\\n            if(sum > target) right--;\\n        }\\n        return new int[] {left+1, right+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036152,
                "title": "java-1ms-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0;\\n        int j=numbers.length-1;\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n                return new int[]{i+1,j+1};\\n            }\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return new int[]{i+1,j+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0;\\n        int j=numbers.length-1;\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n                return new int[]{i+1,j+1};\\n            }\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return new int[]{i+1,j+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953790,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        int i=0, j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)\\n            return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n            else\\n            j--;\\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        int i=0, j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)\\n            return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n            else\\n            j--;\\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205469,
                "title": "java-1ms-beats-99-in-time-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int start = 0, n = nums.length, end = n - 1;\\n        while (start <= end) {\\n            if (nums[start] + nums[end] == target) {\\n                return new int[] { start + 1, end + 1 };\\n            } else if (nums[start] + nums[end] < target) {\\n                start++;\\n            } else\\n                end--;\\n        }\\n        return new int[] {};\\n    }\\n}\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int start = 0, n = nums.length, end = n - 1;\\n        while (start <= end) {\\n            if (nums[start] + nums[end] == target) {\\n                return new int[] { start + 1, end + 1 };\\n            } else if (nums[start] + nums[end] < target) {\\n                start++;\\n            } else\\n                end--;\\n        }\\n        return new int[] {};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190953,
                "title": "keep-it-simple-and-go",
                "content": "```\\nfunc twoSum(nums []int, t int) []int {\\n    for l, r := 0, len(nums) - 1 ;; {\\n        switch {\\n            case nums[l] + nums[r] > t: r--\\n            case nums[l] + nums[r] < t: l++\\n            default: return []int{l+1, r+1}\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc twoSum(nums []int, t int) []int {\\n    for l, r := 0, len(nums) - 1 ;; {\\n        switch {\\n            case nums[l] + nums[r] > t: r--\\n            case nums[l] + nums[r] < t: l++\\n            default: return []int{l+1, r+1}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032483,
                "title": "two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        l , r = 0, len(numbers)-1\\n        while r>l:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        l , r = 0, len(numbers)-1\\n        while r>l:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977708,
                "title": "rust-two-pointers",
                "content": "I just started learning Rust, any improvement advices are welcome!\\n\\n```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut j = numbers.len()-1;\\n        \\n        while i < j {\\n            match (numbers[i]+numbers[j]).cmp(&target) {\\n                Ordering::Less => i += 1,\\n                Ordering::Greater => j -= 1,\\n                Ordering::Equal => return vec![(i+1) as i32, (j+1) as i32],\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut j = numbers.len()-1;\\n        \\n        while i < j {\\n            match (numbers[i]+numbers[j]).cmp(&target) {\\n                Ordering::Less => i += 1,\\n                Ordering::Greater => j -= 1,\\n                Ordering::Equal => return vec![(i+1) as i32, (j+1) as i32],\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084293,
                "title": "python-binary-search-with-comments",
                "content": "Python\\nWe can change the question into multiple binary search problems:\\n1. For each element, find a value (value == target - element) in its right side of the number array\\n\\nThen we can just use a linear search + multiple binary search to find the answer\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        # Binary Search nLogn\\n        # Only one valid answer exist, no special case handler and no need to store combinations\\n        for index in range(len(numbers)):\\n            new_target = target - numbers[index]\\n            # Binary Search\\n            left, right = index + 1, len(numbers) - 1\\n            while left <= right:\\n                middle = (left + right) // 2\\n                if numbers[middle] < new_target:\\n                    left = middle + 1\\n                elif numbers[middle] > new_target:\\n                    right = middle - 1\\n                else:\\n                    return [index + 1, middle + 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        # Binary Search nLogn\\n        # Only one valid answer exist, no special case handler and no need to store combinations\\n        for index in range(len(numbers)):\\n            new_target = target - numbers[index]\\n            # Binary Search\\n            left, right = index + 1, len(numbers) - 1\\n            while left <= right:\\n                middle = (left + right) // 2\\n                if numbers[middle] < new_target:\\n                    left = middle + 1\\n                elif numbers[middle] > new_target:\\n                    right = middle - 1\\n                else:\\n                    return [index + 1, middle + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372761,
                "title": "java-beats-100-runtime-and-memory",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while(left != right){\\n            if(numbers[left] + numbers[right] > target){\\n                right--;\\n            } else if(numbers[left] + numbers[right] < target){\\n                left++;\\n            } else{\\n                return new int[] {left + 1, right + 1};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while(left != right){\\n            if(numbers[left] + numbers[right] > target){\\n                right--;\\n            } else if(numbers[left] + numbers[right] < target){\\n                left++;\\n            } else{\\n                return new int[] {left + 1, right + 1};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357435,
                "title": "java-solutions-brute-force-hash-table-binary-search-two-pointers",
                "content": "\\n### Brute-Force\\n\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      if (nums[i] + nums[j] == target) {\\n        return new int[] { i + 1, j + 1 };\\n      }\\n    }\\n  }\\n\\t\\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n**Time:** $O(N^2)$\\n**Space:** $O(1)$\\n\\n\\n\\n### Hash Table\\n\\n**Two-Pass:**\\n\\n```java\\n// Two-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  // map<target - num, index>\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    map.put(target - nums[i], i);\\n  }\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      if (i == j) continue;\\n      return new int[] { i + 1, j + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n**One-Pass:**\\n\\n```java\\n// One-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      return new int[] { j + 1, i + 1 }; // notice the order\\n    }\\n    map.put(target - val, i);\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n\\n**Time:** $O(N)$\\n**Space:** $O(N)$\\n\\n\\n### Binary Search\\n\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    // binary search\\n    int val = target - nums[i];\\n    int lo = i + 1, hi = n - 1;    // i + 1 instead of i\\n    int result = search(nums, val, lo, hi);\\n    if (result != -1) { // found\\n      return new int[] { i + 1, result + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n\\nprivate int search(int[] nums, int val, int lo, int hi) {\\n  while (lo <= hi) {\\n    int mid = lo + (hi - lo) / 2;\\n    if (nums[mid] == val) return mid;\\n    if (nums[mid] > val) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  return -1;\\n}\\n```\\n\\n**Time:** $O(N\\\\log{N})$\\n**Space:** $O(1)$\\n\\n\\n### Two Pointers\\n\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  int i = 0, j = n - 1;\\n  \\n  while (i < j) {\\n    int val = nums[i] + nums[j];\\n    if (val == target) {\\n      return new int[] { i + 1, j + 1 };\\n    } else if (val < target) {\\n      i += 1;\\n    } else { // val > target\\n      j -= 1;\\n    }\\n  }\\n  \\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n**Time:** $O(N)$\\n**Space:** $O(1)$",
                "solutionTags": [],
                "code": "```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      if (nums[i] + nums[j] == target) {\\n        return new int[] { i + 1, j + 1 };\\n      }\\n    }\\n  }\\n\\t\\n  throw new IllegalArgumentException();\\n}\\n```\n```java\\n// Two-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  // map<target - num, index>\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    map.put(target - nums[i], i);\\n  }\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      if (i == j) continue;\\n      return new int[] { i + 1, j + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\n```java\\n// One-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      return new int[] { j + 1, i + 1 }; // notice the order\\n    }\\n    map.put(target - val, i);\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    // binary search\\n    int val = target - nums[i];\\n    int lo = i + 1, hi = n - 1;    // i + 1 instead of i\\n    int result = search(nums, val, lo, hi);\\n    if (result != -1) { // found\\n      return new int[] { i + 1, result + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n\\nprivate int search(int[] nums, int val, int lo, int hi) {\\n  while (lo <= hi) {\\n    int mid = lo + (hi - lo) / 2;\\n    if (nums[mid] == val) return mid;\\n    if (nums[mid] > val) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  return -1;\\n}\\n```\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  int i = 0, j = n - 1;\\n  \\n  while (i < j) {\\n    int val = nums[i] + nums[j];\\n    if (val == target) {\\n      return new int[] { i + 1, j + 1 };\\n    } else if (val < target) {\\n      i += 1;\\n    } else { // val > target\\n      j -= 1;\\n    }\\n  }\\n  \\n  throw new IllegalArgumentException();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299549,
                "title": "c-concise-straightforward",
                "content": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.Length - 1, sum;\\n        while (true) {\\n            sum = numbers[l] + numbers[r];\\n            if (sum == target)\\n                break;\\n            else if (sum < target) \\n                l += 1;\\n            else\\n                r -= 1;\\n        }\\n        return new int[2] {l + 1, r + 1};\\n    } \\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.Length - 1, sum;\\n        while (true) {\\n            sum = numbers[l] + numbers[r];\\n            if (sum == target)\\n                break;\\n            else if (sum < target) \\n                l += 1;\\n            else\\n                r -= 1;\\n        }\\n        return new int[2] {l + 1, r + 1};\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51252,
                "title": "o-n-time-o-1-space-two-pointer-solution-with-detailed-and-clear-explanation",
                "content": "To find the two numbers that sum to a target value, let's say the left number is numbers[i], and the right number is numbers[j].\\n\\nLet's iterate 0 to numbers.length - 1 one by one to find the left index i. \\n\\nFirstly look at when i = 0. Let's say the right j is j* satisfying numbers[i] + numbers[j*] == target. How to find j*? Let's just take a random j satisfying 0 < j < numbers.length. There are 3 situations:\\n1. numbers[i] + numbers[j] == target\\n2. numbers[i] + numbers[j] < target\\n3. numbers[i] + numbers[j] > target\\n\\nAnswer is found in situation 1.\\n\\nIn situation 2, if numbers[i] + numbers[j] < target, because the array is sorted, we know that numbers[j*] > numbers[j], and j* > j. So we should check the index bigger than j.\\n\\nIn situation 3, if numbers[i] + numbers[j] > target, because the array is sorted, we know that numbers[j*] < numbers[j], and j* < j. So we should check the index smaller than j.\\n\\nIf the left index is not when i == 0, then where is j now? \\n\\nIt should satisfy:\\nnumbers[i] + numbers[j] > target\\nand\\nnumbers[i] + numbers[j - 1] < target\\n\\nBecause answer is not found for i == 0, now let's check when i == 1. \\n\\nThe trick is, now we only have to check the j that is smaller than the j we have when i == 0. If numbers[0] + numbers[j] > target, then also numbers[1] +  numbers[j] > target. So j is decreasing.\\n\\nThat's how 2 pointer solution come from. Start with i == 0, and j == numbers.length - 1, so that we can always decrease j as we increase i to find the solution.\\n\\n```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[2];\\n        int l = 0, r = numbers.length - 1, cur = numbers[l] + numbers[r];\\n        while (l < r) {\\n            if (cur == target) {\\n                res[0] = l + 1;\\n                res[1] = r + 1;\\n                break;\\n            } else if (cur < target) {\\n                cur += numbers[l + 1] - numbers[l]; // increase the left index\\n                l++;\\n            } else {\\n                cur -= numbers[r] - numbers[r - 1]; // decrease the right index\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[2];\\n        int l = 0, r = numbers.length - 1, cur = numbers[l] + numbers[r];\\n        while (l < r) {\\n            if (cur == target) {\\n                res[0] = l + 1;\\n                res[1] = r + 1;\\n                break;\\n            } else if (cur < target) {\\n                cur += numbers[l + 1] - numbers[l]; // increase the left index\\n                l++;\\n            } else {\\n                cur -= numbers[r] - numbers[r - 1]; // decrease the right index\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082169,
                "title": "three-simple-java-solutions-runtime-2ms",
                "content": "\\n# Code1\\n**By BinarySearch**\\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0 , high = numbers.length-1;\\n\\n            while (low < high)\\n            {\\n                int complement = numbers[low] + numbers[high];\\n                if (complement == target)\\n                {\\n                    return new int[]{low+1 , high+1};\\n                }else if (complement > target){\\n                    high--;\\n                }else {\\n                    low++;\\n                }\\n            }\\n            \\n        return new int[] {-1 , -1};\\n    }\\n}\\n```\\n\\n# Code2\\n\\n**By hashMap**\\n\\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        HashMap<Integer , Integer> hashMap = new HashMap<>();\\n\\n        for (int i = 0; i < numbers.length ; i++)\\n        {\\n            int complement = target - numbers[i];\\n            if (hashMap.containsKey(complement))\\n            {\\n                return new int[]{ hashMap.get(complement)+1 , i+1};\\n            }\\n\\n            hashMap.put(numbers[i] , i);\\n        }\\n        \\n        return new int[]{-1 , -1};\\n    }\\n}\\n```\\n\\n\\n# Code3\\n\\n**By hashSet**\\n\\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int [] res = {-1 , -1};\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int n : numbers) {\\n            set.add(n);\\n        }\\n\\n           StringBuilder str = new StringBuilder();\\n           int i = 1 ;\\n        for (int num : numbers)\\n        {\\n            if ( res[0] == -1 && set.contains(target - num))\\n            {\\n                res[0] = i;\\n                str.append(target - num);\\n            }else if (res[0] != -1 && Integer.parseInt(str.toString()) == num ){\\n                res[1] = i;\\n                return res;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/7f2cbe8d-f066-466d-bfc3-6eda2c5f3730_1695501256.7571125.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Hash Function"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0 , high = numbers.length-1;\\n\\n            while (low < high)\\n            {\\n                int complement = numbers[low] + numbers[high];\\n                if (complement == target)\\n                {\\n                    return new int[]{low+1 , high+1};\\n                }else if (complement > target){\\n                    high--;\\n                }else {\\n                    low++;\\n                }\\n            }\\n            \\n        return new int[] {-1 , -1};\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        HashMap<Integer , Integer> hashMap = new HashMap<>();\\n\\n        for (int i = 0; i < numbers.length ; i++)\\n        {\\n            int complement = target - numbers[i];\\n            if (hashMap.containsKey(complement))\\n            {\\n                return new int[]{ hashMap.get(complement)+1 , i+1};\\n            }\\n\\n            hashMap.put(numbers[i] , i);\\n        }\\n        \\n        return new int[]{-1 , -1};\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int [] res = {-1 , -1};\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int n : numbers) {\\n            set.add(n);\\n        }\\n\\n           StringBuilder str = new StringBuilder();\\n           int i = 1 ;\\n        for (int num : numbers)\\n        {\\n            if ( res[0] == -1 && set.contains(target - num))\\n            {\\n                res[0] = i;\\n                str.append(target - num);\\n            }else if (res[0] != -1 && Integer.parseInt(str.toString()) == num ){\\n                res[1] = i;\\n                return res;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916016,
                "title": "unique-two-pointer-solution-visual-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate two pointers where one points at the first index in the array and the other points at the second index. \\n![image.png](https://assets.leetcode.com/users/images/d1bf7a1b-14d2-4c20-95fb-f0e28e8ef04c_1692158325.868738.png)\\n\\nIf the sum of the values at the pointers is less than the target, shift both pointers over one. \\n![image.png](https://assets.leetcode.com/users/images/ab1f29a8-b028-4831-9cb4-d465f80cf8b3_1692158387.3140357.png)\\n\\nIf the values summed are greater, shift the first pointer left one. \\n![image.png](https://assets.leetcode.com/users/images/0729c0f4-9453-4fec-bb8b-cce8c3274bfe_1692158455.6069474.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        p1, p2 = 0, 1;\\n        while not (numbers[p1] + numbers[p2] == target):\\n            if numbers[p1] + numbers[p2] < target:\\n                p2+=1;\\n                p1+=1;\\n            else:\\n                p1-=1; \\n        return [p1+1, p2+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        p1, p2 = 0, 1;\\n        while not (numbers[p1] + numbers[p2] == target):\\n            if numbers[p1] + numbers[p2] < target:\\n                p2+=1;\\n                p1+=1;\\n            else:\\n                p1-=1; \\n        return [p1+1, p2+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753419,
                "title": "2-methods-using-stl-implementation",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Method 1: \\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n       for(int i=0; i<nums.size();i++){\\n           if(binary_search(nums.begin()+i+1,nums.end(),target-nums[i])){\\n           int lb = lower_bound(nums.begin()+i+1, nums.end(), target-nums[i])-nums.begin();\\n               return {i+1,lb+1};\\n           }\\n       }\\n       return {-1,-1};\\n    }\\n};\\n```\\n\\n# Method 2: \\n```\\nclass Solution {\\npublic:\\n     int search(int target, vector<int> &nums, int left, int right){\\n         while(left<=right){\\n             int mid = left + (right-left)/2;\\n             if(nums[mid]>target)\\n                 right = mid-1;\\n             else if(nums[mid]<target)\\n                 left = mid+1;\\n             else \\n                 return mid;\\n         }\\n         return -1;\\n     }\\n\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n      \\n\\n        for(int i=0; i<nums.size();i++){\\n            int j=search(target-nums[i], nums, i+1, nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n         return {-1,-1};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n       for(int i=0; i<nums.size();i++){\\n           if(binary_search(nums.begin()+i+1,nums.end(),target-nums[i])){\\n           int lb = lower_bound(nums.begin()+i+1, nums.end(), target-nums[i])-nums.begin();\\n               return {i+1,lb+1};\\n           }\\n       }\\n       return {-1,-1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int search(int target, vector<int> &nums, int left, int right){\\n         while(left<=right){\\n             int mid = left + (right-left)/2;\\n             if(nums[mid]>target)\\n                 right = mid-1;\\n             else if(nums[mid]<target)\\n                 left = mid+1;\\n             else \\n                 return mid;\\n         }\\n         return -1;\\n     }\\n\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n      \\n\\n        for(int i=0; i<nums.size();i++){\\n            int j=search(target-nums[i], nums, i+1, nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n         return {-1,-1};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744405,
                "title": "2-c-solutions-binary-search-two-pointers-approach",
                "content": "\\n\\n# Code\\n```\\n// Solution 1 (Two-pointers)\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int l = 0, r = numbers.size() -1;\\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target)\\n                return {l+1,r+1};\\n            else if(numbers[l] + numbers[r] > target)\\n                r--;\\n            else\\n                l++;\\n        }\\n\\t    return {};\\n    }\\n};\\n\\n// Solution 2 (Binary Search)\\nclass Solution {\\npublic:\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n                right=mid-1;\\n            else if(nums[mid]<target)\\n                left=mid+1;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n// Solution 1 (Two-pointers)\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int l = 0, r = numbers.size() -1;\\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target)\\n                return {l+1,r+1};\\n            else if(numbers[l] + numbers[r] > target)\\n                r--;\\n            else\\n                l++;\\n        }\\n\\t    return {};\\n    }\\n};\\n\\n// Solution 2 (Binary Search)\\nclass Solution {\\npublic:\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n                right=mid-1;\\n            else if(nums[mid]<target)\\n                left=mid+1;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361903,
                "title": "easiest-solution-beats-99-8-code-optimization-o-n-2-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is similar to a leetcode problem number 1, where array is not sorted. Here, we are given sorted array which make easy for finding optimal solution. \\n\\n# Approach Number 2 (Iterative) \\n<!-- Describe your approach to solving the problem. -->\\n**similar to Two sum problem - leetcode problem 1**\\n1. Run loop from i = 0 to size-1 and another loop(nested one) j = i+1 to size-1.\\n2. check if(nums[i] + nums[j] == target), return {i+1,j+1};\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        for(int i = 0; i < nums.size(); i++)\\n        for(int j = i+1; j < nums.size(); j++)\\n        if(nums[i]+nums[j]==target)\\n        return {i+1,j+1};\\n        return {};\\n    }\\n};\\n```\\n# OPTIMIZATION:-O(n^2)-> O(N).\\n# Approach Number 2\\n1. set two pointer i = 0 and j =  size-1.\\n2. Iterative till (i < j)\\n3. At each step do the following,\\n- if(nums[i] + nums[j] == target), return {i+1,j+1};\\n- else if(nums[i] + nums[j] > target), means our sum is greater than target, (2+15=17>9), we need a smaller number to reduce the sum, so decrease j by 1 as array is sorted.\\n- else increase i by 1. means our sum is smaller thsn target, (2+5=7 9), we need a greater number to increase the sum, so increase i by 1 as array is sorted.\\n\\n# Complexity.\\n**Time**-O(N)\\n**Space**-O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i = 0, j = nums.size()-1;\\n        while(i < j){\\n            if(nums[i] + nums[j] == target) return {i+1,j+1};\\n            else if(nums[i] + nums[j] > target)  j--;\\n            else  i++;     // nums[i] + nums[j] < target\\n        }\\n        return{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        for(int i = 0; i < nums.size(); i++)\\n        for(int j = i+1; j < nums.size(); j++)\\n        if(nums[i]+nums[j]==target)\\n        return {i+1,j+1};\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i = 0, j = nums.size()-1;\\n        while(i < j){\\n            if(nums[i] + nums[j] == target) return {i+1,j+1};\\n            else if(nums[i] + nums[j] > target)  j--;\\n            else  i++;     // nums[i] + nums[j] < target\\n        }\\n        return{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191053,
                "title": "python3-simplest-solution-o-log-n-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131059,
                "title": "c-use-2-pointers-simple-approach-dlc-june-day-9",
                "content": "**Approach:** Use 2 pointers approach\\n\\n**TC: O(N), SC:O(1)**\\n \\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int tar) \\n    {\\n        //define start and end pointer\\n        int s=0, e=nums.size()-1;\\n        \\n        //iterate until both pointers reach at the same index\\n        while(s<e)\\n        {\\n            if(nums[s]+nums[e]==tar) break;\\n            \\n            else if(nums[s]+nums[e]>tar) e--;\\n            \\n            else s++;\\n        }\\n        //return the index of s and e added by one\\n        return {s+1, e+1};           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int tar) \\n    {\\n        //define start and end pointer\\n        int s=0, e=nums.size()-1;\\n        \\n        //iterate until both pointers reach at the same index\\n        while(s<e)\\n        {\\n            if(nums[s]+nums[e]==tar) break;\\n            \\n            else if(nums[s]+nums[e]>tar) e--;\\n            \\n            else s++;\\n        }\\n        //return the index of s and e added by one\\n        return {s+1, e+1};           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128791,
                "title": "o-n-solution-in-c-using-two-pointers",
                "content": "We use a very important property here that the array is sorted...\\nNow we initialize two pointers, i and j, one being at start of the array and other being at the end...\\nIf the sum of these two elements is smaller than the target, we know that no element on left of i can sum with j to give us target, hence we move i forward...\\nSimilarly if sum of these two elements is greater than the target, we know that no element on right of j can sum with i to give us target, hence we j backward...\\nIf we reach target, we simply return these index added by 1...\\n\\n**If you found the solution helpful, pls upvote this thread.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0, j=numbers.size()-1;\\n        while(i<j) {\\n            if(numbers[i]+numbers[j]==target) return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else j--;\\n        }\\n        \\n        return {-1,-1};\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0, j=numbers.size()-1;\\n        while(i<j) {\\n            if(numbers[i]+numbers[j]==target) return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else j--;\\n        }\\n        \\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128757,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        val1=0\\n        val2=len(numbers)-1\\n        while val1<val2:\\n            if numbers[val1]+numbers[val2]==target:\\n                return [val1+1,val2+1]\\n            if numbers[val1]+numbers[val2]<target:\\n                val1+=1\\n            else:\\n                val2-=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        val1=0\\n        val2=len(numbers)-1\\n        while val1<val2:\\n            if numbers[val1]+numbers[val2]==target:\\n                return [val1+1,val2+1]\\n            if numbers[val1]+numbers[val2]<target:\\n                val1+=1\\n            else:\\n                val2-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016230,
                "title": "c-two-approaches-discussed-easy-to-understand",
                "content": "**Approach 1: (Using Binary Search)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size()-1;i++){\\n            int low=i+1,high=numbers.size()-1;\\n            int k=target-numbers[i];\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(numbers[mid]==k)     return{i+1,mid+1};\\n                else if(numbers[mid]<k)    low=mid+1;\\n                else    high=mid-1;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\n**Approach 2: (Using Two Pointers)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low=0,high=numbers.size()-1;\\n        while(low<high){\\n            if(numbers[low]+numbers[high]==target)  return {low+1,high+1};\\n            else if(numbers[low]+numbers[high]<target)  low++;\\n            else high--;\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nIf you liked the solution, then please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size()-1;i++){\\n            int low=i+1,high=numbers.size()-1;\\n            int k=target-numbers[i];\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(numbers[mid]==k)     return{i+1,mid+1};\\n                else if(numbers[mid]<k)    low=mid+1;\\n                else    high=mid-1;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low=0,high=numbers.size()-1;\\n        while(low<high){\\n            if(numbers[low]+numbers[high]==target)  return {low+1,high+1};\\n            else if(numbers[low]+numbers[high]<target)  low++;\\n            else high--;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945409,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the numbers.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        guard !numbers.isEmpty else { return [] }\\n        var i = 0\\n        var j = numbers.count - 1\\n\\n        while i < j {\\n            guard numbers[i] + numbers[j] != target else { break }\\n\\n            if numbers[i] + numbers[j] > target {\\n                j -= 1\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\n        return [i + 1, j + 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the numbers.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        guard !numbers.isEmpty else { return [] }\\n        var i = 0\\n        var j = numbers.count - 1\\n\\n        while i < j {\\n            guard numbers[i] + numbers[j] != target else { break }\\n\\n            if numbers[i] + numbers[j] > target {\\n                j -= 1\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\n        return [i + 1, j + 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749544,
                "title": "python-simple-and-clean-python-solution-using-two-pointer-approach",
                "content": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n# Runtime: 184 ms, faster than 45.91% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n# Memory Usage: 14.8 MB, less than 89.05% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, numbers: List[int], target: int) -> List[int]:\\n\\n\\t\\t\\tlow = 0\\n\\t\\t\\thigh = len(numbers)-1\\n\\n\\t\\t\\twhile low < high:\\n\\n\\t\\t\\t\\tif numbers[low]+numbers[high] < target:\\n\\t\\t\\t\\t\\tlow = low + 1\\n\\t\\t\\t\\telif numbers[low]+numbers[high] > target:\\n\\t\\t\\t\\t\\thigh = high - 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn [low+1, high+1]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n# Runtime: 184 ms, faster than 45.91% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n# Memory Usage: 14.8 MB, less than 89.05% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, numbers: List[int], target: int) -> List[int]:\\n\\n\\t\\t\\tlow = 0\\n\\t\\t\\thigh = len(numbers)-1\\n\\n\\t\\t\\twhile low < high:\\n\\n\\t\\t\\t\\tif numbers[low]+numbers[high] < target:\\n\\t\\t\\t\\t\\tlow = low + 1\\n\\t\\t\\t\\telif numbers[low]+numbers[high] > target:\\n\\t\\t\\t\\t\\thigh = high - 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn [low+1, high+1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1625354,
                "title": "c-binary-search-two-pointers-o-nlogn-o-n",
                "content": "**Binary Search [ O(nlogn) ]**\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size();i++)\\n        {\\n            int lb=0,ub=numbers.size()-1,mid=0;\\n            while(lb<=ub)\\n            {\\n                mid=lb+(ub-lb)/2;\\n                if(numbers[i]+numbers[mid]==target)\\n                {\\n                    if(mid==i)\\n                    {\\n                        if(numbers[i]+numbers[mid+1]==target)\\n                            mid++;\\n                        else if(numbers[i]+numbers[mid-1]==target)\\n                            mid--;\\n                    }\\n                    return vector<int>{i+1,mid+1};\\n                }\\n                    \\n                else if(numbers[i]+numbers[mid]<target)\\n                    lb=mid+1;\\n                else\\n                    ub=mid-1;\\n            }\\n            \\n        }\\n        return vector<int>{0,0};\\n    }\\n```\\nHere, for every number in the array, I am doing a binary search to get the second number. \\n\\nNow while searching for the second number, it might catch the same index as of the first number which is an incorrect answer as both index in the answer could not be the same.\\nBut if it catches the same index and finds the result, it simply means that the first number has repeated atleast twice because all test case could have one exact solution. Now, we know the array is sorted then definitely the same number has repeated either before or after the same index where the first number lies.\\nHence the check:\\n```\\nif(mid==i)\\n{\\n\\tif(numbers[i]+numbers[mid+1]==target)\\n\\t\\tmid++;\\n\\telse if(numbers[i]+numbers[mid-1]==target)\\n        mid--; \\n}\\n```\\n*A testcase justifying the above snippet;*\\n[1,2,3,4,4,9,56,90]\\n8\\n\\n\\n**Method 2: Two pointer [ O(n) ]**\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int lb=0,ub=numbers.size()-1;\\n        while(numbers[lb]+numbers[ub]!=target)\\n        {\\n                if(numbers[lb]+numbers[ub]<target)\\n                    lb++;\\n            else\\n                ub--;\\n        }\\n        return vector<int>{lb+1,ub+1};\\n```\\n\\nIf my solution helped you, please hit an upvote\\nIf you have any query, drop a comment and lets discuss!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size();i++)\\n        {\\n            int lb=0,ub=numbers.size()-1,mid=0;\\n            while(lb<=ub)\\n            {\\n                mid=lb+(ub-lb)/2;\\n                if(numbers[i]+numbers[mid]==target)\\n                {\\n                    if(mid==i)\\n                    {\\n                        if(numbers[i]+numbers[mid+1]==target)\\n                            mid++;\\n                        else if(numbers[i]+numbers[mid-1]==target)\\n                            mid--;\\n                    }\\n                    return vector<int>{i+1,mid+1};\\n                }\\n                    \\n                else if(numbers[i]+numbers[mid]<target)\\n                    lb=mid+1;\\n                else\\n                    ub=mid-1;\\n            }\\n            \\n        }\\n        return vector<int>{0,0};\\n    }\\n```\n```\\nif(mid==i)\\n{\\n\\tif(numbers[i]+numbers[mid+1]==target)\\n\\t\\tmid++;\\n\\telse if(numbers[i]+numbers[mid-1]==target)\\n        mid--; \\n}\\n```\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int lb=0,ub=numbers.size()-1;\\n        while(numbers[lb]+numbers[ub]!=target)\\n        {\\n                if(numbers[lb]+numbers[ub]<target)\\n                    lb++;\\n            else\\n                ub--;\\n        }\\n        return vector<int>{lb+1,ub+1};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534037,
                "title": "c-simple-solution-without-additional-memory",
                "content": "Pleas upvote if you like :-)\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n       int nStart=0, nEnd =numbers.size()-1;\\n        \\n        while(nStart<nEnd)\\n        {\\n            if(numbers[nStart]+numbers[nEnd] == target)\\n                return {nStart+1, nEnd+1};\\n            else if(numbers[nStart]+numbers[nEnd] > target)\\n                nEnd--;\\n            else\\n                nStart++;\\n        }\\n       \\n        return {};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n       int nStart=0, nEnd =numbers.size()-1;\\n        \\n        while(nStart<nEnd)\\n        {\\n            if(numbers[nStart]+numbers[nEnd] == target)\\n                return {nStart+1, nEnd+1};\\n            else if(numbers[nStart]+numbers[nEnd] > target)\\n                nEnd--;\\n            else\\n                nStart++;\\n        }\\n       \\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981444,
                "title": "java-binary-search",
                "content": "```\\nclass Solution { // binary search \\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0, end = numbers.length-1;\\n        while(start + 1 < end){\\n            int mid = start + (end-start)/2;\\n            if(numbers[start] == (target - numbers[end]))\\n                return new int[]{start + 1, end + 1};\\n            else if (numbers[start] < (target-numbers[end])) {\\n                start = (numbers[mid] < (target-numbers[end])) ? mid : start + 1;\\n            }else{\\n                end = (numbers[mid] > (target-numbers[start])) ? mid : end - 1;\\n            }\\n        }\\n        if(numbers[start] == (target - numbers[end]))\\n            return new int[]{start + 1, end + 1};\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // binary search \\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0, end = numbers.length-1;\\n        while(start + 1 < end){\\n            int mid = start + (end-start)/2;\\n            if(numbers[start] == (target - numbers[end]))\\n                return new int[]{start + 1, end + 1};\\n            else if (numbers[start] < (target-numbers[end])) {\\n                start = (numbers[mid] < (target-numbers[end])) ? mid : start + 1;\\n            }else{\\n                end = (numbers[mid] > (target-numbers[start])) ? mid : end - 1;\\n            }\\n        }\\n        if(numbers[start] == (target - numbers[end]))\\n            return new int[]{start + 1, end + 1};\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692019,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        ## RC ##\\n        ## APPRAOCH : 2 POINTER ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while(left < right):\\n            if(nums[left] + nums[right] < target):\\n                left += 1\\n            if(nums[left] + nums[right] > target):\\n                right -= 1\\n            if((nums[left] + nums[right]) == target):\\n                return [left+1,right+1]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        ## RC ##\\n        ## APPRAOCH : 2 POINTER ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while(left < right):\\n            if(nums[left] + nums[right] < target):\\n                left += 1\\n            if(nums[left] + nums[right] > target):\\n                right -= 1\\n            if((nums[left] + nums[right]) == target):\\n                return [left+1,right+1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 281058,
                "title": "javascript-98-runtime",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n    let p1=0, p2=numbers.length;\\n    while(p1<p2){\\n        if(numbers[p1]+numbers[p2]==target) return [p1+1,p2+1];\\n        else if(numbers[p1]+numbers[p2]<target) p1++;\\n        else p2--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    let p1=0, p2=numbers.length;\\n    while(p1<p2){\\n        if(numbers[p1]+numbers[p2]==target) return [p1+1,p2+1];\\n        else if(numbers[p1]+numbers[p2]<target) p1++;\\n        else p2--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51258,
                "title": "clean-easy-to-understand-solution-in-java",
                "content": "```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        \\n        int i = 0;\\n        int j = len - 1;\\n        \\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            \\n            if (sum > target) j--;\\n            else if (sum < target) i++;\\n            else return new int[] {i+1, j+1};\\n        }\\n        return new int[] {-1, -1}; // never comes here if sum exists\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        \\n        int i = 0;\\n        int j = len - 1;\\n        \\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            \\n            if (sum > target) j--;\\n            else if (sum < target) i++;\\n            else return new int[] {i+1, j+1};\\n        }\\n        return new int[] {-1, -1}; // never comes here if sum exists\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51338,
                "title": "c-6ms-two-pointers-6ms-binary-search-clean-code",
                "content": "**6ms: Two Pointers**\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    int low = 0;\\n    int high = numbers.size() - 1;\\n\\n    while(low < high){\\n        int sum = numbers[low] + numbers[high];\\n\\n        if(target == sum) return vector<int>({low+1, high+1});\\n        if(target > sum) ++low;\\n        else --high;\\n    }\\n    return vector<int>();\\n}\\n```\\n\\n**6ms: Binary Search**\\nTime: O(nlogn)\\nSpace: O(1)\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    for(int i = 0; i < numbers.size(); ++i){\\n        int index = bs(numbers, i+1, numbers.size(), target - numbers[i]);\\n        \\n        if(index < 0) continue;\\n        else return vector<int>({i+1, index+1});\\n    }\\n    return vector<int>();\\n}\\n\\nint bs(vector<int>& numbers, int low, int high, int target){\\n    while(low < high){\\n        int mid = low + (high - low) / 2;\\n        if(numbers[mid] == target) return mid;\\n        if(target > numbers[mid]) low = mid + 1;\\n        else high = mid - 1;\\n    }\\n    return numbers[low] == target ? low : -1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    int low = 0;\\n    int high = numbers.size() - 1;\\n\\n    while(low < high){\\n        int sum = numbers[low] + numbers[high];\\n\\n        if(target == sum) return vector<int>({low+1, high+1});\\n        if(target > sum) ++low;\\n        else --high;\\n    }\\n    return vector<int>();\\n}\\n```\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    for(int i = 0; i < numbers.size(); ++i){\\n        int index = bs(numbers, i+1, numbers.size(), target - numbers[i]);\\n        \\n        if(index < 0) continue;\\n        else return vector<int>({i+1, index+1});\\n    }\\n    return vector<int>();\\n}\\n\\nint bs(vector<int>& numbers, int low, int high, int target){\\n    while(low < high){\\n        int mid = low + (high - low) / 2;\\n        if(numbers[mid] == target) return mid;\\n        if(target > numbers[mid]) low = mid + 1;\\n        else high = mid - 1;\\n    }\\n    return numbers[low] == target ? low : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992419,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector <int> ans;\\n        int i = 0, j = numbers.size() - 1;\\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            if (sum == target) {\\n                ans.push_back(i + 1);\\n                ans.push_back(j + 1);\\n                break;\\n            } else if (sum < target) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector <int> ans;\\n        int i = 0, j = numbers.size() - 1;\\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            if (sum == target) {\\n                ans.push_back(i + 1);\\n                ans.push_back(j + 1);\\n                break;\\n            } else if (sum < target) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822273,
                "title": "c-2-pointers-solution",
                "content": "# Intuition\\nUse one single for-loop to give a solution.\\n\\n# Approach\\nWithin the loop it needs only to consider three cases, i.e. \\'==\\', \\'<\\' and \\'>\\'. \\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/uswoJ2X4mfU](https://youtu.be/uswoJ2X4mfU)\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        for(int i=0, j=n-1; i<j; ){\\n            int sum=numbers[i]+numbers[j];\\n            if (sum == target) return {i+1, j+1};\\n            else if ( sum< target) i++;\\n            else j--;\\n        }\\n        return {};        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        for(int i=0, j=n-1; i<j; ){\\n            int sum=numbers[i]+numbers[j];\\n            if (sum == target) return {i+1, j+1};\\n            else if ( sum< target) i++;\\n            else j--;\\n        }\\n        return {};        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364667,
                "title": "easy-two-pointers-solution",
                "content": "![47d7b3d2-77fe-40ef-bd04-ce5a5e314972_1675901748.9217496.jpeg](https://assets.leetcode.com/users/images/3bb26290-c943-45df-88f8-17c3e5e2dd5c_1680330260.6041856.jpeg)\\n# Code\\n```javascript []\\n\\nvar twoSum = function(arr, target) {\\n      let n=arr.length;\\n        let s=0;\\n        let e=n-1;\\n        while(s<e){\\n            let sum=arr[s]+arr[e];\\n            if(sum==target){\\n                s++;\\n                e++;\\n              return [s,e];\\n            }\\n            else if(sum>target){\\n                e--;\\n            }else{\\n                s++;\\n            }\\n        }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] twoSum(int[] arr, int target) {\\n        int n = arr.length;\\n        int s = 0;\\n        int e = n - 1;\\n        int[] ans = new int[2]; // declare and initialize ans\\n        while (s < e) {\\n            int sum = arr[s] + arr[e];\\n            if (sum == target) {\\n                ans[0] = s+1;\\n                ans[1] = e+1;\\n                break; // break out of the loop once a solution is found\\n            } else if (sum > target) {\\n                e--;\\n            } else {\\n                s++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![6233d50d-1433-4516-8d8e-90fb8e13d32f_1677303191.974716.jpeg](https://assets.leetcode.com/users/images/5ea3c40e-f0ce-4300-9bec-70607884e164_1680330293.8649492.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```javascript []\\n\\nvar twoSum = function(arr, target) {\\n      let n=arr.length;\\n        let s=0;\\n        let e=n-1;\\n        while(s<e){\\n            let sum=arr[s]+arr[e];\\n            if(sum==target){\\n                s++;\\n                e++;\\n              return [s,e];\\n            }\\n            else if(sum>target){\\n                e--;\\n            }else{\\n                s++;\\n            }\\n        }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] twoSum(int[] arr, int target) {\\n        int n = arr.length;\\n        int s = 0;\\n        int e = n - 1;\\n        int[] ans = new int[2]; // declare and initialize ans\\n        while (s < e) {\\n            int sum = arr[s] + arr[e];\\n            if (sum == target) {\\n                ans[0] = s+1;\\n                ans[1] = e+1;\\n                break; // break out of the loop once a solution is found\\n            } else if (sum > target) {\\n                e--;\\n            } else {\\n                s++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975227,
                "title": "simple-java-solution-100-faster",
                "content": "\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0 , end = numbers.length-1;\\n        while(start < end){\\n            if(numbers[start] + numbers[end] > target){\\n                end--;\\n            }else if(numbers[start] + numbers[end] < target){\\n                start++;\\n            }else{\\n                return new int[]{start+1, end+1};\\n            }\\n        }\\n        return new int[]{};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0 , end = numbers.length-1;\\n        while(start < end){\\n            if(numbers[start] + numbers[end] > target){\\n                end--;\\n            }else if(numbers[start] + numbers[end] < target){\\n                start++;\\n            }else{\\n                return new int[]{start+1, end+1};\\n            }\\n        }\\n        return new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382513,
                "title": "c-solution-two-pointers-approach-comments-o-n",
                "content": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint n = numbers.size();\\n\\tint i =0, j = n-1;\\n\\t\\n\\t// traversing the array until the left pointer goes further than right pointer\\n\\twhile(i<=j){\\n\\t\\tint sum = numbers[i]+ numbers[j];\\n\\t\\t\\n\\t\\t// if the sum of left and right pointer gives the target,\\n\\t\\t// we return the index positions\\n\\t\\tif(sum==target)  return {i+1, j+1};\\n\\t\\t// else since it\\'s sorted decreasing the right pointer would decrease the sum\\n\\t\\t\\n\\t\\telse if(sum>target) j--;\\n\\t\\t\\n\\t\\t// else increase the left pointer to increase the sum\\n\\t\\telse    i++;\\n\\t}\\n\\treturn {0,0};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint n = numbers.size();\\n\\tint i =0, j = n-1;\\n\\t\\n\\t// traversing the array until the left pointer goes further than right pointer\\n\\twhile(i<=j){\\n\\t\\tint sum = numbers[i]+ numbers[j];\\n\\t\\t\\n\\t\\t// if the sum of left and right pointer gives the target,\\n\\t\\t// we return the index positions\\n\\t\\tif(sum==target)  return {i+1, j+1};\\n\\t\\t// else since it\\'s sorted decreasing the right pointer would decrease the sum\\n\\t\\t\\n\\t\\telse if(sum>target) j--;\\n\\t\\t\\n\\t\\t// else increase the left pointer to increase the sum\\n\\t\\telse    i++;\\n\\t}\\n\\treturn {0,0};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130788,
                "title": "simple-and-easy-approach",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int low=0,high =numbers.size()-1;\\n        int total;\\n        while(low<high){\\n            total=(numbers[low]+numbers[high]);\\n            if(total==target) {\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                return ans;\\n            }\\n            else if(total >target)  high --;\\n            else low++;\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int low=0,high =numbers.size()-1;\\n        int total;\\n        while(low<high){\\n            total=(numbers[low]+numbers[high]);\\n            if(total==target) {\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2130676,
                "title": "two-sum-ii-input-array-is-sorted-two-pointer-simple",
                "content": "Solution:\\nThe precondition of sorted array indicates the use of two pointers,since this is the only point of difference from the normal Two Sum Problem( which btw can be solved using this approach as well but with a greater T.C. ).\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int l=0,h=numbers.size()-1;\\n        while(l<h){\\n            if((numbers[l]+numbers[h])==target){\\n                ans.push_back(l+1);\\n                ans.push_back(h+1);\\n                break;\\n            }\\n            else if((numbers[l]+numbers[h])<target)\\n                l++;\\n            else\\n                h--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int l=0,h=numbers.size()-1;\\n        while(l<h){\\n            if((numbers[l]+numbers[h])==target){\\n                ans.push_back(l+1);\\n                ans.push_back(h+1);\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2129916,
                "title": "c-2-pointer-approach-daily-leetcoding-challenge-june-day-9",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        int left = 0;                    // left pointer\\n        int right = numbers.size()-1;    // right pointer\\n        \\n        // till both the pointers will not collide\\n        while(left<right)\\n        {\\n            // after getting our target value break it\\n            if(numbers[left]+numbers[right]==target)\\n            {\\n                break;\\n            }\\n            \\n            // if current sum is lower than target , so we need to maximize it , so move left pointer towards the right\\n            else if(numbers[left]+numbers[right]<target)\\n            {\\n                left++;\\n            }\\n            \\n            // if current sum is bigger than target so we need to minimize it , so move right pointer towards the left\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        \\n        return {left+1,right+1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        int left = 0;                    // left pointer\\n        int right = numbers.size()-1;    // right pointer\\n        \\n        // till both the pointers will not collide\\n        while(left<right)\\n        {\\n            // after getting our target value break it\\n            if(numbers[left]+numbers[right]==target)\\n            {\\n                break;\\n            }\\n            \\n            // if current sum is lower than target , so we need to maximize it , so move left pointer towards the right\\n            else if(numbers[left]+numbers[right]<target)\\n            {\\n                left++;\\n            }\\n            \\n            // if current sum is bigger than target so we need to minimize it , so move right pointer towards the left\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        \\n        return {left+1,right+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128749,
                "title": "binary-search-approach-not-2-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // USING BINARY SEARCH - nLogn\\n    \\n    int bs(vector<int> &nums, int i ,int j,int target){\\n        int l = i, h = j;\\n        int mid;\\n        \\n        while(l<=h)\\n        {\\n            mid = l + (h-l)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid]>target){\\n                h = mid-1;\\n            }else\\n                l = mid+1;\\n        }\\n        \\n        return INT_MAX;            \\n    }\\n    \\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i<n-1; i++)  //IMP \\n        {   \\n            if(nums[i]>0 and nums[i]>target)        //condition for positive numbers only\\n                break;\\n            \\n            int index = bs(nums,i+1,n-1,target - nums[i]);\\n            \\n            if(index!= INT_MAX){\\n                ans.push_back(i+1);\\n                ans.push_back(index+1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // USING BINARY SEARCH - nLogn\\n    \\n    int bs(vector<int> &nums, int i ,int j,int target){\\n        int l = i, h = j;\\n        int mid;\\n        \\n        while(l<=h)\\n        {\\n            mid = l + (h-l)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid]>target){\\n                h = mid-1;\\n            }else\\n                l = mid+1;\\n        }\\n        \\n        return INT_MAX;            \\n    }\\n    \\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i<n-1; i++)  //IMP \\n        {   \\n            if(nums[i]>0 and nums[i]>target)        //condition for positive numbers only\\n                break;\\n            \\n            int index = bs(nums,i+1,n-1,target - nums[i]);\\n            \\n            if(index!= INT_MAX){\\n                ans.push_back(i+1);\\n                ans.push_back(index+1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014406,
                "title": "two-pointer-using-binary-search-time-o-n-o-1-space-java",
                "content": "* This question straightforward uses **two-pointer** algo , but we can also use **binary search**  within it,  just to remove unwanted part of array (using unwanted part eliminate technique) \\nwhenever eliminated condition hit ,else normally executing by two pointer algo ,  that is help to reduce the overall time complexity .\\n\\n* Basically binary search helps to removes that part of array which have element greater than target.\\n    and only left with element that are lesser than target, on which we apply two-pointer algo.\\n\\n\\n**Time - O(Logn) + O(N) = O(N)\\nSpace - O(1)**\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n     \\n        int i=0;\\n        int j=numbers.length-1;\\n        int[] arr={1,1};\\n        while(i<=j){ \\n            int mid=(i+j)/2;\\n            if(target>0 && numbers[mid]>target){\\n                j=mid-1;\\n            }\\n            else{\\n                if(numbers[i]+numbers[mid]>target){\\n                    j=mid-1;\\n                }\\n            if(numbers[i]+numbers[j]==target){ \\n                arr[0]=i+1;\\n                arr[1]=j+1;\\n                break;\\n            } \\n            if(numbers[i]+numbers[j]<target){\\n                i++; \\n            }\\n            if(numbers[i]+numbers[j]>target){\\n                j--; \\n            }\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n     \\n        int i=0;\\n        int j=numbers.length-1;\\n        int[] arr={1,1};\\n        while(i<=j){ \\n            int mid=(i+j)/2;\\n            if(target>0 && numbers[mid]>target){\\n                j=mid-1;\\n            }\\n            else{\\n                if(numbers[i]+numbers[mid]>target){\\n                    j=mid-1;\\n                }\\n            if(numbers[i]+numbers[j]==target){ \\n                arr[0]=i+1;\\n                arr[1]=j+1;\\n                break;\\n            } \\n            if(numbers[i]+numbers[j]<target){\\n                i++; \\n            }\\n            if(numbers[i]+numbers[j]>target){\\n                j--; \\n            }\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991249,
                "title": "python-simple-beats-84",
                "content": "```\\nclass Solution:\\n    def twoSum(self, n: List[int], target: int) -> List[int]:\\n        \\n        i=0\\n        j=len(n)-1\\n        while i<j:\\n            x=n[i]+n[j]\\n            if(x==target):\\n                return i+1,j+1\\n            elif(x<target):\\n                i+=1\\n            else:\\n                j-=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoSum(self, n: List[int], target: int) -> List[int]:\\n        \\n        i=0\\n        j=len(n)-1\\n        while i<j:\\n            x=n[i]+n[j]\\n            if(x==target):\\n                return i+1,j+1\\n            elif(x<target):\\n                i+=1\\n            else:\\n                j-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846741,
                "title": "java-two-pointer-easy-solution",
                "content": "```\\nclass Solution {\\n      public int[] twoSum(int[] numbers, int target) {\\n        // we assume that s=start,e=end has two pointer\\n           int s=0, e=numbers.length-1;\\n          while(s<e){\\n                if(numbers[s]+numbers[e]>target){\\n                         e--;\\n                }else if(numbers[s]+numbers[e]<target){\\n                         s++;\\n                }else\\n                 {\\n                //In the question says that index start from 1 not 0\\n                              return new int[]{s+1,e+1}; // create new      array for put s & e\\n                  }\\n              }\\n                     return new int[]{};\\n          }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int[] twoSum(int[] numbers, int target) {\\n        // we assume that s=start,e=end has two pointer\\n           int s=0, e=numbers.length-1;\\n          while(s<e){\\n                if(numbers[s]+numbers[e]>target){\\n                         e--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1776647,
                "title": "c-2-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n     \\n        int i1=0,i2=nums.size()-1;\\n        \\n        while(i1 <=i2 ){\\n            \\n            if(nums[i1]+nums[i2] == target) return {i1+1,i2+1};\\n            else if(nums[i1]+nums[i2] > target) i2--;\\n            else i1++;\\n            \\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nPlease **Upvote** if you liked my solution.\\nDon\\'t forget to visit my repository: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n     \\n        int i1=0,i2=nums.size()-1;\\n        \\n        while(i1 <=i2 ){\\n            \\n            if(nums[i1]+nums[i2] == target) return {i1+1,i2+1};\\n            else if(nums[i1]+nums[i2] > target) i2--;\\n            else i1++;\\n            \\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762376,
                "title": "c-efficient-two-pointers-tc-o-n-sc-1-with-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n##### Two pointer technique:-\\n* We can exploit the sorted property of an array.\\n* Let\\'s say for indices` i` & `j` such that` i<j,`\\n* if sum of elements `nums[i]+nums[j] == target, `then we are done\\n* else check whether `nums[i]+nums[j] > target,` then last element has to be removed to reduce the value of sum` (j--).`\\n* similarly if `nums[i]+nums[j] < target`, we have to add little to increase the sum `(i++).`\\n\\n*Time Complexity: O (n)\\nSpace Complexity: O (1)*\\n\\n##### C++ code:-\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0,j=numbers.size()-1;\\n        while(i<=j){\\n            if(numbers[i]+numbers[j]==target) return {i+1,j+1};\\n            else if((numbers[i]+numbers[j]) > target) j--;\\n            else if((numbers[i]+numbers[j]) < target) i++;   \\n        }\\n\\t\\treturn {};//to avoid leetcode error;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0,j=numbers.size()-1;\\n        while(i<=j){\\n            if(numbers[i]+numbers[j]==target) return {i+1,j+1};\\n            else if((numbers[i]+numbers[j]) > target) j--;\\n            else if((numbers[i]+numbers[j]) < target) i++;   \\n        }\\n\\t\\treturn {};//to avoid leetcode error;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708101,
                "title": "javascript-map-o-n-time-o-n-space",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n    const map = new Map(numbers.map((n, i) => [n, i]));\\n    \\n    for(let i = 0; i < numbers.length; i++) {\\n        const complement = Math.abs(numbers[i] - target);\\n        \\n        if (map.has(complement)) {\\n            return [i + 1, map.get(complement) + 1];\\n        }\\n    }\\n    \\n    return [];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    const map = new Map(numbers.map((n, i) => [n, i]));\\n    \\n    for(let i = 0; i < numbers.length; i++) {\\n        const complement = Math.abs(numbers[i] - target);\\n        \\n        if (map.has(complement)) {\\n            return [i + 1, map.get(complement) + 1];\\n        }\\n    }\\n    \\n    return [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706003,
                "title": "faster-than-99-javascript-solution",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n    const seen = {};\\n    for (let i = 0; i < numbers.length; i++) {\\n        const needed = seen[target - numbers[i]];\\n        if (needed !== undefined) {\\n            return [needed + 1, i + 1];\\n        }\\n        seen[numbers[i]] = i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    const seen = {};\\n    for (let i = 0; i < numbers.length; i++) {\\n        const needed = seen[target - numbers[i]];\\n        if (needed !== undefined) {\\n            return [needed + 1, i + 1];\\n        }\\n        seen[numbers[i]] = i;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578339,
                "title": "java-0ms-faster-than-100-optimized-solution-two-pointer-binary-search",
                "content": "```\\n/*\\nC: sorted in non-decreasing order  - > asc dup 1 <= index1 < index2 <= numbers.length\\nA:exactly one solution. \\nR:if length == 2, + -> return 2 indexes 1-indexed return 0-index + 1\\n    mid < target / 2 -> bs -> reduce by left + mid and mid + right -> worst case two pointer O(n),  binary search O(logn), total O(n)\\nT:[0, 1] [1,1, 1, 1, 2, 7,] \\n\\n*/\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[]{-1, -1};\\n        // corner case \\n        if (numbers.length < 2) {\\n            return res;\\n        }\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            // case 1\\n            if (numbers[left] + numbers[right] == target) {\\n                return new int[]{left + 1, right + 1};\\n            } else if (numbers[left] + numbers[right] < target) {\\n                // case 2\\n                if (numbers[mid] + numbers[right] == target) {\\n                    return new int[]{mid + 1, right + 1};\\n                } else if (numbers[mid] + numbers[right] < target) {\\n                    left = mid + 1;\\n                } else {\\n                    left++;\\n                }\\n            } else { // numbers[left] + numbers[right] > target\\n                 // case 3    \\n                if (numbers[left] + numbers[mid] == target) {\\n                    return new int[]{left + 1, mid + 1};\\n                } else if (numbers[left] + numbers[mid] > target) {\\n                    right = mid - 1;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\nC: sorted in non-decreasing order  - > asc dup 1 <= index1 < index2 <= numbers.length\\nA:exactly one solution. \\nR:if length == 2, + -> return 2 indexes 1-indexed return 0-index + 1\\n    mid < target / 2 -> bs -> reduce by left + mid and mid + right -> worst case two pointer O(n),  binary search O(logn), total O(n)\\nT:[0, 1] [1,1, 1, 1, 2, 7,] \\n\\n*/\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[]{-1, -1};\\n        // corner case \\n        if (numbers.length < 2) {\\n            return res;\\n        }\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            // case 1\\n            if (numbers[left] + numbers[right] == target) {\\n                return new int[]{left + 1, right + 1};\\n            } else if (numbers[left] + numbers[right] < target) {\\n                // case 2\\n                if (numbers[mid] + numbers[right] == target) {\\n                    return new int[]{mid + 1, right + 1};\\n                } else if (numbers[mid] + numbers[right] < target) {\\n                    left = mid + 1;\\n                } else {\\n                    left++;\\n                }\\n            } else { // numbers[left] + numbers[right] > target\\n                 // case 3    \\n                if (numbers[left] + numbers[mid] == target) {\\n                    return new int[]{left + 1, mid + 1};\\n                } else if (numbers[left] + numbers[mid] > target) {\\n                    right = mid - 1;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537424,
                "title": "2-easy-js-solutions-with-complexity",
                "content": "Solution 1:  **Two pointers**  \\nTC: O(N) SC: O(1)\\n\\n```\\nvar twoSum = function(numbers, target) {\\n    let start = 0;\\n    let end = numbers.length - 1;\\n    while(start < end) {\\n        let sum = numbers[start] + numbers[end];\\n        if(sum > target) {\\n            end--;\\n        } else if(sum < target) {\\n            start++;\\n        } else {\\n            return [start + 1, end + 1];\\n        }\\n    }\\n}\\n```\\n\\nSolution 2: **Binary Search**\\nTC: O(NlogN)\\nSC: O(1)\\n\\n```\\nvar twoSum = function(numbers, target) {\\n\\tfor(let i = 0;i< numbers.length;i++) {\\n        let number = numbers[i];\\n        let complement = target - number; \\n         \\n        let low = i + 1; //Search for complement from next index\\n        let high = numbers.length - 1;\\n         \\n        while(low <= high) {\\n            let mid = low + Math.floor((high - low) / 2);\\n            \\n            if(numbers[mid] === complement) {\\n                return [i + 1, mid + 1];\\n            } else if(numbers[mid] < complement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    let start = 0;\\n    let end = numbers.length - 1;\\n    while(start < end) {\\n        let sum = numbers[start] + numbers[end];\\n        if(sum > target) {\\n            end--;\\n        } else if(sum < target) {\\n            start++;\\n        } else {\\n            return [start + 1, end + 1];\\n        }\\n    }\\n}\\n```\n```\\nvar twoSum = function(numbers, target) {\\n\\tfor(let i = 0;i< numbers.length;i++) {\\n        let number = numbers[i];\\n        let complement = target - number; \\n         \\n        let low = i + 1; //Search for complement from next index\\n        let high = numbers.length - 1;\\n         \\n        while(low <= high) {\\n            let mid = low + Math.floor((high - low) / 2);\\n            \\n            if(numbers[mid] === complement) {\\n                return [i + 1, mid + 1];\\n            } else if(numbers[mid] < complement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503779,
                "title": "rust-loop",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Two Sum II - Input array is sorted.\\nMemory Usage: 2.1 MB, less than 60.15% of Rust online submissions for Two Sum II - Input array is sorted.\\n```\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut first: usize = 0;\\n        let mut second: usize = numbers.len()-1;\\n        \\n        while first < second {\\n            if numbers[first]+numbers[second] == target {\\n                break;\\n            } else if numbers[first]+numbers[second] < target {\\n                first+=1;\\n            } else {\\n                second-=1;\\n            }\\n        }\\n        return Vec::from([first as i32 + 1, second as i32 + 1]);\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Two Sum II - Input array is sorted.\\nMemory Usage: 2.1 MB, less than 60.15% of Rust online submissions for Two Sum II - Input array is sorted.\\n```\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut first: usize = 0;\\n        let mut second: usize = numbers.len()-1;\\n        \\n        while first < second {\\n            if numbers[first]+numbers[second] == target {\\n                break;\\n            } else if numbers[first]+numbers[second] < target {\\n                first+=1;\\n            } else {\\n                second-=1;\\n            }\\n        }\\n        return Vec::from([first as i32 + 1, second as i32 + 1]);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1448922,
                "title": "java-clean-concise-optimal-code-two-pointer-technique-o-n-time-solution",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int start = 0, end = numbers.length - 1;\\n        \\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[] {start + 1, end + 1};\\n            }\\n            else if (numbers[start] + numbers[end] < target) {\\n                ++start;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n        \\n        return new int[] {-1, -1};\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int start = 0, end = numbers.length - 1;\\n        \\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[] {start + 1, end + 1};\\n            }\\n            else if (numbers[start] + numbers[end] < target) {\\n                ++start;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n        \\n        return new int[] {-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411559,
                "title": "runtime-4-ms-faster-than-88-54",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int i = 0 , j = numbers.size()-1;\\n        while(i < j)\\n        {\\n            if(numbers[i] + numbers[j] > target)\\n                j--;\\n            else\\n            if(numbers[i] + numbers[j] < target)\\n                i++;\\n            else\\n                break;\\n            \\n                \\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int i = 0 , j = numbers.size()-1;\\n        while(i < j)\\n        {\\n            if(numbers[i] + numbers[j] > target)\\n                j--;\\n            else\\n            if(numbers[i] + numbers[j] < target)\\n                i++;\\n            else\\n                break;\\n            \\n                \\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273272,
                "title": "kotlin-100-faster-100-memory-effecient-2-pointer-solution-o-n-time-clean-kotlin-syntax",
                "content": "\\tfun twoSum(numbers: IntArray, target: Int): IntArray {\\n\\t\\tvar i = 1\\n\\t\\tvar j = numbers.size\\n\\n\\t\\twhile (true) { //Use of `while` is ok since an answer is guaranteed \\n\\t\\t\\tval sumIJ = numbers[i-1] + numbers[j-1]\\n\\t\\t\\twhen { //Use of `when` to promote kotlin clean coding convention\\n\\t\\t\\t\\tsumIJ == target -> return intArrayOf(i, j)\\n\\t\\t\\t\\tsumIJ < target -> i++ //shift pointer to the right\\n\\t\\t\\t\\tsumIJ > target -> j-- //shift pointer to the left\\n\\t\\t\\t\\ti == j -> throw IllegalArgumentException(\"No sum\")\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\t\\nPlease Upvote if you like my answer.",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "\\tfun twoSum(numbers: IntArray, target: Int): IntArray {\\n\\t\\tvar i = 1\\n\\t\\tvar j = numbers.size\\n\\n\\t\\twhile (true) { //Use of `while` is ok since an answer is guaranteed \\n\\t\\t\\tval sumIJ = numbers[i-1] + numbers[j-1]\\n\\t\\t\\twhen { //Use of `when` to promote kotlin clean coding convention\\n\\t\\t\\t\\tsumIJ == target -> return intArrayOf(i, j)\\n\\t\\t\\t\\tsumIJ < target -> i++ //shift pointer to the right\\n\\t\\t\\t\\tsumIJ > target -> j-- //shift pointer to the left\\n\\t\\t\\t\\ti == j -> throw IllegalArgumentException(\"No sum\")\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\t\\nPlease Upvote if you like my answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 1136521,
                "title": "python-two-pointers",
                "content": "```\\ndef twoSum(self, numbers: List[int], target: int) -> List[int]: \\n        left = 0\\n        right = len(numbers) - 1\\n        \\n        sumLR = 0\\n        \\n        while left <= right:\\n            sumLR = numbers[left] + numbers[right]\\n            \\n            if sumLR > target:\\n                right -= 1\\n            elif sumLR < target:\\n                left += 1\\n            else:\\n                return [left+1, right+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef twoSum(self, numbers: List[int], target: int) -> List[int]: \\n        left = 0\\n        right = len(numbers) - 1\\n        \\n        sumLR = 0\\n        \\n        while left <= right:\\n            sumLR = numbers[left] + numbers[right]\\n            \\n            if sumLR > target:\\n                right -= 1\\n            elif sumLR < target:\\n                left += 1\\n            else:\\n                return [left+1, right+1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 767436,
                "title": "o-n-c-solution-fast-and-easy-to-understand",
                "content": "```\\nint* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    int* ans = malloc(sizeof(int)*2);\\n    *returnSize = 2;\\n    int l = 0, r = numbersSize-1;\\n    while (l < r)\\n    {\\n        if (numbers[l] + numbers[r] == target)\\n        {\\n            ans[0] = l+1; ans[1] = r+1;\\n            return ans;\\n        }\\n        else\\n        {\\n            if (numbers[l] + numbers[r] < target)\\n                l++;\\n            else\\n                r--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    int* ans = malloc(sizeof(int)*2);\\n    *returnSize = 2;\\n    int l = 0, r = numbersSize-1;\\n    while (l < r)\\n    {\\n        if (numbers[l] + numbers[r] == target)\\n        {\\n            ans[0] = l+1; ans[1] = r+1;\\n            return ans;\\n        }\\n        else\\n        {\\n            if (numbers[l] + numbers[r] < target)\\n                l++;\\n            else\\n                r--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748113,
                "title": "ruby-hash-approach",
                "content": "```\\ndef two_sum(numbers, target)\\n    hash = {}\\n    \\n    numbers.each_with_index do |num, i|\\n        return hash[target - num] + 1, i + 1 if hash[target - num]\\n        hash[num] = i\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef two_sum(numbers, target)\\n    hash = {}\\n    \\n    numbers.each_with_index do |num, i|\\n        return hash[target - num] + 1, i + 1 if hash[target - num]\\n        hash[num] = i\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 646794,
                "title": "java-two-pointer-solution",
                "content": "![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_167.png)  \\n\\n\\n``` java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int lo = 0, len = numbers.length, hi = len - 1;\\n        while (lo < hi){\\n            int sum = numbers[lo] + numbers[hi];\\n            if (sum == target){\\n                return new int[]{lo + 1, hi + 1};\\n            } else if (sum < target){\\n                lo++;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int lo = 0, len = numbers.length, hi = len - 1;\\n        while (lo < hi){\\n            int sum = numbers[lo] + numbers[hi];\\n            if (sum == target){\\n                return new int[]{lo + 1, hi + 1};\\n            } else if (sum < target){\\n                lo++;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487895,
                "title": "java-0-ms-use-two-pointer-approach-while-avoiding-overflow",
                "content": "The accepted solution does not work for inputs with a valid solution where there is a possibility of overflow. The following should be added as a test case and the reference implementation should be updated:\\n![image](https://assets.leetcode.com/users/ed-karabinus/image_1579731057.png)\\n\\n\\n![image](https://assets.leetcode.com/users/ed-karabinus/image_1579730847.png)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int numbersLength = numbers.length;\\n        int low = 0;\\n        int high = numbersLength - 1;\\n        while (low < high) {\\n            int complement = target - numbers[low];\\n            if (complement == numbers[high]) {\\n                return new int[] { low + 1, high + 1 };\\n            } else if (complement > numbers[high]) {\\n                low++;\\n            } else {\\n                high--;\\n            }\\n        }\\n        // We are guaranteed an input with a valid solution,\\n        // so this line will never be reached.\\n        return new int[] { 0, 0 };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int numbersLength = numbers.length;\\n        int low = 0;\\n        int high = numbersLength - 1;\\n        while (low < high) {\\n            int complement = target - numbers[low];\\n            if (complement == numbers[high]) {\\n                return new int[] { low + 1, high + 1 };\\n            } else if (complement > numbers[high]) {\\n                low++;\\n            } else {\\n                high--;\\n            }\\n        }\\n        // We are guaranteed an input with a valid solution,\\n        // so this line will never be reached.\\n        return new int[] { 0, 0 };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362277,
                "title": "ruby-solution",
                "content": "```\\ndef two_sum(numbers, target)\\n    i = 0\\n    j = numbers.length-1\\n    while(i < j)\\n        curr_sum = numbers[i]+numbers[j]\\n        if(target > curr_sum)\\n            i += 1\\n        elsif(target < curr_sum)\\n            j -= 1\\n        else\\n            return [i+1,j+1]\\n        end\\n    end\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef two_sum(numbers, target)\\n    i = 0\\n    j = numbers.length-1\\n    while(i < j)\\n        curr_sum = numbers[i]+numbers[j]\\n        if(target > curr_sum)\\n            i += 1\\n        elsif(target < curr_sum)\\n            j -= 1\\n        else\\n            return [i+1,j+1]\\n        end\\n    end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4083125,
                "title": "two-sum-ii-sorted-array-solution-beats-99-23",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two pointers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the fact the the list is sorted and there exists only one solution, we traverse the list using two pointers both from both ends of the list until they point to the values that add up to target. If the sum at the right and left pointers is greater than target, move the right ponter to the left. If it is less, move the left pointer to the right.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) extra space\\n\\n# Code\\n```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l=0\\n        r=len(numbers)-1\\n        while True:\\n            if numbers[l]+numbers[r] > target:\\n                r-=1\\n            elif numbers[l]+numbers[r] < target:\\n                l+=1\\n            else:\\n                return [l+1,r+1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l=0\\n        r=len(numbers)-1\\n        while True:\\n            if numbers[l]+numbers[r] > target:\\n                r-=1\\n            elif numbers[l]+numbers[r] < target:\\n                l+=1\\n            else:\\n                return [l+1,r+1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768425,
                "title": "javascript-best-solution-with-explanation-two-pointers",
                "content": "# Approach\\n- Declare two pointers at the start and end of the array.\\n- Loop through the array until the sum of the two pointers is equal to the target.\\n- If the sum is greater than the target, move the right pointer to the left\\n- If the sum is less than the target, move the left pointer to the right\\n- Return the indices of the two pointers + 1\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function (numbers, target) {\\n  // declare two pointers at the start and end of the array\\n  let left = 0\\n  let right = numbers.length - 1\\n\\n  // loop through the array until the sum of the two pointers is equal to the target\\n  while (numbers[left] + numbers[right] !== target) {\\n    // if the sum is greater than the target, move the right pointer to the left\\n    if (numbers[left] + numbers[right] > target) {\\n      right--\\n    } else {\\n      // if the sum is less than the target, move the left pointer to the right\\n      left++\\n    }\\n  }\\n\\n  // return the indices of the two pointers + 1\\n  return [left + 1, right + 1]\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function (numbers, target) {\\n  // declare two pointers at the start and end of the array\\n  let left = 0\\n  let right = numbers.length - 1\\n\\n  // loop through the array until the sum of the two pointers is equal to the target\\n  while (numbers[left] + numbers[right] !== target) {\\n    // if the sum is greater than the target, move the right pointer to the left\\n    if (numbers[left] + numbers[right] > target) {\\n      right--\\n    } else {\\n      // if the sum is less than the target, move the left pointer to the right\\n      left++\\n    }\\n  }\\n\\n  // return the indices of the two pointers + 1\\n  return [left + 1, right + 1]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630007,
                "title": "python3",
                "content": "\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        left, right = 0, len(numbers) - 1  # Initialize two pointers, left and right, pointing to the start and end of the list respectively.\\n\\n        while left < right:  # Continue the loop until the pointers meet or cross each other.\\n            if numbers[left] + numbers[right] == target:  # If the sum of the numbers at the left and right pointers is equal to the target:\\n                return [left + 1, right + 1]  # Return the indices (1-based) of the two numbers that add up to the target.\\n            \\n            if numbers[left] + numbers[right] < target:  # If the sum is less than the target:\\n                left += 1  # Move the left pointer to the right, increasing its index.\\n            else:  # If the sum is greater than the target:\\n                right -= 1  # Move the right pointer to the left, decreasing its index.\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        left, right = 0, len(numbers) - 1  # Initialize two pointers, left and right, pointing to the start and end of the list respectively.\\n\\n        while left < right:  # Continue the loop until the pointers meet or cross each other.\\n            if numbers[left] + numbers[right] == target:  # If the sum of the numbers at the left and right pointers is equal to the target:\\n                return [left + 1, right + 1]  # Return the indices (1-based) of the two numbers that add up to the target.\\n            \\n            if numbers[left] + numbers[right] < target:  # If the sum is less than the target:\\n                left += 1  # Move the left pointer to the right, increasing its index.\\n            else:  # If the sum is greater than the target:\\n                right -= 1  # Move the right pointer to the left, decreasing its index.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384290,
                "title": "java-two-pointers-get-two-indexes",
                "content": "\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n                int left = 0;\\n        int right = numbers.length - 1;\\n        int tmp;\\n        while (left < right)\\n        {\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[right];\\n            while (numbers[left] < tmp) left++;\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[left];\\n            while (numbers[right] > tmp) right--;\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n                int left = 0;\\n        int right = numbers.length - 1;\\n        int tmp;\\n        while (left < right)\\n        {\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[right];\\n            while (numbers[left] < tmp) left++;\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[left];\\n            while (numbers[right] > tmp) right--;\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341849,
                "title": "easy-java-solution-two-pointer-approach",
                "content": "\\n\\n# Approach\\nTwo Pointer\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int ans[]=new int[2];\\n        int i=0;\\n        int j=numbers.length-1;\\n\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n            ans[0]=i+1;\\n            ans[1]=j+1;\\n            break;\\n            }\\n            else if(numbers[i]+numbers[j]>target)\\n            j--;\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int ans[]=new int[2];\\n        int i=0;\\n        int j=numbers.length-1;\\n\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n            ans[0]=i+1;\\n            ans[1]=j+1;\\n            break;\\n            }\\n            else if(numbers[i]+numbers[j]>target)\\n            j--;\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159765,
                "title": "java-best-solution-two-pointers-clean-code-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0;\\n        int end = numbers.length-1;\\n        int sum = 0;\\n        while(start < end){\\n            sum = numbers[start] + numbers[end];\\n            if(sum == target) return new int[] {start + 1, end + 1};\\n            if(sum < target) start++;\\n            else end--;\\n        }\\n        return new int[] {0, 0};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0;\\n        int end = numbers.length-1;\\n        int sum = 0;\\n        while(start < end){\\n            sum = numbers[start] + numbers[end];\\n            if(sum == target) return new int[] {start + 1, end + 1};\\n            if(sum < target) start++;\\n            else end--;\\n        }\\n        return new int[] {0, 0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118646,
                "title": "1ms-using-two-pointers-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo Pointers\\n1. Using two pointers to track the start and end of array\\n2. Adjust the start and end pointers accordingly by comparing their sum and the target\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n          O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int end = numbers.length-1;\\n        int start = 0;\\n        while(start != end){\\n            int sum = numbers[start] + numbers[end];\\n            if(sum < target){\\n                start++;\\n            }else if( sum > target){\\n                end--;\\n            }else{\\n                int[] ans = {start+1 , end+1};\\n                return ans;\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int end = numbers.length-1;\\n        int start = 0;\\n        while(start != end){\\n            int sum = numbers[start] + numbers[end];\\n            if(sum < target){\\n                start++;\\n            }else if( sum > target){\\n                end--;\\n            }else{\\n                int[] ans = {start+1 , end+1};\\n                return ans;\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118576,
                "title": "1ms-2-pointer-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                int[] arr = {left + 1, right + 1};\\n                return arr;\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                int[] arr = {left + 1, right + 1};\\n                return arr;\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106481,
                "title": "java-easy-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] n, int t) {\\n        int arr[]=new int[2];\\n      // if(n.length==2){\\n        //   return new int[]{1,2};\\n      // }\\n        for(int i=0;i<=n.length;++i){\\n            for(int j=i+1;j<n.length;++j){\\n                if(n[i]+n[j]==t){\\n                 //   System.out.print(n[i]+\" \"+n[j]+\" \");\\n                   arr[0]=i+1;\\n                   arr[1]=j+1;\\n                   //break;\\n                   return arr;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] n, int t) {\\n        int arr[]=new int[2];\\n      // if(n.length==2){\\n        //   return new int[]{1,2};\\n      // }\\n        for(int i=0;i<=n.length;++i){\\n            for(int j=i+1;j<n.length;++j){\\n                if(n[i]+n[j]==t){\\n                 //   System.out.print(n[i]+\" \"+n[j]+\" \");\\n                   arr[0]=i+1;\\n                   arr[1]=j+1;\\n                   //break;\\n                   return arr;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105605,
                "title": "easy-to-understand-for-beginners-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& num, int target) {\\n        int id=0;\\n        for(int i=0;i<num.size();++i){\\n            int x=num[i];\\n            id=i;\\n            int s=i+1,e=num.size()-1;\\n            int mid=s+(e-s)/2;\\n            while(s<=e){\\n                if(x+num[mid]==target)\\n                    return {id+1,mid+1};\\n                else if(x+num[mid]>target){\\n                    e=mid-1;\\n                }\\n                else\\n                    s=mid+1;\\n                mid=s+(e-s)/2;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& num, int target) {\\n        int id=0;\\n        for(int i=0;i<num.size();++i){\\n            int x=num[i];\\n            id=i;\\n            int s=i+1,e=num.size()-1;\\n            int mid=s+(e-s)/2;\\n            while(s<=e){\\n                if(x+num[mid]==target)\\n                    return {id+1,mid+1};\\n                else if(x+num[mid]>target){\\n                    e=mid-1;\\n                }\\n                else\\n                    s=mid+1;\\n                mid=s+(e-s)/2;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635156,
                "title": "python-faster-than-80-with-explanation",
                "content": "```\\n\"\"\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\"\"\"\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        d={}\\n        for i in range(len(numbers)):\\n            diff=target-numbers[i]\\n            if diff in d:\\n                return [d[diff],i+1]\\n            else:\\n                d[numbers[i]]=i+1\\n        return \\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 156 ms, faster than 80.41% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    # Memory Usage: 15 MB, less than 40.90% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    \\n# EXPLANATION:-\\n    # We will solve this using a hashmap\\n    # We will iterate through the numbers array using the range function\\n    # We will store the difference between the target and current element in diff variable\\n    # We will check if diff is in d(our hasmap), if it is, we will return its index and the index of current element +1 (because indexing starts from zero)\\n    # If it is not present, we will add the current element to the dictionary and its index as +1 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\"\"\"\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        d={}\\n        for i in range(len(numbers)):\\n            diff=target-numbers[i]\\n            if diff in d:\\n                return [d[diff],i+1]\\n            else:\\n                d[numbers[i]]=i+1\\n        return \\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 156 ms, faster than 80.41% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    # Memory Usage: 15 MB, less than 40.90% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    \\n# EXPLANATION:-\\n    # We will solve this using a hashmap\\n    # We will iterate through the numbers array using the range function\\n    # We will store the difference between the target and current element in diff variable\\n    # We will check if diff is in d(our hasmap), if it is, we will return its index and the index of current element +1 (because indexing starts from zero)\\n    # If it is not present, we will add the current element to the dictionary and its index as +1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492070,
                "title": "true-binary-search-javascript-solution-o-n-log-n",
                "content": "**Logic behind the solution**\\nWe\\'ll start solving this by using the following classic TwoSum thinking:\\n*Whenever we have a number selected, (be it array[0] or any position in the array) the number that we need to sum it with to get our target will always be equal to `target - said number`*.\\nWe don\\'t know if that number exists, but we\\'ll find it by making comparing each position in the array *(via our for loop)* with the other ones using binary search. \\n\\n**Time Complexity**\\n`O(n * log n)`\\n`Reasoning: log(n-1) + log(n-2) .... log(2)`\\n\\n\\n```\\nvar twoSum = function (numbers, target) {\\n    let end = numbers.length - 1\\n\\n    for (let i = 0; i < numbers.length; i++) \\n    {\\n        let start = i + 1\\n        while (start <= end) \\n        {\\n            let middle = Math.floor(start + (end - start) / 2)\\n            if (numbers[middle] < target - numbers[i]) \\n            {\\n                start = middle + 1\\n            }\\n            else if (numbers[middle] > target - numbers[i]) \\n            {\\n                end = middle - 1\\n            }\\n            else if (numbers[middle] + numbers[i] === target) \\n            {\\n                return [i + 1, middle + 1]\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar twoSum = function (numbers, target) {\\n    let end = numbers.length - 1\\n\\n    for (let i = 0; i < numbers.length; i++) \\n    {\\n        let start = i + 1\\n        while (start <= end) \\n        {\\n            let middle = Math.floor(start + (end - start) / 2)\\n            if (numbers[middle] < target - numbers[i]) \\n            {\\n                start = middle + 1\\n            }\\n            else if (numbers[middle] > target - numbers[i]) \\n            {\\n                end = middle - 1\\n            }\\n            else if (numbers[middle] + numbers[i] === target) \\n            {\\n                return [i + 1, middle + 1]\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447778,
                "title": "c-4-approaches-two-pointers-hash-map-binary-search-brute-force-easy",
                "content": "**Kindly Upvote if you find this useful**\\n\\nThe **4 Approaches** are:\\n1. Brute Force\\n1. Binary Search\\n1. Hash Map\\n1. Two Pointers\\n\\n1) **Brute Force**\\n**Time Complexity:** O(N^2)\\n**Space Complexity:**  O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(numbers[i] + numbers[j] == target) return {i+1,j+1};\\n            }\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\\n2) **Binary Search**\\n**Time Complexity:** O(N logN)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target-numbers[i];\\n            \\n            int l = i+1;\\n            int r = n-1;\\n            \\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                \\n                if(numbers[mid] == need) return {i+1,mid+1};\\n                \\n                if(need < numbers[mid]) r = mid-1;\\n                else l = mid+1;\\n            }\\n            \\n        }\\n        return {0,1};\\n    }\\n};\\n```\\n3) **Hash Map**\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[numbers[i]] = i;\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target - numbers[i];\\n            if(mp.find(need) != mp.end() && mp[need] != i)\\n\\t\\t\\t\\treturn {i+1,mp[need]+1};\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\\n4) **Two Pointer**\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        int l = 0;\\n        int r = n-1;\\n        \\n        while(l < r){\\n            int sum = numbers[l] + numbers[r];\\n            \\n            if(sum == target) return {l+1,r+1};\\n            \\n            if(sum < target) l++;\\n            else r--;\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\\n**Kindly Upvote if you find this useful**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(numbers[i] + numbers[j] == target) return {i+1,j+1};\\n            }\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target-numbers[i];\\n            \\n            int l = i+1;\\n            int r = n-1;\\n            \\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                \\n                if(numbers[mid] == need) return {i+1,mid+1};\\n                \\n                if(need < numbers[mid]) r = mid-1;\\n                else l = mid+1;\\n            }\\n            \\n        }\\n        return {0,1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[numbers[i]] = i;\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target - numbers[i];\\n            if(mp.find(need) != mp.end() && mp[need] != i)\\n\\t\\t\\t\\treturn {i+1,mp[need]+1};\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        int l = 0;\\n        int r = n-1;\\n        \\n        while(l < r){\\n            int sum = numbers[l] + numbers[r];\\n            \\n            if(sum == target) return {l+1,r+1};\\n            \\n            if(sum < target) l++;\\n            else r--;\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298970,
                "title": "simple-python-solutions-for-beginners",
                "content": "1.Brute force it give tle.\\n  TIme complexity: 0(n*n)\\n```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if (nums[i] + nums[j]) == target:\\n                   return[i, j]\\n```  \\n\\n2. Two pointers\\n   Time complexity: 0(n)\\nExplanation: We can make use of the fact that the numbers are sorted. Because the numbers are ascending, we can put two pointers at each end of the array. Then if the sum of the numbers the two pointers are at arent equal to the target sum, then we can move the first pointer forward by one index if the sum of the numbers is too smaller or move the last pointer backwards by one index if the sum of the numbers is too big. \\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        pointer1 = 0\\n        pointer2 = len(numbers) - 1\\n        while numbers[pointer1] + numbers[pointer2] != target:\\n              if numbers[pointer1] + numbers[pointer2] > target:\\n                 pointer2 -= 1\\n              else:\\n                 pointer1 += 1\\n        return [pointer1 + 1, pointer2 + 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if (nums[i] + nums[j]) == target:\\n                   return[i, j]\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        pointer1 = 0\\n        pointer2 = len(numbers) - 1\\n        while numbers[pointer1] + numbers[pointer2] != target:\\n              if numbers[pointer1] + numbers[pointer2] > target:\\n                 pointer2 -= 1\\n              else:\\n                 pointer1 += 1\\n        return [pointer1 + 1, pointer2 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154515,
                "title": "simple-binary-search-two-pointers-two-methods",
                "content": "Two Pointers: Time Complexity O(N)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        //Q167\\n        //We know that there is only one solution in the entire array and the array is sorted\\n        // So, we can simply check the first element and the last element for the sum\\n        //If the sum is larger than the target, we can instead check for the 2nd last element\\n        //If the sum is smaller than the target, we can instead check for the 2nd element\\n        //This will keep on iterating until we reach the target and the required ans\\n        int firstIndex = 0, lastIndex = numbers.length-1;\\n        while (firstIndex<lastIndex){\\n            int sum = numbers[firstIndex] + numbers[lastIndex];\\n            if (sum==target){\\n                //We have found the answer\\n                return new int[]{firstIndex+1 , lastIndex+1};//As the array is 1-indexed array\\n            }else if (sum>target){\\n                //Sum is greater than the target so, decrease the lastIndex to get a smaller number\\n                lastIndex--;\\n            }else{\\n                //Sum is smaller than the target so, increase the firstIndex to get a larger number\\n                firstIndex++;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```\\nBinary Search O(n*logn)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; ++i) {\\n            int low = i + 1;\\n            int high = nums.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target - nums[i]) {\\n                    return new int[]{i + 1, mid + 1};\\n                } else if (nums[mid] > target - nums[i]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        //Q167\\n        //We know that there is only one solution in the entire array and the array is sorted\\n        // So, we can simply check the first element and the last element for the sum\\n        //If the sum is larger than the target, we can instead check for the 2nd last element\\n        //If the sum is smaller than the target, we can instead check for the 2nd element\\n        //This will keep on iterating until we reach the target and the required ans\\n        int firstIndex = 0, lastIndex = numbers.length-1;\\n        while (firstIndex<lastIndex){\\n            int sum = numbers[firstIndex] + numbers[lastIndex];\\n            if (sum==target){\\n                //We have found the answer\\n                return new int[]{firstIndex+1 , lastIndex+1};//As the array is 1-indexed array\\n            }else if (sum>target){\\n                //Sum is greater than the target so, decrease the lastIndex to get a smaller number\\n                lastIndex--;\\n            }else{\\n                //Sum is smaller than the target so, increase the firstIndex to get a larger number\\n                firstIndex++;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133127,
                "title": "c-solution",
                "content": "Runtime: 169 ms, faster than 73.31% of C# online submissions for Two Sum II - Input Array Is Sorted.\\nMemory Usage: 44.5 MB, less than 94.14% of C# online submissions for Two Sum II - Input Array Is Sorted.\\n```\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int[] RetValue = default;\\n        int left = 0;\\n        int right = numbers.Length - 1;\\n\\n        while (left < right)\\n        { \\n            if (numbers[left] + numbers[right] == target) return new int[] { left+1, right+1 };\\n            if (numbers[left] + numbers[right] < target) left++;\\n            if (numbers[left] + numbers[right] > target) right--;\\n        }\\n\\n        return RetValue;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int[] RetValue = default;\\n        int left = 0;\\n        int right = numbers.Length - 1;\\n\\n        while (left < right)\\n        { \\n            if (numbers[left] + numbers[right] == target) return new int[] { left+1, right+1 };\\n            if (numbers[left] + numbers[right] < target) left++;\\n            if (numbers[left] + numbers[right] > target) right--;\\n        }\\n\\n        return RetValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2131458,
                "title": "c-2-pointers-easy-solution",
                "content": "Easy code. We take one pointer at beginning of **`numbers`** array named **`i`**, and the other pointer at the end of the array named **`j`**.\\n\\nThen we add the two, i.e., **`numbers[i] + numbers[j]`** and compare it to the **`target`** value.\\n\\nIf the addition is equal to our target value, we push both the indices, **`i`** and **`j`** to **`result`** array.\\nHowever, if **`numbers[i] + numbers[j] < target`**, we increment the beginning pointer, i.e., **`i`**.\\nFinally, if **`numbers[i] + numbers[j] > target`**, we decrement the end pointer, i.e., **`j`**.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        vector<int> result;\\n        \\n        int i = 0;\\n        int j = numbers.size() - 1;\\n        \\n        while(i < j){\\n            \\n            if(numbers[i] + numbers[j] == target){\\n                result.push_back(i + 1);\\n                result.push_back(j + 1);\\n                break;\\n            }\\n            \\n            else if(numbers[i] + numbers[j] < target)\\n                i++;\\n            \\n            else\\n                j--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        vector<int> result;\\n        \\n        int i = 0;\\n        int j = numbers.size() - 1;\\n        \\n        while(i < j){\\n            \\n            if(numbers[i] + numbers[j] == target){\\n                result.push_back(i + 1);\\n                result.push_back(j + 1);\\n                break;\\n            }\\n            \\n            else if(numbers[i] + numbers[j] < target)\\n                i++;\\n            \\n            else\\n                j--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130590,
                "title": "o-1-time-o-1-space-and-no-branching-javascript",
                "content": "A solution that runs in constant time, uses constant memory, and has no branches:\\n```\\nconst twoSum = (numbers, target) => {\\n    const indices = [0, 0, numbers.length - 1];\\n    const f = () => {\\n        const diff = numbers[indices[0]] + numbers[indices[2]] - target;\\n        const differenceSign = (diff > 0) - (diff < 0);\\n        indices[differenceSign + 1] -= differenceSign;\\n    };\\n    const g = () => f(f(f(f(f()))));\\n    const h = () => g(g(g(g(g()))));\\n    const j = () => h(h(h(h(h()))));\\n    const k = () => j(j(j(j(j()))));\\n    const l = () => k(k(k(k())));\\n    const m = () => l(l(l(l())));\\n    m(m(m()));\\n    return [indices[0] + 1, indices[2] + 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst twoSum = (numbers, target) => {\\n    const indices = [0, 0, numbers.length - 1];\\n    const f = () => {\\n        const diff = numbers[indices[0]] + numbers[indices[2]] - target;\\n        const differenceSign = (diff > 0) - (diff < 0);\\n        indices[differenceSign + 1] -= differenceSign;\\n    };\\n    const g = () => f(f(f(f(f()))));\\n    const h = () => g(g(g(g(g()))));\\n    const j = () => h(h(h(h(h()))));\\n    const k = () => j(j(j(j(j()))));\\n    const l = () => k(k(k(k())));\\n    const m = () => l(l(l(l())));\\n    m(m(m()));\\n    return [indices[0] + 1, indices[2] + 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130588,
                "title": "c-2-pointer-approach-explained-with-code",
                "content": "**2 Pointer approch explained with code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        //2 pointer approach\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        //find 2 indexes\\n        vector<int> ans;\\n        while(start < end){\\n            if(nums[start]+ nums[end] == target){   //found the numbers, store them (1- index vector)\\n                ans.push_back(start+1);\\n                ans.push_back(end+1);\\n                break;\\n            }\\n            \\n            else if(nums[start]+ nums[end] < target)    //since array is sorted, moving start pointer ahead will increase sum\\n                start++;\\n            else    //if total sum is more than target, call end pointer backward so that value obtain can be decreased\\n                end--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TC: O(N)\\nSC: O(1)**\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        //2 pointer approach\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        //find 2 indexes\\n        vector<int> ans;\\n        while(start < end){\\n            if(nums[start]+ nums[end] == target){   //found the numbers, store them (1- index vector)\\n                ans.push_back(start+1);\\n                ans.push_back(end+1);\\n                break;\\n            }\\n            \\n            else if(nums[start]+ nums[end] < target)    //since array is sorted, moving start pointer ahead will increase sum\\n                start++;\\n            else    //if total sum is more than target, call end pointer backward so that value obtain can be decreased\\n                end--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128751,
                "title": "faster-than-100-c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& a, int target) {\\n        int n = a.size();\\n        int i=0, j=n-1;\\n        while(i<j){\\n            int tm = a[i] + a[j];\\n            if(tm==target){\\n                vector<int> v = {i+1, j+1};\\n                return v;\\n            }\\n            else if(tm>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return a;\\n    }\\n\\t//* If You find helpful upvote*\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& a, int target) {\\n        int n = a.size();\\n        int i=0, j=n-1;\\n        while(i<j){\\n            int tm = a[i] + a[j];\\n            if(tm==target){\\n                vector<int> v = {i+1, j+1};\\n                return v;\\n            }\\n            else if(tm>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return a;\\n    }\\n\\t//* If You find helpful upvote*\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096815,
                "title": "java-3-approaches-binary-two-pointer-hashmap",
                "content": "**Binary Search (1ms): O(log(n))**\\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                if(nums[i] + nums[m] > target)\\n                    j = m - 1;\\n                else\\n                    j--;\\n            else\\n                if(nums[m] + nums[j] < target)\\n                    i = m + 1;\\n                else\\n                    i++;\\n        }\\n        \\n        return null;\\n    }\\n```\\n**Two-Pointer (2ms): O(n)**\\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return null;\\n    }\\n```\\n**Brute Force, HashMap (8ms): O(n)**\\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int n = target - nums[i];\\n            \\n            if(map.containsKey(n)) \\n                return new int[] {map.get(n) + 1, i + 1};\\n            \\n            map.put(nums[i], i);\\n        }\\n        \\n        return null;\\n    }\\n```\\n***Upvote ^, If you like it!***",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                if(nums[i] + nums[m] > target)\\n                    j = m - 1;\\n                else\\n                    j--;\\n            else\\n                if(nums[m] + nums[j] < target)\\n                    i = m + 1;\\n                else\\n                    i++;\\n        }\\n        \\n        return null;\\n    }\\n```\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return null;\\n    }\\n```\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int n = target - nums[i];\\n            \\n            if(map.containsKey(n)) \\n                return new int[] {map.get(n) + 1, i + 1};\\n            \\n            map.put(nums[i], i);\\n        }\\n        \\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039142,
                "title": "fastest-100-0ms-shortestcode",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int a = 0;\\n        int b = numbers.length -1;\\n        while (numbers[a] + numbers[b] != target) {\\n            if (numbers[a] + numbers[b] > target) {\\n                b--;\\n            } else {\\n                a++;\\n            }\\n        }\\n        return new int[]{a+1,b+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int a = 0;\\n        int b = numbers.length -1;\\n        while (numbers[a] + numbers[b] != target) {\\n            if (numbers[a] + numbers[b] > target) {\\n                b--;\\n            } else {\\n                a++;\\n            }\\n        }\\n        return new int[]{a+1,b+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027751,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start =0, end = numbers.length-1;\\n        \\n        while(start < end){\\n            \\n            int sum = numbers[start]+ numbers[end];\\n            \\n            if(sum == target)break;\\n            else if(sum<target) start++;\\n            else end--;\\n        }\\n        \\n        int[] res = new int[2];\\n        res[0] = start+1;\\n        res[1] = end+1;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start =0, end = numbers.length-1;\\n        \\n        while(start < end){\\n            \\n            int sum = numbers[start]+ numbers[end];\\n            \\n            if(sum == target)break;\\n            else if(sum<target) start++;\\n            else end--;\\n        }\\n        \\n        int[] res = new int[2];\\n        res[0] = start+1;\\n        res[1] = end+1;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978000,
                "title": "python-complexity-analysis-o-n",
                "content": "There are four ways to solve this problem.\\n\\n* Dictionary: O(n) time and O(n) space\\nThis does not fulfill the constant space condition\\n\\n* Brute Force: O(n^2) and O(1) space\\nQuadratic runtime\\n\\n* Binary search: O(nlogn) time and O(1) space\\nEfficient but we can do it in linear time\\n\\n* Two pointers: O(n) time and O(1) space\\nBest of both worlds\\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start = 0\\n        end = len(numbers)-1\\n        while start<end:\\n            sum = numbers[start] + numbers[end]\\n            \\n            if sum == target:\\n                return [start+1, end+1]\\n            elif sum>target:\\n                end-=1\\n            else:\\n                start+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start = 0\\n        end = len(numbers)-1\\n        while start<end:\\n            sum = numbers[start] + numbers[end]\\n            \\n            if sum == target:\\n                return [start+1, end+1]\\n            elif sum>target:\\n                end-=1\\n            else:\\n                start+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955828,
                "title": "python-5-lines-faster-than-96-127-ms",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        beg, end = 0, len(numbers) - 1\\n        while beg <= end:\\n            if numbers[beg] + numbers[end] == target: return [beg + 1, end + 1]\\n            elif numbers[beg] + numbers[end] < target: beg += 1\\n            else: end -= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        beg, end = 0, len(numbers) - 1\\n        while beg <= end:\\n            if numbers[beg] + numbers[end] == target: return [beg + 1, end + 1]\\n            elif numbers[beg] + numbers[end] < target: beg += 1\\n            else: end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882469,
                "title": "python3-solution-using-two-pointers",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824651,
                "title": "o-n-javascript-solution",
                "content": "```\\nvar twoSum = function (numbers, target) {\\n  let left = 0,\\n    right = numbers.length - 1;\\n\\n  while (left < right) {\\n    const currentSum = numbers[left] + numbers[right];\\n    if (currentSum === target) {\\n      return [left+1, right+1];\\n    }\\n    if (target < currentSum) {\\n      right--;\\n    } else if (target > currentSum) {\\n      left++;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar twoSum = function (numbers, target) {\\n  let left = 0,\\n    right = numbers.length - 1;\\n\\n  while (left < right) {\\n    const currentSum = numbers[left] + numbers[right];\\n    if (currentSum === target) {\\n      return [left+1, right+1];\\n    }\\n    if (target < currentSum) {\\n      right--;\\n    } else if (target > currentSum) {\\n      left++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752206,
                "title": "two-sum-ii-input-array-is-sorted-solution-java",
                "content": "class Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    int l = 0;\\n    int r = numbers.length - 1;\\n\\n    while (numbers[l] + numbers[r] != target)\\n      if (numbers[l] + numbers[r] < target)\\n        ++l;\\n      else\\n        --r;\\n\\n    return new int[] {l + 1, r + 1};\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    int l = 0;\\n    int r = numbers.length - 1;\\n\\n    while (numbers[l] + numbers[r] != target)\\n      if (numbers[l] + numbers[r] < target)\\n        ++l;\\n      else\\n        --r;\\n\\n    return new int[] {l + 1, r + 1}",
                "codeTag": "Java"
            },
            {
                "id": 1742099,
                "title": "two-approach-using-c",
                "content": "Approach 1: Using unordered map\\n\\tTime complexity : O(N)\\n     Space Complexity : O(N)\\n\\t \\n\\t\\tvector<int> twoSum(vector<int>& nums, int target) \\n\\t\\t{\\n\\t\\t\\tunordered_map <int,int> un_mp;\\n\\t\\t\\tvector <int> v;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint findTarget=target-nums[i];\\n\\t\\t\\t\\tif(un_mp.find(findTarget)!=un_mp.end())\\n\\t\\t\\t\\t{\\n                    v.push_back(un_mp[findTarget]+1);\\n                    v.push_back(i+1);\\n                    return v;\\n                } \\n\\t\\t\\t    else\\n                    un_mp[nums[i]]=i;\\n            \\n         }\\n         return v;\\n\\t }\\n\\n\\nApproach 2: Using Two pointer method\\nTime Complexity :O(N)\\nSpace Complexity: O(1)\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector <int> v;\\n        int left=0,right=numbers.size()-1;\\n        while(left<right)\\n        {\\n            int curr_sum=numbers[left]+numbers[right];\\n            if(curr_sum==target)\\n            {\\n                v.push_back(left+1);\\n                v.push_back(right+1);\\n                return v;\\n            }\\n            else if(curr_sum>target)\\n                right--;\\n            else\\n                left++;\\n            \\n        }\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "Approach 1: Using unordered map\\n\\tTime complexity : O(N)\\n     Space Complexity : O(N)\\n\\t \\n\\t\\tvector<int> twoSum(vector<int>& nums, int target) \\n\\t\\t{\\n\\t\\t\\tunordered_map <int,int> un_mp;\\n\\t\\t\\tvector <int> v;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint findTarget=target-nums[i];\\n\\t\\t\\t\\tif(un_mp.find(findTarget)!=un_mp.end())\\n\\t\\t\\t\\t{\\n                    v.push_back(un_mp[findTarget]+1);\\n                    v.push_back(i+1);\\n                    return v;\\n                } \\n\\t\\t\\t    else\\n                    un_mp[nums[i]]=i;\\n            \\n         }\\n         return v;\\n\\t }\\n\\n\\nApproach 2: Using Two pointer method\\nTime Complexity :O(N)\\nSpace Complexity: O(1)\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector <int> v;\\n        int left=0,right=numbers.size()-1;\\n        while(left<right)\\n        {\\n            int curr_sum=numbers[left]+numbers[right];\\n            if(curr_sum==target)\\n            {\\n                v.push_back(left+1);\\n                v.push_back(right+1);\\n                return v;\\n            }\\n            else if(curr_sum>target)\\n                right--;\\n            else\\n                left++;\\n            \\n        }\\n        return v;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566991,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568755,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565835,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566483,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1741505,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1631771,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566272,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570545,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567219,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567769,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566991,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568755,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565835,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566483,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1741505,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1631771,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566272,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570545,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567219,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567769,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570907,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1576683,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1571367,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1977405,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1858582,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1813001,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1753235,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 2034647,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 2033911,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1576117,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1575678,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1572942,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1572730,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1574587,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1568201,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1571366,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2075234,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2073738,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2057599,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2057525,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2051723,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2046490,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2044688,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2027712,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2018599,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2018517,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2015615,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2015288,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2009775,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2009257,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2006525,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 2006424,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 2004796,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1988539,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1980076,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1976989,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1975572,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1966928,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1957101,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1956571,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1936928,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1934145,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1927523,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1923485,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1922434,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1922273,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1919206,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1919163,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1918223,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1912350,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1911998,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1910259,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1902827,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1901420,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1891982,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1883481,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1858304,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1856376,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1841032,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1837256,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1812407,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1802855,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1794157,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1782091,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1776230,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1756382,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1750314,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1735835,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1733552,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1725868,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1725662,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1723181,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1721280,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1717127,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1715586,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1714642,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1714028,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1707189,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1639551,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1574331,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Permutation II",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Valid Perfect Square",
        "question_content": "<p>Given a positive integer num, return <code>true</code> <em>if</em> <code>num</code> <em>is a perfect square or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>\n\n<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 16\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We return true because 4 * 4 = 16 and 4 is an integer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 83874,
                "title": "a-square-number-is-1-3-5-7-java-code",
                "content": "   ```\\n public boolean isPerfectSquare(int num) {\\n        int i = 1;\\n        while (num > 0) {\\n            num -= i;\\n            i += 2;\\n        }\\n        return num == 0;\\n    }\\n```\\n\\nThe time complexity is **O(sqrt(n))**, a more efficient one using binary search whose time complexity is **O(log(n))**:\\n```\\npublic boolean isPerfectSquare(int num) {\\n        int low = 1, high = num;\\n        while (low <= high) {\\n            long mid = (low + high) >>> 1;\\n            if (mid * mid == num) {\\n                return true;\\n            } else if (mid * mid < num) {\\n                low = (int) mid + 1;\\n            } else {\\n                high = (int) mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```\\nOne thing to note is that we have to use **long** for mid to avoid **mid\\\\*mid** from overflow. Also, you can use **long** type for **low** and **high** to avoid type casting for mid from long to int.\\nAnd a third way is to use **Newton Method** to calculate the square root or num, refer to [Newton Method](https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division) for details. \\n```\\npublic boolean isPerfectSquare(int num) {\\n        long x = num;\\n        while (x * x > num) {\\n            x = (x + num / x) >> 1;\\n        }\\n        return x * x == num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean isPerfectSquare(int num) {\\n        int i = 1;\\n        while (num > 0) {\\n            num -= i;\\n            i += 2;\\n        }\\n        return num == 0;\\n    }\\n```\n```\\npublic boolean isPerfectSquare(int num) {\\n        int low = 1, high = num;\\n        while (low <= high) {\\n            long mid = (low + high) >>> 1;\\n            if (mid * mid == num) {\\n                return true;\\n            } else if (mid * mid < num) {\\n                low = (int) mid + 1;\\n            } else {\\n                high = (int) mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean isPerfectSquare(int num) {\\n        long x = num;\\n        while (x * x > num) {\\n            x = (x + num / x) >> 1;\\n        }\\n        return x * x == num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130010,
                "title": "python-4-methods-with-time-testing",
                "content": "1. Solving with Bitwise trick.\\n ```\\n\\t def BitwiseTrick(self, num):\\n        root = 0\\n        bit = 1 << 15\\n        \\n        while bit > 0 :\\n            root |= bit\\n            if root > num // root:    \\n                root ^= bit                \\n            bit >>= 1        \\n        return root * root == num\\n```\\n\\n2. Using Newton\\'s Method\\n```\\n    def NewtonMethod(self, num):\\n        r = num\\n        while r*r > num:\\n            r = (r + num/r) // 2\\n        return r*r == num\\n```\\n\\n3. Math Trick for Square number is 1+3+5+ ... +(2n-1)\\n```\\n    def Math(self, num):\\n        i = 1\\n        while (num>0):\\n            num -= i\\n            i += 2       \\n        return num == 0\\n```\\n\\n4. Binary Search Method\\n```\\n    def BinarySearch(self, num):\\n        left = 0\\n        right = num\\n        \\n        while left <= right:\\n            mid = left + (right-left)//2\\n            if  mid ** 2 == num:\\n                return True\\n            elif mid ** 2 > num:\\n                right = mid -1\\n            else:\\n                left = mid +1\\n        return False\\n```\\n\\n5. Linear Method (Naive) - For comparison\\n```\\n    def Linear(self, num):\\n        i = 1\\n        while i ** 2 <= num:\\n            if i ** 2 == num:\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```\\nI test these five methods with ``` for i in range(100000): function(i) ```, and get results as below.\\n\\nTime for Bitwise\\'s Method :             0.45249104499816895\\nTime for Newton\\'s Method :            0.3492701053619385\\nTime for Math\\'s Method :                2.641957998275757\\nTime for Binary Search\\'s Method :  1.5031492710113525\\nTime for Linear\\'s Method :              17.613927125930786\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\t def BitwiseTrick(self, num):\\n        root = 0\\n        bit = 1 << 15\\n        \\n        while bit > 0 :\\n            root |= bit\\n            if root > num // root:    \\n                root ^= bit                \\n            bit >>= 1        \\n        return root * root == num\\n```\n```\\n    def NewtonMethod(self, num):\\n        r = num\\n        while r*r > num:\\n            r = (r + num/r) // 2\\n        return r*r == num\\n```\n```\\n    def Math(self, num):\\n        i = 1\\n        while (num>0):\\n            num -= i\\n            i += 2       \\n        return num == 0\\n```\n```\\n    def BinarySearch(self, num):\\n        left = 0\\n        right = num\\n        \\n        while left <= right:\\n            mid = left + (right-left)//2\\n            if  mid ** 2 == num:\\n                return True\\n            elif mid ** 2 > num:\\n                right = mid -1\\n            else:\\n                left = mid +1\\n        return False\\n```\n```\\n    def Linear(self, num):\\n        i = 1\\n        while i ** 2 <= num:\\n            if i ** 2 == num:\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```\n``` for i in range(100000): function(i) ```",
                "codeTag": "Python3"
            },
            {
                "id": 622268,
                "title": "java-binary-search-3-versions-clean-concise",
                "content": "**\\u2714\\uFE0F Version 1: Binary Search - Using Long Type**\\n```java\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long left = 1, right = num;\\n        while (left <= right) {\\n            long mid = (left + right) / 2;\\n            if (mid * mid == num) return true; // check if mid is perfect square\\n            if (mid * mid < num) { // mid is small -> go right to increase mid\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1; // mid is large -> to left to decrease mid\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(logNum)`\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Version 2: Binary Search - Without Long Type**\\n```java\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int left = 1, right = num;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // to avoid overflow incase (left+right)>2147483647\\n            int res = num / mid, remain = num % mid;\\n            if (res == mid && remain == 0) return true; // check if mid * mid == num\\n            if (res > mid) { // mid is small -> go right to increase mid\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1; // mid is large -> to left to decrease mid\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(logNum)`\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Version 3: Binary Search - Search In Range [1...46340]**\\n- We can search in range `[1...sqrt(num)]` and `num <= 2^31-1`, so `sqrt(num) <= 46340`.\\n- So we can search in range `[1...46340]`.\\n```java\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int left = 1, right = 46340;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (mid * mid == num)\\n                return true;\\n            if (mid * mid < num)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(log46340)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long left = 1, right = num;\\n        while (left <= right) {\\n            long mid = (left + right) / 2;\\n            if (mid * mid == num) return true; // check if mid is perfect square\\n            if (mid * mid < num) { // mid is small -> go right to increase mid\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1; // mid is large -> to left to decrease mid\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int left = 1, right = num;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // to avoid overflow incase (left+right)>2147483647\\n            int res = num / mid, remain = num % mid;\\n            if (res == mid && remain == 0) return true; // check if mid * mid == num\\n            if (res > mid) { // mid is small -> go right to increase mid\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1; // mid is large -> to left to decrease mid\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int left = 1, right = 46340;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (mid * mid == num)\\n                return true;\\n            if (mid * mid < num)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622060,
                "title": "unique-solution-easy-to-understand-c",
                "content": "This solution makes use of the fact that all square numbers are sum of odd numbers starting from 1.\\nFor ex :\\n1 = 1\\n1+3 = 4\\n1 + 3 + 5 = 9\\n1 + 3 + 5 + 7 = 16\\n.... and so on\\nSo i keep subtracting odd numbers from the given number, starting from 1. If the number eventually reaches 0, it is a perfect square. If it reaches a negative number without reaching 0 it is not a perfect square.\\nSo the code goes like :\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num -= i;      //Subtracting odd number from num and updating num\\n            i +=2;         // Updating i to the next odd number\\n            if(!num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num -= i;      //Subtracting odd number from num and updating num\\n            i +=2;         // Updating i to the next odd number\\n            if(!num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83907,
                "title": "3-4-short-lines-integer-newton-most-languages",
                "content": "Just slightly modified my [sqrt solutions](https://leetcode.com/discuss/58631/3-4-short-lines-integer-newton-every-language). You can find some explanation there.\\n\\n(Note I renamed the parameter to x because that's the name in the sqrt problem and I like it better.)\\n\\n**Java, C++, C, C#**\\n\\n        long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return r*r == x;\\n\\n**Python**\\n\\n        r = x\\n        while r*r > x:\\n            r = (r + x/r) / 2\\n        return r*r == x\\n\\n**Ruby**\\n\\n        r  = x\\n        r = (r + x/r) / 2 while r*r > x\\n        r*r == x\\n\\n**JavaScript**\\n\\n        r = x;\\n        while (r*r > x)\\n            r = ((r + x/r) / 2) | 0;\\n        return r*r == x;",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "Just slightly modified my [sqrt solutions](https://leetcode.com/discuss/58631/3-4-short-lines-integer-newton-every-language). You can find some explanation there.\\n\\n(Note I renamed the parameter to x because that's the name in the sqrt problem and I like it better.)\\n\\n**Java, C++, C, C#**\\n\\n        long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return r*r == x;\\n\\n**Python**\\n\\n        r = x\\n        while r*r > x:\\n            r = (r + x/r) / 2\\n        return r*r == x\\n\\n**Ruby**\\n\\n        r  = x\\n        r = (r + x/r) / 2 while r*r > x\\n        r*r == x\\n\\n**JavaScript**\\n\\n        r = x;\\n        while (r*r > x)\\n            r = ((r + x/r) / 2) | 0;\\n        return r*r == x;",
                "codeTag": "Unknown"
            },
            {
                "id": 83902,
                "title": "java-three-solutions-1-3-5-sequence-binary-search-newton",
                "content": "1. a square number is 1+3+5+7+... Time Complexity O(sqrt(N)) (Credit to lizhibupt, thanks for correcting this).\\n2. binary search. Time Complexity O(logN)\\n3. Newton Method. See [this wiki page][1]. Time Complexity is close to constant, given a positive integer.\\n\\n<pre><code>\\n\\n    public boolean isPerfectSquare(int num) {\\n      if (num < 1) return false;\\n      for (int i = 1; num > 0; i += 2)\\n        num -= i;\\n      return num == 0;\\n    }\\n    \\n    public boolean isPerfectSquare(int num) {\\n      if (num < 1) return false;\\n      long left = 1, right = num;// long type to avoid 2147483647 case\\n    \\n      while (left <= right) {\\n        long mid = left + (right - left) / 2;\\n        long t = mid * mid;\\n        if (t > num) {\\n          right = mid - 1;\\n        } else if (t < num) {\\n          left = mid + 1;\\n        } else {\\n          return true;\\n        }\\n      }\\n    \\n      return false;\\n    }\\n    \\n    boolean isPerfectSquare(int num) {\\n      if (num < 1) return false;\\n      long t = num / 2;\\n      while (t * t > num) {\\n        t = (t + num / t) / 2;\\n      }\\n      return t * t == num;\\n    }\\n\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Newton%27s_method",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Tree"
                ],
                "code": "1. a square number is 1+3+5+7+... Time Complexity O(sqrt(N)) (Credit to lizhibupt, thanks for correcting this).\\n2. binary search. Time Complexity O(logN)\\n3. Newton Method. See [this wiki page][1]. Time Complexity is close to constant, given a positive integer.\\n\\n<pre><code>\\n\\n    public boolean isPerfectSquare(int num) {\\n      if (num < 1) return false;\\n      for (int i = 1; num > 0; i += 2)\\n        num -= i;\\n      return num == 0;\\n    }\\n    \\n    public boolean isPerfectSquare(int num) {\\n      if (num < 1) return false;\\n      long left = 1, right = num;// long type to avoid 2147483647 case\\n    \\n      while (left <= right) {\\n        long mid = left + (right - left) / 2;\\n        long t = mid * mid;\\n        if (t > num) {\\n          right = mid - 1;\\n        } else if (t < num) {\\n          left = mid + 1;\\n        } else {\\n          return true;\\n        }\\n      }\\n    \\n      return false;\\n    }\\n    \\n    boolean isPerfectSquare(int num) {\\n      if (num < 1) return false;\\n      long t = num / 2;\\n      while (t * t > num) {\\n        t = (t + num / t) / 2;\\n      }\\n      return t * t == num;\\n    }\\n\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Newton%27s_method",
                "codeTag": "Unknown"
            },
            {
                "id": 83889,
                "title": "java-binary-search-solution-the-obvious-one",
                "content": "    public class Solution {\\n        public boolean isPerfectSquare(int num) {\\n    \\n         if(num == 1)\\n            return true;\\n    \\n            long low = 1,\\n                high = num / 2,\\n                mid = 0;\\n    \\n            long nums = (long)num;\\n    \\n            while(low <= high)\\n            {\\n                mid = low + (high - low) / 2;\\n    \\n                if((mid * mid) == nums)\\n                    return true;\\n                else if( (mid * mid) < nums)\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n    \\n    \\n    \\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public boolean isPerfectSquare(int num) {\\n    \\n         if(num == 1)\\n            return true;\\n    \\n            long low = 1,\\n                high = num / 2,\\n                mid = 0;\\n    \\n            long nums = (long)num;\\n    \\n            while(low <= high)\\n            {\\n                mid = low + (high - low) / 2;\\n    \\n                if((mid * mid) == nums)\\n                    return true;\\n                else if( (mid * mid) < nums)\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 622288,
                "title": "super-easy-simple-9th-standard-maths-c-code-100-faster-than-other",
                "content": "AS we all know sum of consecutive odd number( starting from 1 )always led to perfect square \\nfor ex\\n1 perfect square\\n1+3 =4 perfect square\\n1+3+5=9 perfect square\\n1+3+5+7= 16 perfect square\\n\\nso i m using same idea \\nby subtracting consecutive odd numbers(starting from one)\\n\\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int a=1;\\n        while(num>0)\\n        {\\n            num=num-a;\\n            a=a+2;\\n        }\\n        return num==0;\\n        \\n    }\\n};\\n\\nplease upvote if you like the code\\nthanks for coming here\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Valid Perfect Square.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Valid Perfect Square.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int a=1;\\n        while(num>0)\\n        {\\n            num=num-a;\\n            a=a+2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 978914,
                "title": "easy-c-short-solution",
                "content": "1=1\\n1+3=4\\n1+3+5=9\\n1+3+5+7=16\\nand so on ..............\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int a=1;\\n        \\n        while(num>0){\\n            num-=a;\\n            a+=2;\\n        }\\n        return(num==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int a=1;\\n        \\n        while(num>0){\\n            num-=a;\\n            a+=2;\\n        }\\n        return(num==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83872,
                "title": "o-1-time-c-solution-inspired-by-q-rsqrt",
                "content": "    class Solution {\\n    public:\\n        bool isPerfectSquare(int num) {\\n            if (num < 0) return false;\\n            int root = floorSqrt(num);\\n            return root * root == num;\\n        }\\n    \\n        int32_t floorSqrt(int32_t x) {\\n            double y=x; int64_t i=0x5fe6eb50c7b537a9;\\n            y = *(double*)&(i = i-(*(int64_t*)&y)/2);\\n            y = y * (3 - x * y * y) * 0.5;\\n            y = y * (3 - x * y * y) * 0.5;\\n            i = x * y + 1; return i - (i * i > x);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPerfectSquare(int num) {\\n            if (num < 0) return false;\\n            int root = floorSqrt(num);\\n            return root * root == num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 83964,
                "title": "python-solution",
                "content": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            if num<0:\\n                return False\\n            x,i=0,1\\n            while x<num:\\n                x+=i\\n                i+=2\\n            return x==num",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            if num<0:\\n                return False\\n            x,i=0,1\\n            while x<num:\\n                x+=i\\n                i+=2\\n            return x==num",
                "codeTag": "Java"
            },
            {
                "id": 622536,
                "title": "python-o-1-time-and-space-newton-s-method",
                "content": "[Newton\\'s Method](https://en.wikipedia.org/wiki/Newton%27s_method#Square_root_of_a_number), also known as the [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method), can be used to quickly approximate the square root (it converges quadratically, so the number of correct digits doubles each iteration).\\n\\n![image](https://assets.leetcode.com/users/blsckscreen/image_1589029343.png)\\n\\nAfter getting a good approximation, we can round our approximation to the nearest integer and check whether that squares to give our original number.\\n\\nSince it converges so quickly, we can be safe to run 20 iterations to pass all test cases.\\n\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        x = 1 ## Start at 1\\n        \\n        ## Apply Newton\\'s Method for 20 iterations:\\n        for _ in range(20):\\n            x = 0.5 * (x + (num / x))\\n        \\n        ## Check if the result squares to give num\\n        if pow(round(x), 2) == num:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        x = 1 ## Start at 1\\n        \\n        ## Apply Newton\\'s Method for 20 iterations:\\n        for _ in range(20):\\n            x = 0.5 * (x + (num / x))\\n        \\n        ## Check if the result squares to give num\\n        if pow(round(x), 2) == num:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83949,
                "title": "java-binary-search-o-lgn-solution-without-using-long-type-to-avoid-overflow",
                "content": "```\\npublic boolean isPerfectSquare(int num){\\n        \\n        if(num <= 0) return false;\\n        \\n        int left = 1, right = num;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            // use \"/\" to avoid overflow\\n            if(mid > num / mid){\\n                right = mid - 1;\\n            }else if(mid < num / mid){\\n                left = mid + 1;\\n            }else{\\n                return num % mid == 0;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPerfectSquare(int num){\\n        \\n        if(num <= 0) return false;\\n        \\n        int left = 1, right = num;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            // use \"/\" to avoid overflow\\n            if(mid > num / mid){\\n                right = mid - 1;\\n            }else if(mid < num / mid){\\n                left = mid + 1;\\n            }else{\\n                return num % mid == 0;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259084,
                "title": "simple-and-easy-to-understand-with-o-logn-complexity-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int start = 1, end = num;\\n        while(start<=end){\\n            long long int mid = start + (end-start)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }\\n            else if(mid * mid < num){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1; \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nDo upvote!",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int start = 1, end = num;\\n        while(start<=end){\\n            long long int mid = start + (end-start)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }\\n            else if(mid * mid < num){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1; \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83888,
                "title": "o-logn-bisection-method",
                "content": "    bool isPerfectSquare(int num) {\\n        long long l = 0, r = num;\\n        while (l <= r) {\\n            long long mid = (l + r) >> 1;\\n            long long sqmid = mid * mid;\\n            if (sqmid > num) r = mid - 1;\\n            else if (sqmid < num) l = mid + 1;\\n            else return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool isPerfectSquare(int num) {\\n        long long l = 0, r = num;\\n        while (l <= r) {\\n            long long mid = (l + r) >> 1;\\n            long long sqmid = mid * mid;\\n            if (sqmid > num) r = mid - 1;\\n            else if (sqmid < num) l = mid + 1;\\n            else return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 672600,
                "title": "java-simple-mathematical-explained",
                "content": "Every perfect square is the sum of first i odd numbers. So subtract odd numbers starting from 1 until the number becomes less than 1.\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i = 1;\\n        while(num > 0){\\n            num -= i;\\n            i += 2;\\n        }\\n        return num == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i = 1;\\n        while(num > 0){\\n            num -= i;\\n            i += 2;\\n        }\\n        return num == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423149,
                "title": "java-maths-solution",
                "content": "This is a math problem\\uFF1A\\n1 = 1\\n4 = 1 + 3\\n9 = 1 + 3 + 5\\n16 = 1 + 3 + 5 + 7\\n25 = 1 + 3 + 5 + 7 + 9\\n36 = 1 + 3 + 5 + 7 + 9 + 11\\n....\\nso 1+3+...+(2n-1) = (2n-1 + 1)n/2 = nn\\n\\n**NOW THE CODE :**\\n\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n      int i = 1;\\n      while(num > 0) {\\n        num -= i;\\n        i += 2;      // The  1 + 3 + 5 + 7 + 9 +......pattern.\\n      }\\n      return num == 0;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n      int i = 1;\\n      while(num > 0) {\\n        num -= i;\\n        i += 2;      // The  1 + 3 + 5 + 7 + 9 +......pattern.\\n      }\\n      return num == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209660,
                "title": "using-binary-search-to-check-for-perfect-squares",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo check whether a number is a perfect square, we need to find the square root of the number. One way to do this is to use binary search. We can start by setting the left boundary to 1 and the right boundary to num. Then, we can repeatedly compute the middle point between the left and right boundaries and check whether its square is equal to num. If the middle point squared is greater than num, we can update the right boundary to be the middle point minus 1. Otherwise, we can update the left boundary to be the middle point plus 1. We repeat this process until we find the square root of num or we exhaust all possible values of the left and right boundaries.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$, where $$ n$$ is the value of the input integer num. This is because we are using binary search to find the square root of num, and binary search has a time complexity of $$O(log n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, since we are not using any extra data structures.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        left, right = 1, num\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if mid * mid == num:\\n                return True\\n            elif mid * mid < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        left, right = 1, num\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if mid * mid == num:\\n                return True\\n            elif mid * mid < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888073,
                "title": "one-line-solution-with-js",
                "content": "```\\nvar isPerfectSquare = function(num) {\\n    return num ** 0.5 == parseInt(num ** 0.5)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPerfectSquare = function(num) {\\n    return num ** 0.5 == parseInt(num ** 0.5)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2225109,
                "title": "faang-optimised-code-o-1-easy-beginner-friendly-soln",
                "content": "### **Kindly Upvote if u understood the soln. It Really helps !\\uD83D\\uDE4F**\\n\\n## **Method-1**\\n```\\nclass Solution {                                //  O(log(n)) // Most Optimal\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int low = 1, high = num; \\n        while(low <= high){\\n            long long int mid = low + (high - low) / 2;\\n            if(mid * mid == num)\\n                return 1;\\n            else if(mid * mid < num)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n## **Method-2**\\n```\\npublic boolean isPerfectSquare(int num) {      // O(sqrt(n))\\n     int i = 1;\\n     while (num > 0) {\\n         num -= i;\\n         i += 2;\\n     }\\n     return num == 0;\\n }\\n```\\n## **Method-3 by @Jared Mond(kbkcjo)**\\n[https://leetcode.com/problems/valid-perfect-square/discuss/83872/O(1)-time-c%2B%2B-solution-inspired-by-Q_rsqrt](http://)\\n ```\\nclass Solution {                                  // O(1)\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num < 0) return false;\\n        int root = floorSqrt(num);\\n        return root * root == num;\\n    }\\n\\n \\n  int32_t floorSqrt(int32_t x) {\\n        double y=x; int64_t i=0x5fe6eb50c7b537a9;\\n        y = *(double*)&(i = i-(*(int64_t*)&y)/2);\\n        y = y * (3 - x * y * y) * 0.5;\\n        y = y * (3 - x * y * y) * 0.5;\\n        i = x * y + 1; return i - (i * i > x);\\n    }\\n};\\n\\n```\\n### **Kindly Upvote if u understood the soln. It Really helps !\\uD83D\\uDE4F**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {                                //  O(log(n)) // Most Optimal\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int low = 1, high = num; \\n        while(low <= high){\\n            long long int mid = low + (high - low) / 2;\\n            if(mid * mid == num)\\n                return 1;\\n            else if(mid * mid < num)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\npublic boolean isPerfectSquare(int num) {      // O(sqrt(n))\\n     int i = 1;\\n     while (num > 0) {\\n         num -= i;\\n         i += 2;\\n     }\\n     return num == 0;\\n }\\n```\n```\\nclass Solution {                                  // O(1)\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num < 0) return false;\\n        int root = floorSqrt(num);\\n        return root * root == num;\\n    }\\n\\n \\n  int32_t floorSqrt(int32_t x) {\\n        double y=x; int64_t i=0x5fe6eb50c7b537a9;\\n        y = *(double*)&(i = i-(*(int64_t*)&y)/2);\\n        y = y * (3 - x * y * y) * 0.5;\\n        y = y * (3 - x * y * y) * 0.5;\\n        i = x * y + 1; return i - (i * i > x);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333620,
                "title": "java-detailed-explaination-with-full-trace-for-both-perfect-and-non-perfect-square-beats-100",
                "content": "# Intuition\\nNotice this pattern : 1,3,5,7,9,11,13,15,17 => series of odd numbers is only goin to give you a square in every operation , for example :\\n\\n1+3 = 4\\n4+5 = 9\\n9+7 = 16\\n16+9 = 25\\n25+11 = 36\\n36+13 = 49\\n49+15 = 64\\n64+17 = 81\\n\\nSo, when we keep subtracting our number with the series of odd numbers then one situation will occur either our number gets reduced to negative number or it gets reduced to 0 and if our number get reduced to 0 then 100% our number is a Perfect square otherwise it is not .\\n\\nLet\\'s take one example :\\nnum = 16  , i=1  // num-=i => 16-1 = 15 , i+=2 , i=1+2=3, i=3\\nnum = 15  , i=3\\nnum = 12  , i=5\\nnum = 7   , i=7\\nnum = 0\\nHence 16 is a perfect square !!\\n\\nLet\\'s take another example which is not a perfect square :\\nnum = 14 , i=1\\nnum = 13 , i=3\\nnum = 10 , i=5\\nnum = 5  , i=7\\nnum = -2\\nHence our number gets reduced to a negative number so 14 is not a perfect square and actually 14 is not a perfect square !!\\n\\n# Approach\\nBasic Maths , you should know that the series of odd numbers gives you a square on every operation !!\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1) constant space !!\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num-=i;\\n            i+=2;\\n        }\\n        return num==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num-=i;\\n            i+=2;\\n        }\\n        return num==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063963,
                "title": "100-python-one-liner-upvote-please",
                "content": "100% python3 one-liner\\nruntime: 11 ms \\nmemory: 10.3 MB \\nCan use binary search for optimal speed as well.\\nUPVOTE PLEASE\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return int(num**0.5) == num**0.5\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return int(num**0.5) == num**0.5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276788,
                "title": "beats-100-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int start = 1;\\n        int end = num;\\n        while(start <= end){\\n            long mid = (end-start)/2+start;\\n            if(mid*mid == num){\\n                return true;\\n            }\\n            else if(mid*mid < num){\\n                start = (int)(mid+1);\\n            }\\n            else {\\n                end = (int)(mid-1);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nPlease upvote if find useful\\n\\n<p align =\"center\">\\n<img src =\"https://assets.leetcode.com/users/images/d4b72d10-6e72-452b-92f1-43205a5af564_1675351797.5099416.jpeg\" alt =\"\">\\n</p>",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int start = 1;\\n        int end = num;\\n        while(start <= end){\\n            long mid = (end-start)/2+start;\\n            if(mid*mid == num){\\n                return true;\\n            }\\n            else if(mid*mid < num){\\n                start = (int)(mid+1);\\n            }\\n            else {\\n                end = (int)(mid-1);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672535,
                "title": "3-methods-o-sqrtn-o-logn-o-1-fastest-solution-using-newton-method",
                "content": "# O(sqrtN)\\nSince every square number is summation of this series : 1 + 3 + 5 + 7+ ...\\n1\\n1 + 3 = 4\\n1 + 3 + 5 = 9\\n```\\n    bool isPerfectSquare(int num) {\\n        for(int i = 1; num > 0; i += 2)\\n            num -= i;\\n        return num == 0;\\n    }\\n```\\n\\n# O(logN)\\nUsing binary search algo.\\n```\\n    bool isPerfectSquare(int num) {\\n        int l = 1, h = num / 2, mid, sq;\\n        while(l < h) {\\n            mid = l + (h - l) / 2;\\n            sq = mid * mid;\\n            if(sq == num) return true;\\n            else if(sq > num) h = mid-1;\\n            else l = mid + 1;\\n        }        \\n        return l*l == num;        \\n    }\\n```\\n\\n# O(1)\\nUsing Newton-Raphson method :  Xn+1 = 1/2 [ Xn + a / Xn ]\\n\\n```\\n\\tbool isPerfectSquare(int num) {\\n        long temp = num;\\n        while(temp * temp > num)\\n            temp = (temp + num/temp) / 2;\\n        return temp * temp == num;\\n    }\\n```\\n\\n[https://www.youtube.com/watch?v=FpOEx6zFf1o](http://)\\n",
                "solutionTags": [],
                "code": "```\\n    bool isPerfectSquare(int num) {\\n        for(int i = 1; num > 0; i += 2)\\n            num -= i;\\n        return num == 0;\\n    }\\n```\n```\\n    bool isPerfectSquare(int num) {\\n        int l = 1, h = num / 2, mid, sq;\\n        while(l < h) {\\n            mid = l + (h - l) / 2;\\n            sq = mid * mid;\\n            if(sq == num) return true;\\n            else if(sq > num) h = mid-1;\\n            else l = mid + 1;\\n        }        \\n        return l*l == num;        \\n    }\\n```\n```\\n\\tbool isPerfectSquare(int num) {\\n        long temp = num;\\n        while(temp * temp > num)\\n            temp = (temp + num/temp) / 2;\\n        return temp * temp == num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2655418,
                "title": "100-faster-binary-search-technique",
                "content": "![image](https://assets.leetcode.com/users/images/273ece32-d74e-416f-949b-bed942df83e9_1664771297.027013.png)\\n![image](https://assets.leetcode.com/users/images/c73615a0-a6fa-4a3f-8e20-56fafd7fa692_1664771332.9087012.gif)\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num == 1) return true;\\n        int i = 1,j = num/2;\\n        while(i<=j){\\n            long int mid = i + (j-i)/2;\\n            if((long long)mid*mid == num) return true;\\n            if((long long)mid*mid > num) j = mid-1;\\n            else i = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num == 1) return true;\\n        int i = 1,j = num/2;\\n        while(i<=j){\\n            long int mid = i + (j-i)/2;\\n            if((long long)mid*mid == num) return true;\\n            if((long long)mid*mid > num) j = mid-1;\\n            else i = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622214,
                "title": "two-solutions-binary-search-taylor-series",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {boolean}\\n */\\n// Taylor series\\n var isPerfectSquare = function(num) {\\n     //taylor series\\n     // 1+3+5+7 = 16 .. \\n     let i = 1;\\n     while(num > 0){\\n         num -= i;\\n         i += 2\\n     }\\n     return num === 0\\n};\\n\\n// Binary search\\nvar isPerfectSquare = function(num) {\\n    if(num < 1){\\n        return false\\n    }\\n    if(num === 1){\\n        return true\\n    }\\n    let left = 1;\\n    let right = num;\\n    while(left <= right){\\n        let mid = Math.floor((left+right)/2);\\n        if(mid*mid === num){\\n            return true;\\n        }else if(mid*mid > num){\\n            right = mid - 1;\\n        }else if(mid*mid < num){\\n            left = mid+1\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {boolean}\\n */\\n// Taylor series\\n var isPerfectSquare = function(num) {\\n     //taylor series\\n     // 1+3+5+7 = 16 .. \\n     let i = 1;\\n     while(num > 0){\\n         num -= i;\\n         i += 2\\n     }\\n     return num === 0\\n};\\n\\n// Binary search\\nvar isPerfectSquare = function(num) {\\n    if(num < 1){\\n        return false\\n    }\\n    if(num === 1){\\n        return true\\n    }\\n    let left = 1;\\n    let right = num;\\n    while(left <= right){\\n        let mid = Math.floor((left+right)/2);\\n        if(mid*mid === num){\\n            return true;\\n        }else if(mid*mid > num){\\n            right = mid - 1;\\n        }else if(mid*mid < num){\\n            left = mid+1\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83965,
                "title": "python-binary-search",
                "content": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            left = 0; right = num\\n            while left <= right:\\n                mid = (left+right)/2\\n                if mid**2 == num:\\n                    return True\\n                elif mid**2 > num:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n            return False",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            left = 0; right = num\\n            while left <= right:\\n                mid = (left+right)/2\\n                if mid**2 == num:\\n                    return True\\n                elif mid**2 > num:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 83900,
                "title": "python-solution-using-newton-s-method",
                "content": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            if num < 0: return False\\n            if num <= 1: return True\\n            n = num/2  # start guessing using n = num/2\\n            while n*n!= num:\\n                inc = (num-n*n)/(2*n)\\n                n += inc\\n                if -1 <= inc <= 1: break\\n            if n*n < num: n+=1\\n            if n*n > num: n-=1\\n            return n*n == num\\n\\nf(x) = x^2   (find x that f(x) = num)\\n\\nf'(x) = 2*x\\n\\nstart process with x = n (any positive number)\\n\\nif f(x) != num, update x = x + (num - f(x))/f'(x) = x + (num - n^2)/(2n)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            if num < 0: return False\\n            if num <= 1: return True\\n            n = num/2  # start guessing using n = num/2\\n            while n*n!= num:\\n                inc = (num-n*n)/(2*n)\\n                n += inc\\n                if -1 <= inc <= 1: break\\n            if n*n < num: n+=1\\n            if n*n > num: n-=1\\n            return n*n == num\\n\\nf(x) = x^2   (find x that f(x) = num)\\n\\nf'(x) = 2*x\\n\\nstart process with x = n (any positive number)\\n\\nif f(x) != num, update x = x + (num - f(x))/f'(x) = x + (num - n^2)/(2n)",
                "codeTag": "Java"
            },
            {
                "id": 3494008,
                "title": "java-easy-solution-only-using-binary-search-beats",
                "content": "\\n# Approach\\n mid*mid == num   (don\\'t use this condition)\\n       ....... \\u2B07\\uFE0F.......\\nmid = num/mid \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int low = 1;\\n        int heigh = num;\\n        if(num==1) return true;\\n       \\n        while(low<=heigh)\\n        {\\n            int mid = low + (heigh-low)/2;\\n            double val = (num*1.0)/(mid*(1.0));\\n            if(mid == val) return true;\\n            else if(mid<val) low = mid + 1;\\n            else heigh = mid-1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\n\\n![Screenshot from 2023-05-11 10-55-52.png](https://assets.leetcode.com/users/images/76e5088a-9fc6-49f1-8134-8fd47e08ca48_1683857601.0326917.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int low = 1;\\n        int heigh = num;\\n        if(num==1) return true;\\n       \\n        while(low<=heigh)\\n        {\\n            int mid = low + (heigh-low)/2;\\n            double val = (num*1.0)/(mid*(1.0));\\n            if(mid == val) return true;\\n            else if(mid<val) low = mid + 1;\\n            else heigh = mid-1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405812,
                "title": "easy-c-solution-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply checking with each integer if num is its square or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRun a loop from 1 to sqrt(num) and check if this integer\\'s square is equal to num or not\\n\\n# Complexity\\n- Time complexity:O(sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        for(long i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        for(long i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021710,
                "title": "java-binary-search",
                "content": "# Intuition\\nMy first thought was to refer problem number 69.Sqrt(x) as the logic applied in that problem helps with developing initial thought process. Next, as soon as I saw a sorted array I tried applying **Binary Search**.\\n\\n# Approach\\n1. Declare *start* and *end* pointers.\\n2. Find out the mid point.\\n3. We will have three cases:\\nCase 1: The mid value is the square root, in which case we return true.\\nCase 2: The square of  mid value exceeds *num*, in which case we bring our *end* pointer to the value just smaller than mid.\\nCase 3: The square of  mid value is lesser than *num*, in which case we bring our *start* pointer to the value just larger than mid.\\n4. If all cases fail we return false as there is no square root for the given number (*num*).\\n**Note:** I have declared start, end & mid as long to deal with the time limit error which you will encounter in test case 10. \\n# Complexity\\n- Time complexity:\\nO(logn)\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long start = 1;\\n        long end = num;\\n        while(start <= end){\\n            long mid = (start + end)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }\\n            else if(mid * mid > num){\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long start = 1;\\n        long end = num;\\n        while(start <= end){\\n            long mid = (start + end)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }\\n            else if(mid * mid > num){\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911440,
                "title": "easy-c-solution-100-fast-0-ms-runtime",
                "content": "* Basic Idea is to use Binary search\\n* `lo` value will be 1 and `hi` value will be `num / 2`, as no number will have square greater than half of itself, except for `1`  which is handled separately\\n* code is as : \\n\\n```\\nbool isPerfectSquare(int num) {\\n        if (num == 1) return true;\\n        long long lo = 1;\\n        long long hi = num / 2;\\n        \\n        while(lo <= hi) {\\n            long long mid = (lo + hi) / 2;\\n            long long sq = mid * mid;\\n            \\n            if (sq == num) return true;\\n            else if (sq < num) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nbool isPerfectSquare(int num) {\\n        if (num == 1) return true;\\n        long long lo = 1;\\n        long long hi = num / 2;\\n        \\n        while(lo <= hi) {\\n            long long mid = (lo + hi) / 2;\\n            long long sq = mid * mid;\\n            \\n            if (sq == num) return true;\\n            else if (sq < num) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975689,
                "title": "java-math-and-floor-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double sqrt = Math.sqrt(num);\\n        return ((sqrt - Math.floor(sqrt)) == 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double sqrt = Math.sqrt(num);\\n        return ((sqrt - Math.floor(sqrt)) == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622500,
                "title": "runtime-0-ms-memory-20-mb-c-code",
                "content": "**Logic:** We are basically starting a loop from 1 and checking if square of every element is equal to num. A naive solution will be to iterate **linearly from 1 to num**, causing runtime error. A better way to improve runtime is to **minimise the number of times** we are checking whether an element is square root or not. Since i*i=num, we can reaarange the equation as i=num/i. This reduces the number of operations by num/i.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        //base cases\\n        if(!num)\\n            return false;\\n        \\n        if(num==1)\\n            return true;\\n        \\n        //main code\\n        for(int i=1;i<=num/i;i++)\\n        {\\n            if(i*i==num)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        //base cases\\n        if(!num)\\n            return false;\\n        \\n        if(num==1)\\n            return true;\\n        \\n        //main code\\n        for(int i=1;i<=num/i;i++)\\n        {\\n            if(i*i==num)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83957,
                "title": "with-a-little-help-from-my-friends",
                "content": "My friends being the Ruby and Python libraries. Use binary search to find the smallest non-negative integer whose square is at least num. Then test whether its square **is** num.\\n\\n```\\ndef is_perfect_square(num)\\n  (0..num).bsearch { |x| x*x >=num } ** 2 == num\\nend\\n```\\n\\n    def isPerfectSquare(self, num):\\n        class C: __getitem__ = lambda _, x: x*x >= num\\n        return bisect.bisect(C(), False, 0, num) ** 2 == num",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "```\\ndef is_perfect_square(num)\\n  (0..num).bsearch { |x| x*x >=num } ** 2 == num\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3752757,
                "title": "simple-java-logic-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n//Keep iterating loop check perfectsquare and limit in the condition\\n        while(i*i!=num && i*i<num && i<num){\\n            i++;\\n        }\\n        return i*i==num;\\n    }\\n}\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/59395bc6-9862-41ae-bbfa-a1ca5da2e8a4_1689236882.0711348.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n//Keep iterating loop check perfectsquare and limit in the condition\\n        while(i*i!=num && i*i<num && i<num){\\n            i++;\\n        }\\n        return i*i==num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315548,
                "title": "python-simple-python-solution-using-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\n# Apporach 1 Using Binary Search : -\\n# Runtime: 36 ms, faster than 82.70% of Python3 online submissions for Valid Perfect Square.\\n# Memory Usage: 13.9 MB, less than 9.79% of Python3 online submissions for Valid Perfect Square.\\n\\n\\tclass Solution:\\n\\t\\tdef isPerfectSquare(self, num: int) -> bool:\\n\\n\\t\\t\\tlow  = 1\\n\\t\\t\\thigh = num\\n\\n\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\tmid = ( low + high ) //2\\n\\n\\t\\t\\t\\tif mid * mid == num:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\telif mid * mid < num:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telif mid * mid > num:\\n\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\treturn False\\n\\n# Approach 2 Using Math Concept : -\\n  # Runtime: 39 ms, faster than 74.43% of Python3 online submissions for Valid Perfect Square.\\n# Memory Usage: 13.9 MB, less than 9.79% of Python3 online submissions for Valid Perfect Square.\\n\\n\\tclass Solution:\\n\\t\\tdef isPerfectSquare(self, num: int) -> bool:\\n\\n\\t\\t\\tif int(num**0.5)*int(num**0.5)==num:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\t\\n\\n# Thank you \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\n# Apporach 1 Using Binary Search : -\\n# Runtime: 36 ms, faster than 82.70% of Python3 online submissions for Valid Perfect Square.\\n# Memory Usage: 13.9 MB, less than 9.79% of Python3 online submissions for Valid Perfect Square.\\n\\n\\tclass Solution:\\n\\t\\tdef isPerfectSquare(self, num: int) -> bool:\\n\\n\\t\\t\\tlow  = 1\\n\\t\\t\\thigh = num\\n\\n\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\tmid = ( low + high ) //2\\n\\n\\t\\t\\t\\tif mid * mid == num:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\telif mid * mid < num:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telif mid * mid > num:\\n\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\treturn False\\n\\n# Approach 2 Using Math Concept : -\\n  # Runtime: 39 ms, faster than 74.43% of Python3 online submissions for Valid Perfect Square.\\n# Memory Usage: 13.9 MB, less than 9.79% of Python3 online submissions for Valid Perfect Square.\\n\\n\\tclass Solution:\\n\\t\\tdef isPerfectSquare(self, num: int) -> bool:\\n\\n\\t\\t\\tif int(num**0.5)*int(num**0.5)==num:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\t\\n\\n# Thank you \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 83873,
                "title": "javascript-solution-without-math-function",
                "content": "```\\nvar isPerfectSquare = function(num) {\\n    var sum = 0;\\n    for(let i = 1; i <= num; i += 2){\\n        sum += i;\\n        if(sum === num){\\n            return true;\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [],
                "code": "```\\nvar isPerfectSquare = function(num) {\\n    var sum = 0;\\n    for(let i = 1; i <= num; i += 2){\\n        sum += i;\\n        if(sum === num){\\n            return true;\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 83901,
                "title": "o-1-java-solution",
                "content": "\\n    \\n    /*\\n        use solution from 069 - Sqrt(x), compare res * res == num\\n        time: O(16) = O(1), space: O(1)\\n    */\\n    public boolean solution(int num) {\\n        int root = 0, bit = 1 << 15;\\n        while (bit > 0) {\\n            root |= bit;\\n            if (root > num / root) {    // if root * root > num\\n                root ^= bit;    // set the bit back to 0\\n            }\\n            bit >>= 1;\\n        }\\n        return root * root == num;\\n    }",
                "solutionTags": [],
                "code": "\\n    \\n    /*\\n        use solution from 069 - Sqrt(x), compare res * res == num\\n        time: O(16) = O(1), space: O(1)\\n    */\\n    public boolean solution(int num) {\\n        int root = 0, bit = 1 << 15;\\n        while (bit > 0) {\\n            root |= bit;\\n            if (root > num / root) {    // if root * root > num\\n                root ^= bit;    // set the bit back to 0\\n            }\\n            bit >>= 1;\\n        }\\n        return root * root == num;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3954772,
                "title": "easy-java-solution-beat-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n         if(num == 1){\\n            return true;\\n        }\\n        int start = 1;\\n        int end = num;\\n       \\n        while(start<=end){\\n            long   mid = start + (end-start)/2;\\n            if(mid*mid==num){\\n                return true;\\n            }\\n            else if(mid<num/mid ){\\n                start  = (int)mid+1;\\n            }\\n            else{\\n                end = (int)mid-1;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n         if(num == 1){\\n            return true;\\n        }\\n        int start = 1;\\n        int end = num;\\n       \\n        while(start<=end){\\n            long   mid = start + (end-start)/2;\\n            if(mid*mid==num){\\n                return true;\\n            }\\n            else if(mid<num/mid ){\\n                start  = (int)mid+1;\\n            }\\n            else{\\n                end = (int)mid-1;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666779,
                "title": "beginner-friendly-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsearch through all the numbers between 1 and n-1 in binary search . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare two variables with 1 and n-1 do binary search for a number*number == num\\n\\n# Complexity\\n- Time complexity:O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num == 1) return true; \\n        int start = 1, end = num-1; \\n        while(start<=end){\\n            int mid = (start+end)/2;\\n             \\n            if(1ll * mid * mid == num) return true; \\n            else if(1ll *mid*mid > num) end = mid-1; \\n            else start = mid+1;\\n        }\\n\\n        return false; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num == 1) return true; \\n        int start = 1, end = num-1; \\n        while(start<=end){\\n            int mid = (start+end)/2;\\n             \\n            if(1ll * mid * mid == num) return true; \\n            else if(1ll *mid*mid > num) end = mid-1; \\n            else start = mid+1;\\n        }\\n\\n        return false; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214321,
                "title": "runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int minNum = 0;\\n        int maxNum = 46341;\\n\\n        if(num == 1) return true;\\n        \\n        while(minNum < maxNum){\\n            if(Math.pow(minNum,2) == num){\\n                System.out.println(minNum);\\n                return true;\\n            }\\n            \\n            minNum++;\\n            if(minNum > num / 2){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int minNum = 0;\\n        int maxNum = 46341;\\n\\n        if(num == 1) return true;\\n        \\n        while(minNum < maxNum){\\n            if(Math.pow(minNum,2) == num){\\n                System.out.println(minNum);\\n                return true;\\n            }\\n            \\n            minNum++;\\n            if(minNum > num / 2){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172531,
                "title": "python3-extension-of-binary-search",
                "content": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        left,right = 1,num\\n        while left<=right:\\n            middle = (left+right)//2\\n            if middle**2==num:\\n                return True\\n            if middle**2>num:\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        left,right = 1,num\\n        while left<=right:\\n            middle = (left+right)//2\\n            if middle**2==num:\\n                return True\\n            if middle**2>num:\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964251,
                "title": "100-faster-than-c-code-in-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int left = 1;\\n        int right = num;\\n        while(left <= right){\\n            int mid = left+(right-left)/2;\\n            if(mid == (num/mid) and (num%mid) == 0)return true;\\n            else if(mid < num/mid)left = mid+1;\\n            else right = mid-1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int left = 1;\\n        int right = num;\\n        while(left <= right){\\n            int mid = left+(right-left)/2;\\n            if(mid == (num/mid) and (num%mid) == 0)return true;\\n            else if(mid < num/mid)left = mid+1;\\n            else right = mid-1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521299,
                "title": "easy-java-not-binary-search",
                "content": "Any number which ends with either 2, 3, 7, 8 will not be a perfect square.\\n\\nAfter elimination of some cases simply run the loop untill the point where you either\\nfind a perfect square or a number greater than the current number.\\n\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i;\\n        int rem = num%10;\\n        if(rem == 2 || rem == 3 || rem == 7 || rem == 8)\\n            return false;\\n        \\n        \\n        for(i=1; i*i<num; i++){}\\n            \\n            return (i*i == num);\\n    }\\n}\\n```\\n\\nPlease do upvote if you feel the solution was something new!!\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i;\\n        int rem = num%10;\\n        if(rem == 2 || rem == 3 || rem == 7 || rem == 8)\\n            return false;\\n        \\n        \\n        for(i=1; i*i<num; i++){}\\n            \\n            return (i*i == num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409777,
                "title": "easy-to-understand-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) \\n    {\\n        if(num==1)\\n            return true;\\n        for(int i=1;i<=num/2;i++)\\n            if(num/i==i && num%i==0)\\n                return true;\\n            else if(num/i<i)\\n                return false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) \\n    {\\n        if(num==1)\\n            return true;\\n        for(int i=1;i<=num/2;i++)\\n            if(num/i==i && num%i==0)\\n                return true;\\n            else if(num/i<i)\\n                return false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312388,
                "title": "c-easy-simple-explanation-added-solution",
                "content": "**Main Concept :**\\n**sum of first n odd number = n^2**\\n**1 + 3 + 5 + 7 + ... + (2*n -1) = n^2**\\n\\n**Explanation**\\nThis solution makes use of the fact that all square numbers are sum of odd numbers starting from 1.\\nFor example :\\n1 = 1\\n1+3 = 4\\n1 + 3 + 5 = 9\\n1 + 3 + 5 + 7 = 16\\n\\nSo we keep subtracting odd numbers from the given number, starting from 1. If the number eventually reaches 0, it is a perfect square. If it reaches a negative number without reaching 0 it is not a perfect square.\\n\\n**Code In C++**\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int  i = 1;\\n        while(num>0)\\n        {\\n            num -= i;\\n            i += 2;\\n            if(num==0)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n****\\n**Note If sqrt() use allow**\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int ans = sqrt(num);\\n        return (ans*ans == num);\\n    }\\n};\\n```\\n\\n*If find helpful thennPlease Upvote* **:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int  i = 1;\\n        while(num>0)\\n        {\\n            num -= i;\\n            i += 2;\\n            if(num==0)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int ans = sqrt(num);\\n        return (ans*ans == num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744406,
                "title": "python3-binary-search-straight-forward",
                "content": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        l,h=0,num\\n        while(l<=h):\\n            m=(l+h)//2\\n            if (m*m ==num):\\n                return True\\n            elif (m*m < num):\\n                l=m+1\\n            else:\\n                h=m-1\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        l,h=0,num\\n        while(l<=h):\\n            m=(l+h)//2\\n            if (m*m ==num):\\n                return True\\n            elif (m*m < num):\\n                l=m+1\\n            else:\\n                h=m-1\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 622022,
                "title": "java-cpp-python3-with-explanation-100-fast-o-1-space",
                "content": "```\\nExplanation:-\\n   If you take num as 16.\\n   start = 1, end = 16\\n   find mid, mid = (start + end)/2 = (1 + 16)/2 = 17/2 = 8\\n   now, mid * mid = 8 * 8 = 64. it is greater than the given number 16.\\n   so, it\\'s sqrt number must be in     between 1 to 7 if exits.\\n   so, update end = mid - 1, 8 - 1 = 7.\\n   again repeat above process, \\n    Now,  start = 1, end = 7\\n\\tmid = (1 + 7) = 8/2 = 4\\n\\tmid * mid = 4 * 4 = 16. this is equal to given number 16.\\n\\tso, it is perfect square. so, return true.\\n```\\n```\\n\\tfor false case ,\\n\\tsuppose, if the number is 15, then \\n\\tmid * mid = 16. it is greater than the given number 15. \\n\\tso, it\\'s sqrt number must be in between 1 to 3\\n\\tso update end = 4 - 1 = 3\\n\\tnow, start =1, end = 3.\\n\\tmid = (1 + 3)/2 = 2\\n\\tmid * mid = 2 * 2 = 4. it is smaller than the given number 15. \\n\\tso, it\\'s sqrt number must be in later half. i.e, \\n\\tupdate start = mid  + 1 = 2 + 1 = 3.\\n\\tNow, start = 3, end = 3.\\n\\tmid = (3 + 3)/2 = 3. \\n\\tmid * mid = 9. it is smaller than the given number 15. \\n\\tso, update start = mid + 1, start = 4;\\n\\tnow start > end, loop terminates. return false.\\n\\tThis is how it works for false case.\\n ```\\n **IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK**\\n **IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.**\\n```\\nJAVA:-\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num < 2) return true;\\n        long start = 1, end = num;\\n        while(start <= end){\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num) return true;\\n            if(mid * mid > num)\\n                end = mid -1;\\n            else\\n                start = mid + 1;\\n        }\\n        return false;\\n   }\\n }\\n\\nPython3:-\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        if num < 2:\\n            return True\\n        start = 1\\n        end = num\\n        while start <= end:\\n            mid= int(start + (end - start)/2)\\n            if(mid * mid == num):\\n                return True\\n            if (mid * mid < num):\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return False\\n\\t\\t\\n\\t\\t\\nCPP:-\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long start = 1, end = num;\\n        while(start <= end){\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num) return true;\\n            if(mid * mid < num)\\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nExplanation:-\\n   If you take num as 16.\\n   start = 1, end = 16\\n   find mid, mid = (start + end)/2 = (1 + 16)/2 = 17/2 = 8\\n   now, mid * mid = 8 * 8 = 64. it is greater than the given number 16.\\n   so, it\\'s sqrt number must be in     between 1 to 7 if exits.\\n   so, update end = mid - 1, 8 - 1 = 7.\\n   again repeat above process, \\n    Now,  start = 1, end = 7\\n\\tmid = (1 + 7) = 8/2 = 4\\n\\tmid * mid = 4 * 4 = 16. this is equal to given number 16.\\n\\tso, it is perfect square. so, return true.\\n```\n```\\n\\tfor false case ,\\n\\tsuppose, if the number is 15, then \\n\\tmid * mid = 16. it is greater than the given number 15. \\n\\tso, it\\'s sqrt number must be in between 1 to 3\\n\\tso update end = 4 - 1 = 3\\n\\tnow, start =1, end = 3.\\n\\tmid = (1 + 3)/2 = 2\\n\\tmid * mid = 2 * 2 = 4. it is smaller than the given number 15. \\n\\tso, it\\'s sqrt number must be in later half. i.e, \\n\\tupdate start = mid  + 1 = 2 + 1 = 3.\\n\\tNow, start = 3, end = 3.\\n\\tmid = (3 + 3)/2 = 3. \\n\\tmid * mid = 9. it is smaller than the given number 15. \\n\\tso, update start = mid + 1, start = 4;\\n\\tnow start > end, loop terminates. return false.\\n\\tThis is how it works for false case.\\n ```\n```\\nJAVA:-\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num < 2) return true;\\n        long start = 1, end = num;\\n        while(start <= end){\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num) return true;\\n            if(mid * mid > num)\\n                end = mid -1;\\n            else\\n                start = mid + 1;\\n        }\\n        return false;\\n   }\\n }\\n\\nPython3:-\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        if num < 2:\\n            return True\\n        start = 1\\n        end = num\\n        while start <= end:\\n            mid= int(start + (end - start)/2)\\n            if(mid * mid == num):\\n                return True\\n            if (mid * mid < num):\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return False\\n\\t\\t\\n\\t\\t\\nCPP:-\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long start = 1, end = num;\\n        while(start <= end){\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num) return true;\\n            if(mid * mid < num)\\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559495,
                "title": "go-newton-s-method-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Valid Perfect Square.\\nMemory Usage: 1.9 MB, less than 100.00% of Go online submissions for Valid Perfect Square.\\n```\\nfunc isPerfectSquare(num int) bool {\\n    if num < 2{\\n        return true\\n    }\\n    \\n    x := num / 2\\n    for x * x > num{\\n        x = (x+num/x)/2\\n    }\\n    \\n    return x * x == num \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPerfectSquare(num int) bool {\\n    if num < 2{\\n        return true\\n    }\\n    \\n    x := num / 2\\n    for x * x > num{\\n        x = (x+num/x)/2\\n    }\\n    \\n    return x * x == num \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348562,
                "title": "c-very-simple-without-pow-or-sqrt",
                "content": "First look at the properties of perfect squares:\\n\\na = 1\\nb = 4 => b = a + 3\\nc = 9 => c = b + 5\\nd = 16 => d = c + 7\\ne = 25 => e = d + 9\\n...\\nGet the pattern?\\n\\n```\\n    bool isPerfectSquare(int num) {\\n        int i {1};\\n        while (num>0) {\\n            num -= i;\\n             i += 2;\\n        }\\n        return num==0;\\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n    bool isPerfectSquare(int num) {\\n        int i {1};\\n        while (num>0) {\\n            num -= i;\\n             i += 2;\\n        }\\n        return num==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184907,
                "title": "java-simple-solution-beats-100-with-explanation",
                "content": " The idea is simple we just find all pair divisors. We iterate from 2 to ..., and when we find a divisor,\\n we try to divide **num** by it one more time.\\n\\n For example:\\n input: num = 180\\n\\n iterate beginning from 2:\\n 180%2==0 ?\\n yes -> num = 180/2 = 90\\n\\n check if we can divide by 2 again:\\n 90%2==0 ?\\n yes -> num = 90/2 = 45\\n\\n num is 45 now.\\n since num was decreased, we should again iterate beginning from 2:\\n\\n 45%2==0 ?\\n no -> continue to iterate\\n\\n 45%3==0 ?\\n yes -> nums = 45/3 = 15\\n let\\'s divide one more time\\n\\n 15%3==0 ?\\n yes -> nums = 15/3 = 5\\n num is 5 now.\\n\\n num was decreased -> again iterate beginning from 2\\n 5%2==0 ?\\n no -> continue to iterate\\n 5%3==0 ?\\n no -> continue to iterate\\n 5%4==0 ?\\n no -> continue to iterate\\n 5%5==0 ?\\n yes -> nums = 5/5 = 1\\n check if we can divide one more time:\\n 1%5==0 ?\\n no -> return false\\n \\n \\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if (num == 2147483647) return false;\\n        for (int i = 2; num > 1 && i * i <= num;) {\\n            if (num % i == 0) {\\n                num /= i;\\n                if (num % i == 0) {\\n                    num /= i;\\n                    i = 2;\\n                } else return false;\\n            } else i++;\\n        }\\n        return num == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if (num == 2147483647) return false;\\n        for (int i = 2; num > 1 && i * i <= num;) {\\n            if (num % i == 0) {\\n                num /= i;\\n                if (num % i == 0) {\\n                    num /= i;\\n                    i = 2;\\n                } else return false;\\n            } else i++;\\n        }\\n        return num == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160184,
                "title": "java-binary-search-beats-100",
                "content": "```\\n    public boolean isPerfectSquare(int num) {\\n        int left = 1;\\n        int right = num;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (mid == num / mid && num % mid == 0)return true;\\n            if (mid < num / mid) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isPerfectSquare(int num) {\\n        int left = 1;\\n        int right = num;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (mid == num / mid && num % mid == 0)return true;\\n            if (mid < num / mid) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151403,
                "title": "python-one-liner",
                "content": "```\\nclass Solution(object):\\n    def isPerfectSquare(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        return num**0.5 == int(num**0.5) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isPerfectSquare(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        return num**0.5 == int(num**0.5) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788175,
                "title": "beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double n = Math.sqrt(num);\\n        if(n /(int)n == 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/539bc15d-1677-4947-b269-fe68849adc78_1689777081.6770382.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double n = Math.sqrt(num);\\n        if(n /(int)n == 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777812,
                "title": "easy-cpp-solution-with-step-wise-explanation-using-binary-search-beats-100-users",
                "content": "# Intuition\\n - Somehow redce the time complexity\\n\\n# Approach\\n1. Initialize the variable `start` to 0.\\n2. Check if the given number `num` is equal to 1. If so, return `true` as 1 is a perfect square.\\n3. Calculate the variable `end` as `num/2`, which will be the upper limit for the search range.\\n4. Enter a while loop with the condition `start <= end` to perform binary search.\\n5. Inside the while loop, calculate the variable `mid` as `start + (end - start) / 2`, which represents the middle point of the search range.\\n6. Check if `mid * mid` is equal to `num`. If so, the number is a perfect square, so return `true`.\\n7. If `mid * mid` is less than `num`, update `start` to `mid + 1` to search in the upper half of the remaining range.\\n8. If `mid * mid` is greater than `num`, update `end` to `mid - 1` to search in the lower half of the remaining range.\\n9. Repeat steps 6-9 until `start` becomes greater than `end`, indicating that the search range has been exhausted.\\n10. If the loop finishes without finding a perfect square, return `false`.\\n\\n\\n# Complexity\\n- Time complexity:\\n  - O(log n)\\n\\n- Space complexity:\\n    - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int start=0;\\n        if(num==1) return true;\\n        int end=num/2;\\n        while(start<=end)\\n        {\\n            long long int  mid=start+(end-start)/2;\\n            \\n                if(mid*mid==num) return true;\\n                else if(mid*mid<num) start=mid+1;\\n                else end=mid-1;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```\\n# Please upvote and feel free to ask doubts",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int start=0;\\n        if(num==1) return true;\\n        int end=num/2;\\n        while(start<=end)\\n        {\\n            long long int  mid=start+(end-start)/2;\\n            \\n                if(mid*mid==num) return true;\\n                else if(mid*mid<num) start=mid+1;\\n                else end=mid-1;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543953,
                "title": "simple-java-solution-beats-100-runtime-0ms",
                "content": "\\n# Approach 1: \\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double d1 = Math.sqrt(num);\\n        double d2 = Math.round(d1);\\n        double fracValue = d1-d2;\\n        return Math.abs(fracValue)>0 ? false:true;        \\n    }\\n}\\n```\\n\\n# Approach 2 (Without built-in method): \\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long temp =num;\\n        while(temp*temp > num){\\n            temp = (temp + num/temp)/2;\\n        }\\n        boolean response = temp*temp == num ? true: false;\\n        return response;\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding.**",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double d1 = Math.sqrt(num);\\n        double d2 = Math.round(d1);\\n        double fracValue = d1-d2;\\n        return Math.abs(fracValue)>0 ? false:true;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long temp =num;\\n        while(temp*temp > num){\\n            temp = (temp + num/temp)/2;\\n        }\\n        boolean response = temp*temp == num ? true: false;\\n        return response;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153191,
                "title": "0ms-100-fastest-easiest-java-solution-binary-search",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num ==1) return true;\\n//long is used as mid*mid will go above the limit of int\\n        long i=2;\\n        long l = num/2;\\n        while(i<=l){\\n            long mid =i +(l-i)/2;\\n\\n            if(mid*mid == num){\\n                return true;\\n            }\\n            else if(mid*mid<num){\\n                i= mid+1;\\n            }\\n            else{\\n                l = mid-1;\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num ==1) return true;\\n//long is used as mid*mid will go above the limit of int\\n        long i=2;\\n        long l = num/2;\\n        while(i<=l){\\n            long mid =i +(l-i)/2;\\n\\n            if(mid*mid == num){\\n                return true;\\n            }\\n            else if(mid*mid<num){\\n                i= mid+1;\\n            }\\n            else{\\n                l = mid-1;\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065555,
                "title": "cpp-simple-solution-beats-100-runtime-0ms-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int high=num, low=1,mid;\\n        while(high-low>0){\\n            int mid = low + (high-low)/2;\\n            if(mid== sqrt(num)) return true;\\n            else if(mid>sqrt(num)) high = mid-1;\\n            else low=mid+1;\\n        }\\n        return low == sqrt(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int high=num, low=1,mid;\\n        while(high-low>0){\\n            int mid = low + (high-low)/2;\\n            if(mid== sqrt(num)) return true;\\n            else if(mid>sqrt(num)) high = mid-1;\\n            else low=mid+1;\\n        }\\n        return low == sqrt(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870276,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long left = 1, right = num;\\n        while (left < right) {\\n            long mid = (left + right) >>> 1;\\n            if (mid * mid >= num) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left * left == num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long left = 1, right = num;\\n        while (left < right) {\\n            long mid = (left + right) >>> 1;\\n            if (mid * mid >= num) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left * left == num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717910,
                "title": "easy-java-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n    long low=1,high=num;\\n    \\n    while(low<=high){\\n        long mid=low+(high-low)/2;\\n        if(mid*mid==num) return true;\\n    else if(mid*mid>num)\\n        high=mid-1;\\n    else\\n         low=mid+1;\\n    }\\n   return false;\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n    long low=1,high=num;\\n    \\n    while(low<=high){\\n        long mid=low+(high-low)/2;\\n        if(mid*mid==num) return true;\\n    else if(mid*mid>num)\\n        high=mid-1;\\n    else\\n         low=mid+1;\\n    }\\n   return false;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687589,
                "title": "easy-c-binary-search",
                "content": "```cpp \\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long long int l = 0, r = num, s;\\n        while(l <= r){\\n            long long int s = l + (r - l)/2;\\n            if(s*s == num){\\n                return true;\\n            }\\n            else if(s*s > num){\\n                r = s - 1;\\n            }       \\n            else if(s*s < num){\\n                l = s + 1;\\n            }\\n            else {\\n                return false;\\n            }\\n        } return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long long int l = 0, r = num, s;\\n        while(l <= r){\\n            long long int s = l + (r - l)/2;\\n            if(s*s == num){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2398938,
                "title": "c-2-approach-binary-search-and-mathematical",
                "content": "# Approach #1 - Binary Search\\n* If you know binary search, this makes the problem pretty easy. The only thing that you have to take care is about the integer overflow.\\n* Keeping in mind that for a positive number, the **square root of a number is greater than 1/2 of the number**, we start searching the number binarally by keeping the low as 1 (Since the given number ranges from 1 to INT_MAX).\\n* The only extra condition we check is for the integer overflow. For this, we check whether mid >= INT_MAX / mid (Since we need to check if mid * mid >= INT_MAX since we can\\'t store the number in an integer type variable)\\n* *(Not in a very mathematical language)* Using maths, we take one ```mid``` to the other side of the \\'=\\' sign, which makes it divided by INT_MAX. Since `INT_MAX / mid` lies in the integer limits (Division is repeated subtraction), both LHS and RHS can be compared.\\n\\n```\\nif(mid >= INT_MAX / mid){\\n\\t  high = mid - 1;\\n      continue;\\n }\\n```\\n\\n* If there lies a condition of integer overflow, we make high as mid - 1.\\n* The rest of the conditions remains the same as we return when mid * mid == num.\\n\\n\\n**Code**\\n```\\nbool isPerfectSquare(int num) {\\n    if(num == 1){\\n        return true;\\n    }\\n\\n    int low = 2;\\n    int high = num / 2;\\n\\n    while(low <= high){\\n        int mid = high + (low - high) / 2;\\n\\n        if(mid >= INT_MAX / mid){\\n            high = mid - 1;\\n            continue;\\n        }\\n\\n        long long int square = mid * mid;\\n\\n        if(square == num){\\n            return true;\\n        } else if(square > num){\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n\\n    return false;\\n}\\n```\\n# **Approach #2 - Mathematics**\\n* The approach to the question lies in the logic that **Sum of odd numbers always gives a perfect square**\\n* Using this logic, we can keep subtracting odd numbers starting from 1 until the number either becomes zero or a negative number.\\n* Finally we check whether after all the subtracting, the number becomes zero or negative. If after all the subtractions, the number we get is a negative number, it means that the number is not a perfect square. If it is equal to zero, then it is a perfect square.\\n\\n-> What I just said goes like this:\\n```\\n1 = 1\\n4 = 1 + 3\\n9 = 1 + 3 + 5\\n16 = 1 + 3 + 5 + 7\\n25 = 1 + 3 + 5 + 7 + 9\\n36 = 1 + 3 + 5 + 7 + 9 + 11\\n49 = 1 + 3 + 5 + 7 + 9 + 11 + 13\\n64 = 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15\\n81 = 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17\\n100 = 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19\\n```\\n\\n**Code**\\n```\\nbool isPerfectSquare(int num) {\\n    int i = 1;\\n\\n    while(num > 0){\\n        num -= i;\\n        i += 2;\\n    }\\n\\n    return (num == 0);\\n}\\n```\\n\\n# Note:\\nI am still learning and I might be wrong with my approach or code. There might exists another approach or a way of code that is better than mine. Please feel free to comment section to start a discussion. I would be more than happy with the same.\\n\\nFinally I would say never betray a friend who was there at a time no one was there at all costs. IDK why I\\'m writing this but then felt sharing something with you.... Yes you! Who is reading this till the very end.\\n\\nAnd Happy Coding :) I hope that our grind takes us at a place where we all are struggling to be on. \\nAll the best for your future :)",
                "solutionTags": [
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```mid```\n```\\nif(mid >= INT_MAX / mid){\\n\\t  high = mid - 1;\\n      continue;\\n }\\n```\n```\\nbool isPerfectSquare(int num) {\\n    if(num == 1){\\n        return true;\\n    }\\n\\n    int low = 2;\\n    int high = num / 2;\\n\\n    while(low <= high){\\n        int mid = high + (low - high) / 2;\\n\\n        if(mid >= INT_MAX / mid){\\n            high = mid - 1;\\n            continue;\\n        }\\n\\n        long long int square = mid * mid;\\n\\n        if(square == num){\\n            return true;\\n        } else if(square > num){\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n\\n    return false;\\n}\\n```\n```\\n1 = 1\\n4 = 1 + 3\\n9 = 1 + 3 + 5\\n16 = 1 + 3 + 5 + 7\\n25 = 1 + 3 + 5 + 7 + 9\\n36 = 1 + 3 + 5 + 7 + 9 + 11\\n49 = 1 + 3 + 5 + 7 + 9 + 11 + 13\\n64 = 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15\\n81 = 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17\\n100 = 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19\\n```\n```\\nbool isPerfectSquare(int num) {\\n    int i = 1;\\n\\n    while(num > 0){\\n        num -= i;\\n        i += 2;\\n    }\\n\\n    return (num == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2044210,
                "title": "valid-perfect-square-easy-to-understand-100-faster-solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n       if(num == 1) return true ;  // edge case\\n       long start = 0 ;   // Take Long as the inputs have large value\\n       long end = num /2 ;\\n        while(start <= end ){\\n            long mid = start + ( end - start ) / 2 ;\\n            if (mid * mid > num)   end = mid - 1 ; // Mid is greater than the squareroot of the number\\n            else if (mid * mid < num) start = mid + 1 ;  // Mid is less than our required number\\n            else  return true;     // we found our squareroot number\\n            }\\n        return false ;\\n    }\\n}\\n```\\n\\nHope you like the solution.\\nIf it helps you somehow, please share.",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n       if(num == 1) return true ;  // edge case\\n       long start = 0 ;   // Take Long as the inputs have large value\\n       long end = num /2 ;\\n        while(start <= end ){\\n            long mid = start + ( end - start ) / 2 ;\\n            if (mid * mid > num)   end = mid - 1 ; // Mid is greater than the squareroot of the number\\n            else if (mid * mid < num) start = mid + 1 ;  // Mid is less than our required number\\n            else  return true;     // we found our squareroot number\\n            }\\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868087,
                "title": "c-binary-search-100-faster-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        ll l = 0,h = num;\\n        while(l<=h)\\n        {\\n            ll mid = l + (h-l)/2;\\n            if(mid*mid > num)\\n                h = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return h*h == num;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        ll l = 0,h = num;\\n        while(l<=h)\\n        {\\n            ll mid = l + (h-l)/2;\\n            if(mid*mid > num)\\n                h = mid - 1;\\n            else\\n                l = mid + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1799372,
                "title": "both-solutions-c-binary-search-maths",
                "content": "**Binary Search**\\n**Time Complexity : O(log N)**\\n\\nCode: \\n```\\nclass Solution {\\n    public: \\n    bool isPerfectSquare(int num) {\\n        long long  left = 1, right = num;\\n        while (left <= right) {\\n            long long mid = (left + right) / 2;\\n            if (mid * mid == num) \\n\\t\\t\\treturn true; // check if mid is perfect square\\n            if (mid * mid < num) \\n\\t\\t\\t{ // mid is small -> go right to increase mid\\n                left = mid + 1;\\n            }\\n\\t\\t\\telse {\\n                right = mid - 1; // mid is large -> to left to decrease mid\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Maths**\\n**Time Complexity: O(N)**\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n                \\n//         1 = 1\\n//         1+3 = 4\\n//         1+3+5 = 9\\n//         1+3+5+7 = 16\\n//         1+3+5+7+9 = 25\\n        \\n        long long int ptr = 0,i = 1;\\n        while(ptr<=num){\\n            ptr += (2*i - 1);\\n            if(ptr == num){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Do upvote \\uD83D\\uDC4D\\uD83C\\uDFFB, Don\\'t spread Hate by downvoting**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public: \\n    bool isPerfectSquare(int num) {\\n        long long  left = 1, right = num;\\n        while (left <= right) {\\n            long long mid = (left + right) / 2;\\n            if (mid * mid == num) \\n\\t\\t\\treturn true; // check if mid is perfect square\\n            if (mid * mid < num) \\n\\t\\t\\t{ // mid is small -> go right to increase mid\\n                left = mid + 1;\\n            }\\n\\t\\t\\telse {\\n                right = mid - 1; // mid is large -> to left to decrease mid\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n                \\n//         1 = 1\\n//         1+3 = 4\\n//         1+3+5 = 9\\n//         1+3+5+7 = 16\\n//         1+3+5+7+9 = 25\\n        \\n        long long int ptr = 0,i = 1;\\n        while(ptr<=num){\\n            ptr += (2*i - 1);\\n            if(ptr == num){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549028,
                "title": "easy-way-to-understand-and-you-like-it-binary-search",
                "content": "class Solution {\\npublic:\\n\\n\\n    bool isPerfectSquare(int num) {\\n        if(num==0 || num==1){\\n            return true;\\n        }\\n        long long low=1,high=num,mid;\\n        while(low<=high){\\n            mid=low+(high-low)/2;\\n            if(mid*mid==num){\\n                return true;\\n            }\\n            else if(mid*mid>num){\\n                high=mid-1;\\n            }\\n            else if(mid*mid<num){\\n                low=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    bool isPerfectSquare(int num) {\\n        if(num==0 || num==1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1455065,
                "title": "binary-search-solution-cpp",
                "content": "This is a classic binary search solution. The only tricky thing here would be to use a long long or a long int as we would be doing a square of midpoint.\\nAnother thing to note which I faced issue is, in such problems instead of comparing via ```if (mid * mid == num)``` I previously did ``` if (mid = num/mid)``` to avoid overflow issues, but in this problem this would fail because the division will be a floor operation and we will get incorrect output.\\nOther than these quirks, a simple binary search will give the answer\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num == 0 || num == 1) return true;\\n        long int low = 0;\\n        long int high = num;\\n        \\n        while (low <= high) {\\n            long int mid = low + (high - low)/2; // mid needs to be long int or long long to avoid overflow\\n            if (mid*mid == num) { // Dont do mid == num/mid as this will result in incorrect answer\\n                return true;\\n            } else if (mid*mid < num) { // I did mid < num/mid, resulted in TLE\\n                low = mid+1;\\n            } else if (mid*mid > num) { // I did mid > num/mid, resulted in TLE\\n                high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```if (mid * mid == num)```\n``` if (mid = num/mid)```\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num == 0 || num == 1) return true;\\n        long int low = 0;\\n        long int high = num;\\n        \\n        while (low <= high) {\\n            long int mid = low + (high - low)/2; // mid needs to be long int or long long to avoid overflow\\n            if (mid*mid == num) { // Dont do mid == num/mid as this will result in incorrect answer\\n                return true;\\n            } else if (mid*mid < num) { // I did mid < num/mid, resulted in TLE\\n                low = mid+1;\\n            } else if (mid*mid > num) { // I did mid > num/mid, resulted in TLE\\n                high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410001,
                "title": "java-simple-solution-runtime-0-ms-faster-than-100-00-take-a-look",
                "content": "class Solution {\\n    public boolean isPerfectSquare(int num) {\\n        \\n        int lo=1; int hi=num;long mid=-1;\\n        while(lo<=hi){\\n             mid = lo +(hi-lo)/2;\\n            if(mid*mid==num){\\n                return true;\\n            }\\n           else if(mid*mid>num){\\n                hi=(int)mid-1;\\n            }\\n            else{\\n                lo=(int)mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n// Simple solution you can also do something else to settle the overflow condition\\n//Have any suggestion for the code do cooment below",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isPerfectSquare(int num) {\\n        \\n        int lo=1; int hi=num;long mid=-1;\\n        while(lo<=hi){\\n             mid = lo +(hi-lo)/2;\\n            if(mid*mid==num){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1010428,
                "title": "c-4-line-100-easy-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(long num) {\\n        \\n        long left(0), right(num);\\n        while(left <= right){\\n            long mid = (left + right) / 2;\\n            if(mid * mid < num){left = mid + 1;}\\n            else{right = mid - 1;}\\n        }\\n        \\n        return (left * left == num);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(long num) {\\n        \\n        long left(0), right(num);\\n        while(left <= right){\\n            long mid = (left + right) / 2;\\n            if(mid * mid < num){left = mid + 1;}\\n            else{right = mid - 1;}\\n        }\\n        \\n        return (left * left == num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857029,
                "title": "c-simple-solution-follow-up-s-beats-100-runtime-98-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isPerfectSquare(int num)\\n    {\\n        long long res = 1, count = 1;\\n        while (1)\\n        {\\n            if (res == num)\\n                return true;\\n            else if (res < num)\\n            {\\n                res = count * count;\\n                count++;\\n            }\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isPerfectSquare(int num)\\n    {\\n        long long res = 1, count = 1;\\n        while (1)\\n        {\\n            if (res == num)\\n                return true;\\n            else if (res < num)\\n            {\\n                res = count * count;\\n                count++;\\n            }\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661012,
                "title": "faster-then-98-26-python-binary-search-easy-solution",
                "content": "```\\n    \\n        \\n        if num ==1:\\n            return True\\n        \\n        if num ==2:\\n            return False\\n        \\n        start =2\\n        end = num\\n\\n\\n        while start<=end:\\n            mid = (start+end) //2\\n\\n            if mid*mid == num:\\n                return True\\n\\n            elif mid*mid > num:\\n                end = mid -1\\n            else:\\n                start = mid +1\\n                \\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n    \\n        \\n        if num ==1:\\n            return True\\n        \\n        if num ==2:\\n            return False\\n        \\n        start =2\\n        end = num\\n\\n\\n        while start<=end:\\n            mid = (start+end) //2\\n\\n            if mid*mid == num:\\n                return True\\n\\n            elif mid*mid > num:\\n                end = mid -1\\n            else:\\n                start = mid +1\\n                \\n        \\n        return False\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 634373,
                "title": "javascript-o-logn-binary-search",
                "content": "```\\nvar isPerfectSquare = function(num) {\\n    if (num < 2) {\\n      return true;\\n    }\\n  \\n    let left = 0, right = num, guessSquared;\\n    while (left <= right) {\\n      const mid = Math.floor((right + left)/2);\\n      guessSquared = mid * mid;\\n      if (guessSquared == num) {\\n        return true;\\n      }\\n      if (guessSquared > num) {\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar isPerfectSquare = function(num) {\\n    if (num < 2) {\\n      return true;\\n    }\\n  \\n    let left = 0, right = num, guessSquared;\\n    while (left <= right) {\\n      const mid = Math.floor((right + left)/2);\\n      guessSquared = mid * mid;\\n      if (guessSquared == num) {\\n        return true;\\n      }\\n      if (guessSquared > num) {\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623005,
                "title": "java-simple-trick-to-avoid-using-long",
                "content": "Just change the multiplication by division.\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int l = 1, r = num;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (mid  < num / mid) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l * l == num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int l = 1, r = num;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (mid  < num / mid) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l * l == num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622364,
                "title": "java-binary-search-o-logn-without-using-long",
                "content": "```\\npublic boolean isPerfectSquare(int num) {\\n    int l = 1;\\n    int r = num;\\n    while (l <= r) {\\n        int m = l + (r - l) / 2;\\n        if (m == num / m && num % m == 0) {\\n            return true;\\n        }\\n        if (num / m < m) {\\n            r = m - 1;\\n        } else {\\n            l = m + 1;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic boolean isPerfectSquare(int num) {\\n    int l = 1;\\n    int r = num;\\n    while (l <= r) {\\n        int m = l + (r - l) / 2;\\n        if (m == num / m && num % m == 0) {\\n            return true;\\n        }\\n        if (num / m < m) {\\n            r = m - 1;\\n        } else {\\n            l = m + 1;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591501,
                "title": "c-solution-beat-100-with-detailed-explanation",
                "content": "From the wikipedia, we can know that any square number is the sum of two consecutive [triangular numbers](http://en.wikipedia.org/wiki/Triangular_number) . For example, the square number 4 can be written as ``4 = 1 + 3``,  and square number 16 can be written as ``16 = 6 + 10``, and so on\\n```\\n a triangular number sequence is as follows :\\n\\t 0       1        3        6       10      15      21      .......\\n```\\n* so, we use two variables ``pre`` and ``cur`` to record two consecutive triangular numbers, and the variable ``n`` is used to update the next consecutive triangular number; \\n* during the iteration, if the condition `` pre + cur == num`` is satisfied, then we just return true\\nHere are my codes, hope it helps.\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long pre = 0, cur = 0;\\n        long n = 1;\\n        while (pre + cur < num) {\\n            pre = cur;\\n            cur = n * (n + 1) / 2;\\n            n++;\\n            if (pre+cur == num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n a triangular number sequence is as follows :\\n\\t 0       1        3        6       10      15      21      .......\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long pre = 0, cur = 0;\\n        long n = 1;\\n        while (pre + cur < num) {\\n            pre = cur;\\n            cur = n * (n + 1) / 2;\\n            n++;\\n            if (pre+cur == num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372027,
                "title": "binary-search-c-100-fast-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int n) {\\n        long int mid, l=0, r=n, sq;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            sq = mid*mid;\\n            if(sq == n){\\n                return true;\\n            }\\n            else if(sq > n){\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n````",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int n) {\\n        long int mid, l=0, r=n, sq;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            sq = mid*mid;\\n            if(sq == n){\\n                return true;\\n            }\\n            else if(sq > n){\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313573,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution {\\n    public bool IsPerfectSquare(int num) {\\n        if (num < 0) return false;\\n        if (num == 0) return false;\\n        if (num == 1) return true;\\n\\n        long left = 2;\\n        long right = num;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (mid * mid == num) {\\n                return true;\\n            } else if (mid * mid < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPerfectSquare(int num) {\\n        if (num < 0) return false;\\n        if (num == 0) return false;\\n        if (num == 1) return true;\\n\\n        long left = 2;\\n        long right = num;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (mid * mid == num) {\\n                return true;\\n            } else if (mid * mid < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305473,
                "title": "interesting-trick-to-find",
                "content": "One can find whether a number is a perfect square or not just by subtracting odd numbers(1,3,5...) from the given number. If the answer reaches zero at any point, which means the given number is a perfect square else its not.\\nexample:\\nlets say 36\\nsubtracting odd numbers step by step\\n36-1 = 35, 35-3=32, 32-5=27, 27-7=20, 20-9 = 11, and 11-11 ==0 (so its a perfect square)\\n```\\na=1\\nwhile(num >= 0):\\n       if num == 0:\\n\\t\\t   return True\\n       num -=a\\n       a+=2\\nreturn False\\n```\\n",
                "solutionTags": [],
                "code": "```\\na=1\\nwhile(num >= 0):\\n       if num == 0:\\n\\t\\t   return True\\n       num -=a\\n       a+=2\\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83914,
                "title": "python-removing-floating-point-for-solution",
                "content": "To find a perfect square, the number must be square rooted then that answer is squared to get the original number. If we remove the float, it makes it easier for larger numbers, thus using <b>int</b>  as seen in the if statement.\\n\\nIs there a quicker way? Let me know!\\n\\n```\\nclass Solution(object):\\n    def isPerfectSquare(self, num):\\n        if int((num**.5))**2 == num:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPerfectSquare(self, num):\\n        if int((num**.5))**2 == num:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83906,
                "title": "javascript-solution-with-explanation-dynamic-programming",
                "content": "```\\n/*\\nExplanation: \\nIt can be build using dynamic programming:\\nSqrt    Sqr\\n1       1   \\n    3\\n2       4   = 3 + 1\\n    5\\n3       9   = 5 + 4\\n    7\\n4       16  = 9 + 7\\n    9\\n5       25  = 16 + 9\\n    11\\n6       36  = 25 + 11\\n    13\\n7       49  = 36 + 13\\n    15\\n8       64  = 49 + 15\\n    17\\n9       81  = 64 + 17\\n    19\\n10      100 = 81 + 19\\n*/\\nvar isPerfectSquare = function(num) {\\n  var start = 1;\\n  var curr = 1;\\n  var tmp;\\n  \\n  if(num === 1){\\n    return true;\\n  }\\n  \\n  while(curr <= num){\\n    start += 2;\\n    tmp = start + curr;\\n    if (tmp <= num){\\n      curr = tmp;\\n      if(curr === num){\\n          return true;\\n      }\\n    } else{\\n      return false;\\n    }\\n  }\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nExplanation: \\nIt can be build using dynamic programming:\\nSqrt    Sqr\\n1       1   \\n    3\\n2       4   = 3 + 1\\n    5\\n3       9   = 5 + 4\\n    7\\n4       16  = 9 + 7\\n    9\\n5       25  = 16 + 9\\n    11\\n6       36  = 25 + 11\\n    13\\n7       49  = 36 + 13\\n    15\\n8       64  = 49 + 15\\n    17\\n9       81  = 64 + 17\\n    19\\n10      100 = 81 + 19\\n*/\\nvar isPerfectSquare = function(num) {\\n  var start = 1;\\n  var curr = 1;\\n  var tmp;\\n  \\n  if(num === 1){\\n    return true;\\n  }\\n  \\n  while(curr <= num){\\n    start += 2;\\n    tmp = start + curr;\\n    if (tmp <= num){\\n      curr = tmp;\\n      if(curr === num){\\n          return true;\\n      }\\n    } else{\\n      return false;\\n    }\\n  }\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83969,
                "title": "binary-search-solution-in-python",
                "content": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            b, e = 1, (num >> 1) + 1\\n            while b <= e:\\n                mid = (b + e) >> 1\\n                sq = mid * mid\\n                if sq == num:\\n                    return True\\n                if sq > num:\\n                    e = mid - 1\\n                else:\\n                    b = mid + 1\\n            return False",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def isPerfectSquare(self, num):\\n            b, e = 1, (num >> 1) + 1\\n            while b <= e:\\n                mid = (b + e) >> 1\\n                sq = mid * mid\\n                if sq == num:\\n                    return True\\n                if sq > num:\\n                    e = mid - 1\\n                else:\\n                    b = mid + 1\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3954745,
                "title": "easy-c-solution-0-ms-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num==1)\\n        return true;\\n      int start=1;\\n      int end=num/2;\\n      while(start<=end)\\n      {\\n          long long int mid=start+(end-start)/2;\\n          if(mid*mid==num)\\n          {\\n              return true;\\n          }\\n          else if(mid*mid>num)\\n          {\\n              end=mid-1;\\n          }\\n          else{\\n              start=mid+1;\\n          }\\n      }  \\n      return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num==1)\\n        return true;\\n      int start=1;\\n      int end=num/2;\\n      while(start<=end)\\n      {\\n          long long int mid=start+(end-start)/2;\\n          if(mid*mid==num)\\n          {\\n              return true;\\n          }\\n          else if(mid*mid>num)\\n          {\\n              end=mid-1;\\n          }\\n          else{\\n              start=mid+1;\\n          }\\n      }  \\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628877,
                "title": "simple-c-code-maths",
                "content": "**int** in C++ gives the greates integer value of any number.\\nIf p=sqrt(num), then p is square root of num.\\nBut if ``` int p=sqrt(num)``` it will give the greatest integer value of sqrt of num.\\nIf p*p==num, then it will be cleared that num was perfect sqaure because its square root is and integer value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int p=sqrt(num);\\n        if(p*p==num){\\n            return true;\\n        }\\n        return false;\\n    }\\n            //<!-- Please upvote if you liked!!! -->\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "``` int p=sqrt(num)```\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int p=sqrt(num);\\n        if(p*p==num){\\n            return true;\\n        }\\n        return false;\\n    }\\n            //<!-- Please upvote if you liked!!! -->\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312688,
                "title": "binary-search-and-linear-search-approach",
                "content": "\\n1.Binary Search Approach\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        left,right=1,num\\n        while left<=right:\\n            mid=(left+right)//2\\n            if mid*mid==num:\\n                return True\\n            elif (mid*mid)>num:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False\\n    #please upvote me it would encourage me alot\\n\\n```\\n2. Linear search\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        for i in range(50000):\\n            if i*i==num:\\n                return True\\n        else:\\n            return False\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        left,right=1,num\\n        while left<=right:\\n            mid=(left+right)//2\\n            if mid*mid==num:\\n                return True\\n            elif (mid*mid)>num:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False\\n    #please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        for i in range(50000):\\n            if i*i==num:\\n                return True\\n        else:\\n            return False\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282698,
                "title": "c-easy-solution-for-beginner-o-log-n-time-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int s = 1;\\n        int e = 1000000;       \\n        while(s<=e){\\n            long mid = (s+e)/2;\\n            if(mid*mid==num)           return true;\\n            else if (mid*mid>num)      e=mid-1;\\n            else                       s=mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int s = 1;\\n        int e = 1000000;       \\n        while(s<=e){\\n            long mid = (s+e)/2;\\n            if(mid*mid==num)           return true;\\n            else if (mid*mid>num)      e=mid-1;\\n            else                       s=mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250291,
                "title": "367-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses binary search to find the square root of the given number, which allows for a faster runtime compared to iterating through all possible squares.\\n\\nFirst, it checks if the given number is 1, which is considered a perfect square, and returns True if it is.\\n\\nNext, it initializes a binary search range for the possible square root values. The left bound is set to 1, since 1 is the smallest possible square root, and the right bound is set to the given number.\\n\\nIt then enters a while loop that continues until the left bound is greater than the right bound. In each iteration, it computes the middle value of the search range and squares it to check if it matches the given number. If it does, it returns True since the number is a perfect square. If the square of the middle value is less than the given number, it updates the left bound to be the middle value plus 1, since the square root must be greater than or equal to the middle value. If the square of the middle value is greater than the given number, it updates the right bound to be the middle value minus 1, since the square root must be less than or equal to the middle value.\\n\\nIf the while loop completes without finding the square root, it means the given number is not a perfect square, so it returns False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        # Base case: 1 is a perfect square\\n        if num == 1:\\n            return True\\n        \\n        # Binary search for the square root of the number\\n        left, right = 1, num\\n        while left <= right:\\n            mid = (left + right) // 2\\n            square = mid * mid\\n            if square == num:\\n                return True\\n            elif square < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        # If we haven\\'t found the square root, the number is not a perfect square\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        # Base case: 1 is a perfect square\\n        if num == 1:\\n            return True\\n        \\n        # Binary search for the square root of the number\\n        left, right = 1, num\\n        while left <= right:\\n            mid = (left + right) // 2\\n            square = mid * mid\\n            if square == num:\\n                return True\\n            elif square < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        # If we haven\\'t found the square root, the number is not a perfect square\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176900,
                "title": "easy-c-solution-binary-search-o-logn",
                "content": "# Intuition\\n\\nThis problem can be solved by using\\n **Binary search method (optimized)**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n **Binary Search:** \\n\\n\\n----\\n\\n**Solution:** \\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        // Let\\'s try binary search\\n\\n        long long int low = 0;\\n        long long int high = num;\\n\\n        while(low <= high)\\n        {\\n            // find the mid\\n\\n            long long int mid = low + (high - low)/2;\\n\\n            long long int pro = mid * mid;\\n            if(pro == num)\\n                return true;\\n            else if(pro > num)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return false;\\n    }\\n};  \\n```\\n\\n---\\n\\n**Analysis:**\\n- Time complexity:```  O(logn)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\nIf this solution helps you, then please ```UPVOTE```.\\n\\nTill then **Keep Learning, Keep Growing !!!**\\n\\n\\n\\n**Thank You !!!**\\n\\n\\n------",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        // Let\\'s try binary search\\n\\n        long long int low = 0;\\n        long long int high = num;\\n\\n        while(low <= high)\\n        {\\n            // find the mid\\n\\n            long long int mid = low + (high - low)/2;\\n\\n            long long int pro = mid * mid;\\n            if(pro == num)\\n                return true;\\n            else if(pro > num)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return false;\\n    }\\n};  \\n```\n```  O(logn)```\n```O(1)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 3006323,
                "title": "python-one-liner-solution-using-simple-mathematics",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Simply return TRUE if num ** 0.5 is equals to the integer conversion of it else FALSE.\\n* Example - num = 16 : if 4 == 4 : TRUE\\n* num = 14 : if 3.762 == 4 : FALSE\\n# Complexity \\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return True if (num ** 0.5) == int(num ** 0.5) else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return True if (num ** 0.5) == int(num ** 0.5) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991178,
                "title": "easy-to-understand-100-beats-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhat we are doing we are running the loop from 0 to square root of INT_MAX value.so if the condition satisfy then return the true.\\nafter that upon the completion of the loop return false.\\n\\n**Please UPVOTE if you like the solution**\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n    //46340\\n        for(int i=0;i<46341;i++){\\n            if(i*i==num){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n    //46340\\n        for(int i=0;i<46341;i++){\\n            if(i*i==num){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890690,
                "title": "efficient-golang-binary-search-solution",
                "content": "# Complexity\\n- Time complexity: $O(logn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc isPerfectSquare(num int) bool {\\n    left, right := 0, num+1\\n\\n    for left < right {\\n        mid := left + (right - left) / 2\\n\\n        if mid * mid >= num {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    return left * left == num\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nfunc isPerfectSquare(num int) bool {\\n    left, right := 0, num+1\\n\\n    for left < right {\\n        mid := left + (right - left) / 2\\n\\n        if mid * mid >= num {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    return left * left == num\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784321,
                "title": "simple-java-solution-100-faster-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int n) {\\n        \\n        long lo=1,hi=n;\\n        \\n        while(lo<=hi)\\n        {\\n            long mid=lo+(hi-lo)/2;\\n            if(mid*mid==n) return true;\\n            else if(mid*mid>n) hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isPerfectSquare(int n) {\\n        \\n        long lo=1,hi=n;\\n        \\n        while(lo<=hi)\\n        {\\n            long mid=lo+(hi-lo)/2;\\n            if(mid*mid==n) return true;\\n            else if(mid*mid>n) hi=mid-1;\\n            else lo=mid+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2707621,
                "title": "c-solution-100-time-17-03-space-used-sqrt-function",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num);\\n};\\n/*********************************************************************/\\nbool Solution::isPerfectSquare(int num) {\\n    int sq = sqrt(num);\\n    if (sq*sq == num) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n/*********************************************************************/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num);\\n};\\n/*********************************************************************/\\nbool Solution::isPerfectSquare(int num) {\\n    int sq = sqrt(num);\\n    if (sq*sq == num) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n/*********************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545330,
                "title": "easy-understandable-most-efficient-solution",
                "content": "```\\nimport java.util.Scanner;\\n\\npublic class square_root {\\n    public static void main(String[] args) {\\n        Scanner sc=new Scanner(System.in);\\n        int n=sc.nextInt();\\n        int l=0,r=n;\\n        int mid=0;\\n        while(l<=r)\\n        {\\n            mid=l+(r-l)/2;\\n            if(mid*mid==n){\\n                System.out.println(mid);\\n                break;\\n            } else if (mid*mid>n) {\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nimport java.util.Scanner;\\n\\npublic class square_root {\\n    public static void main(String[] args) {\\n        Scanner sc=new Scanner(System.in);\\n        int n=sc.nextInt();\\n        int l=0,r=n;\\n        int mid=0;\\n        while(l<=r)\\n        {\\n            mid=l+(r-l)/2;\\n            if(mid*mid==n){\\n                System.out.println(mid);\\n                break;\\n            } else if (mid*mid>n) {\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426268,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-3lines-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q367. Valid Perfect Square***\\n\\nGiven a **positive **integer num, write a function which returns True if num is a perfect square else False.\\n\\n**Follow up: Do not use** any built-in library function such as sqrt.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        x=num\\n        while x*x>num:\\n            x=(x+num/x)//2\\n        return x*x==num\\n```\\n**Runtime:**  39 ms\\t\\n**Memory Usage:**  14 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long x=num;\\n        while(x*x>num)\\n            x=(x+num/x)/2;  \\n        return x*x==num;\\n    }\\n}\\n```\\n**Runtime:**  0ms\\n**Memory Usage:**  41.2 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long x=num;\\n        while(x*x>num)\\n            x=(x+num/x)/2;  \\n        return x*x==num;\\n    }\\n}\\n```\\n**Runtime:**  3 ms\\t\\n**Memory Usage:**  5.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        x=num\\n        while x*x>num:\\n            x=(x+num/x)//2\\n        return x*x==num\\n```\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long x=num;\\n        while(x*x>num)\\n            x=(x+num/x)/2;  \\n        return x*x==num;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long x=num;\\n        while(x*x>num)\\n            x=(x+num/x)/2;  \\n        return x*x==num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425578,
                "title": "simple-java-code-easy",
                "content": "```\\npublic boolean isPerfectSquare(int num) {\\n        \\n        if(((int)Math.pow(num,0.5)) * ((int)Math.pow(num,0.5)) == num)\\n        {\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic boolean isPerfectSquare(int num) {\\n        \\n        if(((int)Math.pow(num,0.5)) * ((int)Math.pow(num,0.5)) == num)\\n        {\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332177,
                "title": "valid-perfect-square-0-ms-faster-than-100-00-of-c",
                "content": "# **Repeated Subtraction Method of Square Root**\\n\\nThis is a very simple method. We subtract the consecutive odd numbers from the number for which we are finding the square root, till we reach 0. The number of times we subtract is the square root of the given number. This method works only for perfect square numbers. Let us find the square root of 16 using this method.\\n\\n16 - 1 = 15\\n15 - 3 =12\\n12 - 5 = 7\\n7- 7 = 0\\nYou can observe that we have subtracted 4 times. Thus,\\u221A16 = 4\\n\\n**c++ solution**\\n\\n```\\n  bool isPerfectSquare(int num) {\\n        int sub=1;\\n        long n,count=0;\\n        n=num;\\n        while(num>0){\\n            count++;\\n            num=num-sub;\\n            sub=sub+2;\\n        }\\n        cout<<count;\\n        if(n==count*count)\\n            return 1;\\n        return 0;\\n    }\\n```\\n\\n\\n\\ncompiler replied :D\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Valid Perfect Square.\\nMemory Usage: 5.8 MB, less than 86.29% of C++ online submissions for Valid Perfect Square.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\n  bool isPerfectSquare(int num) {\\n        int sub=1;\\n        long n,count=0;\\n        n=num;\\n        while(num>0){\\n            count++;\\n            num=num-sub;\\n            sub=sub+2;\\n        }\\n        cout<<count;\\n        if(n==count*count)\\n            return 1;\\n        return 0;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2076237,
                "title": "easy-python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def isPerfectSquare(self, n: int) -> bool:\\n        if (math.ceil(math.sqrt(n)) == math.floor(math.sqrt(n))):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def isPerfectSquare(self, n: int) -> bool:\\n        if (math.ceil(math.sqrt(n)) == math.floor(math.sqrt(n))):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028807,
                "title": "c-solution-o-logn-time-complexity",
                "content": "```\\nbool isPerfectSquare(int num){\\n    long r = num;\\n    while(r*r > num){\\n        r = (r + num/r) /2;\\n    }\\n    return r*r == num;\\n}\\n```\\n**Please upvote if it helped**\\n*Feel free to ask any questions/query if any*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isPerfectSquare(int num){\\n    long r = num;\\n    while(r*r > num){\\n        r = (r + num/r) /2;\\n    }\\n    return r*r == num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1954741,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_perfect_square(num: i32) -> bool {\\n        use std::cmp::Ordering;\\n        let (mut low, mut high) = (1, num);\\n        while low <= high {\\n            let mid = low + (high - low) / 2;\\n            match mid.checked_mul(mid) {\\n                Some(square) => match square.cmp(&num) {\\n                    Ordering::Equal => return true,\\n                    Ordering::Less => low = mid + 1,\\n                    Ordering::Greater => high = mid - 1,\\n                },\\n                None => high = mid - 1,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_perfect_square(num: i32) -> bool {\\n        use std::cmp::Ordering;\\n        let (mut low, mut high) = (1, num);\\n        while low <= high {\\n            let mid = low + (high - low) / 2;\\n            match mid.checked_mul(mid) {\\n                Some(square) => match square.cmp(&num) {\\n                    Ordering::Equal => return true,\\n                    Ordering::Less => low = mid + 1,\\n                    Ordering::Greater => high = mid - 1,\\n                },\\n                None => high = mid - 1,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936072,
                "title": "cpp-faster-than-100",
                "content": "\\t class Solution {\\n\\t public:\\n  \\n    //Timecomplexity-->O(\\u221An)\\n   \\n    bool isPerfectSquare(int num) {\\n        unsigned long i = 1;\\n        while(i * i <= num)\\n        {\\n            if((num - i * i) == 0)\\n            {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n\\t public:\\n  \\n    //Timecomplexity-->O(\\u221An)\\n   \\n    bool isPerfectSquare(int num) {\\n        unsigned long i = 1;\\n        while(i * i <= num)\\n        {\\n            if((num - i * i) == 0)\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1671399,
                "title": "beware-of-overflowing-of-integers-while-squaring",
                "content": "![image](https://assets.leetcode.com/users/images/1af59a59-a899-4350-ac6f-d984bb8785d1_1641493087.9772003.jpeg)\\n![image](https://assets.leetcode.com/users/images/b8e82e3e-6451-4c85-bb1a-a3f3e12c1b23_1641493104.128103.jpeg)\\n![image](https://assets.leetcode.com/users/images/6d266582-30c3-443b-88a4-1e347849a0db_1641493111.3231914.jpeg)\\n![image](https://assets.leetcode.com/users/images/b479b401-1740-45aa-8756-6daf8c287908_1641493117.9739177.jpeg)\\n\\nthe sequence of p,q shifting changes when assigned to different data types!!\\n![image](https://assets.leetcode.com/users/images/e4e8888a-7636-4a4f-82f5-9b0bf8b33aad_1641493124.895375.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long p= 1, q=num;\\n        \\n        while (p<=q){\\n            long mid= (p+q)/2;\\n            if (mid*mid==num) return true;\\n            if (mid*mid>num)  q=mid-1;\\n            else  p=mid+1;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long p= 1, q=num;\\n        \\n        while (p<=q){\\n            long mid= (p+q)/2;\\n            if (mid*mid==num) return true;\\n            if (mid*mid>num)  q=mid-1;\\n            else  p=mid+1;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426614,
                "title": "one-line-python-solution",
                "content": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return int(num**0.5)==float(num**0.5)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return int(num**0.5)==float(num**0.5)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426161,
                "title": "easy-and-understand-solution",
                "content": "```/**\\n * @param {number} num\\n * @return {boolean}\\n */\\nvar isPerfectSquare = function(num) {\\n    var j=0;\\n    while(j*j <= num){\\n        if(j*j === num ) return true\\n        j++\\n    }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number} num\\n * @return {boolean}\\n */\\nvar isPerfectSquare = function(num) {\\n    var j=0;\\n    while(j*j <= num){\\n        if(j*j === num ) return true\\n        j++\\n    }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1377517,
                "title": "c-100-2-lines",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        float result = sqrt(num);\\n        return floor(result) == ceil(result);\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        float result = sqrt(num);\\n        return floor(result) == ceil(result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158694,
                "title": "c-100-faster-pattern-logic-explained-simple-solution-using-recursion",
                "content": "**Logic :**\\nSquare of 1 = 1 (1)\\nSquare of 2 = 4 (1 + 3)\\nSquare of 3 = 9 (1 + 3 + 5)\\nSquare of 4 = 16 (1 + 3 + 5 + 7)\\nSquare of 5 = 27 (1 + 3 + 5 + 7 + 9)\\n\\n***Note** : For every perfect square (N) as we minus odd numbers from N in ascending order, there eventually comes a point where the N becomes 0.*\\n```\\nclass Solution {\\npublic:\\n    \\n    bool getAns(int n, int i){\\n        if(n-i < 0)\\n            return false;\\n        else if(n-i == 0)\\n            return true;\\n        else\\n            return getAns(n-i, i+2);\\n    }\\n    \\n    bool isPerfectSquare(int num) {\\n        return getAns(num, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool getAns(int n, int i){\\n        if(n-i < 0)\\n            return false;\\n        else if(n-i == 0)\\n            return true;\\n        else\\n            return getAns(n-i, i+2);\\n    }\\n    \\n    bool isPerfectSquare(int num) {\\n        return getAns(num, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623013,
                "title": "c-well-documented-code-100-faster-and-memory-efficient",
                "content": "Using Binary Search -  O(logn) time and O(1) space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(long long int num)\\n    {\\n        long long int start = 1, end = num;\\n        \\n        // using binary search to find if square of any num bet 1 to num is equals to num\\n\\t\\t\\n        while( start <= end )\\n        {\\n            long long int mid = (start+end)/2;\\n\\t\\t\\t// if the square of the mid is equal to num\\n            if( mid*mid == num )\\n                return true;\\n\\t\\t\\t// else divide the problem set\\n            else if( mid*mid > num )\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        // if none of the square of number is equal to num, then we return false\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(long long int num)\\n    {\\n        long long int start = 1, end = num;\\n        \\n        // using binary search to find if square of any num bet 1 to num is equals to num\\n\\t\\t\\n        while( start <= end )\\n        {\\n            long long int mid = (start+end)/2;\\n\\t\\t\\t// if the square of the mid is equal to num\\n            if( mid*mid == num )\\n                return true;\\n\\t\\t\\t// else divide the problem set\\n            else if( mid*mid > num )\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        // if none of the square of number is equal to num, then we return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597005,
                "title": "100-faster-java-using-binary-search",
                "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num == 1) return true;\\n        long low = 1; long high = num/2;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }\\n            else if(mid * mid > num){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num == 1) return true;\\n        long low = 1; long high = num/2;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 486303,
                "title": "kotlin-simple-solution",
                "content": "```\\nfun isPerfectSquare(num: Int): Boolean {\\n    var counter = 1\\n\\n    //Increase the count until it is no longer less than the result of the number divided by it\\n    //1 < 16/1 ..... 4 < (16/4) for example\\n    while (counter < (num / counter)) {\\n        counter++\\n    }\\n\\n    return counter.times(counter) == num\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun isPerfectSquare(num: Int): Boolean {\\n    var counter = 1\\n\\n    //Increase the count until it is no longer less than the result of the number divided by it\\n    //1 < 16/1 ..... 4 < (16/4) for example\\n    while (counter < (num / counter)) {\\n        counter++\\n    }\\n\\n    return counter.times(counter) == num\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459681,
                "title": "c-binary-search-solution-beats-100",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPerfectSquare(int num) {\\n\\t\\t\\tif(num==1) return true;\\n\\t\\t\\tlong long low=1;\\n\\t\\t\\tlong long high=num;\\n\\t\\t\\tlong long mid;\\n\\t\\t\\twhile(low+1<high){\\n\\t\\t\\t\\tmid=(high-low)/2+low;\\n\\t\\t\\t\\tif(mid*mid>num){\\n\\t\\t\\t\\t\\thigh=mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlow=mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(mid*mid==num || low*low==num || high*high==num) return true;\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPerfectSquare(int num) {\\n\\t\\t\\tif(num==1) return true;\\n\\t\\t\\tlong long low=1;\\n\\t\\t\\tlong long high=num;\\n\\t\\t\\tlong long mid;\\n\\t\\t\\twhile(low+1<high){\\n\\t\\t\\t\\tmid=(high-low)/2+low;\\n\\t\\t\\t\\tif(mid*mid>num){\\n\\t\\t\\t\\t\\thigh=mid;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 83887,
                "title": "my-concise-and-easy-to-understand-java-solution-without-using-long",
                "content": "    public class Solution {\\n        public boolean isPerfectSquare(int num) {\\n            if (num < 0) return false;\\n            if (num == 0) return true;\\n            int start = 1, end = num, mid = 0;\\n            while (start <= end) {\\n                mid = (end - start) / 2 + start;\\n                if (mid * mid > num || mid * mid <= 0) end = mid - 1;\\n                else if (mid * mid < num ) start = mid + 1;\\n                else return true;\\n            }\\n            return start * start == num;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPerfectSquare(int num) {\\n            if (num < 0) return false;\\n            if (num == 0) return true;\\n            int start = 1, end = num, mid = 0;\\n            while (start <= end) {\\n                mid = (end - start) / 2 + start;\\n                if (mid * mid > num || mid * mid <= 0) end = mid - 1;\\n                else if (mid * mid < num ) start = mid + 1;\\n                else return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 83971,
                "title": "0ms-binary-search-based-solution",
                "content": "    public boolean isPerfectSquare(int x) {\\n            if(x <= 0) throw new IllegalArgumentException();\\n            if(x == 1) return true;\\n            int hi = x;\\n            int lo = 1;\\n            while(lo <= hi){\\n                int mid = lo + (hi - lo)/2;\\n                if(mid * mid == x) return true;\\n                int div = x/mid;\\n                if(div >= mid){\\n                    lo = mid + 1;\\n                }\\n                if(div < mid){\\n                    hi = mid - 1;\\n                }\\n            }\\n            return false;\\n       }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "    public boolean isPerfectSquare(int x) {\\n            if(x <= 0) throw new IllegalArgumentException();\\n            if(x == 1) return true;\\n            int hi = x;\\n            int lo = 1;\\n            while(lo <= hi){\\n                int mid = lo + (hi - lo)/2;\\n                if(mid * mid == x) return true;\\n                int div = x/mid;\\n                if(div >= mid){\\n                    lo = mid + 1;\\n                }\\n                if(div < mid){\\n                    hi = mid - 1;\\n                }\\n            }\\n            return false;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 83993,
                "title": "java-o-logn-binary-search-using-long",
                "content": "The reason to use long is that for large number such as 808201\\nthe mid * mid will be out of Integer.MAX_VALUE range.\\n\\n\\n    public class Solution {\\n        public boolean isPerfectSquare(int num) {\\n            long start = 1;\\n            long end = num;\\n            while (start < end) {\\n                long mid = start + (end - start) / 2;\\n                if (mid * mid == num) {\\n                    return true;\\n                } else if (mid * mid < num) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid;\\n                }\\n            }\\n            return start * start == num;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPerfectSquare(int num) {\\n            long start = 1;\\n            long end = num;\\n            while (start < end) {\\n                long mid = start + (end - start) / 2;\\n                if (mid * mid == num) {\\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4044012,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num-=i;\\n            i+=2;\\n        }\\n        return num==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num-=i;\\n            i+=2;\\n        }\\n        return num==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042050,
                "title": "python-2-approach-85-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        if num == 1:\\n            return True\\n\\n        half = num//2\\n        endpoint = half\\n        while half*half >= num:\\n            if half*half == num:\\n                # return half\\n                return True\\n            \\n            endpoint = half\\n            half = half//2\\n\\n        for i in range(half,endpoint):\\n            if i*i == num:\\n                return True\\n\\n        return False\\n\\n<!-- ========================================== -->\\n# ------------------------2ND APPROACH---------------\\n\\n        i = 1\\n        j = num\\n        while i <= j:\\n            mid_num = (i + j + 1) // 2\\n            val = mid_num ** 2\\n            if val < num:\\n                i = mid_num + 1\\n            elif val > num:\\n                j = mid_num - 1\\n            else:\\n                return True\\n        return False\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        if num == 1:\\n            return True\\n\\n        half = num//2\\n        endpoint = half\\n        while half*half >= num:\\n            if half*half == num:\\n                # return half\\n                return True\\n            \\n            endpoint = half\\n            half = half//2\\n\\n        for i in range(half,endpoint):\\n            if i*i == num:\\n                return True\\n\\n        return False\\n\\n<!-- ========================================== -->\\n# ------------------------2ND APPROACH---------------\\n\\n        i = 1\\n        j = num\\n        while i <= j:\\n            mid_num = (i + j + 1) // 2\\n            val = mid_num ** 2\\n            if val < num:\\n                i = mid_num + 1\\n            elif val > num:\\n                j = mid_num - 1\\n            else:\\n                return True\\n        return False\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008252,
                "title": "valid-perfect-square",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num)\\n     { int i=0;\\n         int end=sqrt(num);\\n         while(i<=end){\\n             if(i*i==num){\\n                 return true;\\n             }\\n             else\\n             if(i*i<num)\\n             {\\n                 i++;\\n\\n             }\\n             else\\n             end--;\\n         }\\n         return false;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num)\\n     { int i=0;\\n         int end=sqrt(num);\\n         while(i<=end){\\n             if(i*i==num){\\n                 return true;\\n             }\\n             else\\n             if(i*i<num)\\n             {\\n                 i++;\\n\\n             }\\n             else\\n             end--;\\n         }\\n         return false;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840340,
                "title": "easy-and-concise-c-beats-100",
                "content": "# Intuition\\nThe problem asks us to determine if a given number is a perfect square or not. A perfect square is an integer that is the square of some other integer. For example, 4, 9, 16, etc., are perfect squares because they can be expressed as the square of an integer (2, 3, and 4 respectively).\\n\\n# Approach\\nTo check if a given number is a perfect square, we can iterate through all possible integers starting from 1 up to the given number. For each integer i, we calculate the value of num/i. If this value is equal to i, it means that num is a perfect square. Otherwise, if i becomes greater than num/i, we can break out of the loop as there won\\'t be any more perfect squares beyond that point.\\n\\n# Complexity\\n- Time complexity: O(sqrt(n)) - We are iterating through all possible integers from 1 up to the given number, but the loop always breaks out when i>sqrt(n) and therefore takes sqrt(n) time.\\n- Space complexity: O(1) - We are using only a constant amount of extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num == 1) return true;\\n        double val;\\n        for (int i = 1; i < num; i++) {\\n            val = num * 1.0 / i;\\n            if (val == i) return true;\\n            else if (i > val) break;\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num == 1) return true;\\n        double val;\\n        for (int i = 1; i < num; i++) {\\n            val = num * 1.0 / i;\\n            if (val == i) return true;\\n            else if (i > val) break;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752121,
                "title": "easy-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n        int low = 1;\\n        int high = num;\\n\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            \\n            if (mid * mid < num) {\\n                low = (int) mid + 1;\\n            } else if (mid * mid > num) {\\n                high = (int) mid - 1;\\n            } else if (mid * mid == num) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n        int low = 1;\\n        int high = num;\\n\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            \\n            if (mid * mid < num) {\\n                low = (int) mid + 1;\\n            } else if (mid * mid > num) {\\n                high = (int) mid - 1;\\n            } else if (mid * mid == num) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666963,
                "title": "perfectsquare-best-solution-with-explanation-intuition-approach-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif `sqrt(num) == i` then `i*i = num` perhaps we could interate over value of `i` based on condition `i*i < num` \\n- When the loop ends i.e `i*i < num` is false, implies `i*i >= num`\\n- We return `i*i == num`, will return `true` if `i` is square root of `num`\\n`false` otherwise.\\n\\n*For better understanding go through Approach and Code*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We know that, minimum positive square root is 1.\\n- Given `num` is a **positive integer**, SquareRoot will also be positive\\n- To avoid `integer overflow`, we\\'ll use `unsigned int i`\\n\\n\\n****\\n**Please upvote if you find it helpful \\uD83D\\uDE09**\\n****\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        unsigned int i = 1;\\n        while(i*i<num) i++;\\n        return (i*i == num);\\n    }\\n};\\n```\\n****\\n**Please upvote if you find it helpful \\uD83D\\uDE09**\\n****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        unsigned int i = 1;\\n        while(i*i<num) i++;\\n        return (i*i == num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485460,
                "title": "easy-to-understand-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **All the values ends with 2, 3, 7, 8 are never perfect squares (just an simple observation). So if any value ends with these values then simply return false.** \\n\\n- Otherwise, \\n **Do Binary search from 1 to num (given), if square of mid is equal to sum then it\\'s true. if square of mid is greater than given num then if there is any possible value then  it must lie in the right side of mid otherwise if square of mid is less than given num then if there is a possible value then it must lie in the left side of the mid.** \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int lNum=num%10;\\n        if(lNum==2 || lNum==3 || lNum==7 || lNum==8){\\n            return false;\\n        }\\n        int start=1;\\n        int end=num;\\n        long long int mid= start+(end-start)/2;\\n        while(start<=end){\\n            long long int res = mid*mid;\\n            if(res==num){\\n                return true;\\n            }else if(res>num){\\n                end=mid-1;\\n            }else if(res<num){\\n                start=mid+1;\\n            }\\n            mid= (start+end)>>1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int lNum=num%10;\\n        if(lNum==2 || lNum==3 || lNum==7 || lNum==8){\\n            return false;\\n        }\\n        int start=1;\\n        int end=num;\\n        long long int mid= start+(end-start)/2;\\n        while(start<=end){\\n            long long int res = mid*mid;\\n            if(res==num){\\n                return true;\\n            }else if(res>num){\\n                end=mid-1;\\n            }else if(res<num){\\n                start=mid+1;\\n            }\\n            mid= (start+end)>>1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480871,
                "title": "java-binary-search-solution-beats-100-of-the-solution-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num==1)\\n        return true;\\n        long i=2;\\n        long j=num;\\n        while(i<j){\\n            long mid=i+(j-i)/2;\\n            long sq=mid*mid;\\n            if(sq==num)\\n            return true;\\n            else if(sq>num){\\n                j=mid;\\n            }\\n            else\\n            i=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num==1)\\n        return true;\\n        long i=2;\\n        long j=num;\\n        while(i<j){\\n            long mid=i+(j-i)/2;\\n            long sq=mid*mid;\\n            if(sq==num)\\n            return true;\\n            else if(sq>num){\\n                j=mid;\\n            }\\n            else\\n            i=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465174,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func isPerfectSquare(_ num: Int) -> Bool {\\n        var (l, r) = (1, num)\\n\\n        while l<=r{\\n            let mid = (l+r)/2\\n            let res = mid*mid\\n\\n            if res == num{\\n                return true\\n\\n            }else{\\n                res < num ? (l = mid + 1) : (r = mid - 1)\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isPerfectSquare(_ num: Int) -> Bool {\\n        var (l, r) = (1, num)\\n\\n        while l<=r{\\n            let mid = (l+r)/2\\n            let res = mid*mid\\n\\n            if res == num{\\n                return true\\n\\n            }else{\\n                res < num ? (l = mid + 1) : (r = mid - 1)\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431709,
                "title": "super-easy-solution-beats-100-beginners",
                "content": "\\n\\n# Approach\\n1. Initialize count variable\\n2. interate through a loop upto i*i<=n   \\n3. if i*i==n is met then increment count\\n4. now if count is equal to 1 then return true else false\\n\\n# Complexity\\n- Time complexity:\\nO(sqrt(n));\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n       int count = 0;\\n       for(long long int i=0; i*i<=num; i++){\\n           if(i*i == num){\\n               count++;\\n           }\\n       }\\n       if(count==1){\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n       int count = 0;\\n       for(long long int i=0; i*i<=num; i++){\\n           if(i*i == num){\\n               count++;\\n           }\\n       }\\n       if(count==1){\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362147,
                "title": "simple-binary-search-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n      if(num == 1) return true;\\n        int left = 0;\\n        int right = num;\\n        while(left <= right){\\n          double mid = left + (right - left) / 2;\\n          if(mid == num / mid) return true;\\n          if(mid > num / mid) right = mid - 1;\\n          else left = mid + 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n      if(num == 1) return true;\\n        int left = 0;\\n        int right = num;\\n        while(left <= right){\\n          double mid = left + (right - left) / 2;\\n          if(mid == num / mid) return true;\\n          if(mid > num / mid) right = mid - 1;\\n          else left = mid + 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329145,
                "title": "beats-95-speed-without-using-sqrt-python",
                "content": "# Intuition\\nmake number bigger until it is too big then make it smaller then bigger again but use smaller steps and repeat\\n\\n# Approach\\nbasically same as intuition, converted num to n so i didnt have to type extra letters but solution is quite long anyyway so had to type too many letters\\n\\n# Complexity\\n- Time complexity:\\nidk\\n\\n- Space complexity:\\n- sure\\n# Code\\n```\\nclass Solution(object):\\n    def isPerfectSquare(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        n=num\\n        if n == 0: \\n            return True\\n        elif n<0:\\n            return False\\n        elif n==1:\\n            return True\\n        x=1\\n        while x*x<n:\\n            x=x*2\\n        if x*x==n:\\n            return True\\n        no=0\\n        while no==0:\\n            x=floor(x/1.2)\\n\\n            if x*x<=n:\\n                no=1\\n        b=ceil(x/30)\\n        while x*x<n:\\n            x=x+b\\n        if x*x==n:\\n            return True\\n        while x*x>n:\\n            x=x-1\\n        if x*x==n:\\n            return True\\n        else:\\n            return False\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPerfectSquare(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        n=num\\n        if n == 0: \\n            return True\\n        elif n<0:\\n            return False\\n        elif n==1:\\n            return True\\n        x=1\\n        while x*x<n:\\n            x=x*2\\n        if x*x==n:\\n            return True\\n        no=0\\n        while no==0:\\n            x=floor(x/1.2)\\n\\n            if x*x<=n:\\n                no=1\\n        b=ceil(x/30)\\n        while x*x<n:\\n            x=x+b\\n        if x*x==n:\\n            return True\\n        while x*x>n:\\n            x=x-1\\n        if x*x==n:\\n            return True\\n        else:\\n            return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309345,
                "title": "no-brain-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return num in (i**2 for i in range(1, 46341))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return num in (i**2 for i in range(1, 46341))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281571,
                "title": "binary-search-algo-tc-o-logn-simplest-brute-force-and-optimized-approach",
                "content": "# Intuition\\nFind the number whose multiplication with itself is num.\\n\\n# Approach\\n**Brute Force approach**: Start with 1 and increment till multiplication with itself is less than or equals to num. If found return else return false.\\n**TC for this approach:** As we are iterating over numbers one by one till N/2, TC will be O(N)\\n**SC for this approach:** As we are just using few variables, SC will be O(1)\\n\\n**Optimized approach**: Our ultimate goal is to find if there a integer exists whose square is equal to num. As we can observe that minimum number which could be our possible ans is 0 and max number would be num itself. So we know our search space where our answer could possibly be. Now you have a range and data is sorted as well ( 0,1,2,3,....,N), let\\'s use binary search algorithm to find the possbile answer. If there exists a integer whose square equals the num, return true. If you didn\\'t find any answer after your search space is over, it means there is no such number exists whose square is num, which means, num is not perfect square and return false.\\n\\n**TC for this approach:** As we are reducing our search space to half every time hence TC will be O(logN)\\n**SC for this approach:** As we are just using few variables, SC will be O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long mid,left = 0, right = num;\\n        while(left <= right){\\n            mid = ((left + right) / 2 ) % 1000000007; // 1000000007 is largest prime number and we are taking mod to avoid overflowing\\n            if(mid * mid == num){\\n                return true;\\n            }else if(mid * mid < num){\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nKindly upvote if you learnt anything from my efforts. Happy learning! \\n![upvote.png](https://assets.leetcode.com/users/images/96a2089c-edf0-46be-bece-20bc43b6f0ff_1683977130.7090187.png)",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        long mid,left = 0, right = num;\\n        while(left <= right){\\n            mid = ((left + right) / 2 ) % 1000000007; // 1000000007 is largest prime number and we are taking mod to avoid overflowing\\n            if(mid * mid == num){\\n                return true;\\n            }else if(mid * mid < num){\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201805,
                "title": "who-would-have-thought-that-we-will-use-the-binary-search-here",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE APPROACH**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n      if(num==1){\\n          return true;\\n      }\\n      long long int start=2;\\n      long long int end=num/2;\\n      while(start<=end){\\n          long long int mid=start+(end-start)/2;\\n          if(mid*mid==num){\\n              return true;\\n          }\\n          else if(mid*mid<num){\\n              start=mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n      }\\n      return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n      if(num==1){\\n          return true;\\n      }\\n      long long int start=2;\\n      long long int end=num/2;\\n      while(start<=end){\\n          long long int mid=start+(end-start)/2;\\n          if(mid*mid==num){\\n              return true;\\n          }\\n          else if(mid*mid<num){\\n              start=mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n      }\\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185666,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, x: int) -> bool:\\n        l , r = 0 , x\\n        if x == 1: return 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if mid * mid == x:\\n                return True\\n            elif mid * mid > x:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, x: int) -> bool:\\n        l , r = 0 , x\\n        if x == 1: return 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if mid * mid == x:\\n                return True\\n            elif mid * mid > x:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098834,
                "title": "c-2-solutions-binary-search-math-approach-explained",
                "content": "# Intuition \\nUsing *Binary Search*, but rather than comparing key we used to search for, we *compare the square of mid with num*.\\n# Approach - 1\\nSame Binary Search approach \\nBut our loop breaking condition changes\\n`if (mid*mid == num)\\n{\\n    return true;\\n}`\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - 1 \\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long long int s = 0, e = num, mul, mid = (s + e)/2 ;\\n        while (s <= e)\\n        {\\n            mul = mid * mid ;\\n            if (mul == num)\\n            {\\n                return true ; \\n            }\\n            else if (mul > num)\\n            {\\n                e = mid - 1 ; \\n            }\\n            else\\n            {\\n                s = mid + 1 ; \\n            }\\n            mid = (s + e)/2;\\n        } \\n        return false ; \\n    }\\n};\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1 = 1\\n1 + 3 = 4\\n1 + 3 + 5 = 9\\n1 + 3 + 5 + 7 = 16\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\n*On adding consecutive odd numbers we get next perfect square*\\nInversely, if we subtract these odd numbers from the `num` given and get `0` in the end, it implies that the num is a perfect square\\nElse not \\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - 2\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        // 1 = 1\\n        // 1 + 3 = 4\\n        // 1 + 3 + 5 = 9\\n        // 1 + 3 + 5 + 7 = 16\\n        int a = 1 ; \\n        while (num > 0)\\n        {\\n            num -= a ;\\n            a += 2 ; \\n        }\\n        if (num == 0 )\\n        {\\n            return 1;\\n        }\\n        return 0 ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/fb18e486-ac3b-42f8-a76d-2afa6d5d3cc8_1674667689.2504847.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        long long int s = 0, e = num, mul, mid = (s + e)/2 ;\\n        while (s <= e)\\n        {\\n            mul = mid * mid ;\\n            if (mul == num)\\n            {\\n                return true ; \\n            }\\n            else if (mul > num)\\n            {\\n                e = mid - 1 ; \\n            }\\n            else\\n            {\\n                s = mid + 1 ; \\n            }\\n            mid = (s + e)/2;\\n        } \\n        return false ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        // 1 = 1\\n        // 1 + 3 = 4\\n        // 1 + 3 + 5 = 9\\n        // 1 + 3 + 5 + 7 = 16\\n        int a = 1 ; \\n        while (num > 0)\\n        {\\n            num -= a ;\\n            a += 2 ; \\n        }\\n        if (num == 0 )\\n        {\\n            return 1;\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981190,
                "title": "c-binary-search-solution-beats-100",
                "content": "# Intuition\\nBinary search \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n          int start = 1, end = num;\\n        while(start<=end){\\n            long long int mid = start + (end-start)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }\\n            else if(mid * mid < num){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1; \\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n          int start = 1, end = num;\\n        while(start<=end){\\n            long long int mid = start + (end-start)/2;\\n            if(mid * mid == num){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2951412,
                "title": "c-binary-search-technq-iterative-sol",
                "content": "\\n# Complexity\\n- Time complexity: O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n\\n        // Binary Search\\n        int s = 1 , e =num;\\n        while(s<=e){\\n            long long int mid = s+(e-s)/2;\\n            long long int sq = mid*mid; \\n            if(sq == num)return true;\\n            else if(sq > num) e = mid-1;\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return false;\\n\\n        // Brute Force\\n        for(long long int i=1;i<=num;i++){\\n            if(i*i==num){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n\\n        // Binary Search\\n        int s = 1 , e =num;\\n        while(s<=e){\\n            long long int mid = s+(e-s)/2;\\n            long long int sq = mid*mid; \\n            if(sq == num)return true;\\n            else if(sq > num) e = mid-1;\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return false;\\n\\n        // Brute Force\\n        for(long long int i=1;i<=num;i++){\\n            if(i*i==num){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930776,
                "title": "simple-0ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        float a = (float)Math.pow(num,0.5);\\n        if(a%1 == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        float a = (float)Math.pow(num,0.5);\\n        if(a%1 == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924945,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int n) {\\n        \\n        int st=1;\\n        int end=n;\\n        long mid;\\n        while(end>=st){\\n            mid=st+(end-st)/2;\\n            if(mid*mid==n){\\n                return true;\\n            }\\n            if(mid*mid>n){\\n                end=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n    return false;}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int n) {\\n        \\n        int st=1;\\n        int end=n;\\n        long mid;\\n        while(end>=st){\\n            mid=st+(end-st)/2;\\n            if(mid*mid==n){\\n                return true;\\n            }\\n            if(mid*mid>n){\\n                end=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n    return false;}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914712,
                "title": "python-and-cpp-solution-in-o-sqrt-num-time-complexity",
                "content": "# Intuition\\nnum = 16\\n\\ni = 1 , num/i = 16/1 = 16, 16>1 i.e. num/i > i\\ni = 2 , num/i = 16/2 = 8, 8>2 i.e. num/i >i\\ni = 3 , num/i = 16/3 = 5, 5>3 i.e. num/i > i\\ni = 4 , num/i = 16/4 = 4, 4==4 i.e. num/i==i\\ni = 5 , num/i = 16/5 = 3, 3<5 i.e. num/i<i\\n\\nSo here we can Observe a pattern, while finding for the square root of a number, if the quotient of the nums (divided by a number) is smaller than that number(which is dividing the nums) then we will not get the perfect square root of the given Number.\\n\\n# Approach\\nwe will break the search loop as we will hit the above condition i.e. if num/i<i then break.\\n\\n\\n# Complexity\\n- Time complexity: O(SQRT(NUM))\\n\\n- Space complexity: O(1)\\n\\n# Code\\nCOVERING OVERFLOW CONDITION (WHICH MAY ARISE IN C/C++/JAVA)\\n\\nSolution in CPP:\\n```\\nclass Solution1 {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num==1){\\n            return true; }\\n        for(int i=2;i<=num/2;i++)\\n        {\\n            if (num%i==0 && num/i == i) return true;\\n            if (num/i < i) break;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n\\nSolution in Python:\\n```\\nclass Solution5:\\n    def isPerfectSquare(self, num: int) -> bool: \\n        if num==1:\\n            return True \\n        for i in range(2,num//2+1):\\n            if num/i < i:\\n                break\\n            if num/i == i:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution1 {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if (num==1){\\n            return true; }\\n        for(int i=2;i<=num/2;i++)\\n        {\\n            if (num%i==0 && num/i == i) return true;\\n            if (num/i < i) break;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\n```\\nclass Solution5:\\n    def isPerfectSquare(self, num: int) -> bool: \\n        if num==1:\\n            return True \\n        for i in range(2,num//2+1):\\n            if num/i < i:\\n                break\\n            if num/i == i:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863895,
                "title": "easy-to-understand-python-solution-using-binary-search",
                "content": "# Intuition\\nUsing binary search to find if there is a sqrt of n that is an integer. \\n\\n# Code\\n```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        # if using sqrt func\\n        # rounded_sqrt = round(sqrt(num))\\n        # return rounded_sqrt == num \\n\\n        # without using sqrt func \\n        low = 1\\n        high = num\\n        \\n        while high >= low:\\n            middle = (high + low) // 2\\n            middle_sqrd = middle * middle\\n            if middle_sqrd == num:\\n                return True\\n            elif middle_sqrd < num:\\n                low = middle + 1\\n            # This could be else, but I thought this would be easier to understand.\\n            elif middle_sqrd > num:\\n                high = middle - 1\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        # if using sqrt func\\n        # rounded_sqrt = round(sqrt(num))\\n        # return rounded_sqrt == num \\n\\n        # without using sqrt func \\n        low = 1\\n        high = num\\n        \\n        while high >= low:\\n            middle = (high + low) // 2\\n            middle_sqrd = middle * middle\\n            if middle_sqrd == num:\\n                return True\\n            elif middle_sqrd < num:\\n                low = middle + 1\\n            # This could be else, but I thought this would be easier to understand.\\n            elif middle_sqrd > num:\\n                high = middle - 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855745,
                "title": "java-5ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    static int[] squares = fillSquares();\\n\\n    private static int[] fillSquares() {\\n        int[] res = new int[46340 + 1];\\n        for (int i = 1; i < res.length; i++) {\\n            res[i] = i * i;\\n        }\\n        return res;\\n    }\\n\\n    public boolean isPerfectSquare(int num) {\\n        return Arrays.binarySearch(squares, num) > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] squares = fillSquares();\\n\\n    private static int[] fillSquares() {\\n        int[] res = new int[46340 + 1];\\n        for (int i = 1; i < res.length; i++) {\\n            res[i] = i * i;\\n        }\\n        return res;\\n    }\\n\\n    public boolean isPerfectSquare(int num) {\\n        return Arrays.binarySearch(squares, num) > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810483,
                "title": "easy-c-solution-int-datatype-binary-search",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int s=1; int e= num;\\n        int mid= s+(e-s)/2;\\n        while(s<=e){ //high-low>=0\\n            //cout<<mid<<endl;\\n            if(num%mid==0 && mid==num/mid)return true;\\n            if (mid > num/mid){  //9 1 9 5 25>num\\n                e=mid-1;\\n            }\\n            else s= mid+1;\\n            mid= s+(e-s)/2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int s=1; int e= num;\\n        int mid= s+(e-s)/2;\\n        while(s<=e){ //high-low>=0\\n            //cout<<mid<<endl;\\n            if(num%mid==0 && mid==num/mid)return true;\\n            if (mid > num/mid){  //9 1 9 5 25>num\\n                e=mid-1;\\n            }\\n            else s= mid+1;\\n            mid= s+(e-s)/2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2810452,
                "title": "c-0mn-runtime-100-fast-easy-approach",
                "content": "Here is my c++ code for this problem\\nOptimized code:-\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPerfectSquare(int num) {\\n\\t\\t\\tint i=1, j=num;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\t//cout<<mid<<endl;\\n\\t\\t\\t\\tif(num%mid==0 && mid==num/mid){return true;}\\n\\t\\t\\t\\telse if(mid<num/mid){i=mid+1;}\\n\\t\\t\\t\\telse{j=mid-1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'\\nAlternate approach:-\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPerfectSquare(int num) {\\n\\t\\t\\tint i=0, j=num;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tlong long int mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(mid*mid==num){return true;}\\n\\t\\t\\t\\telse if(mid*mid<num){i=mid+1;}\\n\\t\\t\\t\\telse{j=mid-1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPerfectSquare(int num) {\\n\\t\\t\\tint i=1, j=num;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\t//cout<<mid<<endl;\\n\\t\\t\\t\\tif(num%mid==0 && mid==num/mid){return true;}",
                "codeTag": "C++"
            },
            {
                "id": 2800263,
                "title": "valid-perfect-sqaure",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double n = Math.sqrt(num);\\n        if(n/(int)n==1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n        double n = Math.sqrt(num);\\n        if(n/(int)n==1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738159,
                "title": "0ms-runtime-c-binary-search",
                "content": "C++ solution with 0ms runtime. Implemented using binary search:\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int left{1}, right{num}, middle{num/2};\\n\\n        while (left<=right) {\\n            float sqrt = (float)num/middle;\\n            if (sqrt == middle) return true;\\n            left = sqrt>middle ? middle+1:left;\\n            right = sqrt<middle ? middle-1:right;\\n            middle = left + (right-left)/2;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```\\n\\n*Upvote solution if it helped you!*",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int left{1}, right{num}, middle{num/2};\\n\\n        while (left<=right) {\\n            float sqrt = (float)num/middle;\\n            if (sqrt == middle) return true;\\n            left = sqrt>middle ? middle+1:left;\\n            right = sqrt<middle ? middle-1:right;\\n            middle = left + (right-left)/2;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731153,
                "title": "simple-soln",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num==1)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<=num/2;i++)\\n        {\\n            if(pow(i,2)==num)\\n            {\\n                return true;\\n                break;\\n            }\\n            if(pow(i,2)>num)\\n            {\\n                return false;\\n                break;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num==1)\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2711697,
                "title": "python-easy-solution-using-binary-search-in-o-logn",
                "content": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        l=0\\n        h=num\\n        m=(l+h)>>1\\n        while l<=h:\\n            if m*m==num:\\n                return True\\n            elif m*m>num:\\n                h=m-1\\n            else:\\n                l=m+1\\n            m=(l+h)>>1\\n        return False\\n ```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        l=0\\n        h=num\\n        m=(l+h)>>1\\n        while l<=h:\\n            if m*m==num:\\n                return True\\n            elif m*m>num:\\n                h=m-1\\n            else:\\n                l=m+1\\n            m=(l+h)>>1\\n        return False\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2695720,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\n/** 367. Valid Perfect Square **/\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\t\\n        long start = 1; long end = num;\\n  \\n        while(start <= end){\\n            long mid = (start+end)/2;\\n            if(mid*mid == num){\\n                return true;\\n            }\\n            if(mid*mid > num){    \\n                end = mid -1;\\n            }\\n            else{\\n                start = mid +1;\\n            }\\n        }\\n        return false;  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\t\\n        long start = 1; long end = num;\\n  \\n        while(start <= end){\\n            long mid = (start+end)/2;\\n            if(mid*mid == num){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2655110,
                "title": "python-o-n-o-n-o-logn-explained",
                "content": "# **1. BRUTE FORCE - O(N) - TLE**\\nSince the range of num is from 1 to 2^31 - 1, an O(N) solution will not work for all test cases. For huge numbers, you will get TLE.\\n\\nAnywyas, the idea is to go through each number and check which one\\'s square is num. If no number squares to num, return False.\\n\\n```\\ndef isPerfectSquare(self, num: int) -> bool:\\n        if num == 1: return True\\n        \\n        # Go through each number\\n        # And check if its square is equal to num\\n        for i in range(1, num + 1):\\n            if i * i == num: return True\\n        \\n        # Not a perfect square\\n        return False\\n```\\n\\n# **2. MAKING BRUTE FORCE SOLUTION WORK - O(\\u221AN)**\\nWhy bother going for values for which square is > num? That\\'s just extra work that we are doing which is of no use.\\n\\n```\\ndef isPerfectSquare(self, num: int) -> bool:\\n        if num == 1: return True\\n        \\n        # Go through each number from 1 to half of input number\\n        # And check if its square is equal to num\\n        for i in range(1, num + 1):\\n            if i * i == num: return True\\n            # Not a perfect square\\n            # Don\\'t waste time checking for numbers greater than i\\n            # Return from here itself\\n            if i * i > num: return False\\n        \\n        # Not a perfect square\\n        return False\\n```\\n\\n# **3. BINARY SEARCH - O(LogN)**\\n\\nWe know the square of a number is in range 1 to N/2 \\n\\nSo, if in this range, some number, X, is not squaring up to num, then why bother checking any number less than X? \\nSimilarly, if some number, X, has square more than num, why bother checking any number greater than X?\\n\\nThat\\'s the whole point in this Binary Search approach.\\n\\n\\n```\\ndef isPerfectSquare(self, num: int) -> bool:\\n        if num == 1: return True\\n        # For any number > 1, its square root can lie between 1 to half of that number\\n        # So we will apply Binary Search on range 1 to n/2\\n        start = 1\\n        end = num // 2\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            square = mid * mid\\n            # If square of mid is equal to number, that means, number is a perfect square\\n            if square == num : return True\\n            # If square of mid is less than number, that means, we need a bigger value\\n            # So move to right of mid\\n            if square < num: start = mid + 1\\n            # If square of mid is greater than number, that means, we need a smaller value\\n            # So move to left of mid\\n            else: end = mid - 1\\n        \\n        # Not a perfect Square\\n        return False\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef isPerfectSquare(self, num: int) -> bool:\\n        if num == 1: return True\\n        \\n        # Go through each number\\n        # And check if its square is equal to num\\n        for i in range(1, num + 1):\\n            if i * i == num: return True\\n        \\n        # Not a perfect square\\n        return False\\n```\n```\\ndef isPerfectSquare(self, num: int) -> bool:\\n        if num == 1: return True\\n        \\n        # Go through each number from 1 to half of input number\\n        # And check if its square is equal to num\\n        for i in range(1, num + 1):\\n            if i * i == num: return True\\n            # Not a perfect square\\n            # Don\\'t waste time checking for numbers greater than i\\n            # Return from here itself\\n            if i * i > num: return False\\n        \\n        # Not a perfect square\\n        return False\\n```\n```\\ndef isPerfectSquare(self, num: int) -> bool:\\n        if num == 1: return True\\n        # For any number > 1, its square root can lie between 1 to half of that number\\n        # So we will apply Binary Search on range 1 to n/2\\n        start = 1\\n        end = num // 2\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            square = mid * mid\\n            # If square of mid is equal to number, that means, number is a perfect square\\n            if square == num : return True\\n            # If square of mid is less than number, that means, we need a bigger value\\n            # So move to right of mid\\n            if square < num: start = mid + 1\\n            # If square of mid is greater than number, that means, we need a smaller value\\n            # So move to left of mid\\n            else: end = mid - 1\\n        \\n        # Not a perfect Square\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2602695,
                "title": "python-one-liner",
                "content": "not the most efficient, but a one-liner solution \\n```\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return int(str(float((num**(1/2)))).split(\\'.\\')[1]) == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def isPerfectSquare(self, num: int) -> bool:\\n        return int(str(float((num**(1/2)))).split(\\'.\\')[1]) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2552856,
                "title": "java-100-fastest-easy",
                "content": "![image](https://assets.leetcode.com/users/images/e644115c-53ea-49d0-9364-1cb0f4ac44b9_1662711880.6350954.png)\\nT.C : O(logN)\\nS.C : O(1)\\n```\\nclass Solution {\\n    public boolean isPerfectSquare(int n) {\\n        if(n==1)return true;\\n        long s=0,e=n/2;\\n        while(s<=e){\\n            long m=s+(e-s)/2;\\n            long sq=m*m;\\n            if(sq==n)return true;\\n            else if(sq>n)e=m-1;\\n            else s=m+1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**PLEASE UPVOTE IF YOU LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int n) {\\n        if(n==1)return true;\\n        long s=0,e=n/2;\\n        while(s<=e){\\n            long m=s+(e-s)/2;\\n            long sq=m*m;\\n            if(sq==n)return true;\\n            else if(sq>n)e=m-1;\\n            else s=m+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494798,
                "title": "javascript-binary-search-up-to-num",
                "content": "```\\nfunction isPerfectSquare(num) {\\n    let low = 1;\\n    let high = num;\\n    \\n    while (low <= high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const sqr = mid * mid;\\n        \\n        if (sqr < num) {\\n            low = mid + 1;\\n        }\\n        else if (sqr > num) {\\n            high = mid - 1;\\n        }\\n        else {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction isPerfectSquare(num) {\\n    let low = 1;\\n    let high = num;\\n    \\n    while (low <= high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const sqr = mid * mid;\\n        \\n        if (sqr < num) {\\n            low = mid + 1;\\n        }\\n        else if (sqr > num) {\\n            high = mid - 1;\\n        }\\n        else {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2467975,
                "title": "basic-python-solution",
                "content": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        #finding sqrt or nearest number\\n        n = 0\\n        while n*n <= num:\\n            n += 1\\n        sqrt = n-1\\n        \\n        #check condition of valid perfect square\\n        if sqrt*sqrt == num:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isPerfectSquare(self, num: int) -> bool:\\n        #finding sqrt or nearest number\\n        n = 0\\n        while n*n <= num:\\n            n += 1\\n        sqrt = n-1\\n        \\n        #check condition of valid perfect square\\n        if sqrt*sqrt == num:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408365,
                "title": "c-0-ms-faster-than-100-easy-small-code",
                "content": "First we make the base case when input is 0 which returns true.  Then we use a while loop. \\nThe **important condition** in the loop is making sure that **limit of square of i does not exceed the maximum value of int.**\\n```\\n int i = 1;\\n \\n        //base condition\\n        if(i == 0) {\\n            return true;\\n        }\\n        \\n\\t\\t//keeping square of i within the range of int max like below\\n        while(i <= num && i < INT_MAX/i) {\\n            \\n\\t\\t\\t// we check for every input integer given, if it is a square of some integer or not \\n            if (i*i == num) {\\n                return true;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//when the square is not found for one integer,\\n\\t\\t\\t//we update the condition and move on to the next integer\\n            else {\\n                i++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// we keep increasing i only until it is less than input number\\n\\t\\t\\t//because if i is greater than input than obviously it\\'s square will be greater too and not match for any \\n\\t\\t\\t//further value \\n        }\\n        \\n\\t\\t//if it is still not matched we then return false\\n        return false;\\n        \\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n int i = 1;\\n \\n        //base condition\\n        if(i == 0) {\\n            return true;\\n        }\\n        \\n\\t\\t//keeping square of i within the range of int max like below\\n        while(i <= num && i < INT_MAX/i) {\\n            \\n\\t\\t\\t// we check for every input integer given, if it is a square of some integer or not \\n            if (i*i == num) {\\n                return true;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//when the square is not found for one integer,\\n\\t\\t\\t//we update the condition and move on to the next integer\\n            else {\\n                i++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// we keep increasing i only until it is less than input number\\n\\t\\t\\t//because if i is greater than input than obviously it\\'s square will be greater too and not match for any \\n\\t\\t\\t//further value \\n        }\\n        \\n\\t\\t//if it is still not matched we then return false\\n        return false;\\n        \\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1686312,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1571639,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 2015672,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1576112,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1984540,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1817018,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1758060,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1733564,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 2076471,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 2027086,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1686312,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1571639,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 2015672,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1576112,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1984540,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1817018,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1758060,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1733564,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 2076471,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 2027086,
                "content": [
                    {
                        "username": "pavan0007",
                        "content": "Even i use binarySearch algo i doesn\\'t work for num = 2147483647;\\ntime limit was exceeding \\nhelp me out please\\n"
                    },
                    {
                        "username": "catchmesiddhant",
                        "content": "bool isPerfectSquare(int num) {\\n        if (num < 2) {\\n            return true;\\n        }\\n\\n        long left = 2;\\n        long right = num / 2;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long square = mid * mid;\\n\\n            if (square == num) {\\n                return true;\\n            } else if (square < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "Sagarsarkar",
                        "content": "bro u can take long mid = start + (end - start)/2;\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "[@Pavan](/pavan0007) \\ntemp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "codingstar2001",
                        "content": "used long long int instead of int, That solved my problem."
                    },
                    {
                        "username": "smithdashdash",
                        "content": "[@jacksonyyy](/jacksonyyy) this is the trickiest way to handle out of the range"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "bro try using long data type for i or you can check mine solutions "
                    },
                    {
                        "username": "charanBavaji",
                        "content": "[@suraj_3240](/suraj_3240)  thanks it worked"
                    },
                    {
                        "username": "suraj_3240",
                        "content": "For calculating mid value, try using long long int data type.\\nIt solved the issue in my case.\\n\\nBecause for int type (mid*mid) will not fit into the int range and will eventually overflow and hence TLE."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "try \"medium<num/medium\" bro ;)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "make your mid as of long type because when you do mid*mid it will exceed the range limit of integer and that's why it become zero and it will lead to TLE. Just make your mid as long.\n\nFor Example:-\n\n     \n      int start=1;\n\n    int end=num;\n\n    while(start<=end){\n\n    long mid=start+(end-start)/2;\n\n    if(mid*mid==num){\n        return true;\n    }\n\n    if(mid*mid<num){\n        start=(int)mid+1;\n    }\n\n    else{\n        end=(int)mid-1;\n    }\n\n    }\n\n    return false;"
                    },
                    {
                        "username": "YubiYubi",
                        "content": "I'm not entirely convinced that the Newton solution is really all that much better than the binary search log(n) solution.\\n\\nObviously, it takes more than one pass for the Newton solution to achieve the correct result. In fact, it takes *many* passes to reduce the initial \"guess\" to the square root of n. If you try it with the max integer size, 2147483647, Newton's iteration takes 20 cycles to even get to the correct integer value (and then has to continue cycling through ever-decreasing decimals). A log(n) binary search, on the other hand, takes 31 iterations, max.\\n\\nKnowing that, it seems a little disingenuous to call Newton's iteration solution a constant-time solution when it's arguably not really any better than a log(n) search. If you were asked this question in an interview, I feel that the binary search method would be the best way to handle this problem, especially since Newton's iteration is something you either know or you don't - you aren't expected to derive it yourself in a 30 minute interview.\\n\\nIs there anyone who knows the true Big O of Newton's iteration solution?"
                    },
                    {
                        "username": "eduard92",
                        "content": "take me back to 2016 when I was happy..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCDFAANG OPTIMISED CODE | O(1)\\uD83D\\uDE28| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/valid-perfect-square/solutions/2225109/faang-optimised-code-o1-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shivx_444",
                        "content": "use binary search approach and instead of arr[index] use mid*mid and target =num"
                    },
                    {
                        "username": "ElijahO",
                        "content": "return (num ** 0.5) % 1 == 0"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "please don\\'t post answers here!"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "bro played uno reverse\\n"
                    },
                    {
                        "username": "codingstar2001",
                        "content": "Thank !!!"
                    },
                    {
                        "username": "naz224598",
                        "content": " return not(num ** 0.5 % 1)"
                    },
                    {
                        "username": "pavan0007",
                        "content": "i think i doesn\\'t work for java \\ni think so....\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "though it is not exactly a library \"function\". this is a small cheat. the goal is to not use any sort of power or square root operation."
                    },
                    {
                        "username": "mihab",
                        "content": "For \"Time Limit Exceeded\" with Java language, use long instead of int."
                    },
                    {
                        "username": "chiranjivnagarajan",
                        "content": "still getting tle "
                    },
                    {
                        "username": "hoangnn451",
                        "content": "another way to avoid the max integer size is to use division"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "Yup, I did:\\n\\nint end = num/4 + 1;"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Please allow **unsafe** Rust solutions for this problem.\\nI want to implement the fast square root method and feel cool"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "```rust\\nunsafe fn is_perfect_square(num: i32) -> bool {\\n    if num < 0 {\\n        return false;\\n    }\\n    let root = floor_sqrt(num);\\n    root * root == num\\n}\\n\\nunsafe fn floor_sqrt(x: i32) -> i32 {\\n    let mut y: f64 = x as f64;\\n    let i: i64 = 0x5fe6eb50c7b537a9;\\n    y = *(&i as *const i64 as *const f64);\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    y = y * (3.0 - x as f64 * y * y) * 0.5;\\n    let i = (x as f64 * y + 1.0) as i32;\\n    i - (i * i > x) as i32\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "MY experience with this problem was quite confusing after applying binary search it was not successfully being sumitted but after sometime i changed my data types int to long and then it beated 100%"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this Works \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(i*i==num)\\n                return true;\\n            if(i*i>num)\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n\\nBut not this \\n\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        \\n        for( long int i=1;;i++)\\n        {\\n            if(pow(i,2)==num)\\n            return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "piyushpandey15",
                        "content": "cant use these functions  i guess \\n"
                    }
                ]
            },
            {
                "id": 1957510,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1940602,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1881909,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1870832,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1840612,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1827522,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1809722,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1805120,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1795827,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            },
            {
                "id": 1753297,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "bool isPerfectSquare(int num) {\\n        if (pow(num,0.5)-int(pow(num,0.5))==0)\\n            return true;\\n        return false;\\n    }\\n\\nNo \"sqrt()\" used\\nYou don\\'t play a game of statements with programmer :3"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "```\\nclass Solution {\\n    public boolean isPerfectSquare(int num) {\\n\\n            if(num ==1){\\n                return true;\\n            }\\n       int start = 0; int end = num;\\n       while(start<=end){\\n           int mid = start+(end-start)/2;\\n           if(mid*mid == num){\\n               return true;\\n            \\n           }\\n           else if(mid*mid >num){\\n               end = mid-1;\\n           }\\n           else {\\n               start = mid+1;\\n           }\\n       }\\n       return false;\\n    }\\n}\\n``` \\n\\ncan anyone explain me why taking the int gives the wrong answer for input 808201 \\nBUT when I take the data Type as long it gives me correct answer\\n\\nanyone plz explain ....It will big help for me"
                    },
                    {
                        "username": "LAKSHYA_BHATI",
                        "content": "coz. when you calculate mid*mid to compare with int num.. then that mid*mid may go out of int range\\nthats why using long "
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@tushar054](/tushar054) But Why can you plz explain\\n"
                    },
                    {
                        "username": "VivekYadav2095",
                        "content": "[@premsai_7](/premsai_7) But the value num  is mentioned as INT Datatype & we are finding the num by multiplying its square root . It means the value which we are finding , will be not  greater than num, either it will less than or equal to the num . \\n\\nI am still not getting why using LONG instead of INT \\n"
                    },
                    {
                        "username": "premsai_7",
                        "content": "INT is only used for certain range of integers .... if your input is above that range you have to use long "
                    },
                    {
                        "username": "tushar054",
                        "content": "Replace int to long"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean isPerfectSquare(int num) {\\n        long l = 1;\\n        long r = num;\\n        while(l<=r){\\n            long mid = l+(r-l)/2;\\n            long pow = mid*mid;\\n            if(pow>num){\\n                r = mid-1;\\n            }else if(pow<num){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Left should start with 2 rather then 0.\\nRight needs to be at num / 2 since all number\\'s sqrt lies before half of the number.\\nApply a binary search with its common 3 if else ladders.\\nAdd one more case where if the square of mid is less than num and square of mid+1 is greater than num then return False as the sqrt of num lies between those 2 numbers that means it not a perfect square.\\n\\n[Solution](https://leetcode.com/problems/valid-perfect-square/solutions/3443514/python-easy-solution-beats-90/)"
                    },
                    {
                        "username": "premsai_7",
                        "content": "Use Binary Search algorithm for this "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "temp =  math.sqrt(num)\\n    t = str(temp)\\n    if int(t[t.find(\".\")+1::]) > 0:\\n        return False\\n    return True\\n    "
                    },
                    {
                        "username": "soukumpan",
                        "content": "signed integer overflow: 404101 * 404101 cannot be represented in type \\'int\\'--------- hmmm "
                    },
                    {
                        "username": "sedulous_06",
                        "content": " if(num == 1)\\n        {\\n            return true;\\n        }\\n        long start = 2;\\n        long end = num/2;\\n        while(start <= end)\\n        {\\n            long mid = start + (end - start)/2;\\n            if(mid * mid == num)\\n            {\\n                return true;\\n            }\\n            else if(mid * mid > num)\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                end = mid + 1;\\n            }\\n        }\\n        return false;\\n\\nIt\\'s throwing TLE. Can anyone please help me out?"
                    },
                    {
                        "username": "codejava511",
                        "content": "start=mid+1\\nnot end=mid+1"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "we not use for loop and traverse from i=1 to i<=n and multiply i*i and compare with n\\n\\nwe use binary search from 1 to root n.\\nand we take our mid and multiply our mid*mid \\nif mid = n then that mid is root of that number n and return True\\nif mid > n then mid will shift towards left\\nand\\n if mid < n then mid will shift towards right\\n"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "Use long instead of int to passed all the testcase..................."
                    }
                ]
            }
        ]
    },
    {
        "title": "Unique Substrings in Wraparound String",
        "question_content": "<p>We define the string <code>base</code> to be the infinite wraparound string of <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, so <code>base</code> will look like this:</p>\n\n<ul>\n\t<li><code>&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;</code>.</li>\n</ul>\n\n<p>Given a string <code>s</code>, return <em>the number of <strong>unique non-empty substrings</strong> of </em><code>s</code><em> are present in </em><code>base</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Only the substring &quot;a&quot; of s is in base.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cac&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two substrings (&quot;a&quot;, &quot;c&quot;) of s in base.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;zab&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> There are six substrings (&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, and &quot;zab&quot;) of s in base.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 95439,
                "title": "concise-java-solution-using-dp",
                "content": "After failed with pure math solution and time out with DFS solution, I finally realized that this is a DP problem... \\nThe idea is, if we know the max number of unique substrings in ```p``` ends with ```'a', 'b', ..., 'z'```, then the summary of them is the answer. Why is that?\\n1. The max number of unique substring ends with a letter equals to the length of max contiguous substring ends with that letter. Example ```\"abcd\"```, the max number of unique substring ends with ```'d'``` is 4, apparently they are ```\"abcd\", \"bcd\", \"cd\" and \"d\"```.\\n2. If there are overlapping, we only need to consider the longest one because it covers all the possible substrings. Example: ```\"abcdbcd\"```, the max number of unique substring ends with ```'d'``` is 4 and all substrings formed by the 2nd ```\"bcd\"``` part are covered in the 4 substrings already.\\n3. No matter how long is a contiguous substring in ```p```, it is in ```s``` since ```s``` has infinite length.\\n4. Now we know the max number of unique substrings in ```p``` ends with ```'a', 'b', ..., 'z'``` and those substrings are all in ```s```. Summary is the answer, according to the question.\\n\\nHope I made myself clear...\\n```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        // count[i] is the maximum unique substring end with ith letter.\\n        // 0 - 'a', 1 - 'b', ..., 25 - 'z'.\\n        int[] count = new int[26];\\n        \\n        // store longest contiguous substring ends at current position.\\n        int maxLengthCur = 0; \\n\\n        for (int i = 0; i < p.length(); i++) {\\n            if (i > 0 && (p.charAt(i) - p.charAt(i - 1) == 1 || (p.charAt(i - 1) - p.charAt(i) == 25))) {\\n                maxLengthCur++;\\n            }\\n            else {\\n                maxLengthCur = 1;\\n            }\\n            \\n            int index = p.charAt(i) - 'a';\\n            count[index] = Math.max(count[index], maxLengthCur);\\n        }\\n        \\n        // Sum to get result\\n        int sum = 0;\\n        for (int i = 0; i < 26; i++) {\\n            sum += count[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```p```\n```'a', 'b', ..., 'z'```\n```\"abcd\"```\n```'d'```\n```\"abcd\", \"bcd\", \"cd\" and \"d\"```\n```\"abcdbcd\"```\n```'d'```\n```\"bcd\"```\n```p```\n```s```\n```s```\n```p```\n```'a', 'b', ..., 'z'```\n```s```\n```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        // count[i] is the maximum unique substring end with ith letter.\\n        // 0 - 'a', 1 - 'b', ..., 25 - 'z'.\\n        int[] count = new int[26];\\n        \\n        // store longest contiguous substring ends at current position.\\n        int maxLengthCur = 0; \\n\\n        for (int i = 0; i < p.length(); i++) {\\n            if (i > 0 && (p.charAt(i) - p.charAt(i - 1) == 1 || (p.charAt(i - 1) - p.charAt(i) == 25))) {\\n                maxLengthCur++;\\n            }\\n            else {\\n                maxLengthCur = 1;\\n            }\\n            \\n            int index = p.charAt(i) - 'a';\\n            count[index] = Math.max(count[index], maxLengthCur);\\n        }\\n        \\n        // Sum to get result\\n        int sum = 0;\\n        for (int i = 0; i < 26; i++) {\\n            sum += count[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458775,
                "title": "diego-s-understandable-explanations-c",
                "content": "Hi, I\\'m trying to make easily understandable explanations for everyone. Hopefully I did a good job here.\\n*Please upvote if this post helped you, so that others can find it.*\\n\\n**The insight**\\nThe problem insight comes from recognizing that there is a very specific infinite set of possible substrings that end in a particular character. Let\\'s look at an example.\\n\\nIf you want to think about the set of possible substrings that end in **z**, then we have the following...\\n```\\n{z, yz, xyz, wxyz, ...}\\n```\\n\\nTherefore, you can think of `p` as containing a subset of this infinite set for the ending character **z**. The key insight comes from noticing that this subset in `p` has the interesting property that having one element of this subset *implies* having others.\\n\\nUsing the above example, we see that having \"wxyz\" implies having \"xyz\", which implies having \"yz\", which implies having \"z\". In other words, you cannot have the substring \"wxyz\" but not have the substring \"z\", since one necessarily implies the other.\\n\\nOddly enough, we see that there is a connection between the number of elements in this subset and the length of its longest element: the size of the subset is the length of its longest element. In particular, if the longest substring ending in **z** that we find is \"wxyz\", then we can confidently say that there are 4 substrings that end in **z**.\\n\\nThis means that if we want to find all the possible substrings that end in a particular character (i.e. **z**) in `p`, then we only need to find the longest substring in `p` that ends with **z** and take its length.\\n\\n**Wrapping up**\\nNow you have a method to find all the substrings in `p` that end in a particular character. Last I checked, there are only 26 possible characters in the alphabet. So now you can find all the substrings in `p` that end in each character and add all of them!\\n\\nThis may sound some alarm in some of you, but don\\'t worry: all of the substrings you\\'re adding are indeed unique. After all, they end in different characters by definition, so none of them can be the same.\\n\\n**A solution**\\nThis solution can be optimized in some ways for improved performance, but I leave that exercise to the reader.\\n\\n```\\n// Remember that chars are glorified ints.\\nbool is_next(char a, char b) { return a == \\'z\\' ? b == \\'a\\' : a + 1 == b; }\\n\\nint findSubstringInWraproundString(string p) {\\n    unordered_map<char, int> max_lengths;\\n\\n    int max_length = 1; // The first character is one character long.\\n    for (size_t i = 0; i < p.size(); i++) {\\n\\t\\t// Is this the longest substring I\\'ve seen ending in this character?\\n        if (max_lengths.find(p[i]) == max_lengths.end()) {\\n\\t\\t\\t// Never seen this ending character, instantiate it.\\n            max_lengths[p[i]] = max_length;\\n        } else {\\n\\t\\t\\t// Maybe. Pick the longer one.\\n            max_lengths[p[i]] = max(max_length, max_lengths[p[i]]);\\n        }\\n\\t\\t\\n\\t\\t// Is the next character consecutive?\\n        if (i + 1 < p.size() && is_next(p[i], p[i + 1])) max_length++;\\n        else max_length = 1;\\n    }\\n\\t\\n\\t// Add all lengths!\\n    int res = 0;\\n    for (const pair<char, int>& kv : max_lengths) res += kv.second;\\n    return res;\\n}\\n```\\n\\n**What? How am I supposed to get that insight to begin with?**\\nGreat question. I don\\'t know. If you have an idea how, please comment below to help others.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n{z, yz, xyz, wxyz, ...}\\n```\n```\\n// Remember that chars are glorified ints.\\nbool is_next(char a, char b) { return a == \\'z\\' ? b == \\'a\\' : a + 1 == b; }\\n\\nint findSubstringInWraproundString(string p) {\\n    unordered_map<char, int> max_lengths;\\n\\n    int max_length = 1; // The first character is one character long.\\n    for (size_t i = 0; i < p.size(); i++) {\\n\\t\\t// Is this the longest substring I\\'ve seen ending in this character?\\n        if (max_lengths.find(p[i]) == max_lengths.end()) {\\n\\t\\t\\t// Never seen this ending character, instantiate it.\\n            max_lengths[p[i]] = max_length;\\n        } else {\\n\\t\\t\\t// Maybe. Pick the longer one.\\n            max_lengths[p[i]] = max(max_length, max_lengths[p[i]]);\\n        }\\n\\t\\t\\n\\t\\t// Is the next character consecutive?\\n        if (i + 1 < p.size() && is_next(p[i], p[i + 1])) max_length++;\\n        else max_length = 1;\\n    }\\n\\t\\n\\t// Add all lengths!\\n    int res = 0;\\n    for (const pair<char, int>& kv : max_lengths) res += kv.second;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95441,
                "title": "python-concise-solution",
                "content": "```\\ndef findSubstringInWraproundString(self, p):\\n        res = {i: 1 for i in p}\\n        l = 1\\n        for i, j in zip(p, p[1:]):\\n            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1\\n            res[j] = max(res[j], l)\\n        return sum(res.values())",
                "solutionTags": [],
                "code": "```\\ndef findSubstringInWraproundString(self, p):\\n        res = {i: 1 for i in p}\\n        l = 1\\n        for i, j in zip(p, p[1:]):\\n            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1\\n            res[j] = max(res[j], l)\\n        return sum(res.values())",
                "codeTag": "Python3"
            },
            {
                "id": 95454,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "1. O(n^3) check each substr, a hashtable is used to remove duplicate strings.\\n```\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size();\\n        unordered_set<string> ht;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++) {\\n                if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) break;\\n                ht.insert(p.substr(i,j-i+1));\\n            }\\n        return ht.size();\\n    }\\n```\\n2. O(n^2 logn), Each valid substr can be represented by the first char and the length, instead of the whole string.\\n```\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size();\\n        set<pair<char,int>> bst;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++) {\\n                if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) break;\\n                bst.insert(pair<char,int>(p[i],j-i+1));\\n            }\\n        return bst.size();\\n    }\\n```\\n3. O(n^2). For substrs starting at the same char, we only need to record the longest one. Because it covers all the shorter substrs starting from the char. The length is the number of substrings starting at the char.\\n```\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size(), len[26]={0};\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++) {\\n                if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) break;\\n                len[p[i]-'a'] = max(len[p[i]-'a'],j-i+1);\\n            }\\n        return accumulate(len,len+26,0);\\n    }\\n```\\n4. O(n). Getting the longest substr starting from each char can be done in linear time. We can use two pointers to keep track of the current valid substring.\\n```\\n    int findSubstringInWraproundString(string p) {\\n        int len[26]={0}, i = 0, n = p.size();\\n        for(int j=0;j<n;j++)\\n            if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) {\\n                for(int k=i;k<min(j,i+26);k++) len[p[k]-'a'] = max(len[p[k]-'a'],j-k);\\n                i=j--;\\n            }\\n        for(int k=i;k<min(n,i+26);k++) len[p[k]-'a'] = max(len[p[k]-'a'],n-k);\\n        return accumulate(len,len+26,0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size();\\n        unordered_set<string> ht;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++) {\\n                if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) break;\\n                ht.insert(p.substr(i,j-i+1));\\n            }\\n        return ht.size();\\n    }\\n```\n```\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size();\\n        set<pair<char,int>> bst;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++) {\\n                if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) break;\\n                bst.insert(pair<char,int>(p[i],j-i+1));\\n            }\\n        return bst.size();\\n    }\\n```\n```\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size(), len[26]={0};\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++) {\\n                if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) break;\\n                len[p[i]-'a'] = max(len[p[i]-'a'],j-i+1);\\n            }\\n        return accumulate(len,len+26,0);\\n    }\\n```\n```\\n    int findSubstringInWraproundString(string p) {\\n        int len[26]={0}, i = 0, n = p.size();\\n        for(int j=0;j<n;j++)\\n            if(j>i && p[j-1]+1!=p[j] && p[j-1]-p[j]!=25) {\\n                for(int k=i;k<min(j,i+26);k++) len[p[k]-'a'] = max(len[p[k]-'a'],j-k);\\n                i=j--;\\n            }\\n        for(int k=i;k<min(n,i+26);k++) len[p[k]-'a'] = max(len[p[k]-'a'],n-k);\\n        return accumulate(len,len+26,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1473555,
                "title": "c-explained-solution-o-n",
                "content": "\\n## Explanation\\n\\n**Part 1**\\nLets think of the problem for a second as counting the substrings in the wraparound string and forget about the unique part.\\n* For a single character lets say \"a\" the answer is 1 (**current answer: 1**). \\n* Now if we add another character in continuation, we have the string \"ab\". We now are able to form as many solutions as previous answer (i.e. 1 - \"b\") plus 1 (i.e. \"ab\" which includes all the characters) (**current answer: 2**).\\n* Similarly, adding \"c\" we have the string as \"abc\" and we\\'ll be able to form as many substrings as previous answer also having the last character \"c\" (i.e. 2 - \"c\",\"bc\") plus 1 having all characters (i.e. 3 -\"abc\") (**current answer: 3**).\\n\\n*By now it would be clear but let\\'s do this one last time.* \\n* Adding \"d\" we have the string \"abcd\" and we\\'ll be able to form as many solutions as previous answer which has one length lesser and having the last character \"d\" (i.e 3 - \"d\",\"cd\",\"bcd\") plus 1 having all the characters (\"abcd\") (**current answer: 4**).\\n\\nAdding current answer at each step in our final answer will give us the solution.\\n\\n*Note: As soon as continuation breaks (\"abcdm\" continuation breaks at \"m\") we\\'ll reset the current answer to 1.*\\n\\n\\n**In summary the answer is the sum of lengths of all the continuous substrings found (For non unique solution).**\\n\\n**Part 2**\\n\\nTo deal with unique substrings we\\'ll create a 26 size array initialized with 0.\\nAt each string index i, we store the answer at that point (i.e. current answer) in the array. The current answer is stored in the array position of the respective character found at index i.\\n\\nLets take an example string \"ababc\".\\n* Initially the array is ```[0,0,0,0,.....]```\\n* At string index 0, array becomes ```[1,0,0,0,.....]``` (because the answer at that point is 1 for \"a\").\\n* At string index 1, array becomes ```[1,2,0,0,.....]``` (the current answer is 2 for \"ab\").\\n* At string index 2, the continuation breaks. Hence we set the current answer to 1. Since we have 1 at the position of \"a\" in the array, we know that we must have found a substring having length 1 ending at \"a\" (i.e. \"a\") hence we do nothing at this point at go to the next step.\\n* At string index 3, we have the current answer as 2 (for string \"ab\"). Since we already have 2 at position \"b\" in the array, we know that we have previously found substring ending at \"b\" of length 2 (i.e. \"ab\") hence we do nothing and go to the next step.\\n* At string index 4, we calculate the current answer as 3 (for string \"abc\"). Since at position \"c\" in the array we have 0, this is the best solution found at this point. The array becomes ```[1,2,3,0,.....]```.\\n\\n**If at any point we find a greater or equal number in the array, we know that we have already found a  solution in which our current answer solution is included. If our current answer is better than the one stored in the array for the respective character than we\\'ll replace it with our current answer. The final answer is the sum of the elements in the array.**\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int ans=1,prev_ans=1;\\n        vector<int> arr(26,0);\\n        arr[p[0]-\\'a\\']=1;\\n        for (int i=1;i<p.size();i++){\\n            if ((p[i-1]-\\'a\\'+1)%26==p[i]-\\'a\\') // Checking for continuation\\n                prev_ans++;\\n            else\\n                prev_ans=1;\\n            if (arr[p[i]-\\'a\\']<prev_ans){\\n                ans+=prev_ans-arr[p[i]-\\'a\\'];\\n                arr[p[i]-\\'a\\']=prev_ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Please consider upvoting if you found this solution helpful***\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```[0,0,0,0,.....]```\n```[1,0,0,0,.....]```\n```[1,2,0,0,.....]```\n```[1,2,3,0,.....]```\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int ans=1,prev_ans=1;\\n        vector<int> arr(26,0);\\n        arr[p[0]-\\'a\\']=1;\\n        for (int i=1;i<p.size();i++){\\n            if ((p[i-1]-\\'a\\'+1)%26==p[i]-\\'a\\') // Checking for continuation\\n                prev_ans++;\\n            else\\n                prev_ans=1;\\n            if (arr[p[i]-\\'a\\']<prev_ans){\\n                ans+=prev_ans-arr[p[i]-\\'a\\'];\\n                arr[p[i]-\\'a\\']=prev_ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95448,
                "title": "c-concise-solution",
                "content": "```\\nint findSubstringInWraproundString(string p) {\\n        vector<int> letters(26, 0);\\n        int res = 0, len = 0;\\n        for (int i = 0; i < p.size(); i++) {\\n            int cur = p[i] - 'a';\\n            if (i > 0 && p[i - 1] != (cur + 26 - 1) % 26 + 'a') len = 0;\\n            if (++len > letters[cur]) {\\n                res += len - letters[cur];\\n                letters[cur] = len;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findSubstringInWraproundString(string p) {\\n        vector<int> letters(26, 0);\\n        int res = 0, len = 0;\\n        for (int i = 0; i < p.size(); i++) {\\n            int cur = p[i] - 'a';\\n            if (i > 0 && p[i - 1] != (cur + 26 - 1) % 26 + 'a') len = 0;\\n            if (++len > letters[cur]) {\\n                res += len - letters[cur];\\n                letters[cur] = len;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747989,
                "title": "c-dynamic-programming-simple-and-concise",
                "content": "`cnt[i]` stores the number of unique substring ending at character `\\'a\\'+i`. For example `cnt[3]` will count how many unique substrings ending with `d` are there. The condition `p[i-1]-p[i]==25` is when we encount substring like `.....za...`.\\n```c++\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> cnt(26,0);\\n        int n=p.length();\\n        int mx=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 and (p[i]-p[i-1]==1 or p[i-1]-p[i]==25))\\n                mx++;\\n            else\\n                mx=1;\\n            cnt[p[i]-\\'a\\']=max(cnt[p[i]-\\'a\\'],mx);\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)ans+=cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> cnt(26,0);\\n        int n=p.length();\\n        int mx=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 and (p[i]-p[i-1]==1 or p[i-1]-p[i]==25))\\n                mx++;\\n            else\\n                mx=1;\\n            cnt[p[i]-\\'a\\']=max(cnt[p[i]-\\'a\\'],mx);\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)ans+=cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493713,
                "title": "python-solution-with-explanation",
                "content": "This is basically @fire4fly\\'s solution but since there was no explanation I needed some time to figure out what exactly is being done and hopefully i\\'ll help someone else with this post.\\n\\n**Solution**\\n\\nWe are doing a one pass on the string. On each step we compare if our current and previous character are one after the other in the alphabet - with wrapping over for \\'z\\' and \\'a\\' (the % 26 helps with that).\\n\\nThe goal is to count for each character in `p` what\\'s the longest matching substring before that character. We store the longest substring before the character in our dict `d`, and at the end return sum of all values in dict. Our dict[x] for letter `x` is actually storing the ammount of unique combinations we found that end with that letter `x`.\\n\\n**Example**\\nIf our string is `p = \"abczbcde\"`, our dict at the end will look something like this:\\n`\\'a\\': 1, \\'b\\': 2, \\'c\\': 3, \\'z\\': 1, \\'d\\': 3, \\'e\\': 4}`\\nThis means our final result is 14 unique strings.\\nWhen we iterate through the first 4 characters(`abcz`) we will find 7 unique combinations:\\n`a, b, ab, c, bc, abc, z` \\nand our dict will look like:\\n`\\'a\\': 1, \\'b\\': 2, \\'c\\': 3, \\'z\\': 1`\\nOnce we get to the `bcde` part of the string, when we evaluate the `b` and `c`, they will have shorter streaks of matching characters before them, so we won\\'t overwrite the values in our dict for those characters - because basically we already found the combinations `b, c, bc` before that, and the only remaining unique combinations are:\\n`d, bcd, cd, e, de, bcde, cde`\\n\\n**Code**\\n```class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        from collections import defaultdict\\n        d = defaultdict(int)\\n        streak = 0 \\n        for i in range(len(p)):\\n            streak = streak + 1 if (ord(p[i - 1]) - 96) % 26 == (ord(p[i]) - 97) else 1\\n            d[p[i]] = max(d[p[i]], streak)\\n        return sum(d.values())```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        from collections import defaultdict\\n        d = defaultdict(int)\\n        streak = 0 \\n        for i in range(len(p)):\\n            streak = streak + 1 if (ord(p[i - 1]) - 96) % 26 == (ord(p[i]) - 97) else 1\\n            d[p[i]] = max(d[p[i]], streak)\\n        return sum(d.values())```",
                "codeTag": "Java"
            },
            {
                "id": 630639,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] count=new int[26];\\n        int max=0;\\n        for (int i=0;i<p.length();i++){\\n            if (i>0 && (p.charAt(i)-p.charAt(i-1)==1 || p.charAt(i-1)-p.charAt(i)==25)) max++;\\n            else max=1;\\n            int ind=p.charAt(i)-\\'a\\';\\n            count[ind]=Math.max(count[ind],max);            \\n        }\\n        int sum=0;\\n        for (int i=0;i<26;i++){\\n            sum+=count[i];\\n        }\\n        return sum;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] count=new int[26];\\n        int max=0;\\n        for (int i=0;i<p.length();i++){\\n            if (i>0 && (p.charAt(i)-p.charAt(i-1)==1 || p.charAt(i-1)-p.charAt(i)==25)) max++;\\n            else max=1;\\n            int ind=p.charAt(i)-\\'a\\';\\n            count[ind]=Math.max(count[ind],max);            \\n        }\\n        int sum=0;\\n        for (int i=0;i<26;i++){\\n            sum+=count[i];\\n        }\\n        return sum;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193957,
                "title": "c-solution-dynamic-programming-easy-to-understand",
                "content": "\\tint findSubstringInWraproundString(string p) {\\n\\t\\t\\tint n = p.length();\\n\\t\\t\\tif(n == 0 || n == 1)\\n\\t\\t\\t\\treturn n;\\n\\t\\t\\t\\n\\t\\t\\t//the freq of substring ending at ith character\\n\\t\\t\\tvector<int> count(26,0);\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint length = 1;;\\n\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t//if the substring is making a continuous sequence then increase the length\\n\\t\\t\\t\\tif((i > 0) && ((p[i] - p[i-1] == 1) || (p[i-1] - p[i] == 25))){\\n\\t\\t\\t\\t\\tlength++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint idx = p[i] - \\'a\\';\\n\\t\\t\\t\\t//uodate the freq.\\n\\t\\t\\t\\tcount[idx] = max(count[idx], length);\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//take the summation of the freq.\\n\\t\\t\\tfor(auto freq: count){\\n\\t\\t\\t\\tans += freq;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\nfor example - \"abcabdzabcd\"\\ni==0 count[a] = 1;\\ni==1 count[b] = 2;\\ni==3 count[c] = 3;\\ni==4 count[a] = 1;\\ni==5 count[b] = 2;\\ni==6 count[d] = 1;\\ni==7 count[z] = 1;\\ni==8 count[a] = max(1,2) = 2;\\ni==9 count[b] = 3;\\ni==10 count[c] = 4;\\ni==11 count[d] = 5;",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\tint findSubstringInWraproundString(string p) {\\n\\t\\t\\tint n = p.length();\\n\\t\\t\\tif(n == 0 || n == 1)\\n\\t\\t\\t\\treturn n;\\n\\t\\t\\t\\n\\t\\t\\t//the freq of substring ending at ith character\\n\\t\\t\\tvector<int> count(26,0);\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint length = 1;;\\n\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t//if the substring is making a continuous sequence then increase the length\\n\\t\\t\\t\\tif((i > 0) && ((p[i] - p[i-1] == 1) || (p[i-1] - p[i] == 25))){\\n\\t\\t\\t\\t\\tlength++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint idx = p[i] - \\'a\\';\\n\\t\\t\\t\\t//uodate the freq.\\n\\t\\t\\t\\tcount[idx] = max(count[idx], length);\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//take the summation of the freq.\\n\\t\\t\\tfor(auto freq: count){\\n\\t\\t\\t\\tans += freq;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\nfor example - \"abcabdzabcd\"\\ni==0 count[a] = 1;\\ni==1 count[b] = 2;\\ni==3 count[c] = 3;\\ni==4 count[a] = 1;\\ni==5 count[b] = 2;\\ni==6 count[d] = 1;\\ni==7 count[z] = 1;\\ni==8 count[a] = max(1,2) = 2;\\ni==9 count[b] = 3;\\ni==10 count[c] = 4;\\ni==11 count[d] = 5;",
                "codeTag": "Unknown"
            },
            {
                "id": 95463,
                "title": "concise-o-n-6-liner-in-python",
                "content": "Record the longest length for the substrings that end with each letter.\\n\\nUse ```'abcdefghijklmnopqrstuvwxyza\\u2019``` to check if two letters are near each other.\\n\\n```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        p, d, lo = '0'+p, collections.defaultdict(int), 0\\n        for hi in range(1, len(p)):\\n            if p[hi-1]+p[hi] not in 'abcdefghijklmnopqrstuvwxyza':\\n                lo = hi\\n            d[p[hi]] = max(d[p[hi]], hi+1-lo)\\n        return sum(d.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```'abcdefghijklmnopqrstuvwxyza\\u2019```\n```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        p, d, lo = '0'+p, collections.defaultdict(int), 0\\n        for hi in range(1, len(p)):\\n            if p[hi-1]+p[hi] not in 'abcdefghijklmnopqrstuvwxyza':\\n                lo = hi\\n            d[p[hi]] = max(d[p[hi]], hi+1-lo)\\n        return sum(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95474,
                "title": "python-o-n-dp",
                "content": "I use cmap[c] to store the maximum length of sub-string starts with c.\\n\\nThe time complexity of the code below is  O(n) as well.\\n\\n```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        pattern = 'zabcdefghijklmnopqrstuvwxyz'\\n        cmap = collections.defaultdict(int)\\n        start = end = 0\\n        for c in range(len(p)):\\n            if c and p[c-1:c+1] not in pattern:\\n                for x in range(start, end):\\n                    cmap[p[x]] = max(end - x, cmap[p[x]])\\n                start = c\\n            end = c + 1\\n        for x in range(start, end):\\n            cmap[p[x]] = max(end - x, cmap[p[x]])\\n        return sum(cmap.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        pattern = 'zabcdefghijklmnopqrstuvwxyz'\\n        cmap = collections.defaultdict(int)\\n        start = end = 0\\n        for c in range(len(p)):\\n            if c and p[c-1:c+1] not in pattern:\\n                for x in range(start, end):\\n                    cmap[p[x]] = max(end - x, cmap[p[x]])\\n                start = c\\n            end = c + 1\\n        for x in range(start, end):\\n            cmap[p[x]] = max(end - x, cmap[p[x]])\\n        return sum(cmap.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366143,
                "title": "javascript-dp-solution-detailed-explanation",
                "content": "Explanation:\\nThe trick to answering this question is realizing that the number of unique substrings within a string is ultimately the *sum* of all the substrings. Now that statement alone isn\\'t very helpful so let\\'s do an example\\n\\nSay we have string \\'zabcra\\':\\n1. First, we\\'re going to initialize an array which we\\'ll call dp with size 26. \\n```[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]```\\n2. Set the value of dp[p[0].charCodeAt() - 97] to 1\\nAll p[0].charCodeAt() - 97 does is convert a letter a-z to 0-25, so we just took the first letter in p, converted it to a value we can use as an index, and then set the value of dp at that index to 1\\n```[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\\n3. Iterate through p starting at index 1 since we\\'ve just taken care of p[0]\\n4. Check to see if (p[i] - p[i - 1] === 1 || p[i] - p[i - 1] === -25), because if it does, that means we have consecutive letters in p, and therefore a substring within p. We\\'ll use a new variable, currentMax, to keep track of the length of the substring. In the first iteration of this example, we find that we have a valid substring, \\'za\\'.\\n\\n\\tAt the end of each iteration within the loop, we update dp by setting \\n\\t```dp[p[i].charCodeAt() - 97]``` to whichever\\'s greater between its current value or currentMax:\\n``` dp[p[i].charCodeAt() - 97] = Math.max(dp[p[i].charCodeAt() - 97], currentMax)```\\n\\n\\twhich gives us\\n```[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\\n\\n\\tSo what does this do? currentMax keeps track of the length of the current substring, which also happens to be the same as the number of substrings that end with the last character of that substring. Right now, our current substring is \\'za\\', and the substring \\'za\\' ends with \\'a\\'. The substrings within \\'za\\' that end with \\'a\\' including itself are \\'za\\', and \\'a\\'. That\\'s 2 substrings, just like currentMax. Neat.\\n\\n5. Continue with the loop and the next iteration we have run into \\'b\\', making our total current substring \\'zab\\' currentMax = 3\\n ```[2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\\n\\'zab\\', \\'ab\\', \\'b\\'\\n6. Next we run into \\'c\\', currentMax = 4\\n ```[2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\\n\\'zabc\\', \\'abc\\', \\'bc, \\'c\\'\\n7. Next, we run into \\'r\\', so what do we do? Since the condition \\n\\t```(p[i] - p[i - 1] === 1 || p[i] - p[i - 1] === -25)``` is not met, we instead set the currentMax to 1. Remember, at the end of the iteration, we update a value in dp by doing the check (in this case, since we\\'ve run into \\'r\\' it\\'ll be)\\n```dp[index at r] = Math.max(dp[index at r], currentMax)```\\nso we end up with\\n ```[2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1]```\\n8. \\'a\\' is up next, and again, we don\\'t have consecutive characters so, currentMax gets set to 1, and we make the comparison \\n``` dp[index at a] = Math.max(dp[index at a], currentMax)```\\nSince our current substring containing \\'a\\' (currentMax = 1) is smaller than the other substring containing \\'a\\' that we\\'ve encountered (dp[index at a] = 2), dp[index at a] gets set to itself.\\n9. Now that we\\'ve finished iterating through p and storing the count of unique substrings in dp, all we have to do is sum them up and return the value.\\n\\nCode:\\n```\\nvar findSubstringInWraproundString = function(p) {\\n    if (p.length === 0) return 0;\\n    const dp = new Array(26).fill(0);\\n    dp[p[0].charCodeAt() - 97] = 1;\\n    \\n\\tlet currentMax = 1;\\n    for (let i = 1; i < p.length; i++) {\\n        let prevCharIdx = p[i - 1].charCodeAt() - 97;\\n        let charIdx = p[i].charCodeAt() - 97;\\n        if (charIdx - prevCharIdx === 1 || charIdx - prevCharIdx === -25) {\\n            currentMax++;\\n        } else {\\n            currentMax = 1;\\n        }\\n        dp[charIdx] = Math.max(dp[charIdx], currentMax)\\n    }\\n    \\n    return dp.reduce((acc, val) => acc + val);\\n};\\n```",
                "solutionTags": [],
                "code": "```[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]```\n```[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\n```dp[p[i].charCodeAt() - 97]```\n``` dp[p[i].charCodeAt() - 97] = Math.max(dp[p[i].charCodeAt() - 97], currentMax)```\n```[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\n```[2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\n```[2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]```\n```(p[i] - p[i - 1] === 1 || p[i] - p[i - 1] === -25)```\n```dp[index at r] = Math.max(dp[index at r], currentMax)```\n```[2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1]```\n``` dp[index at a] = Math.max(dp[index at a], currentMax)```\n```\\nvar findSubstringInWraproundString = function(p) {\\n    if (p.length === 0) return 0;\\n    const dp = new Array(26).fill(0);\\n    dp[p[0].charCodeAt() - 97] = 1;\\n    \\n\\tlet currentMax = 1;\\n    for (let i = 1; i < p.length; i++) {\\n        let prevCharIdx = p[i - 1].charCodeAt() - 97;\\n        let charIdx = p[i].charCodeAt() - 97;\\n        if (charIdx - prevCharIdx === 1 || charIdx - prevCharIdx === -25) {\\n            currentMax++;\\n        } else {\\n            currentMax = 1;\\n        }\\n        dp[charIdx] = Math.max(dp[charIdx], currentMax)\\n    }\\n    \\n    return dp.reduce((acc, val) => acc + val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616613,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {        \\n        int len = p.length();\\n        if(len == 0) return 0;\\n        if(len == 1) return 1;\\n        vector<int> res(26, 0);\\n        int count = 1;\\n        res[p[0]-\\'a\\'] = 1;\\n        for(int i = 1; i < len; i++){\\n            if(p[i] == p[i-1]+1 || (p[i] == \\'a\\' && p[i-1] == \\'z\\')){\\n                count++;\\n                res[p[i]-\\'a\\'] = max(res[p[i]-\\'a\\'], count);\\n            }\\n            else{\\n                res[p[i]-\\'a\\'] = max(res[p[i]-\\'a\\'], 1);\\n                count = 1;\\n            }\\n        }\\n        int cnt = 0;\\n        for(int num : res){\\n            cnt += num;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {        \\n        int len = p.length();\\n        if(len == 0) return 0;\\n        if(len == 1) return 1;\\n        vector<int> res(26, 0);\\n        int count = 1;\\n        res[p[0]-\\'a\\'] = 1;\\n        for(int i = 1; i < len; i++){\\n            if(p[i] == p[i-1]+1 || (p[i] == \\'a\\' && p[i-1] == \\'z\\')){\\n                count++;\\n                res[p[i]-\\'a\\'] = max(res[p[i]-\\'a\\'], count);\\n            }\\n            else{\\n                res[p[i]-\\'a\\'] = max(res[p[i]-\\'a\\'], 1);\\n                count = 1;\\n            }\\n        }\\n        int cnt = 0;\\n        for(int num : res){\\n            cnt += num;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195867,
                "title": "no-dp-one-iteration",
                "content": "the vector<int> lens record the max ascending string starting from this character.\\n```\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> lens(26, 0);\\n        int i = 0;\\n        int j = 1;\\n        while (j <= p.length()) {\\n            while (p[j]==\\'a\\' && p[j-1]==\\'z\\' || p[j]==p[j-1]+1) {\\n                j++;\\n            }\\n            while (i < j) {\\n                lens[p[i]-\\'a\\'] = max(lens[p[i]-\\'a\\'], j-i);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return accumulate(lens.begin(), lens.end(), 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> lens(26, 0);\\n        int i = 0;\\n        int j = 1;\\n        while (j <= p.length()) {\\n            while (p[j]==\\'a\\' && p[j-1]==\\'z\\' || p[j]==p[j-1]+1) {\\n                j++;\\n            }\\n            while (i < j) {\\n                lens[p[i]-\\'a\\'] = max(lens[p[i]-\\'a\\'], j-i);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return accumulate(lens.begin(), lens.end(), 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046327,
                "title": "had-to-dust-off-my-c-for-this-solution-9ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the substring in the given string that is a consecutive sequence of letters\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI will use a sliding window approach to check for the consecutive sequence of letters in the given string\\nI will keep a counter variable to keep track of the number of times the substring appears in the string\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI will be iterating through the given string once\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI am only using a single variable to store the count\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> cnt(26, 0);\\n        int len = 0;\\n        for (int i = 0; i < p.size(); ++i) {\\n            if (i > 0 && (p[i] == p[i - 1] + 1 || p[i - 1] - p[i] == 25)) ++len;\\n            else len = 1;\\n            cnt[p[i] - \\'a\\'] = max(cnt[p[i] - \\'a\\'], len);\\n        }\\n        return accumulate(cnt.begin(), cnt.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> cnt(26, 0);\\n        int len = 0;\\n        for (int i = 0; i < p.size(); ++i) {\\n            if (i > 0 && (p[i] == p[i - 1] + 1 || p[i - 1] - p[i] == 25)) ++len;\\n            else len = 1;\\n            cnt[p[i] - \\'a\\'] = max(cnt[p[i] - \\'a\\'], len);\\n        }\\n        return accumulate(cnt.begin(), cnt.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413752,
                "title": "python-dp-solution-with-explanation",
                "content": "A  brute-force solution would be this:\\n1. Find all the substrings that are *good*:\\n\\t* A substring is good if each character comes one place after the previous character in the alphabet (with wrap-around).\\n\\t* This can be determined by comparing ordinals: `(ord(char) - ord(prev)) % 26 == 1`\\n 2. Count the number of *unique* good substrings.\\n\\nThis can be improved upon with dynamic programming.\\n\\nTwo good substrings are the same if they are the same length and end with the same character. Also, if the good substring `\\'abcd\\'` is present, then so are \\'`bcd`\\', `\\'cd\\'` and `\\'d\\'`. So, for each letter of the alphabet, we need only find the length of the longest good substring ending with that letter. We can do this by iterating through the characters of the string:\\n\\n* If the current character is the alphabetical successor of the previous character, we extend the length by one, othewise we reset the length to one.\\n* Then we compare this length with the recorded maximum, and update the maximum, if necessary.\\n\\nFinally, we sum up these maximum lengths.\\n\\n```python\\nclass Solution:\\n    \\n    def findSubstringInWraproundString(self, string: str) -> int:\\n        prev, length = \\'a\\', 0\\n        longest_seen = collections.defaultdict(int)\\n        for char in string:\\n            if (ord(char) - ord(prev)) % 26 == 1:\\n                length += 1\\n            else:\\n                length = 1\\n            longest_seen[char] = max(longest_seen[char], length)\\n            prev = char\\n        return sum(longest_seen.values())\\n```\\nThis has a worst-case **time complexity in O(n)**, where n is the length of the string, and worst-case additional **space-complexity in O(1)** (because there are at most 26 unique characters).",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    def findSubstringInWraproundString(self, string: str) -> int:\\n        prev, length = \\'a\\', 0\\n        longest_seen = collections.defaultdict(int)\\n        for char in string:\\n            if (ord(char) - ord(prev)) % 26 == 1:\\n                length += 1\\n            else:\\n                length = 1\\n            longest_seen[char] = max(longest_seen[char], length)\\n            prev = char\\n        return sum(longest_seen.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95447,
                "title": "c-two-passes-o-1-space-find-the-longest-substring-starting-from-each-letter",
                "content": "example: xyzabcefg\\nlongest(x) = 6, ==> we get 6 sub strings started from x, x xy xyz xyza xyzab xyzabc\\nlongest(y) = 5 ==> y yz yza yzab yzabc\\nlongest(c) = longest(g) = 1 ==> c, g \\n\\nadd 26 longest values together\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> longest(26, 0);\\n        int i = 0, left = 0;\\n        while (i < p.size()) {\\n            if (i + 1 == p.size() || (i + 1 < p.size() && (p[i] - 'a' + 1) % 26 != (p[i+1] - 'a'))) {\\n                //from left to i;\\n                for (int j = left; j <= i; j++) {\\n                    longest[p[j] - 'a'] = max(longest[p[j] - 'a'], i - j + 1);\\n                }\\n                left = i+1;\\n            }\\n            i++;\\n        }\\n        \\n        int ret = 0;\\n        for (int k = 0; k < 26; k++) {\\n            ret += longest[k]; \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int> longest(26, 0);\\n        int i = 0, left = 0;\\n        while (i < p.size()) {\\n            if (i + 1 == p.size() || (i + 1 < p.size() && (p[i] - 'a' + 1) % 26 != (p[i+1] - 'a'))) {\\n                //from left to i;\\n                for (int j = left; j <= i; j++) {\\n                    longest[p[j] - 'a'] = max(longest[p[j] - 'a'], i - j + 1);\\n                }\\n                left = i+1;\\n            }\\n            i++;\\n        }\\n        \\n        int ret = 0;\\n        for (int k = 0; k < 26; k++) {\\n            ret += longest[k]; \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95473,
                "title": "java-two-different-solutions-with-explanation",
                "content": "Hi there! I am sharing two different solutions with explanations.\\n\\nWell, the first solution idea is  Optimized brute force. The 'naivest' way is for each substring of p in alphabetic order (with rotation %26) brute force all substrings and add to some set. Then at last just return size of the set. That method works but it has two problems, they are:\\n * Memory limit\\n * Time limit\\n\\nBecause it works for O(n^3) time and O(n^2) space.\\nHow can we optimize memory?  Because we are considering only strings in alphabetic order, it is sufficient to remember the first character index, last character index and the length for each found substring. This way we replace set of strings to 3D boolean array.\\nWell, how can we optimize time complexity? We can increase performance of counting unique substrings for already found substring, which size is greater than 26. The evidence mentioned above helps us again, because we just need to consider combinations of first 26 character and the last 26 characters for different length, by incrementing length by 26. Such a way we get algorithm that runs for O(26*n) time and O((26^2)*n) space complexities.\\n```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if(p == null || p.isEmpty()) return 0;\\n        boolean [][][] set = new boolean[26][26][p.length()+1];\\n        int i = 0;\\n        int count = 0;\\n        boolean [] visited = new boolean[26];\\n        StringBuilder build = new StringBuilder();\\n        char [] s = p.toCharArray();\\n        int n = s.length;\\n        while(i<n){\\n            char prev = s[i];\\n            build.append(prev);\\n            i++;\\n            while(i<p.length() && s[i]-'a' == (prev-'a'+1)%26){\\n                prev = s[i];\\n                build.append(prev);\\n                i++;\\n            }\\n            \\n            String next = build.toString();\\n            int l = next.charAt(0)-'a';\\n            int r = next.charAt(next.length()-1)-'a';\\n            if(!set[l][r][next.length()]){\\n                count++;\\n                set[l][r][next.length()] = true;\\n                count+= countUniqueSubstr(next, set);\\n            }\\n            build.setLength(0);\\n        }\\n        return count;\\n    }\\n    \\n   \\n    public int countUniqueSubstr(String str, boolean [][][] set){\\n        int count = 0;\\n        if(str.length()>26){\\n            int n = str.length();\\n            for(int i = 0;i<26;i++){\\n                int l = str.charAt(i)-'a';\\n                for(int j = n-1;j>=n-26;j--){\\n                    int r = str.charAt(j)-'a';\\n                    int limit = j-i+1;\\n                    int start = r-l+1;\\n                    if(r<l){\\n                        start = 27-l+r;\\n                    }\\n                    for(int size = start;size<=limit;size+=26){\\n                        if(!set[l][r][size]){\\n                            count++;\\n                            set[l][r][size] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        } else {\\n            for(int size = 1;size<str.length();size++){\\n                for(int i = 0;i<=str.length()-size;i++){\\n                    String s = str.substring(i, i+size);\\n                    int l = s.charAt(0)-'a';\\n                    int r = s.charAt(s.length()-1)-'a';\\n                    if(!set[l][r][s.length()]){\\n                        count++;\\n                        set[l][r][s.length()] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nThe second solution is simple, just keep track of maximum length of alphabetic substrings ending at certain character then sum them up. \\n\\n```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if(p == null || p.isEmpty()) return 0;\\n        int dp[] = new int[26];\\n        int i = 0;\\n        int n = p.length();\\n        char [] s = p.toCharArray();\\n        int len = 1;\\n        while(i<n){\\n            char prev = s[i];\\n            i++;\\n            dp[prev - 'a'] = Math.max(dp[prev-'a'], len);\\n            while(i<p.length() && s[i]-'a' == (prev-'a'+1)%26){\\n                prev = s[i];\\n                len++;\\n                i++;\\n                dp[prev - 'a'] = Math.max(dp[prev-'a'], len);\\n            }\\n            dp[prev - 'a'] = Math.max(dp[prev-'a'], len);\\n            len = 1;\\n        }\\n        int count = 0;\\n        for(int j = 0;j<26;j++) count+=dp[j];\\n        return count;\\n    }\\n}\\n```\\nP.S: Sorry for poor and dirty code. I hope it will be understandable anyway",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if(p == null || p.isEmpty()) return 0;\\n        boolean [][][] set = new boolean[26][26][p.length()+1];\\n        int i = 0;\\n        int count = 0;\\n        boolean [] visited = new boolean[26];\\n        StringBuilder build = new StringBuilder();\\n        char [] s = p.toCharArray();\\n        int n = s.length;\\n        while(i<n){\\n            char prev = s[i];\\n            build.append(prev);\\n            i++;\\n            while(i<p.length() && s[i]-'a' == (prev-'a'+1)%26){\\n                prev = s[i];\\n                build.append(prev);\\n                i++;\\n            }\\n            \\n            String next = build.toString();\\n            int l = next.charAt(0)-'a';\\n            int r = next.charAt(next.length()-1)-'a';\\n            if(!set[l][r][next.length()]){\\n                count++;\\n                set[l][r][next.length()] = true;\\n                count+= countUniqueSubstr(next, set);\\n            }\\n            build.setLength(0);\\n        }\\n        return count;\\n    }\\n    \\n   \\n    public int countUniqueSubstr(String str, boolean [][][] set){\\n        int count = 0;\\n        if(str.length()>26){\\n            int n = str.length();\\n            for(int i = 0;i<26;i++){\\n                int l = str.charAt(i)-'a';\\n                for(int j = n-1;j>=n-26;j--){\\n                    int r = str.charAt(j)-'a';\\n                    int limit = j-i+1;\\n                    int start = r-l+1;\\n                    if(r<l){\\n                        start = 27-l+r;\\n                    }\\n                    for(int size = start;size<=limit;size+=26){\\n                        if(!set[l][r][size]){\\n                            count++;\\n                            set[l][r][size] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        } else {\\n            for(int size = 1;size<str.length();size++){\\n                for(int i = 0;i<=str.length()-size;i++){\\n                    String s = str.substring(i, i+size);\\n                    int l = s.charAt(0)-'a';\\n                    int r = s.charAt(s.length()-1)-'a';\\n                    if(!set[l][r][s.length()]){\\n                        count++;\\n                        set[l][r][s.length()] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if(p == null || p.isEmpty()) return 0;\\n        int dp[] = new int[26];\\n        int i = 0;\\n        int n = p.length();\\n        char [] s = p.toCharArray();\\n        int len = 1;\\n        while(i<n){\\n            char prev = s[i];\\n            i++;\\n            dp[prev - 'a'] = Math.max(dp[prev-'a'], len);\\n            while(i<p.length() && s[i]-'a' == (prev-'a'+1)%26){\\n                prev = s[i];\\n                len++;\\n                i++;\\n                dp[prev - 'a'] = Math.max(dp[prev-'a'], len);\\n            }\\n            dp[prev - 'a'] = Math.max(dp[prev-'a'], len);\\n            len = 1;\\n        }\\n        int count = 0;\\n        for(int j = 0;j<26;j++) count+=dp[j];\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463852,
                "title": "c-easy-understandable-solution",
                "content": "**Dp On Each Char**\\n*  We have to find the number of unique substrings ending with a char\\n* If we have \"abcd\" then with \\'d\\' as ending we can make 4(length of string) substrings i.e abcd,bcd,cd,d \\n* So for every char we have to find the largest contiguous substring in the sequence of infinite a-z\\n*  For that we can create a dp vector  of size 26 to store the max length of continuous substring ending with that char \\n*  ex : zabcdab\\n*  index 0 : 1;\\n*  index 1 : 2;\\n*  index 2 : 3;\\n*  index 3 : 4;\\n*  index 4 : 5;\\n*  index 5 : sequence is breaked and \\'a\\' gets 1 which is less than prev length ending with \\'a\\' which is 2 so no change\\n*  index 6 : b gets 2 but it already has max length of 3\\n*  summation of the values in the dp vector gives the required answer as it means the count of subarrays that are unique and are contiguous\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size();\\n        vector<int> dp(26,0);\\n        dp[p[0]-\\'a\\']=1;\\n        int prev_ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            if((p[i-1]-\\'a\\'+1)%26 == (p[i]-\\'a\\')%26)prev_ans++;\\n            else prev_ans = 1;\\n            if(dp[p[i]-\\'a\\']<prev_ans){\\n                dp[p[i]-\\'a\\']=prev_ans;\\n            }\\n        }\\n        \\n        return accumulate(begin(dp),end(dp),0);\\n    }\\n};\\n```\\n\\nplease upvote \\u2764\\uFE0F if you like the post",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size();\\n        vector<int> dp(26,0);\\n        dp[p[0]-\\'a\\']=1;\\n        int prev_ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            if((p[i-1]-\\'a\\'+1)%26 == (p[i]-\\'a\\')%26)prev_ans++;\\n            else prev_ans = 1;\\n            if(dp[p[i]-\\'a\\']<prev_ans){\\n                dp[p[i]-\\'a\\']=prev_ans;\\n            }\\n        }\\n        \\n        return accumulate(begin(dp),end(dp),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267636,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // give score to each character that is equal to the maximum length of substring present in s that ends with that character \\n    int findSubstringInWraproundString(string p) {\\n        int dp[26]={},l=p.length(),curr=1;\\n        // an array to store the score of each character\\n        for(int i=0;i<l;i++){\\n            curr= (i>0 && ((p[i-1]+1)%26)== p[i]%26) ? curr+1:1;\\n            dp[p[i]-97]=max(dp[p[i]-97],curr); \\n        }\\n        return accumulate(dp,dp+26,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // give score to each character that is equal to the maximum length of substring present in s that ends with that character \\n    int findSubstringInWraproundString(string p) {\\n        int dp[26]={},l=p.length(),curr=1;\\n        // an array to store the score of each character\\n        for(int i=0;i<l;i++){\\n            curr= (i>0 && ((p[i-1]+1)%26)== p[i]%26) ? curr+1:1;\\n            dp[p[i]-97]=max(dp[p[i]-97],curr); \\n        }\\n        return accumulate(dp,dp+26,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949158,
                "title": "easy-c-solution-with-explainatory-comments",
                "content": "``` \\nint findSubstringInWraproundString(string p) {\\n        \\n        // For any continuous streak abcd.....xyzabc..  of length n\\n        // no of substrings for ith charater of a streak goes on like\\n        // f(i) = i             :: 1 indexed\\n        // and the total we get is 1 + 2 + 3 + ... + n  = n(n+1)/2\\n        \\n        // Now how we handle overlapping cases like\\n        // p = \"abcdcdef\"\\n        // Here we have two continous streaks \"abcd\" and \"cdef\"\\n        // cd is common in both which will result in counting of\\n        // substring [\"c\",\"d\",\"cd\"] twice\\n        \\n        // We can simply take maximum streak occuring for that particular \\n        // alphabet\\n        // Example : For p = \"abcdcdef\"\\n        // Till \"abcd\" our container will look like\\n        // a : 1\\n        // b : 2\\n        // c : 3\\n        // d : 4\\n        // e : 0\\n        // f : 0\\n        \\n        // For \"abcdc\" our container will look like\\n        // a : 1\\n        // b : 2\\n        // c : 3          ::Streak updated from 4 to 1 as we moved from d -> c :: *c = max(3,1)\\n        // d : 4\\n        // e : 0\\n        // f : 0\\n        \\n        // At the end of \"abcdcdef\" our container will look like\\n        // a : 1\\n        // b : 2\\n        // c : 3\\n        // d : 4\\n        // e : 3\\n        // f : 4\\n        \\n        // And we can simple return the overall sum\\n        // Note : We only took 3 for e So that [\"cde\",\"de\",\"e\"] are only considered\\n        //        similarly 4 for f\\n        \\n        int n = p.length();\\n        \\n        vector<int> v(26,0);\\n        \\n        int streak = 1;\\n        for(int i =0;i<n;i++){\\n            \\n\\t\\t\\tint ind = (int)(p[i] - \\'a\\');\\n            if(i > 0 && ( (int)(p[i] - \\'a\\') - (int)(p[i-1] - \\'a\\') + 26 ) % 26 == 1 ){\\n                streak++;\\n            } else {\\n                streak = 1;\\n            }\\n            \\n            v[ind] = max(v[ind],streak);\\n            \\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i<26;i++) ans+=v[i];\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` \\nint findSubstringInWraproundString(string p) {\\n        \\n        // For any continuous streak abcd.....xyzabc..  of length n\\n        // no of substrings for ith charater of a streak goes on like\\n        // f(i) = i             :: 1 indexed\\n        // and the total we get is 1 + 2 + 3 + ... + n  = n(n+1)/2\\n        \\n        // Now how we handle overlapping cases like\\n        // p = \"abcdcdef\"\\n        // Here we have two continous streaks \"abcd\" and \"cdef\"\\n        // cd is common in both which will result in counting of\\n        // substring [\"c\",\"d\",\"cd\"] twice\\n        \\n        // We can simply take maximum streak occuring for that particular \\n        // alphabet\\n        // Example : For p = \"abcdcdef\"\\n        // Till \"abcd\" our container will look like\\n        // a : 1\\n        // b : 2\\n        // c : 3\\n        // d : 4\\n        // e : 0\\n        // f : 0\\n        \\n        // For \"abcdc\" our container will look like\\n        // a : 1\\n        // b : 2\\n        // c : 3          ::Streak updated from 4 to 1 as we moved from d -> c :: *c = max(3,1)\\n        // d : 4\\n        // e : 0\\n        // f : 0\\n        \\n        // At the end of \"abcdcdef\" our container will look like\\n        // a : 1\\n        // b : 2\\n        // c : 3\\n        // d : 4\\n        // e : 3\\n        // f : 4\\n        \\n        // And we can simple return the overall sum\\n        // Note : We only took 3 for e So that [\"cde\",\"de\",\"e\"] are only considered\\n        //        similarly 4 for f\\n        \\n        int n = p.length();\\n        \\n        vector<int> v(26,0);\\n        \\n        int streak = 1;\\n        for(int i =0;i<n;i++){\\n            \\n\\t\\t\\tint ind = (int)(p[i] - \\'a\\');\\n            if(i > 0 && ( (int)(p[i] - \\'a\\') - (int)(p[i-1] - \\'a\\') + 26 ) % 26 == 1 ){\\n                streak++;\\n            } else {\\n                streak = 1;\\n            }\\n            \\n            v[ind] = max(v[ind],streak);\\n            \\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i<26;i++) ans+=v[i];\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1062991,
                "title": "10-line-c-dp-solution-beats-97-times-o-n-time-o-1-space-with-working-out",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans, alpha[26];\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) return 0;\\n        alpha[p[0]-\\'a\\'] = 1;\\n        int dp = 1;\\n        for(int i = 1; i < p.size(); i++) {\\n            if(p[i]-\\'a\\' == (p[i-1]-\\'a\\'+1)%26) dp++;\\n            else dp = 1;\\n            alpha[p[i]-\\'a\\'] = max(alpha[p[i]-\\'a\\'], dp);\\n        }\\n        for(int i = 0; i < 26; i++) ans += alpha[i];\\n        return ans;\\n    }\\n};\\n```\\nWorking Out\\n```text\\nbrute force:\\nfind substrings of length 1...p.length\\nlength 1:\\nz,a,b\\nlength 2:\\nza,ab\\nlength 3:\\nzab,\\n\\ncurrent letter is continuation if \\np[i]-\\'a\\' == (p[i-1]-\\'a\\'+1)%26\\n\\nBrute force is O(n^2) time.\\n\\ndp approach:\\n\\nsubproblem:\\ndp[i] = number of valid substrings ending at i\\n\\ntransition:\\ndp[i] = 1;\\nif(p[i]-\\'a\\' == (p[i-1]-\\'a\\'+1)%26) {\\n    dp[i] += dp[i-1];\\n}\\n\\nanswer:\\nsum of all dp[i]\\n\\ntest:\\nzab\\ndp[0] = 1\\ndp[1] = 1 + dp[0] = 2\\ndp[2] = 1 + dp[1] = 3\\n\\ntotal = 1 + 2 + 3 = 6\\n\\ntest2:\\nyzabxyzab\\ny = 1\\nz = 2\\na = 3\\nx = 1\\ny = 2\\nz = 3\\na = 4\\n\\n4                      123\\nabcdefghijklmnopqrstuvwxyz\\ntotal = 1 + 2 + 3 + 4 = 15\\n\\nalpha[26] array keeps track of maximum number of substrings ending at a particular letter\\nso that we don\\'t count duplicate substrings.\\n\\n\\ntime complexity:\\nO(n)\\nspace complexity:\\nO(26)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans, alpha[26];\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) return 0;\\n        alpha[p[0]-\\'a\\'] = 1;\\n        int dp = 1;\\n        for(int i = 1; i < p.size(); i++) {\\n            if(p[i]-\\'a\\' == (p[i-1]-\\'a\\'+1)%26) dp++;\\n            else dp = 1;\\n            alpha[p[i]-\\'a\\'] = max(alpha[p[i]-\\'a\\'], dp);\\n        }\\n        for(int i = 0; i < 26; i++) ans += alpha[i];\\n        return ans;\\n    }\\n};\\n```\n```text\\nbrute force:\\nfind substrings of length 1...p.length\\nlength 1:\\nz,a,b\\nlength 2:\\nza,ab\\nlength 3:\\nzab,\\n\\ncurrent letter is continuation if \\np[i]-\\'a\\' == (p[i-1]-\\'a\\'+1)%26\\n\\nBrute force is O(n^2) time.\\n\\ndp approach:\\n\\nsubproblem:\\ndp[i] = number of valid substrings ending at i\\n\\ntransition:\\ndp[i] = 1;\\nif(p[i]-\\'a\\' == (p[i-1]-\\'a\\'+1)%26) {\\n    dp[i] += dp[i-1];\\n}\\n\\nanswer:\\nsum of all dp[i]\\n\\ntest:\\nzab\\ndp[0] = 1\\ndp[1] = 1 + dp[0] = 2\\ndp[2] = 1 + dp[1] = 3\\n\\ntotal = 1 + 2 + 3 = 6\\n\\ntest2:\\nyzabxyzab\\ny = 1\\nz = 2\\na = 3\\nx = 1\\ny = 2\\nz = 3\\na = 4\\n\\n4                      123\\nabcdefghijklmnopqrstuvwxyz\\ntotal = 1 + 2 + 3 + 4 = 15\\n\\nalpha[26] array keeps track of maximum number of substrings ending at a particular letter\\nso that we don\\'t count duplicate substrings.\\n\\n\\ntime complexity:\\nO(n)\\nspace complexity:\\nO(26)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973669,
                "title": "c-o-n-time-o-1-space-top-99-time-and-memory-explanation",
                "content": "Lets call a substring of the input string that is found in the infinite string as **suitable**.\\n\\nFirst insight behind the algorithm is that for each letter each suitable substring of p is contained within the longest suitable substring of p that starts with the same character. This is because we are asked to find the number of **unique** substrings. \\n\\nThe second insight is that the input string p is basically a sequence of suitable strings, for example: *\"xyzadabcf\"* can be looked at as *\"xyza\" + \"d\" + \"abc\" + \"f\"*. Combined with the previous insight, we can see that we only need to look at the longest suitable substring for each letter; so *\"ababc\"* is essentially the same for us as *\"abc\"*, because the longest suitable substring starting from *\"a\"* is *\"abc\"*.\\n\\nWith these two ideas in mind, you can hopefully see that the number of unique suitable substrings of p that start with a certain character is exactly the length of the longest suitable substing starting from that character. For example, if p is *\"ababc\"*, then the longest suitable substring starting from *\"a\"* is *\"abc\"*, so the number of unique suitable substrings of p that start with *\"a\"* is *len(\"abc\") = 3*. Every suitable substring starting from \"a\" is going to be contained within the longest one.\\n\\nWith that, the algorithm is to find the lengths of the longest suitable substrings of p for each letter and sum them up to get the answer.\\n\\n\\n```\\n    int findSubstringInWraproundString(const string& p) {\\n        const int size = static_cast<int>(p.size());\\n        if (size < 2) return size;\\n        \\n        // This array is going to store in each index the length of the longest\\n        // suitable substring of p that starts with the corresponding character.\\n        // For example:\\n        // p = \"abcdf\", maxLengths = [4, 3, 2, 1, 0, 1, 0, .., 0]\\n        // The number of all the unique substrigs of p that are found in the infinite\\n        // string is then going to be the sum of the elements of maxLengths.\\n        vector<int> maxLengths(26, 0);\\n        \\n        int i = 1;\\n        int start = 0;\\n        while (i < size) {\\n            // If i-th character is not the next after i-1-th in the circle alphabet,\\n            // we update the maxLengths knowing that p[start:i] is a suitable string\\n            if (!isNextInAlphabet(i, p)) {\\n                updateMaxLengths(maxLengths, p, start, i);\\n                start = i;\\n            }\\n            ++i;\\n        }\\n        // This handles the end of the string that we didn\\'t get a chance to handle in the loop\\n        updateMaxLengths(maxLengths, p, start, i);\\n        \\n        // Return the sum of elements in maxLengths\\n        return accumulate(maxLengths.begin(), maxLengths.end(), 0);\\n    }\\n    \\n    // Return true if str[index - 1] and str[index] are consecutive in the circle alphabet \\n    inline bool isNextInAlphabet(int index, const string& str) {\\n        int diff = str[index] - str[index - 1];\\n        return diff == 1 || diff == -25;\\n    }\\n    \\n    void updateMaxLengths(vector<int>& maxL, const string& str, int start, int end) {\\n        while (start < end) {\\n            int offset = str[start] - \\'a\\';\\n            if (maxL[offset] < end - start) {\\n                maxL[offset] = end - start;\\n            }\\n            else {\\n                // We can break out here, because we have seen a substing\\n                // starting with str[start] character that is longer than the current substring\\n                break;\\n            }\\n            ++start;\\n        }\\n    }\\n```\\nThe algorithm uses only constant amount of space and its time complexity is *O(n)*, because the loop inside *updateMaxLengths* can run maximum of 26 iterations.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findSubstringInWraproundString(const string& p) {\\n        const int size = static_cast<int>(p.size());\\n        if (size < 2) return size;\\n        \\n        // This array is going to store in each index the length of the longest\\n        // suitable substring of p that starts with the corresponding character.\\n        // For example:\\n        // p = \"abcdf\", maxLengths = [4, 3, 2, 1, 0, 1, 0, .., 0]\\n        // The number of all the unique substrigs of p that are found in the infinite\\n        // string is then going to be the sum of the elements of maxLengths.\\n        vector<int> maxLengths(26, 0);\\n        \\n        int i = 1;\\n        int start = 0;\\n        while (i < size) {\\n            // If i-th character is not the next after i-1-th in the circle alphabet,\\n            // we update the maxLengths knowing that p[start:i] is a suitable string\\n            if (!isNextInAlphabet(i, p)) {\\n                updateMaxLengths(maxLengths, p, start, i);\\n                start = i;\\n            }\\n            ++i;\\n        }\\n        // This handles the end of the string that we didn\\'t get a chance to handle in the loop\\n        updateMaxLengths(maxLengths, p, start, i);\\n        \\n        // Return the sum of elements in maxLengths\\n        return accumulate(maxLengths.begin(), maxLengths.end(), 0);\\n    }\\n    \\n    // Return true if str[index - 1] and str[index] are consecutive in the circle alphabet \\n    inline bool isNextInAlphabet(int index, const string& str) {\\n        int diff = str[index] - str[index - 1];\\n        return diff == 1 || diff == -25;\\n    }\\n    \\n    void updateMaxLengths(vector<int>& maxL, const string& str, int start, int end) {\\n        while (start < end) {\\n            int offset = str[start] - \\'a\\';\\n            if (maxL[offset] < end - start) {\\n                maxL[offset] = end - start;\\n            }\\n            else {\\n                // We can break out here, because we have seen a substing\\n                // starting with str[start] character that is longer than the current substring\\n                break;\\n            }\\n            ++start;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870605,
                "title": "java-dp-easy-understand",
                "content": "```\\nimport java.util.Arrays;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nimport static java.lang.Integer.max;\\n\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if(p == null || p.isEmpty() || p.isBlank()) {\\n            return 0;\\n        }\\n\\n        int[] dp = new int[p.length()];\\n        int[] chars = new int[26];\\n        dp[0] = 1;\\n        chars[p.charAt(0) - \\'a\\'] = 1;\\n        char last = p.charAt(0);\\n        char curr;\\n        for(int i = 1; i < p.length(); i++) {\\n            curr = p.charAt(i);\\n            if(last + 1 == curr || (last == \\'z\\' && curr == \\'a\\')) {\\n                dp[i] = dp[i-1] + 1;\\n            } else {\\n                dp[i] = 1;\\n            }\\n            chars[curr - \\'a\\'] = max(chars[curr - \\'a\\'], dp[i]);\\n            last = curr;\\n        }\\n\\n        return Arrays.stream(chars).sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nimport static java.lang.Integer.max;\\n\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if(p == null || p.isEmpty() || p.isBlank()) {\\n            return 0;\\n        }\\n\\n        int[] dp = new int[p.length()];\\n        int[] chars = new int[26];\\n        dp[0] = 1;\\n        chars[p.charAt(0) - \\'a\\'] = 1;\\n        char last = p.charAt(0);\\n        char curr;\\n        for(int i = 1; i < p.length(); i++) {\\n            curr = p.charAt(i);\\n            if(last + 1 == curr || (last == \\'z\\' && curr == \\'a\\')) {\\n                dp[i] = dp[i-1] + 1;\\n            } else {\\n                dp[i] = 1;\\n            }\\n            chars[curr - \\'a\\'] = max(chars[curr - \\'a\\'], dp[i]);\\n            last = curr;\\n        }\\n\\n        return Arrays.stream(chars).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95464,
                "title": "python-solution",
                "content": "This solution might look a bit verbose but it is straight forward. `dp[i]` is the number of qualified substrings ending at the position `i` in `p`, `seen` is a dictionary keyed by the character `c` that maintains the greatest number of qualified substrings ending at the char `c`.\\n\\n    class Solution(object):\\n        def findSubstringInWraproundString(self, p):\\n            \"\"\"\\n            :type p: str\\n            :rtype: int\\n            \"\"\"\\n\\n            N = len(p)\\n            if N <= 1: return N\\n\\n            dp = [0 for i in range(N)]\\n            start, seen = 0, {}\\n            dp[0], seen[p[0]] = 1, 1\\n\\n            for i in range(1, N):\\n                if p[i - 1] == 'z' and p[i] == 'a' or ord(p[i - 1]) + 1 == ord(p[i]):\\n                    x = i - start + 1\\n                    if p[i] not in seen:\\n                        dp[i] = x\\n                        seen[p[i]] = dp[i]\\n                    else:\\n                        if x > seen[p[i]]:\\n                            dp[i] = x - seen[p[i]]\\n                            seen[p[i]] = x\\n                        else:\\n                            dp[i] = 0\\n                else:\\n                    if p[i] not in seen:\\n                        dp[i] = 1\\n                        seen[p[i]] = dp[i]\\n                    else:\\n                        dp[i] = 0\\n\\n                    start = i\\n\\n            return sum(dp)",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def findSubstringInWraproundString(self, p):\\n            \"\"\"\\n            :type p: str\\n            :rtype: int\\n            \"\"\"\\n\\n            N = len(p)\\n            if N <= 1: return N\\n\\n            dp = [0 for i in range(N)]\\n            start, seen = 0, {}",
                "codeTag": "Java"
            },
            {
                "id": 3997108,
                "title": "learning-to-identify-patterns-between-problems",
                "content": "Before solving this problem please tryout this problem\\n\\n**Number of smooth Descent period of stock**\\nhttps://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/\\n\\nIt is the simpler version of this problem.There you doesn\\'t have to take care about the unique part.\\n\\nHere is the code for that. See the explanation part and try to solve both the problem in one go.\\nhttps://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/solutions/3926472/most-easy-to-understand-solution-just-do-a-dry-runp/\\n\\n\\nUpvote if u like.\\n**Explanation**\\nPart 1\\n**Lets think of the problem for a second as counting the substrings in the wraparound string and forget about the unique part.**\\n\\n1. For a single character lets say \"a\" the answer is 1 (current answer: 1).\\nNow if we add another character in continuation, we have the string \"ab\". We now are able to form as many solutions as previous answer (i.e. 1 - \"b\") plus 1 (i.e. \"ab\" which includes all the characters) (current answer: 2).\\nSimilarly, adding \"c\" we have the string as \"abc\" and we\\'ll be able to form as many substrings as previous answer also having the last character \"c\" (i.e. 2 - \"c\",\"bc\") plus 1 having all characters (i.e. 3 -\"abc\") (current answer: 3).\\nBy now it would be clear but let\\'s do this one last time.\\n\\n- Adding \"d\" we have the string \"abcd\" and we\\'ll be able to form as many solutions as previous answer which has one length lesser and having the last character \"d\" (i.e 3 - \"d\",\"cd\",\"bcd\") plus 1 having all the characters (\"abcd\") (current answer: 4).\\nAdding current answer at each step in our final answer will give us the solution.\\n\\nNote: As soon as continuation breaks (\"abcdm\" continuation breaks at \"m\") we\\'ll reset the current answer to 1.\\n\\n***In summary the answer is the sum of lengths of all the continuous substrings found (For non unique solution).\\n***\\nPart 2\\n\\n**To deal with unique substrings we\\'ll create a 26 size array **initialized with 0.**\\n- At each string index i, we store the answer at that point (i.e. current answer) in the array. The current answer is stored in the array position of the respective character found at index i.**\\n\\nLets take an example string \"ababc\".\\n- \\n1. Initially the array is [0,0,0,0,.....]\\nAt string index 0, array becomes [1,0,0,0,.....] (because the answer at that point is 1 for \"a\").\\nAt string index 1, array becomes [1,2,0,0,.....] (the current answer is 2 for \"ab\").\\n1. At string index 2, the continuation breaks. Hence we set the current answer to 1. Since we have 1 at the position of \"a\" in the array, we know that we must have found a substring having length 1 ending at \"a\" (i.e. \"a\") hence we do nothing at this point at go to the next step.\\n1. At string index 3, we have the current answer as 2 (for string \"ab\"). Since we already have 2 at position \"b\" in the array, we know that we have previously found substring ending at \"b\" of length 2 (i.e. \"ab\") hence we do nothing and go to the next step.\\nAt string index 4, we calculate the current answer as 3 (for string \"abc\"). Since at position \"c\" in the array we have 0, this is the best solution found at this point. The array becomes [1,2,3,0,.....].\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        \\n          int n = s.size();\\n        // difference array\\n         vector<int>diff(n,0);\\n for (int i = 1; i < n; i++) {\\n            int currentDiff = s[i] - s[i - 1];\\n            \\n            // Handle wraparound for \\'z\\' to \\'a\\'\\n            if (currentDiff == 1 || (s[i - 1] == \\'z\\' && s[i] == \\'a\\')) {\\n                diff[i] = 1;\\n            }\\n        }\\n\\n        // Hash array\\n        vector<int>hash(26,0);\\n\\n        int i=0,j=0;\\n        int count = 0 ,ans =0;\\n        while(j < n)\\n        {\\n            if(diff[j] !=1)\\n            {\\n              count=1;\\n            //   ans +=count;\\n              i=j;\\n            }\\n            else\\n            {\\n               count = j-i+1;\\n            //    ans +=count;\\n            }\\n\\n            if(hash[s[j]-\\'a\\'] < count)\\n            {\\n                hash[s[j]-\\'a\\'] = count;\\n            }\\n            j++;\\n        }\\n        \\n        int sum = accumulate(hash.begin(),hash.end(),0);\\n        return sum;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        \\n          int n = s.size();\\n        // difference array\\n         vector<int>diff(n,0);\\n for (int i = 1; i < n; i++) {\\n            int currentDiff = s[i] - s[i - 1];\\n            \\n            // Handle wraparound for \\'z\\' to \\'a\\'\\n            if (currentDiff == 1 || (s[i - 1] == \\'z\\' && s[i] == \\'a\\')) {\\n                diff[i] = 1;\\n            }\\n        }\\n\\n        // Hash array\\n        vector<int>hash(26,0);\\n\\n        int i=0,j=0;\\n        int count = 0 ,ans =0;\\n        while(j < n)\\n        {\\n            if(diff[j] !=1)\\n            {\\n              count=1;\\n            //   ans +=count;\\n              i=j;\\n            }\\n            else\\n            {\\n               count = j-i+1;\\n            //    ans +=count;\\n            }\\n\\n            if(hash[s[j]-\\'a\\'] < count)\\n            {\\n                hash[s[j]-\\'a\\'] = count;\\n            }\\n            j++;\\n        }\\n        \\n        int sum = accumulate(hash.begin(),hash.end(),0);\\n        return sum;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278837,
                "title": "467-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. If s is empty, return 0.\\n2. Create an empty dictionary called count to keep track of the maximum length of substring that ends with each character in s.\\n3. Initialize curr_count and max_len to 0 and 1 respectively, and prev to the first character in s.\\n4. Iterate over each character c in s.\\n5. If the difference between the ASCII values of c and prev is 1 or 25 (the distance between \\'a\\' and \\'z\\' in a circular manner), increment max_len by 1. Otherwise, reset max_len to 1.\\n6. If max_len is greater than or equal to curr_count, update curr_count to max_len. Otherwise, reset curr_count to 1.\\n7. Set the value of count[c] to the maximum of its current value and curr_count.\\n8. Update prev to c.\\n9. Return the sum of the values in count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        count = {}\\n        curr_count = 0\\n        max_len = 1\\n        prev = s[0]\\n        \\n        for i in range(len(s)):\\n            if ord(s[i]) - ord(prev) == 1 or ord(prev) - ord(s[i]) == 25:\\n                max_len += 1\\n            else:\\n                max_len = 1\\n            \\n            if max_len >= curr_count:\\n                curr_count = max_len\\n            else:\\n                curr_count = 1\\n            \\n            count[s[i]] = max(count.get(s[i], 0), curr_count)\\n            \\n            prev = s[i]\\n        \\n        return sum(count.values())\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        count = {}\\n        curr_count = 0\\n        max_len = 1\\n        prev = s[0]\\n        \\n        for i in range(len(s)):\\n            if ord(s[i]) - ord(prev) == 1 or ord(prev) - ord(s[i]) == 25:\\n                max_len += 1\\n            else:\\n                max_len = 1\\n            \\n            if max_len >= curr_count:\\n                curr_count = max_len\\n            else:\\n                curr_count = 1\\n            \\n            count[s[i]] = max(count.get(s[i], 0), curr_count)\\n            \\n            prev = s[i]\\n        \\n        return sum(count.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674644,
                "title": "c-beats-84-solutions-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int findSubstringInWraproundString(string p) {\\n        int n=p.size();\\n        vector<int>v(26);\\n        int cnt=1;\\n        v[p[0]-\\'a\\']=1;\\n        for(int i=1;i<p.size();i++){\\n            if(p[i]-p[i-1]==1 or (p[i]==\\'a\\' and p[i-1]==\\'z\\')){\\n                cnt++;\\n            }\\n            else\\n                cnt=1;\\n                v[p[i]-\\'a\\']=max(cnt,v[p[i]-\\'a\\']);\\n        }\\n        int ans=0;\\n       for(int i=0;i<26;i++){\\n           ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int findSubstringInWraproundString(string p) {\\n        int n=p.size();\\n        vector<int>v(26);\\n        int cnt=1;\\n        v[p[0]-\\'a\\']=1;\\n        for(int i=1;i<p.size();i++){\\n            if(p[i]-p[i-1]==1 or (p[i]==\\'a\\' and p[i-1]==\\'z\\')){\\n                cnt++;\\n            }\\n            else\\n                cnt=1;\\n                v[p[i]-\\'a\\']=max(cnt,v[p[i]-\\'a\\']);\\n        }\\n        int ans=0;\\n       for(int i=0;i<26;i++){\\n           ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573085,
                "title": "full-dry-run-of-everyone-s-short-code",
                "content": "```\\n int findSubstringInWraproundString(string s) {\\n        \\n/* Mai khudpe khtm hone wali kitni substring bna skta hu vo mere tak ki max continuation se pta chlega   \"bczabc\" jab \\'c\\' pehli baar aya tab maine dekha ki iski contunation to sirf 2 length ki hai to merpe khtm hone wli substring sirf 2 hai \\'b\\' \\'bc\\'  \\n par jab \\'c\\' dusri baar aya to use apne par khtm hone wli continuation 4 ki mili yaani 4 substring bnegi uspe khtm hone wli(zabc,abc,bc,c) par 2 to bn chuki(bc,c) jo ki arr[\\'c\\'] me stored hai to ab:\\n               ans+=currContinuation-arr[\\'c\\'] , arr[i]=currContinuation; \\n               \\narr[i] me store b krliya naya bda continuation takai agr aage>4 ki contunation mile to i could calculate */\\n        \\n        vector<int> arr(26,0);  \\n        arr[s[0]-\\'a\\']=1;\\n        int prevAns=1,ans=1;\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            if((s[i-1]-\\'a\\'+1)%26 == s[i]-\\'a\\')  //continuation chl rhi hai\\n                prevAns++;\\n            \\n            else\\n                prevAns=1;  //continuationn (\"cde\") tut gyi\\n            \\n            if(prevAns>arr[s[i]-\\'a\\']) //newContinuation till s[i] > prevContination till s[i]\\n            {\\n                ans+=prevAns-arr[s[i]-\\'a\\']; //add the diff in ans\\n                arr[s[i]-\\'a\\']=prevAns;  //update maxContinaution till me or no of valid ans                                          //substrings ending at s[i]\\n            }     \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n int findSubstringInWraproundString(string s) {\\n        \\n/* Mai khudpe khtm hone wali kitni substring bna skta hu vo mere tak ki max continuation se pta chlega   \"bczabc\" jab \\'c\\' pehli baar aya tab maine dekha ki iski contunation to sirf 2 length ki hai to merpe khtm hone wli substring sirf 2 hai \\'b\\' \\'bc\\'  \\n par jab \\'c\\' dusri baar aya to use apne par khtm hone wli continuation 4 ki mili yaani 4 substring bnegi uspe khtm hone wli(zabc,abc,bc,c) par 2 to bn chuki(bc,c) jo ki arr[\\'c\\'] me stored hai to ab:\\n               ans+=currContinuation-arr[\\'c\\'] , arr[i]=currContinuation; \\n               \\narr[i] me store b krliya naya bda continuation takai agr aage>4 ki contunation mile to i could calculate */\\n        \\n        vector<int> arr(26,0);  \\n        arr[s[0]-\\'a\\']=1;\\n        int prevAns=1,ans=1;\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            if((s[i-1]-\\'a\\'+1)%26 == s[i]-\\'a\\')  //continuation chl rhi hai\\n                prevAns++;\\n            \\n            else\\n                prevAns=1;  //continuationn (\"cde\") tut gyi\\n            \\n            if(prevAns>arr[s[i]-\\'a\\']) //newContinuation till s[i] > prevContination till s[i]\\n            {\\n                ans+=prevAns-arr[s[i]-\\'a\\']; //add the diff in ans\\n                arr[s[i]-\\'a\\']=prevAns;  //update maxContinaution till me or no of valid ans                                          //substrings ending at s[i]\\n            }     \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1466487,
                "title": "python-dp",
                "content": "\\n        dp = [0 for _ in range(len(p))]\\n        dp[0] = 1\\n        \\n        for i in range(1,len(p)):\\n            if ord(p[i]) - ord(p[i-1])==1 or p[i]==\\'a\\'and p[i-1]==\\'z\\':\\n                dp[i] = dp[i-1]+1\\n            else:\\n                dp[i] = 1\\n                \\n        dic = {}\\n        for i in range(len(p)):\\n            if p[i] in dic:\\n                dic[p[i]] = max(dic[p[i]],dp[i])\\n            else:\\n                dic[p[i]] = dp[i]\\n        \\n        res = 0\\n        for k,v in dic.items():\\n            res += v\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n        dp = [0 for _ in range(len(p))]\\n        dp[0] = 1\\n        \\n        for i in range(1,len(p)):\\n            if ord(p[i]) - ord(p[i-1])==1 or p[i]==\\'a\\'and p[i-1]==\\'z\\':\\n                dp[i] = dp[i-1]+1\\n            else:\\n                dp[i] = 1\\n                \\n        dic = {}\\n        for i in range(len(p)):\\n            if p[i] in dic:\\n                dic[p[i]] = max(dic[p[i]],dp[i])\\n            else:\\n                dic[p[i]] = dp[i]\\n        \\n        res = 0\\n        for k,v in dic.items():\\n            res += v\\n            \\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 1373756,
                "title": "c-clean-consice-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        \\n        //stores the wrap around substring  in p ending with a character\\n        vector<int> ending(26,0);\\n        int currLen=1;\\n        int res=1; //the total number of unique sub strings\\n        ending[p[0]-\\'a\\']=1; \\n        int prev=p[0]-\\'a\\'; //prev stores the prev char index in ending array\\n        for(int i=1;i<p.length();i++)\\n        {\\n            int ind=p[i]-\\'a\\'; //the current character index in ending array\\n            if((prev+1)%26 == ind)\\n                currLen++;\\n            else\\n                currLen=1;\\n            \\n            //if currlen is greater then add the addtitional sub strings \\n            //ex - previously sub string ending with d was cd\\n            //now if sub string is abcd add 2 to the result as cd was prevoulsy added\\n            if(ending[ind] < currLen){\\n                res+=currLen-ending[ind];\\n                ending[ind]=currLen;\\n                }\\n            prev=ind;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        \\n        //stores the wrap around substring  in p ending with a character\\n        vector<int> ending(26,0);\\n        int currLen=1;\\n        int res=1; //the total number of unique sub strings\\n        ending[p[0]-\\'a\\']=1; \\n        int prev=p[0]-\\'a\\'; //prev stores the prev char index in ending array\\n        for(int i=1;i<p.length();i++)\\n        {\\n            int ind=p[i]-\\'a\\'; //the current character index in ending array\\n            if((prev+1)%26 == ind)\\n                currLen++;\\n            else\\n                currLen=1;\\n            \\n            //if currlen is greater then add the addtitional sub strings \\n            //ex - previously sub string ending with d was cd\\n            //now if sub string is abcd add 2 to the result as cd was prevoulsy added\\n            if(ending[ind] < currLen){\\n                res+=currLen-ending[ind];\\n                ending[ind]=currLen;\\n                }\\n            prev=ind;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370262,
                "title": "c-short-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string ptr) {\\n        vector<int>cnt(26,0);\\n        int maxlen=1;\\n        for(int i=0;i<ptr.length();i++)\\n        {\\n            if(i>0 && ((ptr[i]-ptr[i-1])==1 ||  (ptr[i-1]-ptr[i])==25))\\n                maxlen++;\\n            else\\n                maxlen=1;\\n            cnt[ptr[i]-\\'a\\']=max(maxlen,cnt[ptr[i]-\\'a\\']);\\n        }\\n        int sum=0;\\n        for(auto it:cnt)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string ptr) {\\n        vector<int>cnt(26,0);\\n        int maxlen=1;\\n        for(int i=0;i<ptr.length();i++)\\n        {\\n            if(i>0 && ((ptr[i]-ptr[i-1])==1 ||  (ptr[i-1]-ptr[i])==25))\\n                maxlen++;\\n            else\\n                maxlen=1;\\n            cnt[ptr[i]-\\'a\\']=max(maxlen,cnt[ptr[i]-\\'a\\']);\\n        }\\n        int sum=0;\\n        for(auto it:cnt)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362185,
                "title": "recursive-solution-with-memoization",
                "content": "I didn\\'t notice a decent recursive solution for this problem, but we can solve this problem recursively though in a general way (I have included the most popular solution as **rec2**). The current solution is differentiated from the most common one in the way that it can work if we try to change the pattern (it doesn\\'t need the supportive logic of p[i] - p[i - 1] == 1 etc, because it doesn\\'t know that our pattern is in the strictly increasing order with +1 in the every step).\\nWhat we need is to count how many substrings we can form for each character from the range \\'a\\'..\\'z\\'.\\nIf we will stay in some recursion state when there is zero characters left in the pattern (we reach the beggining of it), we can just move on the opposite side of the pattern by calling the same recursion instance, but the \\'m\\' position of the pattern should be set as its end.\\nIf we encounter the same character as we did in the previous iterations (\\'z\\' again, for example), we are starting our counting process again and it can lead us to the answer with the same, or more, or less substrings, so we always choose the maximum (because we are not allowed to count repeated substrings several times).\\nThis solution works even without the dp table which I introduced for the memoization purpose, but it works a lot faster with it and beats all the tests. :)\\n\\n**const int ch = b[i - 1] - \\'a\\' + 1;** - is needed to indicate where the current character of the string in our pattern (from which will start comparing). It is incremented by 1 so we can use 1-based indexing.\\n**if (m == 0) return dp[n][m] = rec(dp, b, n, a.size());** - is needed to go backward to the end of the pattern in the circular manner.\\n\\n```c++\\nusing vi = vector<int>;\\nusing vvi = vector<vi>;\\n\\nint rec(vvi& dp, const string& b, const int n, const int m) {\\n    static const string a = \"abcdefghijklmnopqrstuvwxyz\";\\n    if (n == 0) return 0;\\n    if (dp[n][m] != -1) return dp[n][m];\\n    if (m == 0) return dp[n][m] = rec(dp, b, n, a.size());\\n    if (a[m - 1] == b[n - 1]) return dp[n][m] = 1 + rec(dp, b, n - 1, m - 1);\\n    return 0;\\n}\\n\\nint rec(const string& b) {\\n    const int n = b.size();\\n    const int CHARS_SIZE = 27;\\n    vi count(CHARS_SIZE);\\n    vvi dp(n + 1, vi(CHARS_SIZE, -1));\\n    for (int i = n; i >= 1; --i) {\\n        const int ch = b[i - 1] - \\'a\\' + 1;\\n        count[ch] = max(count[ch], rec(dp, b, i, ch));\\n    }\\n    return reduce(cbegin(count), cend(count));\\n}\\n\\nint rec2(vi& dp, const string& b, const int n) {\\n    if (n <= 1) return n;\\n    if (dp[n] != -1) return dp[n];\\n    if ((b[n - 1] - b[n - 2] == 1) or (b[n - 1] == \\'a\\' and b[n - 2] == \\'z\\'))\\n        return dp[n] = 1 + rec2(dp, b, n - 1);\\n    return 1;\\n}\\n\\nint rec2(const string& b) {\\n    const int n = b.size();\\n    const int CHARS_SIZE = 27;\\n    vi count(CHARS_SIZE);\\n    vi dp(n + 1, -1);\\n    for (int i = n; i >= 1; --i) {\\n        const int ch = b[i - 1] - \\'a\\' + 1;\\n        count[ch] = max(count[ch], rec2(dp, b, i));\\n    }\\n    return reduce(cbegin(count), cend(count));\\n}\\n\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(const string& p) {\\n        return rec(p);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nusing vi = vector<int>;\\nusing vvi = vector<vi>;\\n\\nint rec(vvi& dp, const string& b, const int n, const int m) {\\n    static const string a = \"abcdefghijklmnopqrstuvwxyz\";\\n    if (n == 0) return 0;\\n    if (dp[n][m] != -1) return dp[n][m];\\n    if (m == 0) return dp[n][m] = rec(dp, b, n, a.size());\\n    if (a[m - 1] == b[n - 1]) return dp[n][m] = 1 + rec(dp, b, n - 1, m - 1);\\n    return 0;\\n}\\n\\nint rec(const string& b) {\\n    const int n = b.size();\\n    const int CHARS_SIZE = 27;\\n    vi count(CHARS_SIZE);\\n    vvi dp(n + 1, vi(CHARS_SIZE, -1));\\n    for (int i = n; i >= 1; --i) {\\n        const int ch = b[i - 1] - \\'a\\' + 1;\\n        count[ch] = max(count[ch], rec(dp, b, i, ch));\\n    }\\n    return reduce(cbegin(count), cend(count));\\n}\\n\\nint rec2(vi& dp, const string& b, const int n) {\\n    if (n <= 1) return n;\\n    if (dp[n] != -1) return dp[n];\\n    if ((b[n - 1] - b[n - 2] == 1) or (b[n - 1] == \\'a\\' and b[n - 2] == \\'z\\'))\\n        return dp[n] = 1 + rec2(dp, b, n - 1);\\n    return 1;\\n}\\n\\nint rec2(const string& b) {\\n    const int n = b.size();\\n    const int CHARS_SIZE = 27;\\n    vi count(CHARS_SIZE);\\n    vi dp(n + 1, -1);\\n    for (int i = n; i >= 1; --i) {\\n        const int ch = b[i - 1] - \\'a\\' + 1;\\n        count[ch] = max(count[ch], rec2(dp, b, i));\\n    }\\n    return reduce(cbegin(count), cend(count));\\n}\\n\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(const string& p) {\\n        return rec(p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975821,
                "title": "python3-with-explanation",
                "content": "Only focus on the first character of each unique string.\\nFor example. in the string \"**abcdmcdef**\" the strings start with c are : **\"c\", \"cd\", \"c\", \"cd\", \"cde\", \"cdef\"**, however the first \"c\", \"cd\" will be ignored since they were inclued in the substing \"cdef\".\\nTherefore we can only record down the highest index for each character in the **reversed string**, as long as the **ord(current char) - ord(previous char) %26 ==1**, we can add index by 1, otherwise we reset the index to 1.\\n\\nTherefore this string will be like:\\n**\"abcdmcdef\" ----> \"432114321\"**\\nDuring the process from the end to the start of the string, we just update the dictionary to keep the maximum index of each character.\\nThe last thing is return the sum values of the dictionary.\\n\\n\\n```\\ndef findSubstringInWraproundString(self, p: str) -> int:\\n\\t\\td={x:1 for x in p}\\n\\t\\tcur=1\\n\\t\\tfor x in range(len(p)-1,-1,-1):\\n\\t\\t\\tif x==len(p)-1 or (ord(p[x+1])-ord(p[x]))%26!=1:\\n\\t\\t\\t\\tcur=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur+=1\\n\\t\\t\\t\\td[p[x]]=max(d[p[x]],cur)\\n\\t\\treturn sum(d.values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef findSubstringInWraproundString(self, p: str) -> int:\\n\\t\\td={x:1 for x in p}\\n\\t\\tcur=1\\n\\t\\tfor x in range(len(p)-1,-1,-1):\\n\\t\\t\\tif x==len(p)-1 or (ord(p[x+1])-ord(p[x]))%26!=1:\\n\\t\\t\\t\\tcur=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur+=1\\n\\t\\t\\t\\td[p[x]]=max(d[p[x]],cur)\\n\\t\\treturn sum(d.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 940265,
                "title": "explanation-python-o-n-x-o-n",
                "content": "```python\\n\"\"\"\\nKey idea 1: let r be a substring of p, it is sufficient to check if r \\nis a substring of 2 * wraparound (i.e. wraparound + wraparound) to see if it is contained\\nin the infite wraparound string. \\n\\nKey idea 2: since the wraparound is the alphabet in order then any substring \\nmust have characters consecutive to each other e.g. \\'da\\' cannot be a susbstring of\\nwraparound since a is not consecutive to d, thus it is sufficient to check if \\nevery character in the string is consecutive to the previous one or z is the current char and \\na is the previous char (loop-like behaviour so that \"za...\" strings are considered)\\n\\nKey idea 3: every substring can be checked for the properties listed in key idea 2\\nwith a dynamic programming approach in a linear manner O(n) x O(n)\\n\\ndp[i] = dp[i-1]+1 if p[i] = p[i-1] + 1 otherwise 1\\ndp[i] = number of substrings which satisfy the condition ending with p[i]\\n\"\"\"\\n\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dp = [1] * len(p)\\n        dic = defaultdict(int)\\n        \\n        for i in range(1,len(p)):\\n            is_consecutive = ord(p[i]) == ord(p[i-1])+1\\n            is_looptail = p[i] == \\'a\\' and p[i-1] == \\'z\\'\\n            if is_consecutive or is_looptail:\\n                dp[i] = dp[i-1] + 1\\n        \\n        # Consider unique substrings only\\n        for i in range(len(dp)):\\n            dic[p[i]] = max(dic[p[i]], dp[i])\\n        \\n        return sum(dic.values())\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nKey idea 1: let r be a substring of p, it is sufficient to check if r \\nis a substring of 2 * wraparound (i.e. wraparound + wraparound) to see if it is contained\\nin the infite wraparound string. \\n\\nKey idea 2: since the wraparound is the alphabet in order then any substring \\nmust have characters consecutive to each other e.g. \\'da\\' cannot be a susbstring of\\nwraparound since a is not consecutive to d, thus it is sufficient to check if \\nevery character in the string is consecutive to the previous one or z is the current char and \\na is the previous char (loop-like behaviour so that \"za...\" strings are considered)\\n\\nKey idea 3: every substring can be checked for the properties listed in key idea 2\\nwith a dynamic programming approach in a linear manner O(n) x O(n)\\n\\ndp[i] = dp[i-1]+1 if p[i] = p[i-1] + 1 otherwise 1\\ndp[i] = number of substrings which satisfy the condition ending with p[i]\\n\"\"\"\\n\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dp = [1] * len(p)\\n        dic = defaultdict(int)\\n        \\n        for i in range(1,len(p)):\\n            is_consecutive = ord(p[i]) == ord(p[i-1])+1\\n            is_looptail = p[i] == \\'a\\' and p[i-1] == \\'z\\'\\n            if is_consecutive or is_looptail:\\n                dp[i] = dp[i-1] + 1\\n        \\n        # Consider unique substrings only\\n        for i in range(len(dp)):\\n            dic[p[i]] = max(dic[p[i]], dp[i])\\n        \\n        return sum(dic.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828116,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n\\n        public int findSubstringInWraproundString(String p) {\\n            int[] max = new int[26];\\n            int count = 0;\\n\\n            int start = 0;\\n            for (int i = 0; i < p.length(); i++) {\\n\\n                int diff;\\n                if (i == 0) {\\n                    diff = 1;\\n                } else {\\n                    diff = p.charAt(i) - p.charAt(i - 1);\\n                }\\n\\n                if (diff != 1 && diff != -25) {\\n                    start = i;\\n                }\\n\\n                int len = i - start + 1;\\n                int idx = p.charAt(i) - \\'a\\';\\n                if (len > max[idx]) {\\n                    count += (len - max[idx]);\\n                    max[idx] = len;\\n                }\\n            }\\n\\n            return count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n        public int findSubstringInWraproundString(String p) {\\n            int[] max = new int[26];\\n            int count = 0;\\n\\n            int start = 0;\\n            for (int i = 0; i < p.length(); i++) {\\n\\n                int diff;\\n                if (i == 0) {\\n                    diff = 1;\\n                } else {\\n                    diff = p.charAt(i) - p.charAt(i - 1);\\n                }\\n\\n                if (diff != 1 && diff != -25) {\\n                    start = i;\\n                }\\n\\n                int len = i - start + 1;\\n                int idx = p.charAt(i) - \\'a\\';\\n                if (len > max[idx]) {\\n                    count += (len - max[idx]);\\n                    max[idx] = len;\\n                }\\n            }\\n\\n            return count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812114,
                "title": "c-4-solution-with-gradual-optimization",
                "content": "# Fist Version, got TLE \\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<unordered_set<int>> dp(26);\\n        dp[p[0]-\\'a\\'].insert(1);\\n        string tmp = string(1,p[0]);\\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((tmp.back() + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                tmp.push_back(ch);\\n                for(int j = 0;j<tmp.size();j++){\\n                    dp[tmp[j]-\\'a\\'].insert(tmp.size()-j);\\n                }\\n            } else {\\n                tmp = string(1,ch);\\n                dp[ch-\\'a\\'].insert(1);\\n            }\\n        }\\n        int ret = 0;\\n        for(auto& s : dp) {\\n            ret += s.size();\\n        }\\n        return ret; \\n    }\\n};\\n```\\n# Second version, pass, 52 ms. \\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<int> dp(26);\\n        dp[p[0]-\\'a\\'] = 1;\\n        int ret = 1; \\n        string tmp = string(1,p[0]);\\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((tmp.back() + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                tmp.push_back(ch);\\n                for(int j = 0;j<tmp.size()&&j<26;j++){\\n                    if(tmp.size() - j > dp[tmp[j] - \\'a\\']) {\\n                        ret += tmp.size() - j - dp[tmp[j] - \\'a\\'];\\n                        dp[tmp[j] - \\'a\\'] = tmp.size() - j;\\n                    }\\n                }\\n            } else {\\n                tmp = string(1,ch);\\n                if(dp[ch-\\'a\\'] == 0) {\\n                    dp[ch - \\'a\\'] = 1;\\n                    ret++;\\n                }\\n            }\\n        }\\n        return ret; \\n    }\\n};\\n```\\n# Third version, pass, 44 ms. \\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<int> dp(26);\\n        dp[p[0]-\\'a\\'] = 1;\\n        string tmp = string(1,p[0]);\\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((tmp.back() + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                tmp.push_back(ch);\\n                for(int j = 0;j<tmp.size()&&j<26;j++){\\n                    if(tmp.size() - j > dp[tmp[j] - \\'a\\']) {\\n                        dp[tmp[j] - \\'a\\'] = tmp.size() - j;\\n                    }\\n                }\\n            } else {\\n                tmp = string(1,ch);\\n                if(dp[ch-\\'a\\'] == 0) {\\n                    dp[ch - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        for(int x : dp) {\\n            ret += x; \\n        }\\n        return ret; \\n    }\\n};\\n```\\n# Fourth version, pass, 12 ms\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<int> dp(26);\\n        dp[p[0]-\\'a\\'] = 1;\\n        int len = 1; \\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((p[i-1] + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                len++;\\n            } else {\\n                len = 1;\\n            }\\n            dp[ch - \\'a\\'] = max(dp[ch - \\'a\\'],len);\\n        }\\n        \\n        int ret = 0;\\n        for(int x : dp) {\\n            ret += x; \\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<unordered_set<int>> dp(26);\\n        dp[p[0]-\\'a\\'].insert(1);\\n        string tmp = string(1,p[0]);\\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((tmp.back() + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                tmp.push_back(ch);\\n                for(int j = 0;j<tmp.size();j++){\\n                    dp[tmp[j]-\\'a\\'].insert(tmp.size()-j);\\n                }\\n            } else {\\n                tmp = string(1,ch);\\n                dp[ch-\\'a\\'].insert(1);\\n            }\\n        }\\n        int ret = 0;\\n        for(auto& s : dp) {\\n            ret += s.size();\\n        }\\n        return ret; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<int> dp(26);\\n        dp[p[0]-\\'a\\'] = 1;\\n        int ret = 1; \\n        string tmp = string(1,p[0]);\\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((tmp.back() + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                tmp.push_back(ch);\\n                for(int j = 0;j<tmp.size()&&j<26;j++){\\n                    if(tmp.size() - j > dp[tmp[j] - \\'a\\']) {\\n                        ret += tmp.size() - j - dp[tmp[j] - \\'a\\'];\\n                        dp[tmp[j] - \\'a\\'] = tmp.size() - j;\\n                    }\\n                }\\n            } else {\\n                tmp = string(1,ch);\\n                if(dp[ch-\\'a\\'] == 0) {\\n                    dp[ch - \\'a\\'] = 1;\\n                    ret++;\\n                }\\n            }\\n        }\\n        return ret; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<int> dp(26);\\n        dp[p[0]-\\'a\\'] = 1;\\n        string tmp = string(1,p[0]);\\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((tmp.back() + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                tmp.push_back(ch);\\n                for(int j = 0;j<tmp.size()&&j<26;j++){\\n                    if(tmp.size() - j > dp[tmp[j] - \\'a\\']) {\\n                        dp[tmp[j] - \\'a\\'] = tmp.size() - j;\\n                    }\\n                }\\n            } else {\\n                tmp = string(1,ch);\\n                if(dp[ch-\\'a\\'] == 0) {\\n                    dp[ch - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        for(int x : dp) {\\n            ret += x; \\n        }\\n        return ret; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        if(p.empty()) {\\n            return 0;\\n        }\\n        vector<int> dp(26);\\n        dp[p[0]-\\'a\\'] = 1;\\n        int len = 1; \\n        for(int i = 1;i<p.size();i++){\\n            char ch = p[i];\\n            if ((p[i-1] + 1 - \\'a\\') % 26 == ch - \\'a\\') {\\n                len++;\\n            } else {\\n                len = 1;\\n            }\\n            dp[ch - \\'a\\'] = max(dp[ch - \\'a\\'],len);\\n        }\\n        \\n        int ret = 0;\\n        for(int x : dp) {\\n            ret += x; \\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646032,
                "title": "c-8ms-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findSubstringInWraproundString(string p) {\\n\\t\\t\\tif(p.empty()) return 0;\\n\\t\\t\\tvector<int> dp(26); //max len of substring starting with that character \\n\\t\\t\\tdp[p.back()-\\'a\\']=1;\\n\\t\\t\\tint len=1;\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(p[i]-p[i+1]==-1 || (p[i]==\\'z\\' && p[i+1]==\\'a\\'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t\\tdp[p[i]-\\'a\\']=max(dp[p[i]-\\'a\\'], len);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[p[i]-\\'a\\']=max(dp[p[i]-\\'a\\'], 1);\\n\\t\\t\\t\\t\\tlen=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(auto& x:dp)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=x;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;  \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findSubstringInWraproundString(string p) {\\n\\t\\t\\tif(p.empty()) return 0;\\n\\t\\t\\tvector<int> dp(26); //max len of substring starting with that character \\n\\t\\t\\tdp[p.back()-\\'a\\']=1;\\n\\t\\t\\tint len=1;\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(p[i]-p[i+1]==-1 || (p[i]==\\'z\\' && p[i+1]==\\'a\\'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t\\tdp[p[i]-\\'a\\']=max(dp[p[i]-\\'a\\'], len);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 328218,
                "title": "o-n-time-o-26-space",
                "content": "for a string like \"zabc\", its substrings meet the conditions are:\\n+ strings leads by \\'z\\': z, za, zab, zabc\\n+ strings leads by \\'a\\': a, ab, abc\\n+ strings leads by \\'b\\', b, bc\\n+ string leads by \\'c\\', c\\nso the total number of substring meet conditions are maxLen(leads by \\'c\\') + maxLen(leads by \\'a\\') + maxLen(leads by \\'b\\') + maxLen(leads by \\'c\\');\\n\\nnow consider another string has some overlap with it, like \\'bcd\\'\\nit contains:b, bc, bcd + c, cd + d\\nwhile b, bc, c are duplcated from substrings of \\'zabc\\', we can easily find:\\nmaxLen(leads by \\'b\\')  from \\'zabc\\' is 2 < maxLen(leads by \\'b\\') from \\'bcd\\' is 3 and substrings leads by \\'b\\' from \\'zabc\\' are duplidated, we can only count substrings lead by \\'b\\' from \\'bcd\\'.\\n\\nthus, for any substring from p meets the condition, we only count the maxLen of substrings lead by each character.\\n\\n    public int findSubstringInWraproundString(String p) {\\n        if (p == null) return 0;\\n        int index = 0, len = p.length();\\n        int[] arr = new int[26];\\n        while (index < len) {\\n            int i = index+1;\\n            while (i < len && p.charAt(i)-\\'a\\' == (p.charAt(i-1)-\\'a\\'+1)%26) i++;\\n            for (int j = index; j < i; j++) {\\n                int id = p.charAt(j)-\\'a\\';\\n                arr[id] = Math.max(arr[id], i-j);\\n            }\\n            index = i;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            ans += arr[i];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "for a string like \"zabc\", its substrings meet the conditions are:\\n+ strings leads by \\'z\\': z, za, zab, zabc\\n+ strings leads by \\'a\\': a, ab, abc\\n+ strings leads by \\'b\\', b, bc\\n+ string leads by \\'c\\', c\\nso the total number of substring meet conditions are maxLen(leads by \\'c\\') + maxLen(leads by \\'a\\') + maxLen(leads by \\'b\\') + maxLen(leads by \\'c\\');\\n\\nnow consider another string has some overlap with it, like \\'bcd\\'\\nit contains:b, bc, bcd + c, cd + d\\nwhile b, bc, c are duplcated from substrings of \\'zabc\\', we can easily find:\\nmaxLen(leads by \\'b\\')  from \\'zabc\\' is 2 < maxLen(leads by \\'b\\') from \\'bcd\\' is 3 and substrings leads by \\'b\\' from \\'zabc\\' are duplidated, we can only count substrings lead by \\'b\\' from \\'bcd\\'.\\n\\nthus, for any substring from p meets the condition, we only count the maxLen of substrings lead by each character.\\n\\n    public int findSubstringInWraproundString(String p) {\\n        if (p == null) return 0;\\n        int index = 0, len = p.length();\\n        int[] arr = new int[26];\\n        while (index < len) {\\n            int i = index+1;\\n            while (i < len && p.charAt(i)-\\'a\\' == (p.charAt(i-1)-\\'a\\'+1)%26) i++;\\n            for (int j = index; j < i; j++) {\\n                int id = p.charAt(j)-\\'a\\';\\n                arr[id] = Math.max(arr[id], i-j);\\n            }\\n            index = i;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            ans += arr[i];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 178273,
                "title": "what-if-we-need-to-find-the-unique-subsequence-not-substrings",
                "content": "Here is my code. Please correct me if I was wrong!\\n```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int n = p.length();\\n        if(n == 0) return 0;\\n        int[] A =new int[26];\\n        for(int i=0;i<n;i++) {\\n            int j = p.charAt(i)-\\'a\\';\\n            A[j] = Math.max(A[j],A[(j+25)%26]+1) ;\\n        }\\n        int res = 0;\\n        for(int j=0;j<26;j++) {\\n            res += A[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int n = p.length();\\n        if(n == 0) return 0;\\n        int[] A =new int[26];\\n        for(int i=0;i<n;i++) {\\n            int j = p.charAt(i)-\\'a\\';\\n            A[j] = Math.max(A[j],A[(j+25)%26]+1) ;\\n        }\\n        int res = 0;\\n        for(int j=0;j<26;j++) {\\n            res += A[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136292,
                "title": "straightforward-c-with-explanation",
                "content": "**Simple iterative solution:** inefficient O(N^2) algorithm, but easy to understand.  Try to find consecutive substrings of length ```k``` at each starting index ```i``` of the input string ```s```.  Use vector ```v``` to store the maximum length ```k``` for each consecutive substring\\'s unique *beginning* value ```s[i]``` in buckets from ```\\'a\\'``` to ```\\'z\\'``` inclusive.  Finally add up all the buckets and return that sum.\\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        for (int i=0,N=(int)s.size(); i<N; ++i){\\n            int k=1; for (;i+k<N && next(s[i+k-1])==s[i+k]; ++k); // increment k\\n            int bucket=s[i]-\\'a\\';\\n            v[bucket]=max(v[bucket],k);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : ++c; }\\n};\\n```\\n\\n**DP solution #1:** same idea as above using DP to track the ongoing lengths of each substring sequence.  Let ```dp[i]``` denote the substring sequence length at each *ending* char ```s[i]```.  There are two cases to consider.\\n1) if ```s[i]``` is part of a previous sequence *ending* at ```s[i-1]```, then ```dp[i]=dp[i-1]+1```\\n2) ```s[i]``` is *not* part of a previous sequence *ending* at ```s[i-1]```, then ```dp[i]=1```\\n\\nUse vector ```v``` to store the maximum length ```dp[i]``` for each consecutive substring\\'s unique *ending* value ```s[i]``` in buckets from ```\\'a\\'``` to ```\\'z\\'``` inclusive.  Finally add up all the buckets and return that sum.\\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        if (s.empty()) return 0;\\n        vector<int> dp(s.size());\\n        dp[0]=1;\\n        v[s[0]-\\'a\\']=1;\\n        for (int i=1,N=(int)s.size(); i<N; ++i){\\n            char c=next(s[i-1]);\\n            if (c==s[i])\\n                dp[i]=dp[i-1]+1;\\n            else\\n                dp[i]=1;\\n            int bucket=s[i]-\\'a\\';\\n            v[bucket]=max(v[bucket],dp[i]);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : c+1; }\\n};\\n```\\n\\n**DP Solution #2:** same idea as above DP solution, further optimized for O(1) memory using ```len``` to track the previous consequetive substring\\'s length.\\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        for (int i=0,N=(int)s.size(),len=1; i<N; ++i){\\n            char c=i>0 ? next(s[i-1]) : \\'\\\\0\\';\\n            if (c==s[i])\\n                ++len;\\n            else\\n                len=1;\\n            int bucket=s[i]-\\'a\\';\\n            v[bucket]=max(v[bucket],len);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : c+1; }\\n};\\n```\\n**DP Solution #3:** same idea as DP solutions above, written more concisely...\\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        for (int i=0,N=(int)s.size(),len=1; i<N; ++i){\\n            len=(i>0 && next(s[i-1])==s[i]) ? len+1 : 1;\\n            v[s[i]-\\'a\\']=max(v[s[i]-\\'a\\'],len);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : c+1; }\\n};\\n```",
                "solutionTags": [],
                "code": "```k```\n```i```\n```s```\n```v```\n```k```\n```s[i]```\n```\\'a\\'```\n```\\'z\\'```\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        for (int i=0,N=(int)s.size(); i<N; ++i){\\n            int k=1; for (;i+k<N && next(s[i+k-1])==s[i+k]; ++k); // increment k\\n            int bucket=s[i]-\\'a\\';\\n            v[bucket]=max(v[bucket],k);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : ++c; }\\n};\\n```\n```dp[i]```\n```s[i]```\n```s[i]```\n```s[i-1]```\n```dp[i]=dp[i-1]+1```\n```s[i]```\n```s[i-1]```\n```dp[i]=1```\n```v```\n```dp[i]```\n```s[i]```\n```\\'a\\'```\n```\\'z\\'```\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        if (s.empty()) return 0;\\n        vector<int> dp(s.size());\\n        dp[0]=1;\\n        v[s[0]-\\'a\\']=1;\\n        for (int i=1,N=(int)s.size(); i<N; ++i){\\n            char c=next(s[i-1]);\\n            if (c==s[i])\\n                dp[i]=dp[i-1]+1;\\n            else\\n                dp[i]=1;\\n            int bucket=s[i]-\\'a\\';\\n            v[bucket]=max(v[bucket],dp[i]);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : c+1; }\\n};\\n```\n```len```\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        for (int i=0,N=(int)s.size(),len=1; i<N; ++i){\\n            char c=i>0 ? next(s[i-1]) : \\'\\\\0\\';\\n            if (c==s[i])\\n                ++len;\\n            else\\n                len=1;\\n            int bucket=s[i]-\\'a\\';\\n            v[bucket]=max(v[bucket],len);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : c+1; }\\n};\\n```\n```\\nusing VI=vector<int>;\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s, VI v=VI(26,0)) {\\n        for (int i=0,N=(int)s.size(),len=1; i<N; ++i){\\n            len=(i>0 && next(s[i-1])==s[i]) ? len+1 : 1;\\n            v[s[i]-\\'a\\']=max(v[s[i]-\\'a\\'],len);\\n        }\\n        return accumulate(v.begin(),v.end(),0);\\n    }\\nprivate:\\n    const char next(const char c) const { return c==\\'z\\' ? \\'a\\' : c+1; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133147,
                "title": "java-dp-solution-recursive-iterative-improved-iterative",
                "content": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        return dpSolutionIterativeImproved(p);\\n    }\\n    \\n    private int dpSolutionRecursive(String p) {\\n        /*\\n            Stores number of unique substrings starting at each character.\\n            E.g. for p=\"zab\" will store: \\n            \"3\" at index \"25\" (for \"z\", since there are 3 substrings starting with \"z\": \"z\", \"za\", \"zab\"), \\n            \"2\" at index \"0\" (for \"a\", substrings \"a\", \"ab\") etc.\\n        */\\n        int[] uniqueSubstringsStartingAt = new int[26];\\n        int[] cache = new int[p.length() + 1];\\n        for (int i = 0; i < p.length(); i++) {\\n            int index = p.charAt(i) - \\'a\\'; // maps character to index in \"uniqueSubstringsStartingAt\" array\\n            \\n            /*\\n                This part:\\n                Consider string \"abcdab\". In this case there are 2 occurrences of \"a\", \\n                there are 4 substrings starting with the first occurrence of \"a\":\\n                \"a\" \"ab\" \"abc\" \"abcd\" (*1)\\n                but there are only 2 occurrences starting with the second occurrence of \"a\":\\n                \"a\" \"ab\" (*2)\\n                Note: *1 contains all substrings from *2\\n            */\\n            uniqueSubstringsStartingAt[index] = Math.max(uniqueSubstringsStartingAt[index], findUniqueSubstringsStartingAt(p, i, cache));\\n        }\\n        int total = 0;\\n        for (int i = 0; i < uniqueSubstringsStartingAt.length; i++) {\\n            total += uniqueSubstringsStartingAt[i];\\n        }\\n        return total;\\n    }\\n    \\n    private int findUniqueSubstringsStartingAt(String p, int index, int[] cache) {\\n        if (index == p.length() - 1) return 1;\\n        if (cache[index] != 0) return cache[index];\\n        \\n        int uniqueSubstrings = 1;\\n        if ((p.charAt(index + 1) == \\'a\\' && p.charAt(index) == \\'z\\') || \\n            (p.charAt(index + 1) - p.charAt(index) == 1)) {\\n            uniqueSubstrings += findUniqueSubstringsStartingAt(p, index + 1, cache);\\n        }\\n        cache[index] = uniqueSubstrings;\\n        return uniqueSubstrings;\\n    }\\n    \\n    // Recursive solution rewritten iteratively\\n    private int dpSolutionIterative(String p) {\\n        int[] uniqueSubstringsStartingAt = new int[26];\\n        int[] cache = new int[p.length() + 1];\\n        for (int i = p.length() - 1; i >= 0; i--) {\\n            int index = p.charAt(i) - \\'a\\';\\n            int newMaxCandidate = 1;\\n            if (i < p.length() - 1 && ((p.charAt(i) == \\'z\\' && p.charAt(i + 1) == \\'a\\') || (p.charAt(i + 1) - p.charAt(i) == 1))) {\\n                newMaxCandidate += cache[i + 1];\\n            }\\n            cache[i] = newMaxCandidate;            \\n            uniqueSubstringsStartingAt[index] = Math.max(uniqueSubstringsStartingAt[index], newMaxCandidate);\\n        }\\n        int total = 0;\\n        for (int i = 0; i < uniqueSubstringsStartingAt.length; i++) {\\n            total += uniqueSubstringsStartingAt[i];\\n        }\\n        return total;\\n    }\\n    \\n    // Recursive solution rewritten iteratively with space optimization\\n    private int dpSolutionIterativeImproved(String p) {\\n        int[] uniqueSubstringsStartingAt = new int[26];\\n        int prevMax = 0;\\n        int max = 0;\\n        for (int i = p.length() - 1; i >= 0; i--) {\\n            int index = p.charAt(i) - \\'a\\';\\n            int newMaxCandidate = 1;\\n            if (i < p.length() - 1 && ((p.charAt(i) == \\'z\\' && p.charAt(i + 1) == \\'a\\') || (p.charAt(i + 1) - p.charAt(i) == 1))) {\\n                newMaxCandidate += prevMax;\\n            }\\n            prevMax = newMaxCandidate;\\n            uniqueSubstringsStartingAt[index] = Math.max(uniqueSubstringsStartingAt[index], newMaxCandidate);\\n        }\\n        int total = 0;\\n        for (int i = 0; i < uniqueSubstringsStartingAt.length; i++) {\\n            total += uniqueSubstringsStartingAt[i];\\n        }\\n        return total;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        return dpSolutionIterativeImproved(p);\\n    }\\n    \\n    private int dpSolutionRecursive(String p) {\\n        /*\\n            Stores number of unique substrings starting at each character.\\n            E.g. for p=\"zab\" will store: \\n            \"3\" at index \"25\" (for \"z\", since there are 3 substrings starting with \"z\": \"z\", \"za\", \"zab\"), \\n            \"2\" at index \"0\" (for \"a\", substrings \"a\", \"ab\") etc.\\n        */\\n        int[] uniqueSubstringsStartingAt = new int[26];\\n        int[] cache = new int[p.length() + 1];\\n        for (int i = 0; i < p.length(); i++) {\\n            int index = p.charAt(i) - \\'a\\'; // maps character to index in \"uniqueSubstringsStartingAt\" array\\n            \\n            /*\\n                This part:\\n                Consider string \"abcdab\". In this case there are 2 occurrences of \"a\", \\n                there are 4 substrings starting with the first occurrence of \"a\":\\n                \"a\" \"ab\" \"abc\" \"abcd\" (*1)\\n                but there are only 2 occurrences starting with the second occurrence of \"a\":\\n                \"a\" \"ab\" (*2)\\n                Note: *1 contains all substrings from *2\\n            */\\n            uniqueSubstringsStartingAt[index] = Math.max(uniqueSubstringsStartingAt[index], findUniqueSubstringsStartingAt(p, i, cache));\\n        }\\n        int total = 0;\\n        for (int i = 0; i < uniqueSubstringsStartingAt.length; i++) {\\n            total += uniqueSubstringsStartingAt[i];\\n        }\\n        return total;\\n    }\\n    \\n    private int findUniqueSubstringsStartingAt(String p, int index, int[] cache) {\\n        if (index == p.length() - 1) return 1;\\n        if (cache[index] != 0) return cache[index];\\n        \\n        int uniqueSubstrings = 1;\\n        if ((p.charAt(index + 1) == \\'a\\' && p.charAt(index) == \\'z\\') || \\n            (p.charAt(index + 1) - p.charAt(index) == 1)) {\\n            uniqueSubstrings += findUniqueSubstringsStartingAt(p, index + 1, cache);\\n        }\\n        cache[index] = uniqueSubstrings;\\n        return uniqueSubstrings;\\n    }\\n    \\n    // Recursive solution rewritten iteratively\\n    private int dpSolutionIterative(String p) {\\n        int[] uniqueSubstringsStartingAt = new int[26];\\n        int[] cache = new int[p.length() + 1];\\n        for (int i = p.length() - 1; i >= 0; i--) {\\n            int index = p.charAt(i) - \\'a\\';\\n            int newMaxCandidate = 1;\\n            if (i < p.length() - 1 && ((p.charAt(i) == \\'z\\' && p.charAt(i + 1) == \\'a\\') || (p.charAt(i + 1) - p.charAt(i) == 1))) {\\n                newMaxCandidate += cache[i + 1];\\n            }\\n            cache[i] = newMaxCandidate;            \\n            uniqueSubstringsStartingAt[index] = Math.max(uniqueSubstringsStartingAt[index], newMaxCandidate);\\n        }\\n        int total = 0;\\n        for (int i = 0; i < uniqueSubstringsStartingAt.length; i++) {\\n            total += uniqueSubstringsStartingAt[i];\\n        }\\n        return total;\\n    }\\n    \\n    // Recursive solution rewritten iteratively with space optimization\\n    private int dpSolutionIterativeImproved(String p) {\\n        int[] uniqueSubstringsStartingAt = new int[26];\\n        int prevMax = 0;\\n        int max = 0;\\n        for (int i = p.length() - 1; i >= 0; i--) {\\n            int index = p.charAt(i) - \\'a\\';\\n            int newMaxCandidate = 1;\\n            if (i < p.length() - 1 && ((p.charAt(i) == \\'z\\' && p.charAt(i + 1) == \\'a\\') || (p.charAt(i + 1) - p.charAt(i) == 1))) {\\n                newMaxCandidate += prevMax;\\n            }\\n            prevMax = newMaxCandidate;\\n            uniqueSubstringsStartingAt[index] = Math.max(uniqueSubstringsStartingAt[index], newMaxCandidate);\\n        }\\n        int total = 0;\\n        for (int i = 0; i < uniqueSubstringsStartingAt.length; i++) {\\n            total += uniqueSubstringsStartingAt[i];\\n        }\\n        return total;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95455,
                "title": "i-don-t-think-the-main-idea-for-this-problem-is-dp",
                "content": "I've seen many people's posts. They use the vector<int>(26,0) to store the max length of substring in Wraparound String that ended by a fixed char. And the result is simply sum of the vector. \\n\\nThis method mainly apply the property that: the length of the longest valid substring ended by some char is the total number of **unique**  substring  in Wraparound String that ended by that char.\\n\\nFor example, if vec[0] = 4, which means the longest substring in  Wraparound String, tailed by 'a',  is 'xyza'. Then, any valid substring tailed by 'a' can only be chosen from these 4 candidates: \\n'xyza', 'yza', 'za', and 'a' , since we need **unique.** \\n\\nBut the tags and someone's  titles really confused me, and I spend several hours working on normal dp solutions, which of course got TLE.",
                "solutionTags": [],
                "code": "I've seen many people's posts. They use the vector<int>(26,0) to store the max length of substring in Wraparound String that ended by a fixed char. And the result is simply sum of the vector. \\n\\nThis method mainly apply the property that: the length of the longest valid substring ended by some char is the total number of **unique**  substring  in Wraparound String that ended by that char.\\n\\nFor example, if vec[0] = 4, which means the longest substring in  Wraparound String, tailed by 'a',  is 'xyza'. Then, any valid substring tailed by 'a' can only be chosen from these 4 candidates: \\n'xyza', 'yza', 'za', and 'a' , since we need **unique.** \\n\\nBut the tags and someone's  titles really confused me, and I spend several hours working on normal dp solutions, which of course got TLE.",
                "codeTag": "Unknown"
            },
            {
                "id": 95458,
                "title": "java-dp-solution-easy-understand",
                "content": "```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] alphabets=new int[26];\\n        if(p.isEmpty()) return 0;\\n         int len=1;\\n         alphabets[p.charAt(0)-'a']=1;\\n        for(int i=1;i<p.length();i++)\\n        {\\n            int current=p.charAt(i)-'a';\\n            int prev =p.charAt(i-1)-'a';\\n            if((prev+1)%26==current)\\n             len++;\\n            else len=1;\\n            alphabets[current]=Math.max(alphabets[current],len);\\n        }\\n        int sum=0;\\n        for(int i:alphabets) sum+=i;\\n        return sum;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] alphabets=new int[26];\\n        if(p.isEmpty()) return 0;\\n         int len=1;\\n         alphabets[p.charAt(0)-'a']=1;\\n        for(int i=1;i<p.length();i++)\\n        {\\n            int current=p.charAt(i)-'a';\\n            int prev =p.charAt(i-1)-'a';\\n            if((prev+1)%26==current)\\n             len++;\\n            else len=1;\\n            alphabets[current]=Math.max(alphabets[current],len);\\n        }\\n        int sum=0;\\n        for(int i:alphabets) sum+=i;\\n        return sum;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746124,
                "title": "easy-solution-c-dp",
                "content": "# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(26) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int n = s.size();\\n        if(n == 1)return 1;\\n        vector<int>c(26,0);\\n        int maxi = 1;\\n        for(int i = 0;i<n;i++){\\n            if(c[s[i]-\\'a\\']==0){\\n                c[s[i] - \\'a\\'] = maxi;\\n            }else{\\n                c[s[i] - \\'a\\'] = max(maxi, c[s[i] - \\'a\\']);\\n            }\\n            if(i+1 < n && (s[i] == \\'z\\' && s[i+1] == \\'a\\')|| s[i+1]==s[i]+1)maxi++;\\n            else maxi = 1;\\n        }\\n        int ans = 0;\\n        for(auto it : c){\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int n = s.size();\\n        if(n == 1)return 1;\\n        vector<int>c(26,0);\\n        int maxi = 1;\\n        for(int i = 0;i<n;i++){\\n            if(c[s[i]-\\'a\\']==0){\\n                c[s[i] - \\'a\\'] = maxi;\\n            }else{\\n                c[s[i] - \\'a\\'] = max(maxi, c[s[i] - \\'a\\']);\\n            }\\n            if(i+1 < n && (s[i] == \\'z\\' && s[i+1] == \\'a\\')|| s[i+1]==s[i]+1)maxi++;\\n            else maxi = 1;\\n        }\\n        int ans = 0;\\n        for(auto it : c){\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625641,
                "title": "easy-fully-explained-concept-and-commented-c-solution",
                "content": "# Intuition\\nfirstly, here many people are not able to understand one point in question properly which is that for given input string s we need to find subsequences from the base given in question \\nbase -> \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\"   , a infinite string.\\n\\nhere the point to notice is that every character in base in coming after one paricular letter. For example :\\n\\'a\\' is coming after \\'z\\' \\n\\'b\\' is coming after \\'a\\' \\n\\'c\\' is coming after \\'b\\'\\n.... and so on \\'z\\' is coming after \\'y\\'.\\n\\n# Approach\\n\\nbecause here substring are asked so lets understand a simple concept.\\n\\nif we have s = \\'a\\' the substring possible is 1 (\\'a\\').\\nif we have s = \\'ab\\' the substring possible is 3 (\\'a\\', \\'b\\' , \\'ab\\').\\n or we can say the new increased substring is equal to \\n\\n = 1 + number of strings end with \\'a\\'. \\n\\none is because \\'b\\' is also a substring increased.\\n\\n\\nlet say we add \\'c\\'\\n\\ns = \\'abc\\'\\n\\nfor \\'ab\\' the answer is 2. \\n\\nso for \\'abc\\' the answer = is previous answer upto ab + increased answer \\n=>finding increased answer: \\n=> 1 + number of strings end with \\'b\\' \\n=> 1 + 2 = 3  \\n\\nso total is 3(upto \\'ab\\') + 3(increased ) = 6;\\n\\nwe can say the increased answer is equal to its position of new added character for example\\n\\ninitial answer = 0 \\nwhen s = \\'a\\' its position 1 so answer = answer + 1 = 1.\\nwhen s = \\'ab\\' its position 2 so answer = answer + 2 = 3.\\nwhen s = \\'abc\\' its position 3 so answer = answer + 3 = 6.\\n\\nand so on.....\\n\\nif s = efgh\\nanswer  = 0.\\n\\nupto \\'e\\' answer increased 1 as position = 1. answer + 1 = 1\\nupto \\'f\\' answer increased 1 as position = 2. answer + 2 = 3\\nupto \\'g\\' answer increased 1 as position = 3. answer + 3 = 6\\nupto \\'h\\' answer increased 1 as position = 4. answer + 4 = 10.\\n\\n\\ni hope its clear upto now.....\\n\\nso lets take a example of main question s = \\'yzabefab\\'. \\n\\nnow we see how position is defined ...\\n\\nas we need to take substring according to \\'base\\' defined in question so...\\nwe store position of every character also...\\n\\nintially position of \\'y\\' = 1;\\nand z is at true position according to \\'base\\' that is after y so its position = 2.\\naccordigly position of a = 3 and b = 4.\\n\\ns = \\'y\\' substrings = {\\'y\\'}\\ns = \\'yz\\'substrings = {\\'y\\' , \\'z\\' , \\'yz\\'}\\ns = \\'yza\\' substrings = {\\'y\\' , \\'z\\' , \\'yz\\',\\'a\\',\\'za\\' , \\'yza\\'}\\ns = \\'yzab\\' substring = {\\'y\\' , \\'z\\' , \\'yz\\' , \\'a\\' , \\'za\\' ,\\'yza\\', \\'b\\' ,\\'ab\\' , \\'zab\\', \\'yzab\\'};\\n\\nnow when \\'e\\' is added as its not is true position so we need we redefine its position as 1 becoz it cannot give any substring by attaching to string ending with \\'b\\' because according to \\'base\\' its previous letter is \\'d\\'.\\n\\ns = \\'yzabe\\' substring = {\\'y\\' , \\'z\\' , \\'yz\\' , \\'a\\' , \\'za\\' ,\\'yza\\', \\'b\\' ,\\'ab\\' , \\'zab\\', \\'yzab\\', \\'e\\'};\\ns = \\'yzabef\\' \\nso postion of \\'f\\' is 2 bcoz coming after \\'e\\' according to base.\\ngive two new substrings \\n  substring = {\\'y\\' , \\'z\\' , \\'yz\\' , \\'a\\' , \\'za\\' ,\\'yza\\', \\'b\\' ,\\'ab\\' , \\'zab\\', \\'yzab\\', \\'e\\',\\'f\\' ,\\'ef\\'};\\n\\nnow s = \\'yzabefa\\'\\nagain because \\'a\\' is at wrong place according to \\'base\\' so we make its position 1. \\nso the new string added is {\\'a\\' } but this is already present.\\n\\nif s = \\'yzabefab\\' the new strings added { \\'b\\' , \\'ab\\' } but they are also present.\\n\\nfrom here we can say if we have \\'a\\' and \\'b\\' with higher position we don\\'t need to count their contribution back. \\nso we have already \\'a\\' with position = 3 and \\'b\\' with position = 4.\\n\\nso when a contribute 3 new strings its include all contribution of \\'a\\' with lower positions and same of every character.\\n\\n****************************\\n Finally, what we do we find maximum position possible for every character as it is what contribute to our answer .\\n\\nthen finally add their contribution.\\n****************************\\ncharacter      maximum position possible\\n\\'y\\'            1 \\n\\'z\\'            2 \\n\\'a\\'            3\\n\\'b\\'            4\\n\\'e\\'            1    \\n\\'f\\'            2\\n\\nand their postion is equal to their contribution so answer is add all of them.\\n\\n1 + 2 + 3 + 4 + 1 + 2 = 13\\n\\nanswer is 13.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity :  O(26)\\nconstant space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n\\nunordered_map<char,int>mp; // to store position \\n\\nmp[s[0]] = 1; //giving first element position = 1.\\n     int pos = 1;\\n for(int i = 1 ; i < s.size() ; i++){\\n     \\n     if((s[i]-\\'0\\') - (s[i-1]-\\'0\\') == 1 or (s[i]==\\'a\\' and s[i-1]==\\'z\\')){\\n         pos++; // if element at right place position is : (previous element position + 1).\\n     }else pos = 1; // else position = 1\\n\\n    if(pos>mp[s[i]])mp[s[i]] = pos; // updation maximum position possible  \\n }\\n\\nint ans = 0;\\n\\n// adding their contribution\\nfor(auto m : mp){\\n  \\n    ans += m.second;}\\n\\n\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n\\nunordered_map<char,int>mp; // to store position \\n\\nmp[s[0]] = 1; //giving first element position = 1.\\n     int pos = 1;\\n for(int i = 1 ; i < s.size() ; i++){\\n     \\n     if((s[i]-\\'0\\') - (s[i-1]-\\'0\\') == 1 or (s[i]==\\'a\\' and s[i-1]==\\'z\\')){\\n         pos++; // if element at right place position is : (previous element position + 1).\\n     }else pos = 1; // else position = 1\\n\\n    if(pos>mp[s[i]])mp[s[i]] = pos; // updation maximum position possible  \\n }\\n\\nint ans = 0;\\n\\n// adding their contribution\\nfor(auto m : mp){\\n  \\n    ans += m.second;}\\n\\n\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199091,
                "title": "python-video-walkthrough-time-o-n-space-o-1",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/2nCTyDrRm4I)\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        LE, L, S = defaultdict(lambda: 0), 1, \"abcdefghijklmnopqrstuvwxyza\"\\n        LE[s[0]] = 1\\n        for idx in range(1, len(s)):\\n            L, LE[s[idx]] = 1 + L * int(s[idx-1:idx+1] in S)\\n             max(LE[s[idx]], 1 + L * int(s[idx-1:idx+1] in S))\\n        return sum(LE.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        LE, L, S = defaultdict(lambda: 0), 1, \"abcdefghijklmnopqrstuvwxyza\"\\n        LE[s[0]] = 1\\n        for idx in range(1, len(s)):\\n            L, LE[s[idx]] = 1 + L * int(s[idx-1:idx+1] in S)\\n             max(LE[s[idx]], 1 + L * int(s[idx-1:idx+1] in S))\\n        return sum(LE.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106298,
                "title": "python3-100-count-unique-start-length-tuples",
                "content": "# Explanation\\nIn this problem, a unique substring can be defined as a starting character and length.   Also, this is my first 100% ever, so I\\'m a little excited :)   The proc() method was just so I didn\\'t have to copy/paste the same handler code in two places (when I\\'m done and when a run is broken)\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        \\n        ia = list(map(lambda x:ord(x) - ord(\\'a\\'), p))\\n\\n        runs = {i: 0 for i in range(26)}\\n        st, r, la = ia[0], 1, ia[0]\\n        def proc():\\n            nonlocal st, r, la\\n            nonlocal runs\\n            for i in range(27):\\n                if runs[st]<r:\\n                    runs[st]=r\\n                st, r = (st+1)%26, r - 1\\n                if r<=0:\\n                    break\\n\\n\\n        for i in ia[1:]:\\n            if i == la + 1 or la == 25 and i == 0:\\n                st, r, la = st, r + 1, i\\n            else:\\n                proc()\\n                st, r, la = i, 1, i\\n        proc()\\n\\n        ret = 0\\n        for i in runs.values():\\n            ret += i\\n\\n        return ret\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        \\n        ia = list(map(lambda x:ord(x) - ord(\\'a\\'), p))\\n\\n        runs = {i: 0 for i in range(26)}\\n        st, r, la = ia[0], 1, ia[0]\\n        def proc():\\n            nonlocal st, r, la\\n            nonlocal runs\\n            for i in range(27):\\n                if runs[st]<r:\\n                    runs[st]=r\\n                st, r = (st+1)%26, r - 1\\n                if r<=0:\\n                    break\\n\\n\\n        for i in ia[1:]:\\n            if i == la + 1 or la == 25 and i == 0:\\n                st, r, la = st, r + 1, i\\n            else:\\n                proc()\\n                st, r, la = i, 1, i\\n        proc()\\n\\n        ret = 0\\n        for i in runs.values():\\n            ret += i\\n\\n        return ret\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740112,
                "title": "c-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(26)$$ ->  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int ans = 0;\\n        int pre = 1;\\n        unordered_map<char, int> maps;\\n        maps[p[0]] = 1;\\n        for (int i = 1; i < p.size(); i++) {\\n            if (p[i] - p[i - 1]== 1 || p[i] - p[i - 1] == -25) {\\n                pre += 1;\\n            } else {\\n                pre = 1;\\n            }\\n            maps[p[i]] = max(pre, maps[p[i]]);\\n        }\\n        for (auto [k, v] : maps) {\\n            ans += v;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int ans = 0;\\n        int pre = 1;\\n        unordered_map<char, int> maps;\\n        maps[p[0]] = 1;\\n        for (int i = 1; i < p.size(); i++) {\\n            if (p[i] - p[i - 1]== 1 || p[i] - p[i - 1] == -25) {\\n                pre += 1;\\n            } else {\\n                pre = 1;\\n            }\\n            maps[p[i]] = max(pre, maps[p[i]]);\\n        }\\n        for (auto [k, v] : maps) {\\n            ans += v;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697616,
                "title": "iterative-no-dp-including-every-string-starting-with-all-alphabets",
                "content": "basically since the main strings follows a pattern so any string starting ith a given letter should follow a fix pattern (see the code) if wxyzabcd is the maximum string that can be formed from the main string then wx,wxy,wxyz all are parrt of those strings , so by this method we check for every character from a to z and find the maximum good string poosible starting from that alphabet.\\n\\n\\n```\\n int findSubstringInWraproundString(string p) {\\n        \\n      int i,j;\\n        int n=p.size();\\n        \\n        int answer=0;\\n        int count=0;\\n        \\n        int ans=0;\\n        for(j=0;j<26;j++){           \\n            char c=j+\\'a\\';\\n            for(i=0;i<n;i++){\\n                \\n                int inc=(count+j)%26;\\n                char curr=inc+\\'a\\';\\n             \\n                if(p[i]==curr){\\n                  \\n                    count++;\\n                    if(i==n-1){\\n                        ans=max(ans,count);\\n                    }\\n                }\\n                else if(p[i]!=curr){\\n                    \\n                    ans=max(ans,count);\\n                   if(p[i]==c){\\n                       count=1;\\n                   }\\n                    else if(p[i]!=c){\\n                        count=0;\\n                    }\\n                   \\n                }\\n                \\n            }\\n            answer=answer+ans;\\n            ans=0;\\n            count=0;\\n        }\\n        \\n     return answer;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n int findSubstringInWraproundString(string p) {\\n        \\n      int i,j;\\n        int n=p.size();\\n        \\n        int answer=0;\\n        int count=0;\\n        \\n        int ans=0;\\n        for(j=0;j<26;j++){           \\n            char c=j+\\'a\\';\\n            for(i=0;i<n;i++){\\n                \\n                int inc=(count+j)%26;\\n                char curr=inc+\\'a\\';\\n             \\n                if(p[i]==curr){\\n                  \\n                    count++;\\n                    if(i==n-1){\\n                        ans=max(ans,count);\\n                    }\\n                }\\n                else if(p[i]!=curr){\\n                    \\n                    ans=max(ans,count);\\n                   if(p[i]==c){\\n                       count=1;\\n                   }\\n                    else if(p[i]!=c){\\n                        count=0;\\n                    }\\n                   \\n                }\\n                \\n            }\\n            answer=answer+ans;\\n            ans=0;\\n            count=0;\\n        }\\n        \\n     return answer;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2618937,
                "title": "java-dp-o-n",
                "content": "```\\npublic int findSubstringInWraproundString(String p) {\\n        // count the biggest substring ending at char \\'x\\' of p.\\n        // number of substrings in a string ==> n*(n+1)/2 ==> sum of cumulative run\\n        // e.g. abcd ==> 1 + 2 + 3 + 4 ==> 10 substrings\\n        // res[k] is the maximum length of qualified substring in p that ends with character \\'a\\'\\n        int[] res = new int[26];\\n        for (char c : p.toCharArray()) {\\n            res[c - \\'a\\'] = 1;\\n        }\\n\\n        int l = 1;\\n        for (int j = 1; j < p.length(); j++) {\\n            int k = p.charAt(j) - \\'a\\';\\n            l = (k == (p.charAt(j - 1) - \\'a\\' + 1) % 26) ? l + 1 : 1;\\n            res[k] = Math.max(res[k], l);\\n        }\\n        return Arrays.stream(res).sum();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findSubstringInWraproundString(String p) {\\n        // count the biggest substring ending at char \\'x\\' of p.\\n        // number of substrings in a string ==> n*(n+1)/2 ==> sum of cumulative run\\n        // e.g. abcd ==> 1 + 2 + 3 + 4 ==> 10 substrings\\n        // res[k] is the maximum length of qualified substring in p that ends with character \\'a\\'\\n        int[] res = new int[26];\\n        for (char c : p.toCharArray()) {\\n            res[c - \\'a\\'] = 1;\\n        }\\n\\n        int l = 1;\\n        for (int j = 1; j < p.length(); j++) {\\n            int k = p.charAt(j) - \\'a\\';\\n            l = (k == (p.charAt(j - 1) - \\'a\\' + 1) % 26) ? l + 1 : 1;\\n            res[k] = Math.max(res[k], l);\\n        }\\n        return Arrays.stream(res).sum();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531301,
                "title": "c-concise-solution-easy",
                "content": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n=p.length();\\n        int prev=1;\\n        int taken[27];\\n        memset(taken,0,sizeof(taken));\\n        long long sum=1;\\n        taken[p[0]-\\'a\\']=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            \\n            if((p[i]==\\'a\\'&&p[i-1]==\\'z\\')||(p[i]-p[i-1]==1))\\n                prev++;\\n            else\\n                prev=1;\\n            if(taken[p[i]-\\'a\\']<prev)\\n                sum+=prev-taken[p[i]-\\'a\\'];\\n            taken[p[i]-\\'a\\']=max(taken[p[i]-\\'a\\'],prev);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n=p.length();\\n        int prev=1;\\n        int taken[27];\\n        memset(taken,0,sizeof(taken));\\n        long long sum=1;\\n        taken[p[0]-\\'a\\']=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            \\n            if((p[i]==\\'a\\'&&p[i-1]==\\'z\\')||(p[i]-p[i-1]==1))\\n                prev++;\\n            else\\n                prev=1;\\n            if(taken[p[i]-\\'a\\']<prev)\\n                sum+=prev-taken[p[i]-\\'a\\'];\\n            taken[p[i]-\\'a\\']=max(taken[p[i]-\\'a\\'],prev);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2501888,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size(), count=1;\\n        vector<int> arr(256,0);\\n        arr[p[0]] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if((p[i-1]==\\'z\\' && p[i]==\\'a\\') || p[i-1]+1 == p[i])\\n                count++;\\n            else\\n                count = 1;\\n            if(arr[p[i]] < count)\\n                arr[p[i]] = count;\\n        }\\n        return accumulate(arr.begin(),arr.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size(), count=1;\\n        vector<int> arr(256,0);\\n        arr[p[0]] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if((p[i-1]==\\'z\\' && p[i]==\\'a\\') || p[i-1]+1 == p[i])\\n                count++;\\n            else\\n                count = 1;\\n            if(arr[p[i]] < count)\\n                arr[p[i]] = count;\\n        }\\n        return accumulate(arr.begin(),arr.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445513,
                "title": "concise-c-0-n-brute-force",
                "content": "\\nLogic:\\nThe basic logic is to pick the longest string starting from a particular character.\\n\\ne.g.: str = \"abcdabc\"\\n\\nHere the longest string starting from a is \"abcd\"\\nso here we get 4 substring (len) that is, \"a\", \"ab\", \"abc,\" \"abcd\"\\n\\nWe won\\'t consider another string starting from \\'a\\', because that will already be included in our longest string.\\n\\nlike here, \"abcdabc\"\\nwe also have \"abc\" but \"a\", \"ab\", \"abc\" are already incuded.\\n\\nWorking:\\ne.g.: \"abcdabc\"\\n\\nlongest string from char:\\na-> :abcd\"          count = 4 (\"a\", \"ab\", \"abc,\" \"abcd\")\\nb-> \"bcd\"           count = 3 (\"b\", \"bc\", \"bcd\")\\nc-> \"cd\"             count = 2 (\"c\", \"cd\")\\nd-> \"d\"              count = 1 (\"d\")\\n\\nFinal ans is sum of all counts:\\n4 + 3 + 2 + 1 => 10\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// function to get the len of longest substring starting from char ch\\n    int getLen(string p, char ch) {\\n        int len = 0;\\n        int n = p.size();\\n        int temp = 0;\\n        int i = 0;\\n        \\n        while(i < n) {\\n            while(i < n && p[i] != ch) {\\n                i++;\\n            }\\n            \\n            if(i < n) {\\n                temp = 1;\\n                int r;\\n                for(r = i+1; r < n; r++) {\\n                    char curr = p[r];\\n                    char prev = p[r-1];\\n                    \\n                    if(curr == prev + 1 || (curr == \\'a\\' && prev == \\'z\\')) {\\n                        temp++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                len = max(len, temp);\\n                i = r;\\n            }\\n        }\\n        \\n        return len;\\n    }\\n    \\n    int findSubstringInWraproundString(string p) {\\n        int ans = 0;\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n            int len = getLen(p, ch);\\n            ans += len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// function to get the len of longest substring starting from char ch\\n    int getLen(string p, char ch) {\\n        int len = 0;\\n        int n = p.size();\\n        int temp = 0;\\n        int i = 0;\\n        \\n        while(i < n) {\\n            while(i < n && p[i] != ch) {\\n                i++;\\n            }\\n            \\n            if(i < n) {\\n                temp = 1;\\n                int r;\\n                for(r = i+1; r < n; r++) {\\n                    char curr = p[r];\\n                    char prev = p[r-1];\\n                    \\n                    if(curr == prev + 1 || (curr == \\'a\\' && prev == \\'z\\')) {\\n                        temp++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                len = max(len, temp);\\n                i = r;\\n            }\\n        }\\n        \\n        return len;\\n    }\\n    \\n    int findSubstringInWraproundString(string p) {\\n        int ans = 0;\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n            int len = getLen(p, ch);\\n            ans += len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383005,
                "title": "explanation-with-comments-c",
                "content": "#####  Substring is contiguous.\\n\\n Input: `abcdedefgh`\\n `abcd` --> length = 4\\n\\n The mistake which I made was: I did a streak reset to 1 when I found that a character is repeating, here, it\\'s `d` at the `5th` position.\\n At the `5th` position, we find another `d` but we **MUST NOT** reset streak since we might form a different substring later on.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int findSubstringInWraproundString(string p) {\\n        unordered_map<char, int> mp;\\n\\n        // if the characters are not contiguous and also check whether after \\'z\\' I am getting \\'a\\'. If so, reset the streak to 1\\n        // else streak++\\n\\n        int streak = 0;\\n\\n        for (int i = 0; i < p.size(); i++) {\\n\\n            // contiguous\\n            if (i and (p[i] - p[i - 1] == 1)) streak++;\\n\\n            // z...a case\\n            else if (i and (p[i] == \\'a\\' and p[i - 1] == \\'z\\')) streak++;\\n\\n            else streak = 1;\\n\\n            mp[p[i]] = max(mp[p[i]], streak);\\n        }\\n\\n        // why sum? cuz there might be multiple substrings when the streak\\'s broken for one\\n\\n        int ans = 0;\\n        for (auto x : mp) {\\n            ans += x.second;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findSubstringInWraproundString(string p) {\\n        unordered_map<char, int> mp;\\n\\n        // if the characters are not contiguous and also check whether after \\'z\\' I am getting \\'a\\'. If so, reset the streak to 1\\n        // else streak++\\n\\n        int streak = 0;\\n\\n        for (int i = 0; i < p.size(); i++) {\\n\\n            // contiguous\\n            if (i and (p[i] - p[i - 1] == 1)) streak++;\\n\\n            // z...a case\\n            else if (i and (p[i] == \\'a\\' and p[i - 1] == \\'z\\')) streak++;\\n\\n            else streak = 1;\\n\\n            mp[p[i]] = max(mp[p[i]], streak);\\n        }\\n\\n        // why sum? cuz there might be multiple substrings when the streak\\'s broken for one\\n\\n        int ans = 0;\\n        for (auto x : mp) {\\n            ans += x.second;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301961,
                "title": "easy-dp-solution",
                "content": "**DP SOLUTION**\\n\\n1. for any continious string \"abcd\" the number of unique substring ending at its end (in this case d) is its index --> 4 like-> d bcdcd abcd\\n\\n2. now for being continios substring,--> 2 continious character must have 1 diff or 25 diff\\n ab bc cd --> have 1 diff\\n \\n xa --> have 25 diff (this is valid becuase our string is like -->...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....)\\n \\n 3.we are going to make a dp[] of 26 size corrosponding every char and store longest substring ending at that string\\n \\n4. why we are only think about longest string becuase\\n abcbc\\n \\n int first c dp[c]=3\\n int 2nd c dp[c]=2;\\n \\n but we only store 3 becuase for 3 length its cover all the 2 length substrings.\\n \\n abc bc c (3)\\n bc c(2) \\n \\n as we consider only unique we never take the less length.\\n \\n *code*\\n```\\n \\n class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] dp= new int[26];\\n        int continious=0;\\n        for(int i=0;i<p.length();i++){\\n            if(i>0 && ( p.charAt(i)-p.charAt(i-1)==1 || p.charAt(i-1)-p.charAt(i)==25)){\\n                continious++;\\n            }\\n            else{\\n                continious=1;\\n            }\\n            int index=p.charAt(i)-\\'a\\';\\n            dp[index]=Math.max(dp[index],continious);\\n        }\\n        \\n        int ans=0;\\n        for(int i: dp){\\n            ans+=i;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n \\n class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] dp= new int[26];\\n        int continious=0;\\n        for(int i=0;i<p.length();i++){\\n            if(i>0 && ( p.charAt(i)-p.charAt(i-1)==1 || p.charAt(i-1)-p.charAt(i)==25)){\\n                continious++;\\n            }\\n            else{\\n                continious=1;\\n            }\\n            int index=p.charAt(i)-\\'a\\';\\n            dp[index]=Math.max(dp[index],continious);\\n        }\\n        \\n        int ans=0;\\n        for(int i: dp){\\n            ans+=i;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116705,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size(), cum = 0;\\n        vector<int> cnt(26,0);\\n        \\n        for(int i=0; i<n;) {\\n            if(cum == 0 || (p[i]-p[i-1] == 1) || (p[i-1]==\\'z\\' && p[i]==\\'a\\')) {\\n                cum++;\\n                cnt[p[i]-\\'a\\'] = max(cnt[p[i]-\\'a\\'], cum);\\n                i++;\\n            }\\n            else\\n                cum = 0;\\n        }\\n\\n        int ret = 0;\\n        for(int i=0; i<26; i++)\\n            ret += cnt[i];\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n = p.size(), cum = 0;\\n        vector<int> cnt(26,0);\\n        \\n        for(int i=0; i<n;) {\\n            if(cum == 0 || (p[i]-p[i-1] == 1) || (p[i-1]==\\'z\\' && p[i]==\\'a\\')) {\\n                cum++;\\n                cnt[p[i]-\\'a\\'] = max(cnt[p[i]-\\'a\\'], cum);\\n                i++;\\n            }\\n            else\\n                cum = 0;\\n        }\\n\\n        int ret = 0;\\n        for(int i=0; i<26; i++)\\n            ret += cnt[i];\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982492,
                "title": "javascript-top-down-memoization-recursive-explanation",
                "content": "```\\n/** https://leetcode.com/problems/unique-substrings-in-wraparound-string/\\n * @param {string} p\\n * @return {number}\\n */\\nvar findSubstringInWraproundString = function(p) {\\n  // Memo\\n  // Set the memo to size 26 to represent alphabet in each index, \\'a\\' is 0, \\'b\\' is 1, \\'c\\' is 2, etc\\n  this.memo = Array(26).fill(0);\\n  \\n  // Dynamic programming from the end of array\\n  // The function `dp(p, i)` will return the maximum of unique substring at `i`\\n  // Once we have the result from `dp(p, i)`, we store it in `this.memo` by its last character\\n  // Eg: \\'a\\' result in [1,0,0,...,0]\\n  // Eg\" \\'ab\\' result in [1,2,0,...,0], index 1 has value 2 because we have unique substring \\'b\\' and \\'ab\\'\\n  // Eg\" \\'abc\\' result in [1,2,3,...,0], index 2 has value 3 because we have unique substring \\'c\\', \\'bc\\' and \\'abc\\'\\n  dp(p, p.length - 1);\\n  \\n  // The final result is the sum of all the substring\\n  return this.memo.reduce((sum, m) => sum + m, 0);\\n};\\n\\nvar dp = function(p, currIdx) {\\n  // Base, reach beginning of the array\\n  if (currIdx === 0) {\\n    this.memo[getCharCode(p[currIdx])] = 1;\\n    return 1;\\n  }\\n  \\n  // Start the `currMax` with value from prev index\\n  let currMax = dp(p, currIdx - 1);\\n  \\n  // Get the char code for previous and current character\\n  let prevCharCode = getCharCode(p[currIdx - 1]);\\n  let currCharCode = getCharCode(p[currIdx]);\\n  \\n  // We have substring when current and previous chacaraters are neighbor to the right, ie: ab, bc, cd, fg, abc, abcd, fgh\\n  // Eg: current character is \\'a\\', the char code is 0, next character is \\'b\\', the char code is 1, `currCharCode - prevCharCode === 1`\\n  // Eg: current character is \\'z\\', the char code is 25, next character is \\'a\\', the char code is 0, `currCharCode - prevCharCode === -25`\\n  if (currCharCode - prevCharCode === 1 ||\\n      currCharCode - prevCharCode === -25) {\\n    currMax += 1;\\n  }\\n  // Reset the `currMax` count if current and previous characters are not neighbor\\n  else {\\n    currMax = 1;\\n  }\\n  \\n  // Set the memo to max value\\n  this.memo[currCharCode] = Math.max(this.memo[currCharCode], currMax);\\n  \\n  return currMax;\\n};\\n\\nvar getCharCode = function(char) {\\n  // Get character code\\n  // Eg: \\'a\\' is 0, \\'b\\' is 1, \\'c\\' is 2, ..., \\'z\\' is 25\\n  return char.charCodeAt(0) - 97;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/** https://leetcode.com/problems/unique-substrings-in-wraparound-string/\\n * @param {string} p\\n * @return {number}\\n */\\nvar findSubstringInWraproundString = function(p) {\\n  // Memo\\n  // Set the memo to size 26 to represent alphabet in each index, \\'a\\' is 0, \\'b\\' is 1, \\'c\\' is 2, etc\\n  this.memo = Array(26).fill(0);\\n  \\n  // Dynamic programming from the end of array\\n  // The function `dp(p, i)` will return the maximum of unique substring at `i`\\n  // Once we have the result from `dp(p, i)`, we store it in `this.memo` by its last character\\n  // Eg: \\'a\\' result in [1,0,0,...,0]\\n  // Eg\" \\'ab\\' result in [1,2,0,...,0], index 1 has value 2 because we have unique substring \\'b\\' and \\'ab\\'\\n  // Eg\" \\'abc\\' result in [1,2,3,...,0], index 2 has value 3 because we have unique substring \\'c\\', \\'bc\\' and \\'abc\\'\\n  dp(p, p.length - 1);\\n  \\n  // The final result is the sum of all the substring\\n  return this.memo.reduce((sum, m) => sum + m, 0);\\n};\\n\\nvar dp = function(p, currIdx) {\\n  // Base, reach beginning of the array\\n  if (currIdx === 0) {\\n    this.memo[getCharCode(p[currIdx])] = 1;\\n    return 1;\\n  }\\n  \\n  // Start the `currMax` with value from prev index\\n  let currMax = dp(p, currIdx - 1);\\n  \\n  // Get the char code for previous and current character\\n  let prevCharCode = getCharCode(p[currIdx - 1]);\\n  let currCharCode = getCharCode(p[currIdx]);\\n  \\n  // We have substring when current and previous chacaraters are neighbor to the right, ie: ab, bc, cd, fg, abc, abcd, fgh\\n  // Eg: current character is \\'a\\', the char code is 0, next character is \\'b\\', the char code is 1, `currCharCode - prevCharCode === 1`\\n  // Eg: current character is \\'z\\', the char code is 25, next character is \\'a\\', the char code is 0, `currCharCode - prevCharCode === -25`\\n  if (currCharCode - prevCharCode === 1 ||\\n      currCharCode - prevCharCode === -25) {\\n    currMax += 1;\\n  }\\n  // Reset the `currMax` count if current and previous characters are not neighbor\\n  else {\\n    currMax = 1;\\n  }\\n  \\n  // Set the memo to max value\\n  this.memo[currCharCode] = Math.max(this.memo[currCharCode], currMax);\\n  \\n  return currMax;\\n};\\n\\nvar getCharCode = function(char) {\\n  // Get character code\\n  // Eg: \\'a\\' is 0, \\'b\\' is 1, \\'c\\' is 2, ..., \\'z\\' is 25\\n  return char.charCodeAt(0) - 97;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705570,
                "title": "python3-dp-o-n-time-o-1-space",
                "content": "Count the number of substrings ending at a letter. To do so, and to avoid counting duplicates, we only need to find the largest substring ending in the letter. The number of substrings ending at that letter is simply the length of that max substring.\\n\\ne.g.\\nConsider p = abcdzabc\\n\\n**Consecutive Substrings ending in c**:\\nabc\\nbc\\nc\\nzabc\\nabc\\nbc\\nc\\n\\nThe max length substring ending in c: zabc\\nSo number of *unique* substrings ending in c is 4\\n\\nThe sum of the max lengths substring ending with each of the distinct letters in p will be the answer.\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        consecutive = 1\\n        \\n        # stores the maximum length of a substring ending at a character \\n        maxSubstr = defaultdict(int)\\n        maxSubstr[p[0]] = 1\\n        \\n        ans = 0\\n        for x in range(1, len(p)):\\n            if ord(p[x]) - ord(p[x - 1]) == 1 or p[x] == \\'a\\' and p[x - 1] == \\'z\\':\\n                consecutive += 1\\n            else:\\n                consecutive = 1\\n            maxSubstr[p[x]] = max(maxSubstr[p[x]], consecutive)\\n        \\n        return sum(maxSubstr.values())\\n```\\nSince p only contains lowercase letters, maxSubstr will have at most 26 elements, and thus O(1) space",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        consecutive = 1\\n        \\n        # stores the maximum length of a substring ending at a character \\n        maxSubstr = defaultdict(int)\\n        maxSubstr[p[0]] = 1\\n        \\n        ans = 0\\n        for x in range(1, len(p)):\\n            if ord(p[x]) - ord(p[x - 1]) == 1 or p[x] == \\'a\\' and p[x - 1] == \\'z\\':\\n                consecutive += 1\\n            else:\\n                consecutive = 1\\n            maxSubstr[p[x]] = max(maxSubstr[p[x]], consecutive)\\n        \\n        return sum(maxSubstr.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630211,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) \\n    {\\n        int size=s.size();\\n        int len=0;\\n        vector<int>count(26,0);\\n        for(int i=0;i<size;i++)\\n        {\\n            if(i-1>=0&&(s[i]-s[i-1]==1||s[i-1]-s[i]==25))\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                len=1;\\n            }\\n            count[s[i]-97]=max(count[s[i]-97],len);\\n        }\\n        return accumulate(count.begin(),count.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) \\n    {\\n        int size=s.size();\\n        int len=0;\\n        vector<int>count(26,0);\\n        for(int i=0;i<size;i++)\\n        {\\n            if(i-1>=0&&(s[i]-s[i-1]==1||s[i-1]-s[i]==25))\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                len=1;\\n            }\\n            count[s[i]-97]=max(count[s[i]-97],len);\\n        }\\n        return accumulate(count.begin(),count.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543717,
                "title": "c-8ms-56-ascii",
                "content": "Runtime: 8 ms, faster than 56.82% of C++ online submissions for Unique Substrings in Wraparound String.\\nMemory Usage: 7.3 MB, less than 52.09% of C++ online submissions for Unique Substrings in Wraparound String.\\n```\\nclass Solution {\\npublic:\\n  int findSubstringInWraproundString(string p) {\\n    int table[26] = {0}, i = 0, n = p.size();\\n    \\n    while(i != n){\\n      int j = i; char ch = p[i];\\n      while(j != n && p[j] == ch)\\n        j++, ch == \\'z\\' ? ch = \\'a\\' : ch++;\\n      \\n      int lim_id = p[i] - \\'a\\', id = p[i] - \\'a\\', lim = j - i;  \\n      for(;i != j && id != 26; i++, id++)\\n        table[id] = max(table[id], lim--); \\n     \\n      if(id == 26) id = 0;\\n      for(;i != j && id != lim_id; i++, id++)\\n        table[id] = max(table[id], lim--); \\n    }\\n    \\n    return accumulate(table, table + 26, 0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findSubstringInWraproundString(string p) {\\n    int table[26] = {0}, i = 0, n = p.size();\\n    \\n    while(i != n){\\n      int j = i; char ch = p[i];\\n      while(j != n && p[j] == ch)\\n        j++, ch == \\'z\\' ? ch = \\'a\\' : ch++;\\n      \\n      int lim_id = p[i] - \\'a\\', id = p[i] - \\'a\\', lim = j - i;  \\n      for(;i != j && id != 26; i++, id++)\\n        table[id] = max(table[id], lim--); \\n     \\n      if(id == 26) id = 0;\\n      for(;i != j && id != lim_id; i++, id++)\\n        table[id] = max(table[id], lim--); \\n    }\\n    \\n    return accumulate(table, table + 26, 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453051,
                "title": "python-100-faster-hash-map-solution-explained",
                "content": "##### Idea\\nNothing I\\'ve done here is particularly new. The basic idea is that we want a table of the longest valid substring beginning with each unique character in p. The result is the sum of all of the lengths in this table, since for character:length pair in the table, there are \\'length\\' unique substrings beginning with that character.\\n\\nThere are a few optimizations I used to achieve a faster runtime though. The first is to use a pre-computed hashmap of the valid transitions rather than checking if (ord(p[i]) - ord(p[i - 1]))%26 == 1. Both of these operations are O(1), however the second is a significantly worse O(1). The second optimization I used was to prune when I\\'m recording the maximum lengths. This is possible because if a character in the first run was previously in a longer run (from its perspective), then we can stop updating all of the current characters since each of the next characters shares the same longer run (or something even longer). Finally, I stored the lengths in a defaultdict, because this reduces the work required to access keys, and optimizes the final sum (though that shouldn\\'t matter much).\\n\\n##### Example\\nInput: p = \"abccdefgabcdef\"\\n\\nThe first run is \"abc\" -> lengths = {a:3, b:2, c:1}\\nThe second run is \"cdefg\" -> lengths = {a:3, b:2, c:5, d:4, e:3, f:2, g:1}\\nThe final run is \"abcdef\" -> lengths = {a:6, b:5, c:5, d:4, e:3, f:2, g:1}\\n(notice how nothing beyond \\'b\\' was updated in that final run. This is because the run \"cdefg\" was better for all of the characters \"cdef\" than the run \"abcdef\")\\n\\nThe solution is the sum of the lengths: 6 + 5 + 5 + 4 + 3 + 2 + 1 = 26\\n\\nFor reference, the substrings these lengths imply are:\\na:6 -> a, ab, abc, abcd, abcde, abcdef\\nb:5 -> b, bc, bcd, bcde, bcdef\\nc:5 -> c, cd, cde, cdef, cdefg\\nd:4 -> d, de, def, defg\\ne:3 -> e, ef, efg\\nf:2 -> f, fg\\ng:1 -> g\\n\\n##### Code\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\nBest Performance: 48 ms/14.4 MB : 100%/75%\\n\\n\\'\\'\\'\\n\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        #Find the Maximum Length Starting With Each Character - O(n)\\n        i = 0\\n        lengths = defaultdict(int)\\n        mapping = {chr(i + 97):chr((i + 1)%26 + 97) for i in range(26)} # chr(97) is \\'a\\'\\n        while i < len(p):\\n            #Find the Whole of the Next Run - O(n)\\n            j = i + 1\\n            while j < len(p) and p[j] == mapping[p[j - 1]]:\\n                j += 1\\n            \\n            #Compute the Length\\n            l = j - i\\n            \\n            #Update the Maximum Lengths (index j isn\\'t in the current run) - O(min(n, 26))\\n            for i in range(i, j):\\n\\t\\t\\t\\t#Check if the Length Beats the Previous Value (if it existed)\\n                if lengths[p[i]] < l:\\n\\t\\t\\t\\t\\t#Save the New Best Value\\n                    lengths[p[i]] = l\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t#Decrement the Length Before Moving to the Next Character\\n                    l -= 1\\n                else:\\n\\t\\t\\t\\t\\t#Prune (none of the future lengths will beat their old values)\\n                    break\\n            \\n            #Increment i\\n            i = j\\n        \\n        #Compute the Result - O(min(n, 26))\\n        return sum(lengths.values())\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "##### Idea\\nNothing I\\'ve done here is particularly new. The basic idea is that we want a table of the longest valid substring beginning with each unique character in p. The result is the sum of all of the lengths in this table, since for character:length pair in the table, there are \\'length\\' unique substrings beginning with that character.\\n\\nThere are a few optimizations I used to achieve a faster runtime though. The first is to use a pre-computed hashmap of the valid transitions rather than checking if (ord(p[i]) - ord(p[i - 1]))%26 == 1. Both of these operations are O(1), however the second is a significantly worse O(1). The second optimization I used was to prune when I\\'m recording the maximum lengths. This is possible because if a character in the first run was previously in a longer run (from its perspective), then we can stop updating all of the current characters since each of the next characters shares the same longer run (or something even longer). Finally, I stored the lengths in a defaultdict, because this reduces the work required to access keys, and optimizes the final sum (though that shouldn\\'t matter much).\\n\\n##### Example\\nInput: p = \"abccdefgabcdef\"\\n\\nThe first run is \"abc\" -> lengths = {a:3, b:2, c:1}\\nThe second run is \"cdefg\" -> lengths = {a:3, b:2, c:5, d:4, e:3, f:2, g:1}\\nThe final run is \"abcdef\" -> lengths = {a:6, b:5, c:5, d:4, e:3, f:2, g:1}\\n(notice how nothing beyond \\'b\\' was updated in that final run. This is because the run \"cdefg\" was better for all of the characters \"cdef\" than the run \"abcdef\")\\n\\nThe solution is the sum of the lengths: 6 + 5 + 5 + 4 + 3 + 2 + 1 = 26\\n\\nFor reference, the substrings these lengths imply are:\\na:6 -> a, ab, abc, abcd, abcde, abcdef\\nb:5 -> b, bc, bcd, bcde, bcdef\\nc:5 -> c, cd, cde, cdef, cdefg\\nd:4 -> d, de, def, defg\\ne:3 -> e, ef, efg\\nf:2 -> f, fg\\ng:1 -> g\\n\\n##### Code\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\nBest Performance: 48 ms/14.4 MB : 100%/75%\\n\\n\\'\\'\\'\\n\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        #Find the Maximum Length Starting With Each Character - O(n)\\n        i = 0\\n        lengths = defaultdict(int)\\n        mapping = {chr(i + 97):chr((i + 1)%26 + 97) for i in range(26)} # chr(97) is \\'a\\'\\n        while i < len(p):\\n            #Find the Whole of the Next Run - O(n)\\n            j = i + 1\\n            while j < len(p) and p[j] == mapping[p[j - 1]]:\\n                j += 1\\n            \\n            #Compute the Length\\n            l = j - i\\n            \\n            #Update the Maximum Lengths (index j isn\\'t in the current run) - O(min(n, 26))\\n            for i in range(i, j):\\n\\t\\t\\t\\t#Check if the Length Beats the Previous Value (if it existed)\\n                if lengths[p[i]] < l:\\n\\t\\t\\t\\t\\t#Save the New Best Value\\n                    lengths[p[i]] = l\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t#Decrement the Length Before Moving to the Next Character\\n                    l -= 1\\n                else:\\n\\t\\t\\t\\t\\t#Prune (none of the future lengths will beat their old values)\\n                    break\\n            \\n            #Increment i\\n            i = j\\n        \\n        #Compute the Result - O(min(n, 26))\\n        return sum(lengths.values())\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1400923,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int cnt[26] = {0};\\n        int len = 0;\\n        \\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(i>0)\\n            {\\n               if(p[i]==\\'a\\')  // in case if current character is a but the previous one is not z then re-initialize your len to zero\\n               {\\n                   if(p[i-1]!=\\'z\\')\\n                   {\\n                      len = 0; \\n                   }\\n               }\\n                \\n               else\\n               {\\n                   if(p[i-1]+1!=p[i])  // Two characters should be consecutive \\'a\\'->\\'b\\'\\n                   {\\n                       len = 0;\\n                   }\\n               }\\n            }\\n            len = len+1; \\n            if(len>cnt[p[i]-\\'a\\'])  \\n            {\\n                cnt[p[i]-\\'a\\'] = len;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<26;i++)\\n        {\\n            ans+=(cnt[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}; \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int cnt[26] = {0};\\n        int len = 0;\\n        \\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(i>0)\\n            {\\n               if(p[i]==\\'a\\')  // in case if current character is a but the previous one is not z then re-initialize your len to zero\\n               {\\n                   if(p[i-1]!=\\'z\\')\\n                   {\\n                      len = 0; \\n                   }\\n               }\\n                \\n               else\\n               {\\n                   if(p[i-1]+1!=p[i])  // Two characters should be consecutive \\'a\\'->\\'b\\'\\n                   {\\n                       len = 0;\\n                   }\\n               }\\n            }\\n            len = len+1; \\n            if(len>cnt[p[i]-\\'a\\'])  \\n            {\\n                cnt[p[i]-\\'a\\'] = len;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<26;i++)\\n        {\\n            ans+=(cnt[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320742,
                "title": "rust-cheapest-best",
                "content": "```\\nimpl Solution {\\n    pub fn find_substring_in_wrapround_string(p: String) -> i32 {\\n        let (mut dp, mut n, mut iter) = ([0; 123], 1, p.chars().peekable());\\n        while let Some(a) = iter.next() {\\n            dp[a as usize] = dp[a as usize].max(n);\\n            n = match iter.peek().filter(|&b| match b {\\n                \\'a\\' => a == \\'z\\',\\n                _ => (*b as u8) == (a as u8) + 1,\\n            }) {\\n                Some(_) => n + 1,\\n                None => 1,\\n            }\\n        }\\n\\n        dp.iter().skip(97).sum()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_substring_in_wrapround_string(p: String) -> i32 {\\n        let (mut dp, mut n, mut iter) = ([0; 123], 1, p.chars().peekable());\\n        while let Some(a) = iter.next() {\\n            dp[a as usize] = dp[a as usize].max(n);\\n            n = match iter.peek().filter(|&b| match b {\\n                \\'a\\' => a == \\'z\\',\\n                _ => (*b as u8) == (a as u8) + 1,\\n            }) {\\n                Some(_) => n + 1,\\n                None => 1,\\n            }\\n        }\\n\\n        dp.iter().skip(97).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274596,
                "title": "ruby-recognize-string-by-ending-there-are-26-types-of-endings",
                "content": "## Leetcode: 467. Unique Substrings in Wraparound String.\\n \\n\\n**Important**: Do not overide [Kernel.p](https://apidock.com/ruby/Kernel/p) in the Ruby programs. `p \"text\"` it\\'s an extremely usefull tool for debuging. \\n\\nString defined by it last character, each uniq string eding with particular characher stores N unique substring with same ending. Where N is the length of the string. Thus only need to store length of the longest string for a particular ending and there are 26 ending for this problem.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 467. Unique Substrings in Wraparound String.\\n# https://leetcode.com/problems/unique-substrings-in-wraparound-string/\\n# Runtime: 144 ms, faster than 50.00% of Ruby online submissions for Unique Substrings in Wraparound String.\\n# Memory Usage: 210.3 MB, less than 50.00% of Ruby online submissions for Unique Substrings in Wraparound String.\\n# Thanks God!\\n# @param {String} p\\n# @return {Integer}\\ndef find_substring_in_wrapround_string(ps)\\n    len = 1\\n    h = {}\\n    (0...ps.size).each do |i|\\n        if i>0 && (ps[i-1].ord + 1 == ps[i].ord  || (ps[i-1] == ?z && ?a == ps[i]))\\n            len += 1\\n        else\\n            len = 1\\n        end\\n        h[ps[i]] ||= 0\\n        h[ps[i]] = len if len > h[ps[i]]\\n    end\\n    h.values.sum\\nend\\n```\\n\\nP.S. I got this Idea for solution from [this article](https://leetcode.com/problems/unique-substrings-in-wraparound-string/discuss/747989/C%2B%2B-Dynamic-programming-simple-and-concise) by @suhailakhtar039. \\n\\n",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```Ruby\\n# Leetcode: 467. Unique Substrings in Wraparound String.\\n# https://leetcode.com/problems/unique-substrings-in-wraparound-string/\\n# Runtime: 144 ms, faster than 50.00% of Ruby online submissions for Unique Substrings in Wraparound String.\\n# Memory Usage: 210.3 MB, less than 50.00% of Ruby online submissions for Unique Substrings in Wraparound String.\\n# Thanks God!\\n# @param {String} p\\n# @return {Integer}\\ndef find_substring_in_wrapround_string(ps)\\n    len = 1\\n    h = {}\\n    (0...ps.size).each do |i|\\n        if i>0 && (ps[i-1].ord + 1 == ps[i].ord  || (ps[i-1] == ?z && ?a == ps[i]))\\n            len += 1\\n        else\\n            len = 1\\n        end\\n        h[ps[i]] ||= 0\\n        h[ps[i]] = len if len > h[ps[i]]\\n    end\\n    h.values.sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1159444,
                "title": "java-dp-o-n-time-and-space-beats-100-of-the-solutions",
                "content": "The idea is to store the maximum possible valid length of substring ending at that index in the dp array.\\nAnd then in the second pass, store the maximum length of substring ending at a particular character in the map array.\\n\\n```\\n  public int findSubstringInWraproundString(String p) {\\n        int n = p.length(), ans=0 ;\\n        char[] arr = p.toCharArray() ;\\n        int[] dp = new int[n] ;\\n        dp[0] = 1 ;\\n        for(int i=1; i<n; i++) {\\n            dp[i] = 1; \\n            if((arr[i] == \\'a\\' && arr[i-1] == \\'z\\') || arr[i] - arr[i-1] == 1) \\n                dp[i] += dp[i-1] ; \\n        }\\n        int[] map = new int[256] ;\\n        for(int i=0; i<n; i++) {\\n            map[arr[i]] = Math.max(map[arr[i]], dp[i]) ;\\n        }\\n        for(int i : map) ans += i;\\n        return ans;\\n   }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "The idea is to store the maximum possible valid length of substring ending at that index in the dp array.\\nAnd then in the second pass, store the maximum length of substring ending at a particular character in the map array.\\n\\n```\\n  public int findSubstringInWraproundString(String p) {\\n        int n = p.length(), ans=0 ;\\n        char[] arr = p.toCharArray() ;\\n        int[] dp = new int[n] ;\\n        dp[0] = 1 ;\\n        for(int i=1; i<n; i++) {\\n            dp[i] = 1; \\n            if((arr[i] == \\'a\\' && arr[i-1] == \\'z\\') || arr[i] - arr[i-1] == 1) \\n                dp[i] += dp[i-1] ; \\n        }\\n        int[] map = new int[256] ;\\n        for(int i=0; i<n; i++) {\\n            map[arr[i]] = Math.max(map[arr[i]], dp[i]) ;\\n        }\\n        for(int i : map) ans += i;\\n        return ans;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 1068770,
                "title": "c-solution",
                "content": ",,,\\nclass Solution {\\npublic:\\n    \\n    int findSubstringInWraproundString(string p) {\\n        if(p.size()==0)\\n            return 0;\\n        vector<int> dp(26,0);\\n        vector<int> dp1(p.size(),0);\\n        dp[p[0]-\\'a\\']=1;\\n        dp1[0]=1;\\n        for(int i=1;i<p.size();i++){\\n            int curr=p[i]-\\'a\\';\\n            int prev=p[i-1]-\\'a\\';\\n            if(curr==0){\\n                dp1[i]=max(1,1+(prev==25?dp1[i-1]:0));\\n                dp[curr]=max(dp[curr],dp1[i]);\\n            }else{\\n                dp1[i]=max(1,1+((curr-prev)==1?dp1[i-1]:0));\\n                dp[curr]=max(dp[curr],dp1[i]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int findSubstringInWraproundString(string p) {\\n        if(p.size()==0)\\n            return 0;\\n        vector<int> dp(26,0);\\n        vector<int> dp1(p.size(),0);\\n        dp[p[0]-\\'a\\']=1;\\n        dp1[0]=1;\\n        for(int i=1;i<p.size();i++){\\n            int curr=p[i]-\\'a\\';\\n            int prev=p[i-1]-\\'a\\';\\n            if(curr==0){\\n                dp1[i]=max(1,1+(prev==25?dp1[i-1]:0));\\n                dp[curr]=max(dp[curr],dp1[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1056437,
                "title": "java-dp-prefix-sum",
                "content": "Typically when uniqe substrings are involved, the genral idea is to maintain a hashset of visited strings ( where you store hashcode of strings to a integer set), the naive approach to iteating over all substrings and maintaing a hashset of visited strings for unique ness would result in TLE.\\n\\nhowever the substring here is bound by a constraint and hence you can use a trick to deduce what would be the no of unique substrings ending at a charcater.\\n\\nConsider input string \\u201Czabyza\\u201D. Substrings \\u201Czab\\u201D and \\u201Cyza\\u201D appear in s and are longest. Given that letter \\u201Cb\\u201D appears only in \\u201Czab\\u201D, the count of substrings that end with \\u201Cb\\u201D is given only by \\u201Czab\\u201D. In the case of letter \\u201Cy\\u201D, the count is given by \\u201Cyza\\u201D. For letters \\u201Ca\\u201D consider the corresponding substrings in \\u201Czab\\u201D and \\u201Cyza\\u201D.\\n\\nFor \\u201Cyza\\u201D, the substrings that end with \\u201Ca\\u201D  are the following.\\n\\nsubstrings that end with a: (via substring zab)\\n  a\\n  za\\nsubstrings that end with a:(via substring yza)\\n  a\\n  za\\n  yza\\n\\nNotice substrings ending with \\'a\\' is constributed by yza is basically super set of the one constributed by zab. It will hence contain all possible substring that would been contributed from \"zab\"\\n```\\nclass Solution {\\n  public int findSubstringInWraproundString(String str) {\\n        if(str == null || str.length() == 0) return 0;\\n        int sum = 0;\\n        int[] countArr = new int[26];\\n        countArr[str.charAt(0)-\\'a\\'] = 1;\\n\\n        int[] dp = new int[str.length()];\\n        dp[0] = 1;\\n        for (int i = 1; i < str.length(); i++){\\n            if(str.charAt(i-1) + 1 == str.charAt(i) || (str.charAt(i)- str.charAt(i-1) == -25)){\\n                dp[i] = 1 + dp[i-1];\\n            }else{\\n                dp[i] = 1;\\n            }\\n            countArr[str.charAt(i)-\\'a\\'] = Math.max(countArr[str.charAt(i)-\\'a\\'], dp[i]);\\n        }\\n        for (int item : countArr)\\n            sum += item;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int findSubstringInWraproundString(String str) {\\n        if(str == null || str.length() == 0) return 0;\\n        int sum = 0;\\n        int[] countArr = new int[26];\\n        countArr[str.charAt(0)-\\'a\\'] = 1;\\n\\n        int[] dp = new int[str.length()];\\n        dp[0] = 1;\\n        for (int i = 1; i < str.length(); i++){\\n            if(str.charAt(i-1) + 1 == str.charAt(i) || (str.charAt(i)- str.charAt(i-1) == -25)){\\n                dp[i] = 1 + dp[i-1];\\n            }else{\\n                dp[i] = 1;\\n            }\\n            countArr[str.charAt(i)-\\'a\\'] = Math.max(countArr[str.charAt(i)-\\'a\\'], dp[i]);\\n        }\\n        for (int item : countArr)\\n            sum += item;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030116,
                "title": "python-sliding-window-with-explanation",
                "content": "Use cnt to count the maxium length of substring ending at that character, e.g., use cnt[0] to count max len substring end with \\'a\\'.\\nSame idea as sliding window: advance right end point or advance left end point to the position of right. \\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        if not p:\\n            return 0\\n        left = 0\\n        cnt = [0] * 26\\n        \\n        for right in range(len(p)):\\n            if right>=1 and ord(p[right]) - ord(p[right-1]) == 1 or p[right] == \\'a\\' and p[right-1] == \\'z\\':\\n                cnt[ord(p[right]) - ord(\\'a\\')] = max(right-left+1, cnt[ord(p[right]) - ord(\\'a\\')])\\n                \\n            else:\\n                left = right\\n                cnt[ord(p[right]) - ord(\\'a\\')] = max(1, cnt[ord(p[right]) - ord(\\'a\\')])\\n                \\n        return sum(cnt)",
                "solutionTags": [],
                "code": "Use cnt to count the maxium length of substring ending at that character, e.g., use cnt[0] to count max len substring end with \\'a\\'.\\nSame idea as sliding window: advance right end point or advance left end point to the position of right. \\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        if not p:\\n            return 0\\n        left = 0\\n        cnt = [0] * 26\\n        \\n        for right in range(len(p)):\\n            if right>=1 and ord(p[right]) - ord(p[right-1]) == 1 or p[right] == \\'a\\' and p[right-1] == \\'z\\':\\n                cnt[ord(p[right]) - ord(\\'a\\')] = max(right-left+1, cnt[ord(p[right]) - ord(\\'a\\')])\\n                \\n            else:\\n                left = right\\n                cnt[ord(p[right]) - ord(\\'a\\')] = max(1, cnt[ord(p[right]) - ord(\\'a\\')])\\n                \\n        return sum(cnt)",
                "codeTag": "Java"
            },
            {
                "id": 1019586,
                "title": "98-8-faster-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) \\n    {\\n        vector<int>dp(26,0);\\n        if(!p.size())\\n            return 0;\\n        int index=p[0]-\\'a\\',len=1,i=1;\\n        while(i<p.size())\\n        {\\n            if((p[i-1]+1==p[i] || (p[i-1]==\\'z\\' && p[i]==\\'a\\')))\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                while(len)\\n                {\\n                    if(dp[index]==0 || dp[index]<len)\\n                        dp[index]=len;\\n                    index=(index+1)%26;\\n                    len--;\\n                }\\n                len=1;\\n                index=p[i]-\\'a\\';\\n            }\\n            i++;\\n        }\\n        while(len)\\n        {\\n            if(dp[index]==0 || dp[index]<len)\\n                dp[index]=len;\\n            index=(index+1)%26;\\n                    len--;\\n        }\\n        int res=0;\\n        for(int x:dp)\\n        {\\n            res+=x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) \\n    {\\n        vector<int>dp(26,0);\\n        if(!p.size())\\n            return 0;\\n        int index=p[0]-\\'a\\',len=1,i=1;\\n        while(i<p.size())\\n        {\\n            if((p[i-1]+1==p[i] || (p[i-1]==\\'z\\' && p[i]==\\'a\\')))\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                while(len)\\n                {\\n                    if(dp[index]==0 || dp[index]<len)\\n                        dp[index]=len;\\n                    index=(index+1)%26;\\n                    len--;\\n                }\\n                len=1;\\n                index=p[i]-\\'a\\';\\n            }\\n            i++;\\n        }\\n        while(len)\\n        {\\n            if(dp[index]==0 || dp[index]<len)\\n                dp[index]=len;\\n            index=(index+1)%26;\\n                    len--;\\n        }\\n        int res=0;\\n        for(int x:dp)\\n        {\\n            res+=x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946390,
                "title": "golang-0ms-solution-easy-to-understand",
                "content": "maxLen of a letter means the max length of substring end up with the letter, for example substring \"abc\", the maxLen of c is 3.\\n\\nWhich stands for there are 3 substrings are end up with c, they are \"abc\", \"bc\" and \"c\".\\n\\nIterate p, for each letter find out the maxLen, the answer is just the sum of all the max lengths  \\n\\n```\\nfunc findSubstringInWraproundString(p string) int {\\n    if len(p) == 0 {\\n        return 0\\n    }\\n    pre := 1\\n    res := 0\\n    maxLen := make([]int, 26) //use maxLen slice to maintain the max len of substring of each letter\\n    maxLen[p[0] - \\'a\\'] = 1\\n    \\n    for i := 1; i < len(p); i++ {\\n        if p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25 {\\n            pre++ //if current letter is at alphabet sequence of previous letter, increase 1 to the max len\\n        } else {\\n            pre = 1 //otherwise the max len is 1\\n        }    \\n        maxLen[p[i] - \\'a\\'] = max(maxLen[p[i] - \\'a\\'], pre) //update the maxLen of this letter\\n    }\\n    for _, v := range maxLen {\\n        res += v //sum up the max len of each letters\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findSubstringInWraproundString(p string) int {\\n    if len(p) == 0 {\\n        return 0\\n    }\\n    pre := 1\\n    res := 0\\n    maxLen := make([]int, 26) //use maxLen slice to maintain the max len of substring of each letter\\n    maxLen[p[0] - \\'a\\'] = 1\\n    \\n    for i := 1; i < len(p); i++ {\\n        if p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25 {\\n            pre++ //if current letter is at alphabet sequence of previous letter, increase 1 to the max len\\n        } else {\\n            pre = 1 //otherwise the max len is 1\\n        }    \\n        maxLen[p[i] - \\'a\\'] = max(maxLen[p[i] - \\'a\\'], pre) //update the maxLen of this letter\\n    }\\n    for _, v := range maxLen {\\n        res += v //sum up the max len of each letters\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850138,
                "title": "python3-two-linear-implementations",
                "content": "Required are the lengths of longest continuous sub-string ending at every letter. The sum of such length is the number of interest. Two implementations are given below to reflect this idea. \\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        ans = cnt = 0\\n        seen = {} # longest string ending at char \\n        for i in range(len(p)): \\n            if 0 < i and (ord(p[i]) - ord(p[i-1])) % 26 != 1: cnt = 0 # reset counter \\n            cnt += 1\\n            if cnt > seen.get(p[i], 0): # duplicate of seen.get(p[i], 0) \\n                ans += cnt - seen.get(p[i], 0) # non-duplicate \\n                seen[p[i]] = cnt\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        cnt = 0\\n        seen = {} # longest string ending at char \\n        for i in range(len(p)): \\n            if 0 < i and (ord(p[i]) - ord(p[i-1])) % 26 != 1: cnt = 0 # reset counter \\n            cnt += 1\\n            seen[p[i]] = max(seen.get(p[i], 0), cnt)\\n        return sum(seen.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        ans = cnt = 0\\n        seen = {} # longest string ending at char \\n        for i in range(len(p)): \\n            if 0 < i and (ord(p[i]) - ord(p[i-1])) % 26 != 1: cnt = 0 # reset counter \\n            cnt += 1\\n            if cnt > seen.get(p[i], 0): # duplicate of seen.get(p[i], 0) \\n                ans += cnt - seen.get(p[i], 0) # non-duplicate \\n                seen[p[i]] = cnt\\n        return ans \\n```\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        cnt = 0\\n        seen = {} # longest string ending at char \\n        for i in range(len(p)): \\n            if 0 < i and (ord(p[i]) - ord(p[i-1])) % 26 != 1: cnt = 0 # reset counter \\n            cnt += 1\\n            seen[p[i]] = max(seen.get(p[i], 0), cnt)\\n        return sum(seen.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843269,
                "title": "go-0ms",
                "content": "0ms\\n```\\nfunc findSubstringInWraproundString(p string) int {\\n    maxlen := make([]int, 26)\\n    i := 0\\n    for i < len(p) {\\n        j := i + 1\\n        for j < len(p) &&\\n        (p[j] == p[j - 1] + 1 || (p[j - 1] == \\'z\\' && p[j] == \\'a\\'))  {\\n            j++\\n        }\\n        for k := i; k < j; k++ {\\n            maxlen[int(p[k] - \\'a\\')] = max(maxlen[int(p[k] - \\'a\\')], k + 1 - i)\\n        }   \\n        i = j\\n    }\\n    res := 0\\n    for i := 0; i < 26; i++ {\\n        res += maxlen[i]\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n320ms \\n```\\nfunc findSubstringInWraproundString(p string) int {\\n    maxlen := make([]int, 26)\\n    for i := 0; i < len(p); i++ {\\n        j := i + 1\\n        for j < len(p) &&\\n        (p[j] == p[j - 1] + 1 || (p[j - 1] == \\'z\\' && p[j] == \\'a\\'))  {\\n            j++\\n        }\\n        maxlen[ int(p[i] - \\'a\\')] = max(maxlen[int(p[i] - \\'a\\')],  j - i)\\n    }\\n    \\n    res := 0\\n    for i := 0; i < 26; i++ {\\n        res += maxlen[i]\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findSubstringInWraproundString(p string) int {\\n    maxlen := make([]int, 26)\\n    i := 0\\n    for i < len(p) {\\n        j := i + 1\\n        for j < len(p) &&\\n        (p[j] == p[j - 1] + 1 || (p[j - 1] == \\'z\\' && p[j] == \\'a\\'))  {\\n            j++\\n        }\\n        for k := i; k < j; k++ {\\n            maxlen[int(p[k] - \\'a\\')] = max(maxlen[int(p[k] - \\'a\\')], k + 1 - i)\\n        }   \\n        i = j\\n    }\\n    res := 0\\n    for i := 0; i < 26; i++ {\\n        res += maxlen[i]\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n```\\nfunc findSubstringInWraproundString(p string) int {\\n    maxlen := make([]int, 26)\\n    for i := 0; i < len(p); i++ {\\n        j := i + 1\\n        for j < len(p) &&\\n        (p[j] == p[j - 1] + 1 || (p[j - 1] == \\'z\\' && p[j] == \\'a\\'))  {\\n            j++\\n        }\\n        maxlen[ int(p[i] - \\'a\\')] = max(maxlen[int(p[i] - \\'a\\')],  j - i)\\n    }\\n    \\n    res := 0\\n    for i := 0; i < 26; i++ {\\n        res += maxlen[i]\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779843,
                "title": "c-o-n-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n\\tif (p.empty()) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint len[26] {};\\n\\tlen[p[0]-\\'a\\'] = 1;\\n\\tint pos = 0;\\n\\tfor (int i=1; i<p.size(); ++i) {\\n\\t\\tif ((p[i]-p[i-1]+26) % 26 != 1) {\\n\\t\\t\\tpos = i;    \\n\\t\\t}\\n\\t\\tlen[p[i]-\\'a\\'] = max(len[p[i]-\\'a\\'], i-pos+1);\\n\\t}\\n\\treturn accumulate(begin(len), end(len), 0);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n\\tif (p.empty()) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint len[26] {};\\n\\tlen[p[0]-\\'a\\'] = 1;\\n\\tint pos = 0;\\n\\tfor (int i=1; i<p.size(); ++i) {\\n\\t\\tif ((p[i]-p[i-1]+26) % 26 != 1) {\\n\\t\\t\\tpos = i;    \\n\\t\\t}\\n\\t\\tlen[p[i]-\\'a\\'] = max(len[p[i]-\\'a\\'], i-pos+1);\\n\\t}\\n\\treturn accumulate(begin(len), end(len), 0);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755511,
                "title": "java-count-num-of-substring-ending-with-certain-char",
                "content": "Trick: every certain len of substrings that end with same char are the same.\\nThen you just loop the aray once, and find the maximum len of subarrays ending with each char, things will be done.\\n\\nSpace:O(26)  ==> O(1)\\ntime: O(n)\\n```\\n    public int findSubstringInWraproundString(String p) {\\n        if (p == null || p.length() == 0) return 0;\\n        int res = 0, l = 0, m = p.length(), prev = -2, cnt[] = new int[26];  // prev off\\n        for (int i = 0; i < m; i++) {\\n            int off = p.charAt(i) - \\'a\\';\\n            if (off != prev + 1 && !(prev == 25 && off == 0)) l = i;\\n            cnt[off] = Math.max(cnt[off], i - l + 1);\\n            prev = off;\\n        }\\n        for (int i = 0; i < 26; i++) res += cnt[i];\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findSubstringInWraproundString(String p) {\\n        if (p == null || p.length() == 0) return 0;\\n        int res = 0, l = 0, m = p.length(), prev = -2, cnt[] = new int[26];  // prev off\\n        for (int i = 0; i < m; i++) {\\n            int off = p.charAt(i) - \\'a\\';\\n            if (off != prev + 1 && !(prev == 25 && off == 0)) l = i;\\n            cnt[off] = Math.max(cnt[off], i - l + 1);\\n            prev = off;\\n        }\\n        for (int i = 0; i < 26; i++) res += cnt[i];\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724405,
                "title": "probably-the-shortest-code-possible",
                "content": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {int n=s.length(),i,ans=0,cnt=1;\\n        if(!n)\\n            return 0;\\n        vector<int>dp(26);dp[s[0]-\\'a\\']=1;\\n        for(i=1;i<n;i++)\\n        {\\n            if(abs(s[i]-s[i-1])==25||s[i]-s[i-1]==1)\\n                dp[s[i]-\\'a\\']=max(dp[s[i]-\\'a\\'],++cnt);\\n            else\\n                dp[s[i]-\\'a\\']=max(dp[s[i]-\\'a\\'],cnt=1); \\n        }return accumulate(dp.begin(),dp.end(),0);        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {int n=s.length(),i,ans=0,cnt=1;\\n        if(!n)\\n            return 0;\\n        vector<int>dp(26);dp[s[0]-\\'a\\']=1;\\n        for(i=1;i<n;i++)\\n        {\\n            if(abs(s[i]-s[i-1])==25||s[i]-s[i-1]==1)\\n                dp[s[i]-\\'a\\']=max(dp[s[i]-\\'a\\'],++cnt);\\n            else\\n                dp[s[i]-\\'a\\']=max(dp[s[i]-\\'a\\'],cnt=1); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 620562,
                "title": "python-solution-dp",
                "content": "```py\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        \\'\\'\\'\\n        Let\\'s explain the procedure in some understandable way\\n        \\n        Try 1: we just used DP such that the optimal sub-problem was\\n              \\n              NumOfContSubsEndingAt(i) = NumOfContSubsEndingAt(i-1) if p[i-1] == p[i] else 1\\n        \\n        which was good, but since each substring should be unique, it was not particularly giving\\n        the required values, so the next approach\\n        \\n        Try 2: (Saw the procedure on Discuss)\\n        \\n        We create a DP of the largest substring ending at a particular character (a - z),\\n        since all the intermediate substrings would be included in this largest substring\\n        the value would give all the unique substrings ending at suppose \\'i\\'\\n        \\n        We will have a running length of continuous substring which will become 1 when continuity\\n        ends.\\n        \\n        so, the optimal sub-problem would be\\n        \\n           MaxLenOfContSubsEndingAtChar(i) = max(MaxLenOfContSubsEndingAtChar(i), runningLenOfContSubsEndingAtChar(i))\\n           \\n        The result is just the sum of all these values:\\n        \\n        Explanation: why each substring ending at (i) is unique to any other substring ending at any other (j)? Simply\\n        because, each substrings ending at i, has i at the end and hence unique.\\n        \\n        like an example: abcdefzab\\n        \\n           i  substring ending at i                  maxsubstrings\\n           a: a, za                                  za\\n           b: ab, b, zab,                            zab\\n           c: abc, bc, c                             abc\\n           d: abcd, bcd, cd,                         abcd\\n           e: abcde, bcde, cde, de, e                abcde\\n           f: abcdef, bcdef, cdef, def, ef, f        abcdef\\n           z: z                                      z\\n        \\n        clearly maxsubstrings include all the substrings, and all the substrings in the maxsubstring are unique\\n        So, total substrings ending at a = 2 (length of maxsubstring), similarly so for all\\n        \\'\\'\\'\\n        # Length of Max Substring Ending at Char\\n        LMSEC = [0 for i in range(26)]\\n        \\n        if(len(p)):\\n            # Initialize the first value (missed afterwords)\\n            LMSEC[ord(p[0]) - ord(\\'a\\')] = 1\\n        else:\\n            return 0\\n        \\n        running_len = 1\\n\\t\\t\\n        for i, j in zip(p, p[1:]):\\n            running_len = running_len + 1 if (ord(j) - ord(i)) % 26 == 1 else 1\\n            LMSEC[ord(j) - ord(\\'a\\')] = max(running_len, LMSEC[ord(j) - ord(\\'a\\')])\\n        \\n        return sum(LMSEC)\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        \\'\\'\\'\\n        Let\\'s explain the procedure in some understandable way\\n        \\n        Try 1: we just used DP such that the optimal sub-problem was\\n              \\n              NumOfContSubsEndingAt(i) = NumOfContSubsEndingAt(i-1) if p[i-1] == p[i] else 1\\n        \\n        which was good, but since each substring should be unique, it was not particularly giving\\n        the required values, so the next approach\\n        \\n        Try 2: (Saw the procedure on Discuss)\\n        \\n        We create a DP of the largest substring ending at a particular character (a - z),\\n        since all the intermediate substrings would be included in this largest substring\\n        the value would give all the unique substrings ending at suppose \\'i\\'\\n        \\n        We will have a running length of continuous substring which will become 1 when continuity\\n        ends.\\n        \\n        so, the optimal sub-problem would be\\n        \\n           MaxLenOfContSubsEndingAtChar(i) = max(MaxLenOfContSubsEndingAtChar(i), runningLenOfContSubsEndingAtChar(i))\\n           \\n        The result is just the sum of all these values:\\n        \\n        Explanation: why each substring ending at (i) is unique to any other substring ending at any other (j)? Simply\\n        because, each substrings ending at i, has i at the end and hence unique.\\n        \\n        like an example: abcdefzab\\n        \\n           i  substring ending at i                  maxsubstrings\\n           a: a, za                                  za\\n           b: ab, b, zab,                            zab\\n           c: abc, bc, c                             abc\\n           d: abcd, bcd, cd,                         abcd\\n           e: abcde, bcde, cde, de, e                abcde\\n           f: abcdef, bcdef, cdef, def, ef, f        abcdef\\n           z: z                                      z\\n        \\n        clearly maxsubstrings include all the substrings, and all the substrings in the maxsubstring are unique\\n        So, total substrings ending at a = 2 (length of maxsubstring), similarly so for all\\n        \\'\\'\\'\\n        # Length of Max Substring Ending at Char\\n        LMSEC = [0 for i in range(26)]\\n        \\n        if(len(p)):\\n            # Initialize the first value (missed afterwords)\\n            LMSEC[ord(p[0]) - ord(\\'a\\')] = 1\\n        else:\\n            return 0\\n        \\n        running_len = 1\\n\\t\\t\\n        for i, j in zip(p, p[1:]):\\n            running_len = running_len + 1 if (ord(j) - ord(i)) % 26 == 1 else 1\\n            LMSEC[ord(j) - ord(\\'a\\')] = max(running_len, LMSEC[ord(j) - ord(\\'a\\')])\\n        \\n        return sum(LMSEC)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584752,
                "title": "the-description-is-not-clear",
                "content": "Does anybody have the same confusion with me?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 580014,
                "title": "c-easy-understand-solution",
                "content": "First,we should find substring like \"zab......\",\"ab...\",\"bc...\"....in string p.\\nSecond,we use these found substrings to refresh dp,which stores the max length of substrings that start with \\'a\\',\\'b\\'...\\'z\\'.\\nThird,we just need to add all the values in dp.\\n\\nfor example:\\np=\"zab\",then dp[0]=dp[\\'a\\'-\\'a\\']=2(\"ab\")  dp[1]=dp[\\'b\\'-\\'a\\']=1(\"b\") dp[25]=dp[\\'z\\'-\\'a\\']=3(\"zab\")\\nfrom dp[0]=2,we get \"a\",\"ab\";\\nfrom dp[1]=1,we get \"b\";\\nfrom dp[25]=3,we get \"z\",\"za\",\"zab\";\\nso the ans is 6.\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int ans=0,j;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<p.size();i=j){\\n            j=i+1;\\n            while(j<p.size()&&(p[j]-p[j-1]==1||(p[j-1]==\\'z\\'&&p[j]==\\'a\\'))) ++j;\\n            string t=p.substr(i,j-i);\\n            for(int k=0;k<t.size();++k){\\n                if(dp[t[k]-\\'a\\']<t.size()-k) dp[t[k]-\\'a\\']=t.size()-k;\\n            }\\n        }\\n        for(int i=0;i<26;++i) ans+=dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int ans=0,j;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<p.size();i=j){\\n            j=i+1;\\n            while(j<p.size()&&(p[j]-p[j-1]==1||(p[j-1]==\\'z\\'&&p[j]==\\'a\\'))) ++j;\\n            string t=p.substr(i,j-i);\\n            for(int k=0;k<t.size();++k){\\n                if(dp[t[k]-\\'a\\']<t.size()-k) dp[t[k]-\\'a\\']=t.size()-k;\\n            }\\n        }\\n        for(int i=0;i<26;++i) ans+=dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540738,
                "title": "python-with-documentation-and-inspiration",
                "content": "```python\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        # Original guidance followed: https://tinyurl.com/vr3as6l\\n        \\n        # The \"s\" is so huge! You don\\'t really need to build it\\n        # just assume that it exists i.e. consecutive letters can\\n        # be easily tested for.\\n        \\n        # One critical thing to remember: Number of unique strings\\n        # is equal to the length of the longest contiguous string.\\n        # Since we can have multiple chunks of contiguous strings in\\n        # \\'p\\', we use this map to compare the previous longest with\\n        # what will be computed next, and pick the largest one.\\n        uniqueStringsEndingInLetter = {}\\n        contiguousLength = 0\\n        \\n        for letterIdx in range(len(p)):\\n            \\n            # If we are in a contiguous string, lets keep adding to the\\n            # length. We may eventually not be able to expand this string\\n            # further and at that point we will decide that we will reset the\\n            # contiguous length to 1.\\n            if letterIdx > 0 and \\\\\\n                ord(p[letterIdx - 1]) + 1 == ord(p[letterIdx]) or \\\\\\n                ord(p[letterIdx - 1]) - ord(p[letterIdx]) == 25:\\n                contiguousLength += 1\\n            else:\\n                contiguousLength = 1\\n                \\n            # Since we may encounter a different contiguous length\\n            # substring ending at the same character in another part of \\'p\\',\\n            # we compare the previous and the current one to make sure we are\\n            # storing only the maximum of the two.\\n            uniqueStringsEndingInLetter[p[letterIdx]] = max(\\n                uniqueStringsEndingInLetter.get(p[letterIdx], 0),\\n                contiguousLength\\n            )\\n        \\n        # Why is it that this is being returend?\\n        # Well, total number of substrings ending in a letter\\n        # represents the number of unique substrings that can be\\n        # formed with this character at the end. This is different\\n        # than any substrings ending in another character. Every sub\\n        # string has to end in some charcter. So, this will sum the \\n        # substrings ending at all characters, thereby summing all\\n        # unique substrings that occur.\\n        return sum(uniqueStringsEndingInLetter.values())\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        # Original guidance followed: https://tinyurl.com/vr3as6l\\n        \\n        # The \"s\" is so huge! You don\\'t really need to build it\\n        # just assume that it exists i.e. consecutive letters can\\n        # be easily tested for.\\n        \\n        # One critical thing to remember: Number of unique strings\\n        # is equal to the length of the longest contiguous string.\\n        # Since we can have multiple chunks of contiguous strings in\\n        # \\'p\\', we use this map to compare the previous longest with\\n        # what will be computed next, and pick the largest one.\\n        uniqueStringsEndingInLetter = {}\\n        contiguousLength = 0\\n        \\n        for letterIdx in range(len(p)):\\n            \\n            # If we are in a contiguous string, lets keep adding to the\\n            # length. We may eventually not be able to expand this string\\n            # further and at that point we will decide that we will reset the\\n            # contiguous length to 1.\\n            if letterIdx > 0 and \\\\\\n                ord(p[letterIdx - 1]) + 1 == ord(p[letterIdx]) or \\\\\\n                ord(p[letterIdx - 1]) - ord(p[letterIdx]) == 25:\\n                contiguousLength += 1\\n            else:\\n                contiguousLength = 1\\n                \\n            # Since we may encounter a different contiguous length\\n            # substring ending at the same character in another part of \\'p\\',\\n            # we compare the previous and the current one to make sure we are\\n            # storing only the maximum of the two.\\n            uniqueStringsEndingInLetter[p[letterIdx]] = max(\\n                uniqueStringsEndingInLetter.get(p[letterIdx], 0),\\n                contiguousLength\\n            )\\n        \\n        # Why is it that this is being returend?\\n        # Well, total number of substrings ending in a letter\\n        # represents the number of unique substrings that can be\\n        # formed with this character at the end. This is different\\n        # than any substrings ending in another character. Every sub\\n        # string has to end in some charcter. So, this will sum the \\n        # substrings ending at all characters, thereby summing all\\n        # unique substrings that occur.\\n        return sum(uniqueStringsEndingInLetter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468619,
                "title": "6-lines-python-beats-100",
                "content": "```python3\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dl = defaultdict(int)\\n        maxlen = 0 \\n        for i in range(len(p)):\\n            maxlen = maxlen + 1 if i and (ord(p[i - 1]) - 96) % 26 == (ord(p[i]) - 97) else 1 \\n            dl[p[i]] = max(dl[p[i]], maxlen)\\n        return sum(dl.values())\\n\\n```",
                "solutionTags": [],
                "code": "```python3\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dl = defaultdict(int)\\n        maxlen = 0 \\n        for i in range(len(p)):\\n            maxlen = maxlen + 1 if i and (ord(p[i - 1]) - 96) % 26 == (ord(p[i]) - 97) else 1 \\n            dl[p[i]] = max(dl[p[i]], maxlen)\\n        return sum(dl.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389693,
                "title": "python-dp-solutioin",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        L = len(p)\\n        if L == 0: return 0\\n        DP = [1] * L\\n        dic = defaultdict(int)\\n        dic[p[0]] = 1\\n        for i in range(1, L):\\n            if ord(p[i]) - ord(p[i-1]) == 1 or (p[i] == \\'a\\' and p[i-1] == \\'z\\'):\\n                DP[i] = DP[i-1] + 1\\n            else:\\n                DP[i] = 1\\n            dic[p[i]] = max(dic[p[i]], DP[i])\\n        return sum(dic.values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        L = len(p)\\n        if L == 0: return 0\\n        DP = [1] * L\\n        dic = defaultdict(int)\\n        dic[p[0]] = 1\\n        for i in range(1, L):\\n            if ord(p[i]) - ord(p[i-1]) == 1 or (p[i] == \\'a\\' and p[i-1] == \\'z\\'):\\n                DP[i] = DP[i-1] + 1\\n            else:\\n                DP[i] = 1\\n            dic[p[i]] = max(dic[p[i]], DP[i])\\n        return sum(dic.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345831,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int FindSubstringInWraproundString(string p) {\\n        var n = p.Length;\\n        if (n == 0) return 0;\\n        var counts = new int[26];\\n\\n        var local = 1;\\n\\n        counts[p[0] - \\'a\\'] = 1;\\n        for (int i = 1; i < n; i++) {\\n            var pre = p[i - 1] - \\'a\\';\\n            var cur = p[i] - \\'a\\';\\n\\n            if ((cur - pre + 26) % 26 == 1) {\\n\\t\\t\\t\\t// abc => [1,2,3] when c: c, bc, abc (count: 3)\\n                local++;\\n            } else {\\n                local = 1;\\n            }\\n\\n            counts[cur] = Math.Max(counts[cur], local);\\n        }\\n\\n        return counts.Sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindSubstringInWraproundString(string p) {\\n        var n = p.Length;\\n        if (n == 0) return 0;\\n        var counts = new int[26];\\n\\n        var local = 1;\\n\\n        counts[p[0] - \\'a\\'] = 1;\\n        for (int i = 1; i < n; i++) {\\n            var pre = p[i - 1] - \\'a\\';\\n            var cur = p[i] - \\'a\\';\\n\\n            if ((cur - pre + 26) % 26 == 1) {\\n\\t\\t\\t\\t// abc => [1,2,3] when c: c, bc, abc (count: 3)\\n                local++;\\n            } else {\\n                local = 1;\\n            }\\n\\n            counts[cur] = Math.Max(counts[cur], local);\\n        }\\n\\n        return counts.Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292925,
                "title": "simple-java-solution-3ms",
                "content": "```\\nclass Solution {\\n    int[] chs;\\n    \\n    public int findSubstringInWraproundString(String p) {\\n        int[] lens = new int[26];\\n        int N = p.length();\\n        chs = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            chs[i] = p.charAt(i)-\\'a\\';\\n        }\\n        \\n        int start = 0;\\n        int cur = 0;\\n        while (cur < N) {\\n            start = cur;\\n            while (cur+1 < N && (chs[cur]+1) % 26 == chs[cur+1]) {\\n                cur++;\\n            }\\n            update(lens, start, cur);\\n            cur++;\\n        }\\n        \\n        int total = 0;\\n        for (int len: lens) {\\n            total += len;\\n        }\\n        return total;\\n    }\\n    \\n    void update(int[] lens, int start, int end) {\\n        for (int i = start; i <= end; i++) {\\n            if (end-i+1 <= lens[chs[i]]) {\\n                break;\\n            }\\n            lens[chs[i]] = end-i+1;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] chs;\\n    \\n    public int findSubstringInWraproundString(String p) {\\n        int[] lens = new int[26];\\n        int N = p.length();\\n        chs = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            chs[i] = p.charAt(i)-\\'a\\';\\n        }\\n        \\n        int start = 0;\\n        int cur = 0;\\n        while (cur < N) {\\n            start = cur;\\n            while (cur+1 < N && (chs[cur]+1) % 26 == chs[cur+1]) {\\n                cur++;\\n            }\\n            update(lens, start, cur);\\n            cur++;\\n        }\\n        \\n        int total = 0;\\n        for (int len: lens) {\\n            total += len;\\n        }\\n        return total;\\n    }\\n    \\n    void update(int[] lens, int start, int end) {\\n        for (int i = start; i <= end; i++) {\\n            if (end-i+1 <= lens[chs[i]]) {\\n                break;\\n            }\\n            lens[chs[i]] = end-i+1;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292040,
                "title": "python-dp-solution",
                "content": "```python\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        A = [ord(c) - ord(\\'a\\') for c in p]\\n        n = len(A)\\n        dp = [1] * n\\n        res = 0\\n        cnt = collections.Counter()\\n        for i in range(n):\\n            if i > 0 and A[i] == (A[i - 1] + 1) % 26:\\n                dp[i] = dp[i - 1] + 1\\n            cnt[A[i]] = max(cnt[A[i]], dp[i])\\n        return sum(cnt.values())\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        A = [ord(c) - ord(\\'a\\') for c in p]\\n        n = len(A)\\n        dp = [1] * n\\n        res = 0\\n        cnt = collections.Counter()\\n        for i in range(n):\\n            if i > 0 and A[i] == (A[i - 1] + 1) % 26:\\n                dp[i] = dp[i - 1] + 1\\n            cnt[A[i]] = max(cnt[A[i]], dp[i])\\n        return sum(cnt.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281965,
                "title": "python3-solution-runtime-beats-98-76-of-python3-submissions",
                "content": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        letters={\\n            \\'a\\':0,\\n            \\'b\\':1,\\n            \\'c\\':2,\\n            \\'d\\':3,\\n            \\'e\\':4,\\n            \\'f\\':5,\\n            \\'g\\':6,\\n            \\'h\\':7,\\n            \\'i\\':8,\\n            \\'j\\':9,\\n            \\'k\\':10,\\n            \\'l\\':11,\\n            \\'m\\':12,\\n            \\'n\\':13,\\n            \\'o\\':14,\\n            \\'p\\':15,\\n            \\'q\\':16,\\n            \\'r\\':17,\\n            \\'s\\':18,\\n            \\'t\\':19,\\n            \\'u\\':20,\\n            \\'v\\':21,\\n            \\'w\\':22,\\n            \\'x\\':23,\\n            \\'y\\':24,\\n            \\'z\\':25\\n        }\\n        max_len_on_letter_end = {}\\n        prev_index = -2\\n        sequence_len = 0\\n        substrings_number = 0\\n        for i, c in enumerate(p):\\n            index = letters[c]\\n            # counting sequence length:\\n            if (index == 0 and prev_index==25) or (index-prev_index==1):\\n                sequence_len += 1\\n            else:\\n                sequence_len = 1\\n            # new sequence:\\n            if c not in max_len_on_letter_end: \\n                substrings_number += sequence_len\\n                max_len_on_letter_end[c] = sequence_len\\n            # sequence repeated, but is larger than previous like \\'abcdefg\\' > \\'abc\\':\\n            elif sequence_len > max_len_on_letter_end[c]: \\n                substrings_number += sequence_len - max_len_on_letter_end[c]\\n                max_len_on_letter_end[c] = sequence_len\\n            # sequence repeated, but is less than previous like \\'abc\\' < \\'abcdefg\\':\\n            else: # in this case we don\\'t do anything\\n                pass\\n            prev_index = index\\n        return substrings_number\\n    ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        letters={\\n            \\'a\\':0,\\n            \\'b\\':1,\\n            \\'c\\':2,\\n            \\'d\\':3,\\n            \\'e\\':4,\\n            \\'f\\':5,\\n            \\'g\\':6,\\n            \\'h\\':7,\\n            \\'i\\':8,\\n            \\'j\\':9,\\n            \\'k\\':10,\\n            \\'l\\':11,\\n            \\'m\\':12,\\n            \\'n\\':13,\\n            \\'o\\':14,\\n            \\'p\\':15,\\n            \\'q\\':16,\\n            \\'r\\':17,\\n            \\'s\\':18,\\n            \\'t\\':19,\\n            \\'u\\':20,\\n            \\'v\\':21,\\n            \\'w\\':22,\\n            \\'x\\':23,\\n            \\'y\\':24,\\n            \\'z\\':25\\n        }\\n        max_len_on_letter_end = {}\\n        prev_index = -2\\n        sequence_len = 0\\n        substrings_number = 0\\n        for i, c in enumerate(p):\\n            index = letters[c]\\n            # counting sequence length:\\n            if (index == 0 and prev_index==25) or (index-prev_index==1):\\n                sequence_len += 1\\n            else:\\n                sequence_len = 1\\n            # new sequence:\\n            if c not in max_len_on_letter_end: \\n                substrings_number += sequence_len\\n                max_len_on_letter_end[c] = sequence_len\\n            # sequence repeated, but is larger than previous like \\'abcdefg\\' > \\'abc\\':\\n            elif sequence_len > max_len_on_letter_end[c]: \\n                substrings_number += sequence_len - max_len_on_letter_end[c]\\n                max_len_on_letter_end[c] = sequence_len\\n            # sequence repeated, but is less than previous like \\'abc\\' < \\'abcdefg\\':\\n            else: # in this case we don\\'t do anything\\n                pass\\n            prev_index = index\\n        return substrings_number\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 241136,
                "title": "short-python-dp-beats-98",
                "content": "The main idea is to use DP to record the longest length of the substrings that ends with the same letter. Then the sum of the longest lengths of all letters is the final result. Time O(N), Space O(1).\\n```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        prev = -1\\n        count = 0\\n        dicts = [0 for i in xrange(26)]\\n        for i in p:\\n            idx = ord(i)-97\\n            if prev == -1: count = 1\\n            elif (idx - prev)%26 == 1: count += 1\\n            else: count = 1\\n            prev = idx\\n            dicts[idx] = max(dicts[idx],count)\\n                \\n        return sum(dicts)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        prev = -1\\n        count = 0\\n        dicts = [0 for i in xrange(26)]\\n        for i in p:\\n            idx = ord(i)-97\\n            if prev == -1: count = 1\\n            elif (idx - prev)%26 == 1: count += 1\\n            else: count = 1\\n            prev = idx\\n            dicts[idx] = max(dicts[idx],count)\\n                \\n        return sum(dicts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209181,
                "title": "swift-dp",
                "content": "\\n    func findSubstringInWraproundString(_ p: String) -> Int {\\n        var map = [Character: Int]()\\n        var i = 0\\n        \"abcdefghijklmnopqrstuvwxyz\".forEach { (c) in\\n            map[c] = i\\n            i+=1\\n        }\\n\\n        var dp = [Int](repeating: 0, count: 26)\\n        let chars = Array(p.lowercased())\\n        var len = 0\\n        for i in 0..<chars.count {\\n            if i > 0 {\\n                let diff = map[chars[i]]! - map[chars[i-1]]!\\n                if diff == 1 || diff == -25 {\\n                    len += 1\\n                } else {\\n                    len = 1\\n                }\\n            }else {\\n                len = 1\\n            }\\n            let index = map[chars[i]]!\\n            dp[index] = max(dp[index], len);\\n        }\\n        var sum = 0\\n        dp.forEach { (x) in\\n            sum += x\\n        }\\n        return sum\\n    }",
                "solutionTags": [],
                "code": "\\n    func findSubstringInWraproundString(_ p: String) -> Int {\\n        var map = [Character: Int]()\\n        var i = 0\\n        \"abcdefghijklmnopqrstuvwxyz\".forEach { (c) in\\n            map[c] = i\\n            i+=1\\n        }\\n\\n        var dp = [Int](repeating: 0, count: 26)\\n        let chars = Array(p.lowercased())\\n        var len = 0\\n        for i in 0..<chars.count {\\n            if i > 0 {\\n                let diff = map[chars[i]]! - map[chars[i-1]]!\\n                if diff == 1 || diff == -25 {\\n                    len += 1\\n                } else {\\n                    len = 1\\n                }\\n            }else {\\n                len = 1\\n            }\\n            let index = map[chars[i]]!\\n            dp[index] = max(dp[index], len);\\n        }\\n        var sum = 0\\n        dp.forEach { (x) in\\n            sum += x\\n        }\\n        return sum\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 205458,
                "title": "java-o-n-time-and-o-1-space-solution-with-explanation",
                "content": "One of the approaches to solve this problem is try to figure out the number of substrings present in the string `s` that start with  char `c` (`c` ranges from `a` to `z`). Then the problem just drills down to addition of all such substrings. And the number of substrings present in the string `s` that start with char `c` is simply the max length sequence starting with `c`. Example :  in s = `abcbcd` the number of substrings starting with char `b` is 3 which is the max length sequence\\'s(`bcd`) length and the substrings starting with `b` are `b`, `bc`, `bcd`\\n\\nCode:\\n```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] subStringsStartingWith = new int[26];\\n        int i=0;\\n        int j=1;\\n        while(j<p.length()){\\n            while(j<p.length() && ((p.charAt(j-1) == \\'z\\' && p.charAt(j) == \\'a\\') || p.charAt(j)-p.charAt(j-1) == 1))\\n                j++;\\n            while(i<j){\\n                subStringsStartingWith[p.charAt(i)-\\'a\\'] = Math.max(subStringsStartingWith[p.charAt(i)-\\'a\\'], j-i);\\n                i++;\\n            }\\n            j++;\\n        }\\n        while(i<p.length()){\\n                subStringsStartingWith[p.charAt(i)-\\'a\\'] = Math.max(subStringsStartingWith[p.charAt(i)-\\'a\\'], p.length()-i);\\n                i++;\\n        }\\n        return Arrays.stream(subStringsStartingWith).sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] subStringsStartingWith = new int[26];\\n        int i=0;\\n        int j=1;\\n        while(j<p.length()){\\n            while(j<p.length() && ((p.charAt(j-1) == \\'z\\' && p.charAt(j) == \\'a\\') || p.charAt(j)-p.charAt(j-1) == 1))\\n                j++;\\n            while(i<j){\\n                subStringsStartingWith[p.charAt(i)-\\'a\\'] = Math.max(subStringsStartingWith[p.charAt(i)-\\'a\\'], j-i);\\n                i++;\\n            }\\n            j++;\\n        }\\n        while(i<p.length()){\\n                subStringsStartingWith[p.charAt(i)-\\'a\\'] = Math.max(subStringsStartingWith[p.charAt(i)-\\'a\\'], p.length()-i);\\n                i++;\\n        }\\n        return Arrays.stream(subStringsStartingWith).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203926,
                "title": "python-time-o-n-space-o-1",
                "content": "```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        count = [0] * 26\\n        max_len = 1\\n        \\n        for i in range(len(p)):\\n            if i > 0:\\n                prev, curr = ord(p[i-1]), ord(p[i])\\n                max_len = max_len+1 if (prev-curr) % 26 == 25 else 1\\n            \\n            idx = ord(p[i]) - ord(\\'a\\')\\n            count[idx] = max(count[idx], max_len)\\n        return sum(count)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        count = [0] * 26\\n        max_len = 1\\n        \\n        for i in range(len(p)):\\n            if i > 0:\\n                prev, curr = ord(p[i-1]), ord(p[i])\\n                max_len = max_len+1 if (prev-curr) % 26 == 25 else 1\\n            \\n            idx = ord(p[i]) - ord(\\'a\\')\\n            count[idx] = max(count[idx], max_len)\\n        return sum(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95442,
                "title": "9-lines-c",
                "content": "C++ version of this [post](https://discuss.leetcode.com/topic/70658/concise-java-solution-using-dp).\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int>dp(26);\\n        int len = 0;\\n        for(int i = 0; i < p.size(); i++){\\n            len = (i > 0 && (p[i] - p[i - 1] == 1 || p[i] - p[i - 1] == -25)) ? len + 1 : 1;\\n            dp[p[i] - 'a'] = max(dp[p[i] - 'a'], len);\\n        }\\n        int sum = 0;\\n        for(int x: dp) sum += x;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<int>dp(26);\\n        int len = 0;\\n        for(int i = 0; i < p.size(); i++){\\n            len = (i > 0 && (p[i] - p[i - 1] == 1 || p[i] - p[i - 1] == -25)) ? len + 1 : 1;\\n            dp[p[i] - 'a'] = max(dp[p[i] - 'a'], len);\\n        }\\n        int sum = 0;\\n        for(int x: dp) sum += x;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95451,
                "title": "short-python-sliding-window-o-n-time-o-1-space",
                "content": "I tried math method to solve this problem but I found it is too tricky to deal with duplicates. Then, I use a dictionary to store max length that ends at a certain character.\\n```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        cnt = 0\\n        for i in range(len(p)):\\n            if i > 0 and (ord(p[i]) - ord(p[i-1]) == 1 or ord(p[i-1]) - ord(p[i]) == 25):\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            d[ord(p[i])] = max(d.get(ord(p[i]), 0), cnt)\\n        return sum(d.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        cnt = 0\\n        for i in range(len(p)):\\n            if i > 0 and (ord(p[i]) - ord(p[i-1]) == 1 or ord(p[i-1]) - ord(p[i]) == 25):\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            d[ord(p[i])] = max(d.get(ord(p[i]), 0), cnt)\\n        return sum(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95469,
                "title": "o-n-time-o-alphabet-size-memory-store-maximum-length-for-each-alphabet",
                "content": "1) O(n) time complexity. O(alphabet size) memory space. We can do it by calculating the maximum length of sequential characters for each alphabet. At the end we can just sum up the all maximum lengths of each alphabet.\\n\\n```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if (p==null || p.isEmpty()) return 0;\\n       \\n        HashMap<Character, Integer> charMaxLen = new HashMap<>();\\n        charMaxLen.put(p.charAt(0), 1);\\n        int sum = 1;\\n        int len = 1;\\n        \\n        for (int i=1; i<p.length(); i++) {\\n            char prev = p.charAt(i-1);\\n            char cur = p.charAt(i);\\n            if (isSequential(prev, cur)) {\\n                len++;\\n            } else {\\n                len = 1;\\n            }\\n            \\n            sum+=Math.max(len-charMaxLen.getOrDefault(cur,0), 0);\\n            charMaxLen.putIfAbsent(cur, 0);\\n            charMaxLen.put(cur, Math.max(len, charMaxLen.get(cur)));\\n        }\\n        return sum;\\n    }\\n    \\n    private boolean isSequential(char prev, char cur) {\\n        return (prev=='z' && cur=='a') || (cur-prev==1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        if (p==null || p.isEmpty()) return 0;\\n       \\n        HashMap<Character, Integer> charMaxLen = new HashMap<>();\\n        charMaxLen.put(p.charAt(0), 1);\\n        int sum = 1;\\n        int len = 1;\\n        \\n        for (int i=1; i<p.length(); i++) {\\n            char prev = p.charAt(i-1);\\n            char cur = p.charAt(i);\\n            if (isSequential(prev, cur)) {\\n                len++;\\n            } else {\\n                len = 1;\\n            }\\n            \\n            sum+=Math.max(len-charMaxLen.getOrDefault(cur,0), 0);\\n            charMaxLen.putIfAbsent(cur, 0);\\n            charMaxLen.put(cur, Math.max(len, charMaxLen.get(cur)));\\n        }\\n        return sum;\\n    }\\n    \\n    private boolean isSequential(char prev, char cur) {\\n        return (prev=='z' && cur=='a') || (cur-prev==1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95446,
                "title": "java-solution-17ms",
                "content": "```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] map = new int[128];\\n        for(int i = 0; i < p.length(); i++){\\n            int j = i;\\n            while(i + 1 < p.length() && (p.charAt(i + 1) == p.charAt(i) + 1 || p.charAt(i + 1) + 25 == p.charAt(i))) i++;\\n            int len = i - j + 1;\\n            for(int k = j; k < j + Math.min(len, 26); k++){\\n                map[p.charAt(k)] = Math.max(map[p.charAt(k)], i - k + 1);\\n            }\\n        }\\n        int res = 0;\\n        for(int e : map){\\n            res += e;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findSubstringInWraproundString(String p) {\\n        int[] map = new int[128];\\n        for(int i = 0; i < p.length(); i++){\\n            int j = i;\\n            while(i + 1 < p.length() && (p.charAt(i + 1) == p.charAt(i) + 1 || p.charAt(i + 1) + 25 == p.charAt(i))) i++;\\n            int len = i - j + 1;\\n            for(int k = j; k < j + Math.min(len, 26); k++){\\n                map[p.charAt(k)] = Math.max(map[p.charAt(k)], i - k + 1);\\n            }\\n        }\\n        int res = 0;\\n        for(int e : map){\\n            res += e;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064251,
                "title": "unique-substrings-in-wraparound-string-o-n-easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] maxlen = new int[26];\\n        int maxEnd = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char currChar = s.charAt(i);\\n\\n            // If the current character is adjacent to the previous character in the wraparound string\\n            if (i > 0 && (currChar - s.charAt(i - 1) == 1 || s.charAt(i - 1) - currChar == 25)) {\\n                maxEnd++;\\n            } else {\\n                maxEnd = 1;\\n            }\\n\\n            // Update the maximum length for the current character\\n            int charInd = currChar - \\'a\\';\\n            maxlen[charInd] = Math.max(maxlen[charInd], maxEnd);\\n        }\\n\\n        // Sum up the maximum lengths for all characters to get the total count of unique substrings\\n        int totalCount = 0;\\n        for (int length : maxlen) {\\n            totalCount += length;\\n        }\\n\\n        return totalCount;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] maxlen = new int[26];\\n        int maxEnd = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char currChar = s.charAt(i);\\n\\n            // If the current character is adjacent to the previous character in the wraparound string\\n            if (i > 0 && (currChar - s.charAt(i - 1) == 1 || s.charAt(i - 1) - currChar == 25)) {\\n                maxEnd++;\\n            } else {\\n                maxEnd = 1;\\n            }\\n\\n            // Update the maximum length for the current character\\n            int charInd = currChar - \\'a\\';\\n            maxlen[charInd] = Math.max(maxlen[charInd], maxEnd);\\n        }\\n\\n        // Sum up the maximum lengths for all characters to get the total count of unique substrings\\n        int totalCount = 0;\\n        for (int length : maxlen) {\\n            totalCount += length;\\n        }\\n\\n        return totalCount;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061455,
                "title": "linear-solution",
                "content": "## Approach \\n\\nWe have to find continuous or increasing substring where difference between consecutive elements is 1, and record no. of elements appeared before them against each of the elements. If we find a break in the subarray then reset the counter to 1, and then continue in same fashion. When encountered an element which has appeared before we have to record largest value for that element. See below example for more understanding. \\n\\n```\\ncurrent , previous\\n# Setting the counter \\nif current - previous == 1 or current == \\'a\\' and previous == \\'z\\' : \\n  counter += 1 # increse the counter as our sequence continues \\n else : counter = 1 # reset the counter as sequence breaks \\n \\n # Assigning the counter values \\n if current exists already : \\n   count[current] = maximum(count[current], counter) \\n  else : # counter doesn\\'t exist or is appearing for first time \\n    count[current] = counter \\n```\\n  \\n\\n  \\n\\n*Do this for all the elements except first and return sum of all the counts.*\\n\\n**Illustration**\\n\\n``` \\nstring = abckdefxabcdxde\\n\\ncounter, current:count[current]\\n\\n1, a:1\\n\\n2, b:2 \\n\\n3, c:3\\n\\n1, k:1\\n\\n1, d:1\\n\\n2, e:2\\n\\n3, f:3\\n\\n1, x:1 \\n\\n1, a:1\\n\\n2, b:2\\n\\n3, c:3\\n\\n4, d:4\\n\\n1, x:1 \\n\\n1, d:4\\n\\n2, e:2\\n```\\n\\nTime Complexity : O(N) \\n\\n \\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n      count, n, so_far = {}, len(s), 1\\n      count[s[0]] = so_far \\n      for i in range(1,n):\\n        curr, prev = s[i], s[i-1]\\n        if (ord(curr) - ord(prev) == 1) or (curr == \\'a\\' and prev == \\'z\\'): so_far += 1 \\n        else : so_far = 1 \\n        if curr in count : count[curr] = max(count[curr], so_far) \\n        elif not (curr in count) : count[curr] = so_far \\n\\n      # print(count)\\n      return sum(count.values())\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ncurrent , previous\\n# Setting the counter \\nif current - previous == 1 or current == \\'a\\' and previous == \\'z\\' : \\n  counter += 1 # increse the counter as our sequence continues \\n else : counter = 1 # reset the counter as sequence breaks \\n \\n # Assigning the counter values \\n if current exists already : \\n   count[current] = maximum(count[current], counter) \\n  else : # counter doesn\\'t exist or is appearing for first time \\n    count[current] = counter \\n```\n``` \\nstring = abckdefxabcdxde\\n\\ncounter, current:count[current]\\n\\n1, a:1\\n\\n2, b:2 \\n\\n3, c:3\\n\\n1, k:1\\n\\n1, d:1\\n\\n2, e:2\\n\\n3, f:3\\n\\n1, x:1 \\n\\n1, a:1\\n\\n2, b:2\\n\\n3, c:3\\n\\n4, d:4\\n\\n1, x:1 \\n\\n1, d:4\\n\\n2, e:2\\n```\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n      count, n, so_far = {}, len(s), 1\\n      count[s[0]] = so_far \\n      for i in range(1,n):\\n        curr, prev = s[i], s[i-1]\\n        if (ord(curr) - ord(prev) == 1) or (curr == \\'a\\' and prev == \\'z\\'): so_far += 1 \\n        else : so_far = 1 \\n        if curr in count : count[curr] = max(count[curr], so_far) \\n        elif not (curr in count) : count[curr] = so_far \\n\\n      # print(count)\\n      return sum(count.values())\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046055,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar findSubstringInWraproundString = function(s) {\\n    const dp = Array(26).fill(0);\\n\\tconst origin = \\'a\\'.charCodeAt(0);\\n\\tlet count = 0;\\n\\n\\tfor (let index = 0; index < s.length; index++) {\\n\\t\\tconst code = s.charCodeAt(index);\\n\\t\\tconst preCode = s.charCodeAt(index - 1);\\n\\t\\tconst pos = code - origin;\\n\\n\\t\\tcount = code - preCode === 1 || preCode - code === 25\\n\\t\\t\\t? count + 1\\n\\t\\t\\t: 1;\\n\\n\\t\\tdp[pos] = Math.max(count, dp[pos]);\\n\\t}\\n\\n\\treturn dp.reduce((total, count) => total + count);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar findSubstringInWraproundString = function(s) {\\n    const dp = Array(26).fill(0);\\n\\tconst origin = \\'a\\'.charCodeAt(0);\\n\\tlet count = 0;\\n\\n\\tfor (let index = 0; index < s.length; index++) {\\n\\t\\tconst code = s.charCodeAt(index);\\n\\t\\tconst preCode = s.charCodeAt(index - 1);\\n\\t\\tconst pos = code - origin;\\n\\n\\t\\tcount = code - preCode === 1 || preCode - code === 25\\n\\t\\t\\t? count + 1\\n\\t\\t\\t: 1;\\n\\n\\t\\tdp[pos] = Math.max(count, dp[pos]);\\n\\t}\\n\\n\\treturn dp.reduce((total, count) => total + count);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005383,
                "title": "o-n-solution",
                "content": "![image](https://assets.leetcode.com/users/images/bd7857ff-4a45-416e-9464-34ba3dd53358_1693916449.0873551.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bd7857ff-4a45-416e-9464-34ba3dd53358_1693916449.0873551.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3972603,
                "title": "c-recursion-backtracking-dp-super-easy-easy-to-understand",
                "content": "\\n\\n# Approach\\nIf that character series already present then substract;\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n O(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_map<char,int> hash;\\n    \\n    int res;\\n\\n    int helper(string &s,int i,int r)\\n    {\\n        if(s.length()==i)\\n            return 0;\\n\\n        r%=26;\\n\\n        if(s[i]!=(\\'a\\'+r))\\n        {\\n             helper(s,i,s[i]-\\'a\\');\\n             return 0;   \\n        }\\n\\n        int val=1+helper(s,i+1,r+1);\\n\\n        res+=max(val-hash[s[i]],0);\\n        \\n        hash[s[i]]=max(hash[s[i]],val);\\n\\n        return val;\\n    }\\n\\n    int findSubstringInWraproundString(string s)\\n    {\\n        res=0;\\n\\n        helper(s,0,0);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_map<char,int> hash;\\n    \\n    int res;\\n\\n    int helper(string &s,int i,int r)\\n    {\\n        if(s.length()==i)\\n            return 0;\\n\\n        r%=26;\\n\\n        if(s[i]!=(\\'a\\'+r))\\n        {\\n             helper(s,i,s[i]-\\'a\\');\\n             return 0;   \\n        }\\n\\n        int val=1+helper(s,i+1,r+1);\\n\\n        res+=max(val-hash[s[i]],0);\\n        \\n        hash[s[i]]=max(hash[s[i]],val);\\n\\n        return val;\\n    }\\n\\n    int findSubstringInWraproundString(string s)\\n    {\\n        res=0;\\n\\n        helper(s,0,0);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957690,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery substring must have consecutive letters in it as shown in base.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will create a dp array of 26 size representing each alphabet which stores maximum length of substring ending at that alphabet.\\nif dp[s[i] - \\'a\\'] = x ,  it contains x no. of substrings in the base string.\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int ans = 0, res = 0, n = s.size();\\n        vector<int> dp(26,0);\\n        for (int i=0;i<n;i++)\\n        {\\n            res = 1;\\n            dp[s[i] - \\'a\\'] = max(dp[s[i] - \\'a\\'], res);\\n            while (i+1 < n && (s[i+1] - s[i] == 1) || (s[i] == \\'z\\' && s[i+1] == \\'a\\'))\\n            {\\n                res++;\\n                i++;\\n                dp[s[i] - \\'a\\'] = max(dp[s[i] - \\'a\\'], res);\\n            }\\n        }\\n        for (int i=0;i<26;i++) ans += dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int ans = 0, res = 0, n = s.size();\\n        vector<int> dp(26,0);\\n        for (int i=0;i<n;i++)\\n        {\\n            res = 1;\\n            dp[s[i] - \\'a\\'] = max(dp[s[i] - \\'a\\'], res);\\n            while (i+1 < n && (s[i+1] - s[i] == 1) || (s[i] == \\'z\\' && s[i+1] == \\'a\\'))\\n            {\\n                res++;\\n                i++;\\n                dp[s[i] - \\'a\\'] = max(dp[s[i] - \\'a\\'], res);\\n            }\\n        }\\n        for (int i=0;i<26;i++) ans += dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933841,
                "title": "store-longest-chain-ending-at-each-character",
                "content": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        n = len(s)\\n        char = [0] * 26\\n        longest = 0\\n        for i in range(n):\\n            curr = ord(s[i]) - ord(\\'a\\')\\n            if i > 0 and (ord(s[i - 1]) - ord(\\'a\\') + 1) % 26 == curr:\\n                longest += 1\\n            else:\\n                longest = 1\\n            char[curr] = max(char[curr], longest)\\n        return sum(char)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        n = len(s)\\n        char = [0] * 26\\n        longest = 0\\n        for i in range(n):\\n            curr = ord(s[i]) - ord(\\'a\\')\\n            if i > 0 and (ord(s[i - 1]) - ord(\\'a\\') + 1) % 26 == curr:\\n                longest += 1\\n            else:\\n                longest = 1\\n            char[curr] = max(char[curr], longest)\\n        return sum(char)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881159,
                "title": "string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        long long ans=0;\\n        for(int i=0;i<26;i++){\\n            int id=0;\\n            int n=s.size();\\n            int mx=0;\\n            while(id<n){\\n                if(s[id]-\\'a\\'!=i){\\n                     id+=1;\\n                     continue;\\n                }\\n                int val=i;\\n                int len=0;\\n                while(id<s.size()){\\n                    int r=(val%26);\\n                    if(s[id]-\\'a\\'!=r) break;\\n                    else{\\n                        id+=1;\\n                        len+=1;\\n                        val+=1;\\n                    }\\n\\n                }\\n                \\n                mx=max(mx,len);\\n            }\\n            \\n            ans+=mx;\\n        }\\n\\n               return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        long long ans=0;\\n        for(int i=0;i<26;i++){\\n            int id=0;\\n            int n=s.size();\\n            int mx=0;\\n            while(id<n){\\n                if(s[id]-\\'a\\'!=i){\\n                     id+=1;\\n                     continue;\\n                }\\n                int val=i;\\n                int len=0;\\n                while(id<s.size()){\\n                    int r=(val%26);\\n                    if(s[id]-\\'a\\'!=r) break;\\n                    else{\\n                        id+=1;\\n                        len+=1;\\n                        val+=1;\\n                    }\\n\\n                }\\n                \\n                mx=max(mx,len);\\n            }\\n            \\n            ans+=mx;\\n        }\\n\\n               return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851564,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n public int findSubstringInWraproundString(String s) {\\n    int [] res = new int[26];\\n    int l = 0;\\n    for(int i = 0 ;i<s.length();i++){\\n    if(i>0 &&((s.charAt(i-1)+1)==s.charAt(i)||s.charAt(i-1)==s.charAt(i)+25))\\n        l++;\\n        else\\n        l = 1;\\n        res[s.charAt(i)-\\'a\\'] = Math.max(res[s.charAt(i)-\\'a\\'],l);\\n        }\\n        return Arrays.stream(res).sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n public int findSubstringInWraproundString(String s) {\\n    int [] res = new int[26];\\n    int l = 0;\\n    for(int i = 0 ;i<s.length();i++){\\n    if(i>0 &&((s.charAt(i-1)+1)==s.charAt(i)||s.charAt(i-1)==s.charAt(i)+25))\\n        l++;\\n        else\\n        l = 1;\\n        res[s.charAt(i)-\\'a\\'] = Math.max(res[s.charAt(i)-\\'a\\'],l);\\n        }\\n        return Arrays.stream(res).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848873,
                "title": "sliding-window-simple",
                "content": "what makes this problem tough?\\neach subsequence has to unique \\n\\nlet\\'s first just try to calculate all possible subsequence with given properties \\nso lets say we found two substrings which is ending at \\'c\\' \\n\"abc\"  & \"yzabc\"  so here what we can see is larger substring can be devided in to substrings=> yz, abc,.... and so on .. so here we can see we can genrate allpossible substrigs which also contains all substrings of samller (abc) substring\\n\\nso if any substring ends at certain character and after some time we encounter larger substring ending at same char then we can just simply discard previous substring and can move on with larger substring eacuse larger substring will always cover smaller one.\\n\\nat the end just return sum of all\\n\\n```\\n\\n```\\n   UPVOTE IF FIND THIS HELPFULL\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        vector<int> v(26,0);\\n        \\n        int l=0;\\n        int r=0;\\n        \\n        int n=s.size();\\n        r=1;\\n        v[s[0]-\\'a\\']=1;\\n        \\n        while(r<n)\\n        {\\n            if(s[r]==\\'a\\')\\n            {\\n                if(s[r-1]==\\'z\\')\\n                {\\n                    v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }else\\n                {\\n                    l=r;\\n                     v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }\\n                \\n            }else\\n            {\\n                if(s[r-1]==s[r]-1)\\n                {\\n                    v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }else\\n                {\\n                    l=r;\\n                     v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }\\n                \\n            }\\n            \\n            r++;\\n        }\\n        \\n        \\n        int ans=0;\\n        for(auto i: v) ans+=i;\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        vector<int> v(26,0);\\n        \\n        int l=0;\\n        int r=0;\\n        \\n        int n=s.size();\\n        r=1;\\n        v[s[0]-\\'a\\']=1;\\n        \\n        while(r<n)\\n        {\\n            if(s[r]==\\'a\\')\\n            {\\n                if(s[r-1]==\\'z\\')\\n                {\\n                    v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }else\\n                {\\n                    l=r;\\n                     v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }\\n                \\n            }else\\n            {\\n                if(s[r-1]==s[r]-1)\\n                {\\n                    v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }else\\n                {\\n                    l=r;\\n                     v[s[r]-\\'a\\']=max(v[s[r]-\\'a\\'], r-l+1);\\n                }\\n                \\n            }\\n            \\n            r++;\\n        }\\n        \\n        \\n        int ans=0;\\n        for(auto i: v) ans+=i;\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847767,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```dp[i]``` is max length of substring whose end is ```i```, where ```i``` is from ```[a-z]```.\\n```cur``` is a length of window where letter are consecutive alphabetical order.\\nif current letter and previous letter are consecutive alphabetical order, cur += 1.\\nif not, cur = 1.\\nand update ```dp[current letter] = max(dp[current letter], cur)```\\n\\ntc is O(n), sc is O(26)\\n### python\\n\\n```python\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        dp = [0] * 26\\n        dp[ord(s[0]) - ord(\\'a\\')] = 1\\n        cur = 1\\n        for i in range(1, len(s)):\\n            if (ord(s[i]) - ord(s[i-1]) + 26) % 26 == 1: cur += 1\\n            else: cur = 1\\n            dp[ord(s[i]) - ord(\\'a\\')] = dp[ord(s[i]) - ord(\\'a\\')] if dp[ord(s[i]) - ord(\\'a\\')] > cur else cur\\n        return sum(dp)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int dp[26] {0};\\n        int cur = 1;\\n        dp[s[0]-\\'a\\'] = 1;\\n        for (int i = 1; i < s.size(); i+=1) {\\n            if ((s[i] - s[i-1] + 26) % 26 == 1) cur += 1;\\n            else cur = 1;\\n            dp[s[i]-\\'a\\'] = dp[s[i]-\\'a\\'] > cur ? dp[s[i]-\\'a\\']: cur;\\n        }\\n        return accumulate(dp, dp+26, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```i```\n```i```\n```[a-z]```\n```cur```\n```dp[current letter] = max(dp[current letter], cur)```\n```python\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        dp = [0] * 26\\n        dp[ord(s[0]) - ord(\\'a\\')] = 1\\n        cur = 1\\n        for i in range(1, len(s)):\\n            if (ord(s[i]) - ord(s[i-1]) + 26) % 26 == 1: cur += 1\\n            else: cur = 1\\n            dp[ord(s[i]) - ord(\\'a\\')] = dp[ord(s[i]) - ord(\\'a\\')] if dp[ord(s[i]) - ord(\\'a\\')] > cur else cur\\n        return sum(dp)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int dp[26] {0};\\n        int cur = 1;\\n        dp[s[0]-\\'a\\'] = 1;\\n        for (int i = 1; i < s.size(); i+=1) {\\n            if ((s[i] - s[i-1] + 26) % 26 == 1) cur += 1;\\n            else cur = 1;\\n            dp[s[i]-\\'a\\'] = dp[s[i]-\\'a\\'] > cur ? dp[s[i]-\\'a\\']: cur;\\n        }\\n        return accumulate(dp, dp+26, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832377,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] list = new int[26];\\n        int count = 1;\\n        \\n        char[] arr = s.toCharArray();\\n        for (int i = 0;i < arr.length; i++){\\n            if (i > 0 && (arr[i] - arr[i-1]+26)%26==1) count++;\\n            else count = 1;\\n            list[arr[i]-\\'a\\'] = Math.max(list[arr[i]-\\'a\\'],count);\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < list.length;j++){\\n            sum += list[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] list = new int[26];\\n        int count = 1;\\n        \\n        char[] arr = s.toCharArray();\\n        for (int i = 0;i < arr.length; i++){\\n            if (i > 0 && (arr[i] - arr[i-1]+26)%26==1) count++;\\n            else count = 1;\\n            list[arr[i]-\\'a\\'] = Math.max(list[arr[i]-\\'a\\'],count);\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < list.length;j++){\\n            sum += list[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826123,
                "title": "o-n-time-one-pass-python-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        s += \",\"\\n        res = 0\\n        dp = [0] * 26\\n        count = 1\\n        for i in range(len(s)-1):\\n            if (s[i]==\\'z\\' and s[i+1]==\\'a\\') or (ord(s[i]) == ord(s[i+1])-1):\\n                count += 1\\n            else:\\n                count = 1\\n            res += max((count-dp[ord(s[i])-ord(\\'a\\')]),0)\\n            dp[ord(s[i])-ord(\\'a\\')] = max(dp[ord(s[i])-ord(\\'a\\')], count)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        s += \",\"\\n        res = 0\\n        dp = [0] * 26\\n        count = 1\\n        for i in range(len(s)-1):\\n            if (s[i]==\\'z\\' and s[i+1]==\\'a\\') or (ord(s[i]) == ord(s[i+1])-1):\\n                count += 1\\n            else:\\n                count = 1\\n            res += max((count-dp[ord(s[i])-ord(\\'a\\')]),0)\\n            dp[ord(s[i])-ord(\\'a\\')] = max(dp[ord(s[i])-ord(\\'a\\')], count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810935,
                "title": "easy-java-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] list = new int[26];\\n        int count = 1;\\n        \\n        char[] arr = s.toCharArray();\\n        for (int i = 0;i < arr.length; i++){\\n            if (i > 0 && (arr[i] - arr[i-1]+26)%26==1) count++;\\n            else count = 1;\\n            list[arr[i]-\\'a\\'] = Math.max(list[arr[i]-\\'a\\'],count);\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < list.length;j++){\\n            sum += list[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] list = new int[26];\\n        int count = 1;\\n        \\n        char[] arr = s.toCharArray();\\n        for (int i = 0;i < arr.length; i++){\\n            if (i > 0 && (arr[i] - arr[i-1]+26)%26==1) count++;\\n            else count = 1;\\n            list[arr[i]-\\'a\\'] = Math.max(list[arr[i]-\\'a\\'],count);\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < list.length;j++){\\n            sum += list[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624663,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findSubstringInWraproundString(s: String): Int = {\\n      val base = \"abcdefghijklmnopqrstuvwxyz\"\\n      val count = Array.fill(26)(0)\\n      var maxLength = 0\\n      for (i <- s.indices) {\\n        if (i > 0 && (s(i-1)+1) % 26 == s(i) % 26) maxLength += 1\\n        else maxLength = 1\\n        val index = s(i) - \\'a\\'\\n        count(index) = math.max(count(index), maxLength)\\n      }\\n      count.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findSubstringInWraproundString(s: String): Int = {\\n      val base = \"abcdefghijklmnopqrstuvwxyz\"\\n      val count = Array.fill(26)(0)\\n      var maxLength = 0\\n      for (i <- s.indices) {\\n        if (i > 0 && (s(i-1)+1) % 26 == s(i) % 26) maxLength += 1\\n        else maxLength = 1\\n        val index = s(i) - \\'a\\'\\n        count(index) = math.max(count(index), maxLength)\\n      }\\n      count.sum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3429578,
                "title": "concise-c-and-python-solution-using-dp",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        vector<int>maxs(26, 0);\\n        int cnt = 1, ans = 0;\\n        for(int i = 1; i < s.length(); i++){\\n            if((s[i] - s[i-1] == 1) || (s[i] == \\'a\\' && s[i-1] ==\\'z\\')) cnt += 1;\\n            else cnt = 1;\\n            ans += max(0, cnt-maxs[s[i]-\\'a\\']);\\n            maxs[s[i]-\\'a\\'] = max(maxs[s[i]-\\'a\\'], cnt);\\n        }\\n        if(maxs[s[0]-\\'a\\'] < 1) ans++;\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Python Solution**\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        maxs = [0] * 26\\n        cnt, ans = 1, 0\\n        for i in range(1, len(s)):\\n            if (ord(s[i]) - ord(s[i-1]) == 1) or (s[i] == \\'a\\' and s[i-1] == \\'z\\'):\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            ans += max(0, cnt - maxs[ord(s[i]) - ord(\\'a\\')])\\n            maxs[ord(s[i]) - ord(\\'a\\')] = max(maxs[ord(s[i]) - ord(\\'a\\')], cnt)\\n        if maxs[ord(s[0]) - ord(\\'a\\')] < 1:\\n            ans += 1\\n        return ans\\n```\\n\\n****",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        vector<int>maxs(26, 0);\\n        int cnt = 1, ans = 0;\\n        for(int i = 1; i < s.length(); i++){\\n            if((s[i] - s[i-1] == 1) || (s[i] == \\'a\\' && s[i-1] ==\\'z\\')) cnt += 1;\\n            else cnt = 1;\\n            ans += max(0, cnt-maxs[s[i]-\\'a\\']);\\n            maxs[s[i]-\\'a\\'] = max(maxs[s[i]-\\'a\\'], cnt);\\n        }\\n        if(maxs[s[0]-\\'a\\'] < 1) ans++;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        maxs = [0] * 26\\n        cnt, ans = 1, 0\\n        for i in range(1, len(s)):\\n            if (ord(s[i]) - ord(s[i-1]) == 1) or (s[i] == \\'a\\' and s[i-1] == \\'z\\'):\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            ans += max(0, cnt - maxs[ord(s[i]) - ord(\\'a\\')])\\n            maxs[ord(s[i]) - ord(\\'a\\')] = max(maxs[ord(s[i]) - ord(\\'a\\')], cnt)\\n        if maxs[ord(s[0]) - ord(\\'a\\')] < 1:\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420707,
                "title": "c-o-n-sln-with-comments",
                "content": "```\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        map<char, int> m;\\n        // find max length of consecutive string starting with each letter\\n        for (int i = 0, n = size(s); i < n; ++i) {\\n            int j = i;\\n            while (i + 1 < n && s[i + 1] - s[i] == 1 || s[i] == \\'z\\' && s[i + 1] == \\'a\\') {\\n                ++i;\\n            }\\n            int l = i - j + 1;\\n            m[s[j]] = max(m[s[j]], l);\\n        }\\n        // update maximums \\n        for (const auto[ch, l]: m) {\\n            for (int i = 1; i <= min(26, l - 1); ++i) {\\n                char c = (ch -\\'a\\' + i) % 26 + \\'a\\';\\n                m[c] = max(m[c], l - i);\\n            }\\n        }\\n        // now ready to sum\\n        return accumulate(cbegin(m), cend(m), 0, [](int sum, auto p) { return sum + p.second; });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        map<char, int> m;\\n        // find max length of consecutive string starting with each letter\\n        for (int i = 0, n = size(s); i < n; ++i) {\\n            int j = i;\\n            while (i + 1 < n && s[i + 1] - s[i] == 1 || s[i] == \\'z\\' && s[i + 1] == \\'a\\') {\\n                ++i;\\n            }\\n            int l = i - j + 1;\\n            m[s[j]] = max(m[s[j]], l);\\n        }\\n        // update maximums \\n        for (const auto[ch, l]: m) {\\n            for (int i = 1; i <= min(26, l - 1); ++i) {\\n                char c = (ch -\\'a\\' + i) % 26 + \\'a\\';\\n                m[c] = max(m[c], l - i);\\n            }\\n        }\\n        // now ready to sum\\n        return accumulate(cbegin(m), cend(m), 0, [](int sum, auto p) { return sum + p.second; });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398761,
                "title": "java-simple-method-94-faster-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] list = new int[26];\\n        int count = 1;\\n        \\n        char[] arr = s.toCharArray();\\n        for (int i = 0;i < arr.length; i++){\\n            if (i > 0 && (arr[i] - arr[i-1]+26)%26==1) count++;\\n            else count = 1;\\n            list[arr[i]-\\'a\\'] = Math.max(list[arr[i]-\\'a\\'],count);\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < list.length;j++){\\n            sum += list[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] list = new int[26];\\n        int count = 1;\\n        \\n        char[] arr = s.toCharArray();\\n        for (int i = 0;i < arr.length; i++){\\n            if (i > 0 && (arr[i] - arr[i-1]+26)%26==1) count++;\\n            else count = 1;\\n            list[arr[i]-\\'a\\'] = Math.max(list[arr[i]-\\'a\\'],count);\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < list.length;j++){\\n            sum += list[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378783,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int n = s.size() ;\\n        vector<int>alpha(26) ;\\n        int maxLength = 1 ;\\n        for(int i = 0; i < n; i++){\\n            if(i > 0 && (s[i-1] -\\'a\\' + 1) % 26 == (s[i] -\\'a\\') )\\n                maxLength++ ;\\n            else\\n                maxLength = 1 ;\\n            alpha[s[i] -\\'a\\'] = max(alpha[s[i] -\\'a\\'], maxLength) ;\\n        }\\n        \\n        return accumulate(alpha.begin(), alpha.end(), 0) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int n = s.size() ;\\n        vector<int>alpha(26) ;\\n        int maxLength = 1 ;\\n        for(int i = 0; i < n; i++){\\n            if(i > 0 && (s[i-1] -\\'a\\' + 1) % 26 == (s[i] -\\'a\\') )\\n                maxLength++ ;\\n            else\\n                maxLength = 1 ;\\n            alpha[s[i] -\\'a\\'] = max(alpha[s[i] -\\'a\\'], maxLength) ;\\n        }\\n        \\n        return accumulate(alpha.begin(), alpha.end(), 0) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370367,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        vector<long long> mxAlpha(26);\\n        int n = s.length();\\n        long long ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int st = i, len=0;\\n            char ch = s[i];\\n            while(i<n && s[i]==ch){\\n                i++;\\n                len++;\\n                if(ch==\\'z\\') ch = \\'a\\';\\n                else ch++;\\n            }\\n            st = s[st]-\\'a\\';\\n            bool flag = 1;\\n            for(int j = st;len-- && (flag || j!=st);j = (j+1)%26){\\n                \\n                flag = 0;\\n                if(len+1>mxAlpha[j]){\\n                    ans+=len+1;\\n                    ans -= mxAlpha[j];\\n                    mxAlpha[j] = len+1;\\n                }   \\n            }     \\n            --i;\\n        }\\n        return ans;    \\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        table = {c:value for c, value in zip(\"abcdefghijklmnopqrstuvwxyz\", \"bcdefghijklmnopqrstuvwxyza\")}\\n        first, cnt = s[0], 1\\n        _next = table[first]\\n        record = []\\n        for c in s[1:]:\\n            if c==_next:\\n                cnt += 1\\n            else:\\n                record.append((cnt, first))\\n                first, cnt = c, 1\\n            _next = table[c]\\n        record.append((cnt, first))\\n        max_length = max(cnt for cnt, c in record)\\n        min_bound = max(max_length-26, 0)\\n        result = min_bound*26\\n        dp = {i:set() for i in range(max_length, min_bound, -1)}\\n        indics = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"\\n        for cnt, c in record:\\n            if cnt>min_bound:\\n                idx = ord(c)-97\\n                for l, i in enumerate(range(cnt, min_bound, -1), 1):\\n                    dp[i].update(indics[idx:idx+l])\\n        return result+sum(len(values) for values in dp.values())\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        char[] str = s.toCharArray();\\n        int n = str.length;\\n        int ans = 0;\\n        int len = 1;\\n        int[] max = new int[256];\\n        max[str[0]] = 1;\\n        for(int i = 1; i < n; i++){\\n            char cur = str[i];\\n            char pre = str[i - 1];\\n            if((cur == \\'a\\' && pre == \\'z\\') || cur == pre + 1){\\n                len++;\\n            }else{\\n                len = 1;\\n            }\\n            max[cur] = Math.max(max[cur],len);\\n        }\\n        for(int i = 0; i < max.length; i++){\\n            ans += max[i];\\n        }\\n        return ans;\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        vector<long long> mxAlpha(26);\\n        int n = s.length();\\n        long long ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int st = i, len=0;\\n            char ch = s[i];\\n            while(i<n && s[i]==ch){\\n                i++;\\n                len++;\\n                if(ch==\\'z\\') ch = \\'a\\';\\n                else ch++;\\n            }\\n            st = s[st]-\\'a\\';\\n            bool flag = 1;\\n            for(int j = st;len-- && (flag || j!=st);j = (j+1)%26){\\n                \\n                flag = 0;\\n                if(len+1>mxAlpha[j]){\\n                    ans+=len+1;\\n                    ans -= mxAlpha[j];\\n                    mxAlpha[j] = len+1;\\n                }   \\n            }     \\n            --i;\\n        }\\n        return ans;    \\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n        table = {c:value for c, value in zip(\"abcdefghijklmnopqrstuvwxyz\", \"bcdefghijklmnopqrstuvwxyza\")}\\n        first, cnt = s[0], 1\\n        _next = table[first]\\n        record = []\\n        for c in s[1:]:\\n            if c==_next:\\n                cnt += 1\\n            else:\\n                record.append((cnt, first))\\n                first, cnt = c, 1\\n            _next = table[c]\\n        record.append((cnt, first))\\n        max_length = max(cnt for cnt, c in record)\\n        min_bound = max(max_length-26, 0)\\n        result = min_bound*26\\n        dp = {i:set() for i in range(max_length, min_bound, -1)}\\n        indics = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"\\n        for cnt, c in record:\\n            if cnt>min_bound:\\n                idx = ord(c)-97\\n                for l, i in enumerate(range(cnt, min_bound, -1), 1):\\n                    dp[i].update(indics[idx:idx+l])\\n        return result+sum(len(values) for values in dp.values())\\n```\n```Java []\\nclass Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        char[] str = s.toCharArray();\\n        int n = str.length;\\n        int ans = 0;\\n        int len = 1;\\n        int[] max = new int[256];\\n        max[str[0]] = 1;\\n        for(int i = 1; i < n; i++){\\n            char cur = str[i];\\n            char pre = str[i - 1];\\n            if((cur == \\'a\\' && pre == \\'z\\') || cur == pre + 1){\\n                len++;\\n            }else{\\n                len = 1;\\n            }\\n            max[cur] = Math.max(max[cur],len);\\n        }\\n        for(int i = 0; i < max.length; i++){\\n            ans += max[i];\\n        }\\n        return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329852,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int findSubstringInWraproundString(String s) {\\n        char[] arr = s.toCharArray();\\n        int[] counts = new int[26];\\n        int maxLength = 1;\\n        counts[arr[0] - \\'a\\'] = 1;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (isValid(arr[i - 1], arr[i])) maxLength += 1;\\n            else maxLength = 1;\\n            counts[arr[i] - \\'a\\'] = Math.max(maxLength, counts[arr[i] - \\'a\\']);\\n        }\\n        int total = 0;\\n        for (int c : counts) total += c;\\n        return total;\\n    }\\n\\n    private boolean isValid(char first, char second) {\\n        return (first == \\'z\\' && second == \\'a\\') ||\\n                (second - first) == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findSubstringInWraproundString(String s) {\\n        char[] arr = s.toCharArray();\\n        int[] counts = new int[26];\\n        int maxLength = 1;\\n        counts[arr[0] - \\'a\\'] = 1;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (isValid(arr[i - 1], arr[i])) maxLength += 1;\\n            else maxLength = 1;\\n            counts[arr[i] - \\'a\\'] = Math.max(maxLength, counts[arr[i] - \\'a\\']);\\n        }\\n        int total = 0;\\n        for (int c : counts) total += c;\\n        return total;\\n    }\\n\\n    private boolean isValid(char first, char second) {\\n        return (first == \\'z\\' && second == \\'a\\') ||\\n                (second - first) == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310181,
                "title": "first-time-i-beat-100-runtime-0-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindSubstringInWraproundString(string s) {\\n        int[] count = new int[26];\\n        int maxLength = 0;\\n        int result = 0;\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (i > 0 && (s[i] - s[i-1] == 1 || s[i-1] - s[i] == 25))\\n                maxLength++;\\n            else \\n                maxLength = 1;\\n            \\n            count[s[i]-\\'a\\'] = Math.Max(count[s[i]-\\'a\\'], maxLength);\\n        }\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            result += count[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindSubstringInWraproundString(string s) {\\n        int[] count = new int[26];\\n        int maxLength = 0;\\n        int result = 0;\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (i > 0 && (s[i] - s[i-1] == 1 || s[i-1] - s[i] == 25))\\n                maxLength++;\\n            else \\n                maxLength = 1;\\n            \\n            count[s[i]-\\'a\\'] = Math.Max(count[s[i]-\\'a\\'], maxLength);\\n        }\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            result += count[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281420,
                "title": "c-solution-from-dp-table-tle-7ms-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int ans=0;\\n        // int mask=0;\\n        // for(int i=0;i<s.size();i++){\\n        //     dp[i][i]=\\'1\\';\\n        //     if(!(mask&(1<<(s[i]-\\'a\\')))) ans++;\\n        //     mask=mask|(1<<s[i]-\\'a\\');\\n        // }\\n        // cout<<ans;\\n        // for(int col=1;col<s.size();col++){\\n        //     int j=col;\\n        //     int arr[26]={};\\n        //     for(int i=0;j<s.size();j++,i++){\\n        //         if((s[i]-\\'a\\'+1)%26 == s[i+1]-\\'a\\'){\\n        //             if(i+1==j){\\n        //                 dp[i][j]=\\'1\\';\\n        //                 if(!(arr[s[i]-\\'a\\']&(1<<(s[j]-\\'a\\')))){\\n        //                     // cout<<i<<\" \"<<j<<\" \"<<1;\\n        //                     ans++;\\n        //                 }\\n        //                 arr[s[i]-\\'a\\']=arr[s[i]-\\'a\\']|(1<<(s[j]-\\'a\\'));\\n        //             }\\n        //             else if(dp[i+1][j]==\\'1\\'){\\n        //                 dp[i][j]=\\'1\\';\\n        //                 if(!(arr[s[i]-\\'a\\']&(1<<(s[j]-\\'a\\')))){\\n        //                     // cout<<i<<\" \"<<j<<\" \"<<2;\\n        //                     ans++;\\n        //                 }\\n        //                 arr[s[i]-\\'a\\']=arr[s[i]-\\'a\\']|(1<<(s[j]-\\'a\\'));\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        int arr[26]={};\\n        for(int i=0;i<s.size();i++){\\n            int j=i+1;\\n            while(j<s.size() && s[j]-\\'a\\'==(s[j-1]-\\'a\\'+1)%26){\\n                j++;\\n            }\\n            while(i<j){\\n                if(arr[s[i]-\\'a\\']<j-i){\\n                    ans+=j-i-arr[s[i]-\\'a\\'];\\n                    arr[s[i]-\\'a\\']=j-i;\\n                    i++;\\n                }\\n                else{\\n                    i+=min(j-i,arr[s[i]-\\'a\\']);\\n                }\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int ans=0;\\n        // int mask=0;\\n        // for(int i=0;i<s.size();i++){\\n        //     dp[i][i]=\\'1\\';\\n        //     if(!(mask&(1<<(s[i]-\\'a\\')))) ans++;\\n        //     mask=mask|(1<<s[i]-\\'a\\');\\n        // }\\n        // cout<<ans;\\n        // for(int col=1;col<s.size();col++){\\n        //     int j=col;\\n        //     int arr[26]={};\\n        //     for(int i=0;j<s.size();j++,i++){\\n        //         if((s[i]-\\'a\\'+1)%26 == s[i+1]-\\'a\\'){\\n        //             if(i+1==j){\\n        //                 dp[i][j]=\\'1\\';\\n        //                 if(!(arr[s[i]-\\'a\\']&(1<<(s[j]-\\'a\\')))){\\n        //                     // cout<<i<<\" \"<<j<<\" \"<<1;\\n        //                     ans++;\\n        //                 }\\n        //                 arr[s[i]-\\'a\\']=arr[s[i]-\\'a\\']|(1<<(s[j]-\\'a\\'));\\n        //             }\\n        //             else if(dp[i+1][j]==\\'1\\'){\\n        //                 dp[i][j]=\\'1\\';\\n        //                 if(!(arr[s[i]-\\'a\\']&(1<<(s[j]-\\'a\\')))){\\n        //                     // cout<<i<<\" \"<<j<<\" \"<<2;\\n        //                     ans++;\\n        //                 }\\n        //                 arr[s[i]-\\'a\\']=arr[s[i]-\\'a\\']|(1<<(s[j]-\\'a\\'));\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        int arr[26]={};\\n        for(int i=0;i<s.size();i++){\\n            int j=i+1;\\n            while(j<s.size() && s[j]-\\'a\\'==(s[j-1]-\\'a\\'+1)%26){\\n                j++;\\n            }\\n            while(i<j){\\n                if(arr[s[i]-\\'a\\']<j-i){\\n                    ans+=j-i-arr[s[i]-\\'a\\'];\\n                    arr[s[i]-\\'a\\']=j-i;\\n                    i++;\\n                }\\n                else{\\n                    i+=min(j-i,arr[s[i]-\\'a\\']);\\n                }\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3248466,
                "title": "single-pass",
                "content": "# Intuition\\nCount the number of substrings ending with each letter.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_substring_in_wrapround_string(s: String) -> i32 {\\n        let mut res: std::collections::HashMap<u8,i32> = s.bytes().map(|b| (b,1)).collect();\\n        let mut l = 1;\\n        for (i, j) in s.bytes().zip(s.bytes().skip(1)) {\\n            l = if i == j -1 || i == j + 25 {l + 1} else {1};\\n            res.insert(j,res[&j].max(l));\\n        }\\n        return res.values().sum()\\n    }\\n}\\n```\\nconverted from Lee215\\'s python:\\n```\\ndef findSubstringInWraproundString(self, p):\\n        res = {i: 1 for i in p}\\n        l = 1\\n        for i, j in zip(p, p[1:]):\\n            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1\\n            res[j] = max(res[j], l)\\n        return sum(res.values())\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_substring_in_wrapround_string(s: String) -> i32 {\\n        let mut res: std::collections::HashMap<u8,i32> = s.bytes().map(|b| (b,1)).collect();\\n        let mut l = 1;\\n        for (i, j) in s.bytes().zip(s.bytes().skip(1)) {\\n            l = if i == j -1 || i == j + 25 {l + 1} else {1};\\n            res.insert(j,res[&j].max(l));\\n        }\\n        return res.values().sum()\\n    }\\n}\\n```\n```\\ndef findSubstringInWraproundString(self, p):\\n        res = {i: 1 for i in p}\\n        l = 1\\n        for i, j in zip(p, p[1:]):\\n            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1\\n            res[j] = max(res[j], l)\\n        return sum(res.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3201019,
                "title": "sliding-window-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int l=0, result=0;\\n\\n        // length of the longest substring ending at each character\\n        vector<int> len(26, 0);\\n\\n        for(int i=0; i<s.size(); i++) {\\n            if(i!=l and s[i]-s[i-1]!=1 and s[i]-s[i-1]!=-25) {\\n                l = i;\\n            }\\n\\n            result += (i-l+1);\\n\\n            // remove the duplicate substrings\\n            result -= min(i-l+1, len[s[i]-\\'a\\']);\\n\\n            len[s[i]-\\'a\\'] = max(len[s[i]-\\'a\\'], i-l+1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string s) {\\n        int l=0, result=0;\\n\\n        // length of the longest substring ending at each character\\n        vector<int> len(26, 0);\\n\\n        for(int i=0; i<s.size(); i++) {\\n            if(i!=l and s[i]-s[i-1]!=1 and s[i]-s[i-1]!=-25) {\\n                l = i;\\n            }\\n\\n            result += (i-l+1);\\n\\n            // remove the duplicate substrings\\n            result -= min(i-l+1, len[s[i]-\\'a\\']);\\n\\n            len[s[i]-\\'a\\'] = max(len[s[i]-\\'a\\'], i-l+1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192755,
                "title": "python-concise-sliding-window-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n\\n\\n        left=0\\n        d=defaultdict(int)\\n\\n        for right,ch in enumerate(s):\\n            if right==0:\\n                d[ch]=1\\n                prev=ch\\n                continue\\n\\n            if not(ord(ch)-ord(prev)==1) and  not(ord(prev)-ord(ch))==25:\\n                left=right\\n            \\n\\n            d[ch]=max(d[ch],right-left+1)\\n            \\n            prev=ch\\n    \\n        return sum(d.values())\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s: str) -> int:\\n\\n\\n        left=0\\n        d=defaultdict(int)\\n\\n        for right,ch in enumerate(s):\\n            if right==0:\\n                d[ch]=1\\n                prev=ch\\n                continue\\n\\n            if not(ord(ch)-ord(prev)==1) and  not(ord(prev)-ord(ch))==25:\\n                left=right\\n            \\n\\n            d[ch]=max(d[ch],right-left+1)\\n            \\n            prev=ch\\n    \\n        return sum(d.values())\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188339,
                "title": "easiest-c-o-n-solution-no-dp-required",
                "content": "So basically we will check for what is the maximum length substring I can find that starts with \\'a\\', \\'b\\', \\'c\\' ..... \\'z\\', and then just sum it up.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int Solve(string &s, char ch)\\n    {\\n        // maximum length starting from ch\\n        int Ans = 0 ;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n                int temp = 1; \\n\\t\\t\\t\\t// checking whether the next character is in sequence or not. i.e x -> y -> z -> a -> b ........ \\n                while(i+1<s.size() && (s[i+1]-\\'a\\')==(s[i]-\\'a\\'+1)%26){\\n                    i++;\\n                    temp++;\\n                }\\n                Ans = max(Ans,temp) ;\\n            }\\n        }\\n        \\n        return Ans ;\\n    }\\n    \\n    int findSubstringInWraproundString(string s) {\\n        \\n        int Ans = 0 ;\\n        for(int i=0 ;i<26; i++){\\n            Ans += Solve(s,\\'a\\'+i) ;\\n        }\\n        return Ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Solve(string &s, char ch)\\n    {\\n        // maximum length starting from ch\\n        int Ans = 0 ;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n                int temp = 1; \\n\\t\\t\\t\\t// checking whether the next character is in sequence or not. i.e x -> y -> z -> a -> b ........ \\n                while(i+1<s.size() && (s[i+1]-\\'a\\')==(s[i]-\\'a\\'+1)%26){\\n                    i++;\\n                    temp++;\\n                }\\n                Ans = max(Ans,temp) ;\\n            }\\n        }\\n        \\n        return Ans ;\\n    }\\n    \\n    int findSubstringInWraproundString(string s) {\\n        \\n        int Ans = 0 ;\\n        for(int i=0 ;i<26; i++){\\n            Ans += Solve(s,\\'a\\'+i) ;\\n        }\\n        return Ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135949,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) \\n    {\\n        int cont=1;\\n        int ans=0;\\n        int prev=-5;\\n        vector<int>dp(26,0);\\n        for (int i=0;i<p.size();i++)\\n        {\\n          int cur=p[i]-\\'a\\';\\n          if (cur==((prev+1)%26))\\n          {\\n              cont++;\\n          }\\n          else{\\n              cont=1;\\n          }\\n          ans+=max(cont-dp[cur],0);\\n          if (cont>dp[cur]) dp[cur]=cont;\\n          prev=cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) \\n    {\\n        int cont=1;\\n        int ans=0;\\n        int prev=-5;\\n        vector<int>dp(26,0);\\n        for (int i=0;i<p.size();i++)\\n        {\\n          int cur=p[i]-\\'a\\';\\n          if (cur==((prev+1)%26))\\n          {\\n              cont++;\\n          }\\n          else{\\n              cont=1;\\n          }\\n          ans+=max(cont-dp[cur],0);\\n          if (cont>dp[cur]) dp[cur]=cont;\\n          prev=cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018064,
                "title": "simple-golang-solution-beats-98-8",
                "content": "```\\nfunc findSubstringInWraproundString(p string) int {\\n    if len(p) == 0 {\\n        return 0\\n    }\\n    var tmp int\\n\\n    tmpSlice: = [26] int {}\\n\\n    for i: = 0;\\n    i < len(p); {\\n        index: = i + 1\\n        for index < len(p) && (p[index] == p[index - 1] + 1 || p[index] == p[index - 1] - 25) {\\n            index++\\n        }\\n        for j: = i;j < index;j++{\\n            id: = int(p[j]) - int(\\'a\\')\\n            tmpSlice[id] = int(math.Max(float64(tmpSlice[id]), float64(index - j)))\\n        }\\n        i = index\\n    }\\n\\n    for _, v: = range tmpSlice {\\n        tmp += v\\n    }\\n\\n    return tmp\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findSubstringInWraproundString(p string) int {\\n    if len(p) == 0 {\\n        return 0\\n    }\\n    var tmp int\\n\\n    tmpSlice: = [26] int {}\\n\\n    for i: = 0;\\n    i < len(p); {\\n        index: = i + 1\\n        for index < len(p) && (p[index] == p[index - 1] + 1 || p[index] == p[index - 1] - 25) {\\n            index++\\n        }\\n        for j: = i;j < index;j++{\\n            id: = int(p[j]) - int(\\'a\\')\\n            tmpSlice[id] = int(math.Max(float64(tmpSlice[id]), float64(index - j)))\\n        }\\n        i = index\\n    }\\n\\n    for _, v: = range tmpSlice {\\n        tmp += v\\n    }\\n\\n    return tmp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016417,
                "title": "rust-solution-using-dynamic-programing",
                "content": "# Intuition\\nThe substrings in this problem are decided by start character and length. So I should memorize the max length of substring for every character from \\'a\\' to \\'z\\'.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn find_substring_in_wrapround_string(p: String) -> i32 {\\n    let s = p.chars().into_iter().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let mut memo = vec![0;26];\\n\\n    let mut len = 1;\\n    let mut last = s[0];\\n    let mut start = 0;\\n    for i in 1..n {\\n      let c = s[i];\\n      if (last + 1) % 26 == c {\\n        len += 1;\\n      } else {\\n        let edge = n.min(start+len).min(start+26);\\n        for j in start..edge {\\n          let padding = j - start;\\n          let ti = (s[start] + padding) % 26;\\n          let real_len = len - padding;\\n          memo[ti] = memo[ti].max(real_len);\\n        }\\n        start = i;\\n        len = 1;\\n      }\\n      last = c;\\n    }\\n\\n    let edge = n.min(start+len).min(start+26);\\n    for j in start..edge {\\n      let padding = j - start;\\n      let ti = (s[start] + padding) % 26;\\n      let real_len = len - padding;\\n      memo[ti] = memo[ti].max(real_len);\\n    }\\n\\n    let mut result = 0usize;\\n    for v in memo {\\n      result += v;\\n    }\\n    result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn find_substring_in_wrapround_string(p: String) -> i32 {\\n    let s = p.chars().into_iter().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let mut memo = vec![0;26];\\n\\n    let mut len = 1;\\n    let mut last = s[0];\\n    let mut start = 0;\\n    for i in 1..n {\\n      let c = s[i];\\n      if (last + 1) % 26 == c {\\n        len += 1;\\n      } else {\\n        let edge = n.min(start+len).min(start+26);\\n        for j in start..edge {\\n          let padding = j - start;\\n          let ti = (s[start] + padding) % 26;\\n          let real_len = len - padding;\\n          memo[ti] = memo[ti].max(real_len);\\n        }\\n        start = i;\\n        len = 1;\\n      }\\n      last = c;\\n    }\\n\\n    let edge = n.min(start+len).min(start+26);\\n    for j in start..edge {\\n      let padding = j - start;\\n      let ti = (s[start] + padding) % 26;\\n      let real_len = len - padding;\\n      memo[ti] = memo[ti].max(real_len);\\n    }\\n\\n    let mut result = 0usize;\\n    for v in memo {\\n      result += v;\\n    }\\n    result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2925042,
                "title": "python-dp-bottom-up-solution",
                "content": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dp = [1] * len(p)\\n        res=0\\n        counter = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0, \\'d\\': 0, \\'e\\': 0, \\'f\\': 0, \\'g\\': 0, \\'h\\': 0, \\'i\\': 0, \\'j\\': 0, \\'k\\': 0, \\'l\\': 0\\n                    , \\'m\\': 0, \\'n\\': 0, \\'o\\': 0, \\'p\\': 0, \\'q\\': 0, \\'r\\': 0, \\'s\\': 0, \\'t\\': 0, \\'u\\': 0, \\'v\\': 0, \\'w\\': 0, \\'x\\': 0, \\'y\\': 0, \\'z\\': 0}\\n\\n        for i in range(1,len(p)):\\n            if ord(p[i]) - ord(p[i-1]) == 1 or p[i-1] == \\'z\\' and p[i] == \\'a\\':\\n                dp[i] += dp[i-1]\\n\\n        for i in range(len(dp)):\\n            res += max(0,dp[i]-counter[p[i]])\\n            counter[p[i]] = max(counter[p[i]],dp[i])\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dp = [1] * len(p)\\n        res=0\\n        counter = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0, \\'d\\': 0, \\'e\\': 0, \\'f\\': 0, \\'g\\': 0, \\'h\\': 0, \\'i\\': 0, \\'j\\': 0, \\'k\\': 0, \\'l\\': 0\\n                    , \\'m\\': 0, \\'n\\': 0, \\'o\\': 0, \\'p\\': 0, \\'q\\': 0, \\'r\\': 0, \\'s\\': 0, \\'t\\': 0, \\'u\\': 0, \\'v\\': 0, \\'w\\': 0, \\'x\\': 0, \\'y\\': 0, \\'z\\': 0}\\n\\n        for i in range(1,len(p)):\\n            if ord(p[i]) - ord(p[i-1]) == 1 or p[i-1] == \\'z\\' and p[i] == \\'a\\':\\n                dp[i] += dp[i-1]\\n\\n        for i in range(len(dp)):\\n            res += max(0,dp[i]-counter[p[i]])\\n            counter[p[i]] = max(counter[p[i]],dp[i])\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887493,
                "title": "python-o-n",
                "content": "# Intuition\\n- We need to check consequtive characters to have sequential values (by module 26).\\n- To maintain uniquiness we will be keeping track of longest substrings, that start at given value (first substring character defines the whole substring).\\n\\n# Approach\\nWe can tackle that as a DP problem. \\nLet\\'s consider substring \"abc\" - this substring implies 6 wraparound string substrings - \"abc\", \"ab\", \"a\", \"bc\", \"b\", \"c\" - thus for each starting character we will be looking for a longest substring of the wraparound string which starts at this character. \\nWe will also go backwards to get \"suffices\" subsrtings first - like in the example above - \"c\" and \"bc\".\\n\\n1. Initialize array ``dp`` of the length of the input string filled with ones - as long as every single character is a substring of the wraparound string.\\n2. Initialize array ``starts`` which will contain longest substrings starting with the character ``chr(starts[i])`` in the input string.\\n3. We will iterate characters of the input string backwards, and check if character at ``i`` has the previous value to the character at ``i+1``. At each iteration we update ``starts`` array with the information from the current character\\n4. As long as ``starts`` array contain longest substrings starting with given character, and every prefix of this string is also wraparound string substring, each item of this array contains the number of substrings starting from the given character. So we sum it up and return as the result.\\n\\n# Complexity\\n- Time complexity:\\nWe iterate over string once - $$O(n)$$\\n\\n- Space complexity:\\nWe have ``dp`` array of the string length, and starts array of the number of characters in the alphabet - 26, it\\'s a constant in this problem.\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        n = len(p)\\n        dp = [1] * n\\n        starts = [0] * 26\\n        for i in range(n-1, -1, -1):\\n            if i < n-1 and ord(p[i+1])-ord(\\'a\\') == (ord(p[i])-ord(\\'a\\') + 1) % 26:\\n                dp[i] = dp[i+1] + 1\\n            starts[ord(p[i]) - ord(\\'a\\')] = max(starts[ord(p[i]) - ord(\\'a\\')], dp[i])\\n        return sum(starts)\\n```\\n\\nMemory could be optimized to $$O(1)$$ as long as we only use previous step value.\\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        n = len(p)\\n        starts = [0] * 26\\n        dp = 1\\n        for i in range(n-1, -1, -1):\\n            if i < n-1 and ord(p[i+1])-ord(\\'a\\') == (ord(p[i])-ord(\\'a\\') + 1) % 26:\\n                dp += 1\\n            else:\\n                dp = 1\\n            starts[ord(p[i]) - ord(\\'a\\')] = max(starts[ord(p[i]) - ord(\\'a\\')], dp)\\n        return sum(starts)\\n```\\n\\n\\nShall you have questions or concerns - please comment, and upvote if you like it!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        n = len(p)\\n        dp = [1] * n\\n        starts = [0] * 26\\n        for i in range(n-1, -1, -1):\\n            if i < n-1 and ord(p[i+1])-ord(\\'a\\') == (ord(p[i])-ord(\\'a\\') + 1) % 26:\\n                dp[i] = dp[i+1] + 1\\n            starts[ord(p[i]) - ord(\\'a\\')] = max(starts[ord(p[i]) - ord(\\'a\\')], dp[i])\\n        return sum(starts)\\n```\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        n = len(p)\\n        starts = [0] * 26\\n        dp = 1\\n        for i in range(n-1, -1, -1):\\n            if i < n-1 and ord(p[i+1])-ord(\\'a\\') == (ord(p[i])-ord(\\'a\\') + 1) % 26:\\n                dp += 1\\n            else:\\n                dp = 1\\n            starts[ord(p[i]) - ord(\\'a\\')] = max(starts[ord(p[i]) - ord(\\'a\\')], dp)\\n        return sum(starts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862547,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s):\\n        n, dict1, count = len(s), {i:1 for i in s}, 1\\n\\n        for i in range(1,n):\\n            if (ord(s[i]) - ord(s[i-1]))%26 == 1:\\n                count += 1\\n            else:\\n                count = 1\\n\\n            dict1[s[i]] = max(dict1[s[i]],count)\\n\\n        return sum(dict1.values())\\n\\n            \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, s):\\n        n, dict1, count = len(s), {i:1 for i in s}, 1\\n\\n        for i in range(1,n):\\n            if (ord(s[i]) - ord(s[i-1]))%26 == 1:\\n                count += 1\\n            else:\\n                count = 1\\n\\n            dict1[s[i]] = max(dict1[s[i]],count)\\n\\n        return sum(dict1.values())\\n\\n            \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859061,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_substring_in_wrapround_string(p: String) -> i32 {\\n        let mut counts = vec![0; 26];\\n        let mut len = 1;\\n        let p = p.as_bytes();\\n        for (i, ch) in p.iter().enumerate() {\\n            let ch = *ch as i32;\\n            let v = if i > 0 { *p.get(i - 1).unwrap() as i32 } else { 0 };\\n\\n            if i > 0 && (ch - v == 1 || ch - v == -25) {\\n                len += 1;\\n            } else {\\n                len = 1;\\n            }\\n            let idx = ch as usize - \\'a\\' as usize;\\n            counts[idx] = counts[idx].max(len);\\n        }\\n        counts.iter().sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_substring_in_wrapround_string(p: String) -> i32 {\\n        let mut counts = vec![0; 26];\\n        let mut len = 1;\\n        let p = p.as_bytes();\\n        for (i, ch) in p.iter().enumerate() {\\n            let ch = *ch as i32;\\n            let v = if i > 0 { *p.get(i - 1).unwrap() as i32 } else { 0 };\\n\\n            if i > 0 && (ch - v == 1 || ch - v == -25) {\\n                len += 1;\\n            } else {\\n                len = 1;\\n            }\\n            let idx = ch as usize - \\'a\\' as usize;\\n            counts[idx] = counts[idx].max(len);\\n        }\\n        counts.iter().sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739180,
                "title": "fast-and-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        \\n        def index(s):\\n            return ord(s) - ord(\\'a\\')\\n        \\n        def is_subseq(pi, pj):\\n            idx, idx_next = index(pi), index(pj)\\n            return (idx_next - idx == 1) or (pi == \\'z\\' and pj == \\'a\\')\\n            \\n        n_substring = [0 for _ in range(26)]\\n        \\n        current_length = 1\\n        for i in reversed(range(len(p))):\\n            if i < len(p) - 1 and is_subseq(p[i], p[i + 1]):\\n                current_length += 1\\n            else:\\n                current_length = 1\\n            n_substring[index(p[i])] = max(n_substring[index(p[i])], current_length)\\n        return sum(n_substring)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        \\n        def index(s):\\n            return ord(s) - ord(\\'a\\')\\n        \\n        def is_subseq(pi, pj):\\n            idx, idx_next = index(pi), index(pj)\\n            return (idx_next - idx == 1) or (pi == \\'z\\' and pj == \\'a\\')\\n            \\n        n_substring = [0 for _ in range(26)]\\n        \\n        current_length = 1\\n        for i in reversed(range(len(p))):\\n            if i < len(p) - 1 and is_subseq(p[i], p[i + 1]):\\n                current_length += 1\\n            else:\\n                current_length = 1\\n            n_substring[index(p[i])] = max(n_substring[index(p[i])], current_length)\\n        return sum(n_substring)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736493,
                "title": "c-o-n-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        /*  \\n            Only sustrings with consecutive characters are valid\\n            For each character in the string store the length \\n            of the longest  valid substring it has been a part of \\n        */\\n        int n = p.size();\\n        int len = 1, ans = 1;\\n        \\n        int got[26] = {0};\\n        got[p[0] - \\'a\\'] = 1;\\n        \\n        for (int i=1; i<n; i++) {\\n            if (p[i] - p[i-1] == 1 || (p[i] == \\'a\\' && p[i-1] == \\'z\\')) len++;\\n            else len = 1;\\n            \\n            /*  \\n                If length of current substring with consecutive \\n                letters is greater than the past longest substring\\n                add all the subtrings that end with that letter\\n            */\\n            if (got[p[i]-\\'a\\'] <= len) ans+= (len - got[p[i]-\\'a\\']);\\n            // update the length of longest valid substring for the current character\\n            got[p[i] - \\'a\\'] = max(got[p[i] - \\'a\\'], len);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        /*  \\n            Only sustrings with consecutive characters are valid\\n            For each character in the string store the length \\n            of the longest  valid substring it has been a part of \\n        */\\n        int n = p.size();\\n        int len = 1, ans = 1;\\n        \\n        int got[26] = {0};\\n        got[p[0] - \\'a\\'] = 1;\\n        \\n        for (int i=1; i<n; i++) {\\n            if (p[i] - p[i-1] == 1 || (p[i] == \\'a\\' && p[i-1] == \\'z\\')) len++;\\n            else len = 1;\\n            \\n            /*  \\n                If length of current substring with consecutive \\n                letters is greater than the past longest substring\\n                add all the subtrings that end with that letter\\n            */\\n            if (got[p[i]-\\'a\\'] <= len) ans+= (len - got[p[i]-\\'a\\']);\\n            // update the length of longest valid substring for the current character\\n            got[p[i] - \\'a\\'] = max(got[p[i] - \\'a\\'], len);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672309,
                "title": "my-simple-c-dp-aproach-beats-99-05-submissions",
                "content": "**Hint:-** The main idea behind it is to find all maximum length of substring ending to \\'a\\' ,\\'b\\', \\'c\\' , .............. \\'y\\' ,\\'z\\' in main string p.  Suppose you get a string ending with \\'z\\' is \"wxyz\" then its cntribution to the answer will be \"wxyz\", \"xyz\", \"yz\", \"z\" , total 4==length of this substring and main interesting thing here is that it will cover all smaller substring which are ending with \\'z\\'  like \"xyz\", \"yz\", \"z\" .Find all 26 substring and sum the lenght of all substring to get final answer.\\n\\nfor example:  p=\"zabcghimno\"\\nmaximum lenght substring ending with \\'a\\' = \"za\" ,contribution in final ans=2\\nmaximum lenght substring ending with \\'b\\' = \"zab\" ,contribution in final ans=3\\nmaximum lenght substring ending with \\'c\\' = \"zabc\" ,contribution in final ans=4\\nmaximum lenght substring ending with \\'g\\' = \"g\"  ,contribution in final ans=1\\nmaximum lenght substring ending with \\'h\\' = \"gh\"  ,contribution in final ans=2\\nmaximum lenght substring ending with \\'i\\' = \"ghi\"  ,contribution in final ans=3\\nmaximum lenght substring ending with \\'m\\' = \"m\"  ,contribution in final ans=1\\nmaximum lenght substring ending with \\'n\\' = \"mn\"  ,contribution in final ans=2\\nmaximum lenght substring ending with \\'o\\' = \"mno\"  ,contribution in final ans=3\\nmaximum lenght substring ending with \\'z\\' = \"z\" ,contribution in final ans=1\\n\\nso final answer =2+3+4+1+2+3+1+2+3+1 =22;\\n\\t\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n=p.size();\\n        vector<int>v(26);\\n        int cnt=1;\\n        v[p[0]-\\'a\\']=1;\\n        for(int i=1;i<p.size();i++){\\n            if(p[i]-p[i-1]==1 or (p[i]==\\'a\\' and p[i-1]==\\'z\\')){\\n                cnt++;\\n            }\\n            else\\n                cnt=1;\\n                v[p[i]-\\'a\\']=max(cnt,v[p[i]-\\'a\\']);\\n        }\\n        int ans=0;\\n       for(int i=0;i<26;i++){\\n           ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        int n=p.size();\\n        vector<int>v(26);\\n        int cnt=1;\\n        v[p[0]-\\'a\\']=1;\\n        for(int i=1;i<p.size();i++){\\n            if(p[i]-p[i-1]==1 or (p[i]==\\'a\\' and p[i-1]==\\'z\\')){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2556620,
                "title": "c-easy-approach-solution",
                "content": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        unordered_map<char,int> m;\\n        int count=1;\\n        int start=-1;\\n        int n = p.size();\\n        vector<int> visited(n);\\n        for(int i=0;i<n-1;i++){\\n            if(p[i]+1==p[i+1]){\\n                if(start==-1) start=i;\\n                count++;\\n            }\\n            else if(p[i]==\\'z\\' && p[i+1]==\\'a\\'){\\n                    if(start==-1) start=i;\\n                count++;\\n            }\\n                    else{\\n                        \\n                        if(count>1){\\n                            visited[start]=1;\\n                            visited[i]=2;\\n                            count=1;\\n                            start=-1;\\n                        }\\n                         start=-1;\\n                        \\n                    }\\n        }\\n        int flag=0;\\n        if(n>1 && (p[n-2]+1==p[n-1] || (p[n-2]==\\'z\\' && p[n-1]==\\'a\\'))){\\n           visited[start]=1;\\n            visited[n-1]=2;\\n           // flag=2;\\n        }\\n         // please check condition also for last index\\n                    int k,indx;\\n                    for(int i=n-1;i>=0;i--){\\n                        cout<<visited[i]<<\" \";\\n                        if(visited[i]==1){\\n                            k = indx-i+1;\\n                            m[p[i]] = max(m[p[i]],k);\\n                            flag=0;\\n                            indx=-1;\\n                        }\\n                        else if(visited[i]==2){\\n                            m[p[i]] = max(m[p[i]],1);\\n                            flag=2;\\n                            indx = i;\\n                        }\\n                        else{\\n                            if(flag==2){\\n                                k = indx-i+1;\\n                            m[p[i]] = max(m[p[i]],k); \\n                            }\\n                            else{\\n                                 m[p[i]] = max(m[p[i]],1);\\n                            }\\n                        }\\n                    }\\n                    int ans=0;\\n                    for(auto j:m){\\n                        ans += j.second;\\n                    }\\n                    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        unordered_map<char,int> m;\\n        int count=1;\\n        int start=-1;\\n        int n = p.size();\\n        vector<int> visited(n);\\n        for(int i=0;i<n-1;i++){\\n            if(p[i]+1==p[i+1]){\\n                if(start==-1) start=i;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2509215,
                "title": "python-kandane-s-algorithm-o-n",
                "content": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        res = {c:1 for c in p}\\n        l = 1\\n        for i in range(len(p)-1):\\n            x, y = p[i], p[i+1]\\n            if (ord(y)-ord(x))%26 == 1:\\n                l += 1\\n                res[y] = max(res[y], l) \\n            else:\\n                l = 1\\n        return sum(res.values())\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        res = {c:1 for c in p}",
                "codeTag": "Java"
            },
            {
                "id": 2494073,
                "title": "python3-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef findSubstringInWraproundString(self, p: str) -> int:\\n\\t\\t\\tdic = defaultdict(lambda : 0)\\n\\t\\t\\tprev = 1\\n\\t\\t\\tdic[p[0]] = 1\\n\\n\\t\\t\\tfor i in range(1,len(p)):\\n\\t\\t\\t\\ttemp = 0\\n\\t\\t\\t\\tif (p[i] == \\'a\\' and p[i-1] == \\'z\\') or (ord(p[i]) - ord(p[i-1]) == 1):\\n\\t\\t\\t\\t\\ttemp = prev\\n\\t\\t\\t\\ttemp+=1\\n\\t\\t\\t\\tdic[p[i]] = max(dic[p[i]],temp)\\n\\t\\t\\t\\tprev = temp\\n\\t\\t\\treturn sum(dic.values())",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findSubstringInWraproundString(self, p: str) -> int:\\n\\t\\t\\tdic = defaultdict(lambda : 0)\\n\\t\\t\\tprev = 1\\n\\t\\t\\tdic[p[0]] = 1\\n\\n\\t\\t\\tfor i in range(1,len(p)):\\n\\t\\t\\t\\ttemp = 0\\n\\t\\t\\t\\tif (p[i] == \\'a\\' and p[i-1] == \\'z\\') or (ord(p[i]) - ord(p[i-1]) == 1):\\n\\t\\t\\t\\t\\ttemp = prev\\n\\t\\t\\t\\ttemp+=1\\n\\t\\t\\t\\tdic[p[i]] = max(dic[p[i]],temp)\\n\\t\\t\\t\\tprev = temp\\n\\t\\t\\treturn sum(dic.values())",
                "codeTag": "Java"
            },
            {
                "id": 2451404,
                "title": "c-easy-map",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int> mp;\\n    long long countwrap(string& s,int i){\\n        if(i>=s.size()) return 0; \\n        int j=i+1;\\n        int count=1;\\n        while(true){\\n            if(j<s.size()){\\n               if(s[j]<s[j-1]){\\n                   if(s[j]==97 && s[j-1]==122) count++;\\n                   else break;\\n               }\\n               else if(s[j-1]+1==s[j]) count++;\\n               else break;\\n            }\\n            else break;\\n            j++;\\n        }\\n        long long ans=0;\\n        int f=i;\\n        while(f<j){\\n            int s1=mp[s[f]];\\n            if(!(s1>=j-f)) ans+=(j-f)-s1;\\n            mp[s[f]]=max(j-f,mp[s[f]]);\\n            f++;\\n        }\\n        return ans+countwrap(s,j);\\n    }\\n    int findSubstringInWraproundString(string p) {\\n        return countwrap(p,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,int> mp;\\n    long long countwrap(string& s,int i){\\n        if(i>=s.size()) return 0; \\n        int j=i+1;\\n        int count=1;\\n        while(true){\\n            if(j<s.size()){\\n               if(s[j]<s[j-1]){\\n                   if(s[j]==97 && s[j-1]==122) count++;\\n                   else break;\\n               }\\n               else if(s[j-1]+1==s[j]) count++;\\n               else break;\\n            }\\n            else break;\\n            j++;\\n        }\\n        long long ans=0;\\n        int f=i;\\n        while(f<j){\\n            int s1=mp[s[f]];\\n            if(!(s1>=j-f)) ans+=(j-f)-s1;\\n            mp[s[f]]=max(j-f,mp[s[f]]);\\n            f++;\\n        }\\n        return ans+countwrap(s,j);\\n    }\\n    int findSubstringInWraproundString(string p) {\\n        return countwrap(p,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443993,
                "title": "java-using-dp",
                "content": "\\n        int t[]=new int[p.length()];\\n        t[0]=1;\\n        Set<String> st=new HashSet<>();\\n        st.add(p.charAt(0)+\"\");\\n        for(int i=1;i<p.length();i++)\\n        {\\n            int x=(p.charAt(i-1)-\\'a\\'+1),y=(p.charAt(i)-\\'a\\'+1);\\n            if((p.charAt(i)==\\'a\\'&& p.charAt(i-1)==\\'z\\') || x+1==y)\\n            {\\n                t[i]=t[i-1]+1;\\n            }\\n            else\\n            {\\n                t[i]=1;\\n            }\\n        }\\n        Map<Character,Integer> mp=new HashMap<>();\\n        int ans=0;\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!mp.containsKey(p.charAt(i)))\\n            {\\n               ans+=t[i];\\n               mp.put(p.charAt(i),t[i]); \\n            }\\n            else if(mp.get(p.charAt(i))<=t[i])\\n            {\\n                ans+=t[i]-mp.get(p.charAt(i));\\n                mp.put(p.charAt(i),t[i]); \\n\\n            }\\n            \\n        }\\n        return ans;\\n        \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "\\n        int t[]=new int[p.length()];\\n        t[0]=1;\\n        Set<String> st=new HashSet<>();\\n        st.add(p.charAt(0)+\"\");\\n        for(int i=1;i<p.length();i++)\\n        {\\n            int x=(p.charAt(i-1)-\\'a\\'+1),y=(p.charAt(i)-\\'a\\'+1);\\n            if((p.charAt(i)==\\'a\\'&& p.charAt(i-1)==\\'z\\') || x+1==y)\\n            {\\n                t[i]=t[i-1]+1;\\n            }\\n            else\\n            {\\n                t[i]=1;\\n            }\\n        }\\n        Map<Character,Integer> mp=new HashMap<>();\\n        int ans=0;\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!mp.containsKey(p.charAt(i)))\\n            {\\n               ans+=t[i];\\n               mp.put(p.charAt(i),t[i]); \\n            }\\n            else if(mp.get(p.charAt(i))<=t[i])\\n            {\\n                ans+=t[i]-mp.get(p.charAt(i));\\n                mp.put(p.charAt(i),t[i]); \\n\\n            }\\n            \\n        }\\n        return ans;\\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2438698,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n      \\n        int dp[26]={0},count=1;\\n        dp[p[0]-\\'a\\']=1;\\n        for(int i=1;i<p.size();i++)\\n        {\\n            if((p[i-1]-\\'a\\'+1)%26==(p[i]-\\'a\\')%26)\\n            {\\n                count++;\\n                dp[p[i]-\\'a\\']=max(dp[p[i]-\\'a\\'],count);\\n            }\\n            else {\\n            if(dp[p[i]-\\'a\\']==0)    \\n                dp[p[i]-\\'a\\']=1;\\n               \\n                count=1;\\n            }\\n        }\\n        int ans=0;\\n       for(auto it:dp)\\n       {\\n          ans+=it; \\n       }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n      \\n        int dp[26]={0},count=1;\\n        dp[p[0]-\\'a\\']=1;\\n        for(int i=1;i<p.size();i++)\\n        {\\n            if((p[i-1]-\\'a\\'+1)%26==(p[i]-\\'a\\')%26)\\n            {\\n                count++;\\n                dp[p[i]-\\'a\\']=max(dp[p[i]-\\'a\\'],count);\\n            }\\n            else {\\n            if(dp[p[i]-\\'a\\']==0)    \\n                dp[p[i]-\\'a\\']=1;\\n               \\n                count=1;\\n            }\\n        }\\n        int ans=0;\\n       for(auto it:dp)\\n       {\\n          ans+=it; \\n       }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429228,
                "title": "python-solution-tc-o-n-sc-o-1",
                "content": "# class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        prev = 1\\n        d = collections.defaultdict(int)\\n        d[p[-1]] = 1\\n        \\n        for i in range(len(p) - 2, -1, -1):\\n            curr = 0\\n            if (p[i] == \\'z\\' and p[i+1] == \\'a\\') or (ord(p[i+1]) - ord(p[i]) == 1):\\n                curr = prev\\n            curr += 1\\n            d[p[i]] = max(d[p[i]], curr)\\n            prev = curr\\n        \\n        return sum(d.values())",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "# class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        prev = 1\\n        d = collections.defaultdict(int)\\n        d[p[-1]] = 1\\n        \\n        for i in range(len(p) - 2, -1, -1):\\n            curr = 0\\n            if (p[i] == \\'z\\' and p[i+1] == \\'a\\') or (ord(p[i+1]) - ord(p[i]) == 1):\\n                curr = prev\\n            curr += 1\\n            d[p[i]] = max(d[p[i]], curr)\\n            prev = curr\\n        \\n        return sum(d.values())",
                "codeTag": "Java"
            },
            {
                "id": 2423473,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        streak, streakHashMap, ans = 0, defaultdict(int), 0\\n        for i in range(len(p)):\\n            if i != 0 and ((ord(p[i]) - ord(p[i - 1])) % 26) == 1:\\n                streak += 1\\n            else:\\n                streak = 1\\n            streakHashMap[p[i]] = max(streak, streakHashMap[p[i]])\\n        for key in streakHashMap:\\n            ans += streakHashMap[key]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        streak, streakHashMap, ans = 0, defaultdict(int), 0\\n        for i in range(len(p)):\\n            if i != 0 and ((ord(p[i]) - ord(p[i - 1])) % 26) == 1:\\n                streak += 1\\n            else:\\n                streak = 1\\n            streakHashMap[p[i]] = max(streak, streakHashMap[p[i]])\\n        for key in streakHashMap:\\n            ans += streakHashMap[key]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414351,
                "title": "easy-sliding-window-solution-intuitive",
                "content": "basically it is a sliding window but here i also use storage for each char as simple sliding window would count same strings multiple times , thats why i am storing the length of longest string ending at that char which is continuous......\\n\\n//code\\n\\nclass Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<char>vec(26);\\n       for(int i=0;i<25;i++){\\n           vec[i]=\\'b\\'+i;\\n       }\\n        vec[25]=\\'a\\';\\n    \\n    int i=0;\\n    int j=0;\\n    int ans=0;\\n        vector<int> dp(26,0);\\n        //map<string,bool> mp;\\n    while(j<p.length()){\\n        if(i==j){\\n            \\n            dp[p[i]-\\'a\\']=max(dp[p[i]-\\'a\\'],1);\\n           j++;\\n        }\\n        else{\\n            char c=p[j];\\n            char b=p[j-1];\\n            int val=b-\\'a\\';\\n            if(vec[val]==c){\\n                dp[p[j]-\\'a\\']=max(dp[p[j]-\\'a\\'],(j-i+1));\\n                j++;\\n            }\\n            else{\\n                i=j;\\n            }\\n        }\\n    }\\n        int sum=0;\\n        for(int i=0;i<26;i++){\\n            sum+=dp[i];\\n        }\\n    return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        vector<char>vec(26);\\n       for(int i=0;i<25;i++){\\n           vec[i]=\\'b\\'+i;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2406513,
                "title": "java-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) \\n    {\\n        int dp[]=new int[26];\\n        int i=0,j=1;\\n        \\n        while(j<p.length())\\n        {\\n            if((p.charAt(j)!=\\'a\\' && p.charAt(j)-p.charAt(j-1)!=1) || (p.charAt(j)==\\'a\\' && p.charAt(j-1)!=\\'z\\'))\\n            {\\n                set((int)p.charAt(i)-\\'a\\',dp,j-i);\\n                i=j;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        set((int)p.charAt(i)-\\'a\\',dp,j-i);\\n        \\n        int ans=0;\\n        for(int x=0;x<26;x++)\\n        ans+=dp[x];\\n        \\n        return ans;\\n    }\\n    \\n    public void set(int pos,int dp[],int len)\\n    {\\n        int c=0;\\n        \\n        for(int i=len;i>0;i--)\\n        {\\n            c++;\\n            dp[pos]=Math.max(dp[pos],i);\\n            pos=(pos+1)%26;\\n            \\n            if(c>26)\\n            break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findSubstringInWraproundString(String p) \\n    {\\n        int dp[]=new int[26];\\n        int i=0,j=1;\\n        \\n        while(j<p.length())\\n        {\\n            if((p.charAt(j)!=\\'a\\' && p.charAt(j)-p.charAt(j-1)!=1) || (p.charAt(j)==\\'a\\' && p.charAt(j-1)!=\\'z\\'))\\n            {\\n                set((int)p.charAt(i)-\\'a\\',dp,j-i);\\n                i=j;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        set((int)p.charAt(i)-\\'a\\',dp,j-i);\\n        \\n        int ans=0;\\n        for(int x=0;x<26;x++)\\n        ans+=dp[x];\\n        \\n        return ans;\\n    }\\n    \\n    public void set(int pos,int dp[],int len)\\n    {\\n        int c=0;\\n        \\n        for(int i=len;i>0;i--)\\n        {\\n            c++;\\n            dp[pos]=Math.max(dp[pos],i);\\n            pos=(pos+1)%26;\\n            \\n            if(c>26)\\n            break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390299,
                "title": "python-solution",
                "content": "```\\ndef findSubstringInWraproundString(self, p: str) -> int:\\n\\td, l = {c: 1 for c in p}, 1\\n\\tfor i in range(len(p)-1):\\n\\t\\tif (ord(p[i+1])-ord(p[i])+26)%26==1:\\n\\t\\t\\tl += 1\\n\\t\\telse:\\n\\t\\t\\tl = 1\\n\\t\\td[p[i]] = max(d[p[i]], l)\\n\\treturn sum(d.values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef findSubstringInWraproundString(self, p: str) -> int:\\n\\td, l = {c: 1 for c in p}, 1\\n\\tfor i in range(len(p)-1):\\n\\t\\tif (ord(p[i+1])-ord(p[i])+26)%26==1:\\n\\t\\t\\tl += 1\\n\\t\\telse:\\n\\t\\t\\tl = 1\\n\\t\\td[p[i]] = max(d[p[i]], l)\\n\\treturn sum(d.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2296966,
                "title": "easy-understanding-java-slide-window-solution",
                "content": "```\\n    //record the character\\'s substring length(equal substring numbers contained this character), \\n\\t// when the character is at rightmost endpoint; at last, count all 26 charaters\\' substring count numbers\\n    public int findSubstringInWraproundString(String p) {\\n        int left = 0;\\n        int cnt = 0;\\n        Character pre = null;\\n        int[] cntArray = new int[26];\\n        Arrays.fill(cntArray, 0);\\n        for (int right = 0; right < p.length(); right++) {\\n            while (!checkContinue(pre, p.charAt(right)) && left < right) {\\n                left++;\\n            }\\n            cntArray[p.charAt(right) - \\'a\\'] = Math.max(cntArray[p.charAt(right) - \\'a\\'], right - left + 1);\\n            pre = p.charAt(right);\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            cnt += cntArray[i];\\n        }\\n        return cnt;\\n    }\\n\\n    private boolean checkContinue(Character pre, Character c) {\\n        if (pre == null) {\\n            return true;\\n        }\\n        if (\\'z\\' == pre && \\'a\\' == c) {\\n            return true;\\n        }\\n        if (c - pre == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //record the character\\'s substring length(equal substring numbers contained this character), \\n\\t// when the character is at rightmost endpoint; at last, count all 26 charaters\\' substring count numbers\\n    public int findSubstringInWraproundString(String p) {\\n        int left = 0;\\n        int cnt = 0;\\n        Character pre = null;\\n        int[] cntArray = new int[26];\\n        Arrays.fill(cntArray, 0);\\n        for (int right = 0; right < p.length(); right++) {\\n            while (!checkContinue(pre, p.charAt(right)) && left < right) {\\n                left++;\\n            }\\n            cntArray[p.charAt(right) - \\'a\\'] = Math.max(cntArray[p.charAt(right) - \\'a\\'], right - left + 1);\\n            pre = p.charAt(right);\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            cnt += cntArray[i];\\n        }\\n        return cnt;\\n    }\\n\\n    private boolean checkContinue(Character pre, Character c) {\\n        if (pre == null) {\\n            return true;\\n        }\\n        if (\\'z\\' == pre && \\'a\\' == c) {\\n            return true;\\n        }\\n        if (c - pre == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269074,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint findSubstringInWraproundString(string p) {\\n\\t\\tvector<int> ct(26, 0);\\n\\t\\tint len = 1;\\n\\t\\tfor (int i = 0; i < p.size(); ++i) {\\n\\t\\t\\tif (i > 0 && (p[i] == p[i - 1] + 1 || p[i] + 25 == p[i - 1])) len++;\\n\\t\\t\\telse len = 1;\\n\\t\\t\\tct[p[i] - \\'a\\'] = max(len, ct[p[i] - \\'a\\']);\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor (auto &e : ct) ans += e;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint findSubstringInWraproundString(string p) {\\n\\t\\tvector<int> ct(26, 0);\\n\\t\\tint len = 1;\\n\\t\\tfor (int i = 0; i < p.size(); ++i) {\\n\\t\\t\\tif (i > 0 && (p[i] == p[i - 1] + 1 || p[i] + 25 == p[i - 1])) len++;\\n\\t\\t\\telse len = 1;\\n\\t\\t\\tct[p[i] - \\'a\\'] = max(len, ct[p[i] - \\'a\\']);\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor (auto &e : ct) ans += e;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260519,
                "title": "c-0ms-100-space-time-very-easy",
                "content": "```\\nclass Solution {\\n    int dp[26];\\n    void add(char starting, int count){\\n        for(int x=0;x<min(count,26);x++){\\n            int idx=(x+starting-\\'a\\')%26;\\n            dp[idx]=max(count-x,dp[idx]);\\n        }\\n    }\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        memset(dp,0,sizeof(dp));\\n        int len=p.size();\\n        int m=1;\\n        for(int x=1;x<len;x++){\\n            int prev=p[x-1]-\\'a\\';\\n            int cur=p[x]-\\'a\\';\\n            if((prev+1)%26==cur){\\n                m++;\\n            }\\n            else{\\n                add(p[x-m],m);\\n                m=1;\\n            }\\n        }\\n        add(p[len-m],m);\\n        return accumulate(begin(dp),end(dp),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[26];\\n    void add(char starting, int count){\\n        for(int x=0;x<min(count,26);x++){\\n            int idx=(x+starting-\\'a\\')%26;\\n            dp[idx]=max(count-x,dp[idx]);\\n        }\\n    }\\npublic:\\n    int findSubstringInWraproundString(string p) {\\n        memset(dp,0,sizeof(dp));\\n        int len=p.size();\\n        int m=1;\\n        for(int x=1;x<len;x++){\\n            int prev=p[x-1]-\\'a\\';\\n            int cur=p[x]-\\'a\\';\\n            if((prev+1)%26==cur){\\n                m++;\\n            }\\n            else{\\n                add(p[x-m],m);\\n                m=1;\\n            }\\n        }\\n        add(p[len-m],m);\\n        return accumulate(begin(dp),end(dp),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258605,
                "title": "most-time-and-space-efficient-solutions",
                "content": "**Solution 1: My first AC Solution.**\\n\\n```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        count = [0] * 26\\n        max_len = 1\\n        \\n        for i in range(len(p)):\\n            if i > 0:\\n                prev, curr = ord(p[i-1]), ord(p[i])\\n                max_len = max_len+1 if (prev-curr) % 26 == 25 else 1\\n            \\n            idx = ord(p[i]) - ord(\\'a\\')\\n            count[idx] = max(count[idx], max_len)\\n        return sum(count)\\n```\\n\\n**Solution 2: Most Time Efficient.**\\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        lo, hi, ll = 0, 1, len(p)\\n        base = ord(\"a\")\\n        ns = [ord(c) - base for c in p]\\n        longest = [0 for _ in range(26)]\\n\\n        while lo < ll:\\n            while hi < ll and (ns[hi] == ns[hi - 1] + 1 or ns[hi - 1] == 25 and ns[hi] == 0):\\n                hi += 1\\n            con = hi - lo\\n            for i, c in enumerate(ns[lo:hi]):\\n                tmp = con - i\\n                if tmp > longest[c]:\\n                    longest[c] = tmp\\n            lo = hi\\n            hi += 1\\n\\n        return sum(longest)\\n```\\n\\n**Solution 3: Most Memory Efficient.**\\n\\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        i = 0\\n        lengths = defaultdict(int)\\n        mapping = {chr(i + 97):chr((i + 1)%26 + 97) for i in range(26)}\\n        \\n        while i < len(p):\\n            j = i + 1\\n            while j < len(p) and p[j] == mapping[p[j - 1]]:\\n                j += 1\\n            l = j - i\\n            for i in range(i, j):\\n                if lengths[p[i]] < l:\\n                    lengths[p[i]] = l\\n                    l -= 1\\n                else:\\n                    break\\n            i = j\\n\\n        return sum(lengths.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSubstringInWraproundString(self, p):\\n        \"\"\"\\n        :type p: str\\n        :rtype: int\\n        \"\"\"\\n        count = [0] * 26\\n        max_len = 1\\n        \\n        for i in range(len(p)):\\n            if i > 0:\\n                prev, curr = ord(p[i-1]), ord(p[i])\\n                max_len = max_len+1 if (prev-curr) % 26 == 25 else 1\\n            \\n            idx = ord(p[i]) - ord(\\'a\\')\\n            count[idx] = max(count[idx], max_len)\\n        return sum(count)\\n```\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        lo, hi, ll = 0, 1, len(p)\\n        base = ord(\"a\")\\n        ns = [ord(c) - base for c in p]\\n        longest = [0 for _ in range(26)]\\n\\n        while lo < ll:\\n            while hi < ll and (ns[hi] == ns[hi - 1] + 1 or ns[hi - 1] == 25 and ns[hi] == 0):\\n                hi += 1\\n            con = hi - lo\\n            for i, c in enumerate(ns[lo:hi]):\\n                tmp = con - i\\n                if tmp > longest[c]:\\n                    longest[c] = tmp\\n            lo = hi\\n            hi += 1\\n\\n        return sum(longest)\\n```\n```\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        i = 0\\n        lengths = defaultdict(int)\\n        mapping = {chr(i + 97):chr((i + 1)%26 + 97) for i in range(26)}\\n        \\n        while i < len(p):\\n            j = i + 1\\n            while j < len(p) and p[j] == mapping[p[j - 1]]:\\n                j += 1\\n            l = j - i\\n            for i in range(i, j):\\n                if lengths[p[i]] < l:\\n                    lengths[p[i]] = l\\n                    l -= 1\\n                else:\\n                    break\\n            i = j\\n\\n        return sum(lengths.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227550,
                "title": "error-in-python-code",
                "content": "Cannot figure out what\\'s wrong in this code\\n\\n\\'\\'\\'\\nfrom collections import defaultdict\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dp=defaultdict(lambda:0)\\n        dp[p[-1]]=1\\n        for i in range(len(p)-2,-1,-1):\\n            c=p[i]\\n            if c==\\'z\\':\\n                if p[i+1]==\\'a\\':\\n                    dp[c]=max(dp[c],1+dp[p[i+1]])\\n                else:\\n                    dp[c]=max(dp[c],1)\\n            else:\\n                if ord(p[i+1])==ord(c)+1:\\n                    dp[c]=max(dp[c],1+dp[p[i+1]])\\n                else:\\n                    dp[c]=max(dp[c],1)\\n        ans=0\\n        for x in dp.keys():\\n            ans+=dp[x]\\n        return ans\\n\\t\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "Cannot figure out what\\'s wrong in this code\\n\\n\\'\\'\\'\\nfrom collections import defaultdict\\nclass Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        dp=defaultdict(lambda:0)\\n        dp[p[-1]]=1\\n        for i in range(len(p)-2,-1,-1):\\n            c=p[i]\\n            if c==\\'z\\':\\n                if p[i+1]==\\'a\\':\\n                    dp[c]=max(dp[c],1+dp[p[i+1]])\\n                else:\\n                    dp[c]=max(dp[c],1)\\n            else:\\n                if ord(p[i+1])==ord(c)+1:\\n                    dp[c]=max(dp[c],1+dp[p[i+1]])\\n                else:\\n                    dp[c]=max(dp[c],1)\\n        ans=0\\n        for x in dp.keys():\\n            ans+=dp[x]\\n        return ans\\n\\t\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2222927,
                "title": "java-kind-of-sliding-window-solution",
                "content": "```\\npublic int findSubstringInWraproundString(String p)\\n    {\\n        int[] arr = new int[26];\\n        int i = 0;\\n        int j = 1;\\n        arr[p.charAt(0)-\\'a\\'] = 1;\\n        while(j < p.length())\\n        {\\n            int ch = p.charAt(j)-\\'a\\';\\n            int prev = p.charAt(j-1)-\\'a\\';\\n            \\n            if((prev == 25 && ch == 0) || (prev+1==ch))\\n            {\\n                arr[ch] = Math.max(arr[ch],j-i+1);\\n            }\\n            else\\n            {\\n                i = j;\\n                arr[ch] = Math.max(arr[ch],1);\\n            }\\n            j++;\\n        }\\n        int sum = 0;\\n        for(int ele : arr) sum+=ele;\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int findSubstringInWraproundString(String p)\\n    {\\n        int[] arr = new int[26];\\n        int i = 0;\\n        int j = 1;\\n        arr[p.charAt(0)-\\'a\\'] = 1;\\n        while(j < p.length())\\n        {\\n            int ch = p.charAt(j)-\\'a\\';\\n            int prev = p.charAt(j-1)-\\'a\\';\\n            \\n            if((prev == 25 && ch == 0) || (prev+1==ch))\\n            {\\n                arr[ch] = Math.max(arr[ch],j-i+1);\\n            }\\n            else\\n            {\\n                i = j;\\n                arr[ch] = Math.max(arr[ch],1);\\n            }\\n            j++;\\n        }\\n        int sum = 0;\\n        for(int ele : arr) sum+=ele;\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2210613,
                "title": "python-dp-o-n-solution-simplest-solution",
                "content": "```class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        arr = [0 for _ in range(27)]\\n        arr[ord(p[0])-ord(\"a\")+1] = 1\\n        length = 1\\n        i = 1\\n        while i < len(p):\\n            prev = (ord(p[i-1])-ord(\"a\")+1)%26\\n            curr = ord(p[i])-ord(\"a\")+1\\n            if prev + 1 == curr:\\n                length += 1\\n            else:\\n                length = 1\\n            arr[curr] = max(arr[curr],length)\\n            i += 1\\n        return sum(arr)\\n\\n            \\n",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```class Solution:\\n    def findSubstringInWraproundString(self, p: str) -> int:\\n        arr = [0 for _ in range(27)]\\n        arr[ord(p[0])-ord(\"a\")+1] = 1\\n        length = 1\\n        i = 1\\n        while i < len(p):\\n            prev = (ord(p[i-1])-ord(\"a\")+1)%26\\n            curr = ord(p[i])-ord(\"a\")+1\\n            if prev + 1 == curr:\\n                length += 1\\n            else:\\n                length = 1\\n            arr[curr] = max(arr[curr],length)\\n            i += 1\\n        return sum(arr)\\n\\n            \\n",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1571741,
                "content": [
                    {
                        "username": "dukeforever",
                        "content": "In the second example, why \"ca\" or \"ac\" not a sub-string of \"cac\"?"
                    },
                    {
                        "username": "tanni26",
                        "content": "They are not present in base"
                    },
                    {
                        "username": "user1894Bh",
                        "content": "I did not find this question to be very clear at all, example 2 especially, if s = \\'cac\\' then the wraparound string is surely base = \\'...caccaccaccaccaccac...\\'. So why would the only substrings be \\'a\\' and \\'c\\', it looks to me as though \\'ca\\', \\'ac\\' and \\'cac\\' are all valid substrings as well. Perhaps the question could be improved with a better description of the problem statement."
                    },
                    {
                        "username": "tanni26",
                        "content": "Base is a wraparounnd of the string a to z"
                    },
                    {
                        "username": "am___k",
                        "content": "why test case \"cac\" answer is 3 - In my understanding it is 5 - \\'c\\', \\'a\\', \\'ca\\', \\'ac\\', \\'cac\\'"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "the substring must be there in the base string \\n"
                    },
                    {
                        "username": "ricooooo",
                        "content": "\\'ca\\', \\'ac\\', \\'cac\\' are not  present in s \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\\n"
                    }
                ]
            },
            {
                "id": 1800415,
                "content": [
                    {
                        "username": "dukeforever",
                        "content": "In the second example, why \"ca\" or \"ac\" not a sub-string of \"cac\"?"
                    },
                    {
                        "username": "tanni26",
                        "content": "They are not present in base"
                    },
                    {
                        "username": "user1894Bh",
                        "content": "I did not find this question to be very clear at all, example 2 especially, if s = \\'cac\\' then the wraparound string is surely base = \\'...caccaccaccaccaccac...\\'. So why would the only substrings be \\'a\\' and \\'c\\', it looks to me as though \\'ca\\', \\'ac\\' and \\'cac\\' are all valid substrings as well. Perhaps the question could be improved with a better description of the problem statement."
                    },
                    {
                        "username": "tanni26",
                        "content": "Base is a wraparounnd of the string a to z"
                    },
                    {
                        "username": "am___k",
                        "content": "why test case \"cac\" answer is 3 - In my understanding it is 5 - \\'c\\', \\'a\\', \\'ca\\', \\'ac\\', \\'cac\\'"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "the substring must be there in the base string \\n"
                    },
                    {
                        "username": "ricooooo",
                        "content": "\\'ca\\', \\'ac\\', \\'cac\\' are not  present in s \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\\n"
                    }
                ]
            },
            {
                "id": 1573355,
                "content": [
                    {
                        "username": "dukeforever",
                        "content": "In the second example, why \"ca\" or \"ac\" not a sub-string of \"cac\"?"
                    },
                    {
                        "username": "tanni26",
                        "content": "They are not present in base"
                    },
                    {
                        "username": "user1894Bh",
                        "content": "I did not find this question to be very clear at all, example 2 especially, if s = \\'cac\\' then the wraparound string is surely base = \\'...caccaccaccaccaccac...\\'. So why would the only substrings be \\'a\\' and \\'c\\', it looks to me as though \\'ca\\', \\'ac\\' and \\'cac\\' are all valid substrings as well. Perhaps the question could be improved with a better description of the problem statement."
                    },
                    {
                        "username": "tanni26",
                        "content": "Base is a wraparounnd of the string a to z"
                    },
                    {
                        "username": "am___k",
                        "content": "why test case \"cac\" answer is 3 - In my understanding it is 5 - \\'c\\', \\'a\\', \\'ca\\', \\'ac\\', \\'cac\\'"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "the substring must be there in the base string \\n"
                    },
                    {
                        "username": "ricooooo",
                        "content": "\\'ca\\', \\'ac\\', \\'cac\\' are not  present in s \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\\n"
                    }
                ]
            }
        ]
    }
]