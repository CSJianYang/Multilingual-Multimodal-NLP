[
    {
        "title": "Number of Subarrays With LCM Equal to K",
        "question_content": "Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe least common multiple of an array is the smallest positive integer that is divisible by all the array elements.\n&nbsp;\nExample 1:\n\nInput: nums = [3,6,2,7,1], k = 6\nOutput: 4\nExplanation: The subarrays of nums where 6 is the least common multiple of all the subarray's elements are:\n- [3,6,2,7,1]\n- [3,6,2,7,1]\n- [3,6,2,7,1]\n- [3,6,2,7,1]\n\nExample 2:\n\nInput: nums = [3], k = 2\nOutput: 0\nExplanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i], k <= 1000",
        "solutions": [
            {
                "id": 2808843,
                "title": "o-n-d-k-log-k",
                "content": "Quadratic is simple (see the second solution below), so let\\'s see if we can do better.\\n\\nFor an element `i`, we count unique `lcm` values for all subarrays that ends at `i`.\\n\\nThe number of unique `lcm` values will not exceed the number of divisors of `k` (which is d(k)). For each divisor, we compute LCM (log k).\\n\\n## O(n d(k) log(k))\\n**C++**\\n```cpp\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int res = 0;\\n    unordered_map<int, int> m;\\n    for (int n : nums) {\\n        unordered_map<int, int> m1;\\n        if (k % n == 0) {\\n            ++m[n];    \\n            for (auto &[d, cnt] : m)\\n                m1[lcm(d, n)] += cnt;\\n            res += m1[k];\\n        }\\n        swap(m, m1);\\n    }\\n    return res;\\n}\\n```\\n\\n## O(n ^ 2)\\n**C++**\\n```cpp\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int res = 0;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int j = i, cur = 1; j < nums.size() && k % nums[j] == 0; ++j) {\\n            cur = lcm(cur, nums[j]);\\n            res += cur == k;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int res = 0;\\n    unordered_map<int, int> m;\\n    for (int n : nums) {\\n        unordered_map<int, int> m1;\\n        if (k % n == 0) {\\n            ++m[n];    \\n            for (auto &[d, cnt] : m)\\n                m1[lcm(d, n)] += cnt;\\n            res += m1[k];\\n        }\\n        swap(m, m1);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int res = 0;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int j = i, cur = 1; j < nums.size() && k % nums[j] == 0; ++j) {\\n            cur = lcm(cur, nums[j]);\\n            res += cur == k;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808839,
                "title": "python-use-python-s-lcm-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs the use of a built-in LCM function. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is constant: **O(1)**.\\n\\n**Comment.** Given constraints of the problem, a quadratic-time brute-force with an iterative update of LCM is doable.\\n\\n\\n**Python.**\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n\\n        for i in range(0, len(nums)):       # [1] for every initial number, try extending\\n            l = nums[i]                     #     a continuous sequence of numbers\\n            for j in range(i, len(nums)):  \\n                l = lcm(l,nums[j])          # [2] once LCM becomes \\'k\\', each subsequent number\\n                if l == k : cnt += 1        #     that don\\'t increase this value will give one\\n                if l > k  : break           #     more valid subarray\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n\\n        for i in range(0, len(nums)):       # [1] for every initial number, try extending\\n            l = nums[i]                     #     a continuous sequence of numbers\\n            for j in range(i, len(nums)):  \\n                l = lcm(l,nums[j])          # [2] once LCM becomes \\'k\\', each subsequent number\\n                if l == k : cnt += 1        #     that don\\'t increase this value will give one\\n                if l > k  : break           #     more valid subarray\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808871,
                "title": "c-lcm-easy-solution",
                "content": "Similar to [https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/description/](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    long long gcd(long long int a, long long int b)\\n     {\\n       if (b == 0)\\n           return a;\\n        return gcd(b, a % b);\\n      }\\n \\n      long long lcm(int a, int b)\\n      {\\n        return (a / gcd(a, b)) * b;\\n       }\\n  \\n    int subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n        \\n    int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int c  = nums[i];\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = lcm(c, nums[j]);\\n\\n                if(c == k){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcd(long long int a, long long int b)\\n     {\\n       if (b == 0)\\n           return a;\\n        return gcd(b, a % b);\\n      }\\n \\n      long long lcm(int a, int b)\\n      {\\n        return (a / gcd(a, b)) * b;\\n       }\\n  \\n    int subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n        \\n    int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int c  = nums[i];\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = lcm(c, nums[j]);\\n\\n                if(c == k){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808809,
                "title": "c-solution-very-simple-and-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nSimply check the LCM of each sub array by brute force \\n\\n*/\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            int mx = nums[i], t;\\n            for(int j = i; j < nums.size(); ++j){\\n                t = lcm(mx, nums[j]);\\n                if(t == k){\\n                    ans++;\\n                    mx = max(mx, nums[j]);\\n                }\\n                else if( t == 1) continue;\\n                else if( i != j ) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSimply check the LCM of each sub array by brute force \\n\\n*/\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            int mx = nums[i], t;\\n            for(int j = i; j < nums.size(); ++j){\\n                t = lcm(mx, nums[j]);\\n                if(t == k){\\n                    ans++;\\n                    mx = max(mx, nums[j]);\\n                }\\n                else if( t == 1) continue;\\n                else if( i != j ) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808830,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int a=0,n=nums.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            int c=1;\\n            for(int j=i;j<n;j++)\\n            {\\n                c=task(c, nums[j]);\\n                a+=(c==k)?1:0;\\n            }\\n        }\\n        return a;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int task(int a, int b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int a=0,n=nums.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            int c=1;\\n            for(int j=i;j<n;j++)\\n            {\\n                c=task(c, nums[j]);\\n                a+=(c==k)?1:0;\\n            }\\n        }\\n        return a;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int task(int a, int b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808824,
                "title": "c-euclidean-algorithm",
                "content": "# Time Complexity\\n\\n- $$O(n^2 * log(n))$$\\n\\n\\n# With STL\\n```\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n    for (int i = 0; i < size(nums); i++)\\n    {\\n        int currLcm = 1;\\n        for (int j = i; j < size(nums); j++)\\n        {\\n            currLcm = lcm(currLcm, nums[j]);\\n            if (currLcm == k) cnt++;\\n            if (currLcm > k) break;\\n        }\\n    }\\n    return cnt; \\n}\\n```\\n\\n---\\n\\n# Without STL\\nUsing Euclidean Algorithm to find GCD\\n- $$gcd(a,b) * lcm(a,b) = a * b$$\\n- $$lcm(a,b) = (a*b)/gcd(a,b)$$\\n```\\nint getGCD(int a, int b)\\n{\\n    return (a == 0) ? b : getGCD(b % a, a);\\n}\\n\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        int currLcm = 1;\\n        for (int j = i; j < nums.size(); j++)\\n        {\\n            currLcm = (a * b) / getGCD(currLcm, nums[j]); \\n            if (currLcm == k) cnt++;\\n            if (currLcm > k)  break;\\n        }\\n    }\\n    return cnt;\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n    for (int i = 0; i < size(nums); i++)\\n    {\\n        int currLcm = 1;\\n        for (int j = i; j < size(nums); j++)\\n        {\\n            currLcm = lcm(currLcm, nums[j]);\\n            if (currLcm == k) cnt++;\\n            if (currLcm > k) break;\\n        }\\n    }\\n    return cnt; \\n}\\n```\n```\\nint getGCD(int a, int b)\\n{\\n    return (a == 0) ? b : getGCD(b % a, a);\\n}\\n\\nint subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        int currLcm = 1;\\n        for (int j = i; j < nums.size(); j++)\\n        {\\n            currLcm = (a * b) / getGCD(currLcm, nums[j]); \\n            if (currLcm == k) cnt++;\\n            if (currLcm > k)  break;\\n        }\\n    }\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808867,
                "title": "c-lcm-of-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        long long ans=0,mul=1;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                mul = lcm(mul,nums[j]);\\n                if(mul == k) ans++;\\n                if(mul>k) break;\\n            }\\n            mul=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        long long ans=0,mul=1;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                mul = lcm(mul,nums[j]);\\n                if(mul == k) ans++;\\n                if(mul>k) break;\\n            }\\n            mul=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085516,
                "title": "easy-c-lcm-two-implementations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply we can check all the subarrays and those having lcm=k we will increment the counter. Since n is less so n*n will not give tle .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo in implementation we can lcm stl or custom lcm function . I have showed both . Custom can be used to take care of integer overflow.\\n**Note:** Use `long long` to avoid integer overflow\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using STL**\\n**Beats 70%**\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll unsigned int\\n    int subarrayLCM(vector<int>& nums, int k) {\\n     ll  res = 0;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int j = i, cur = 1; j < nums.size() && k % nums[j] == 0; ++j) {\\n            cur = lcm(cur, nums[j]);\\n            res += (cur == k);\\n        }\\n    return res;\\n      \\n    }\\n    \\n};\\n```\\n**Using Custom LCM function**\\n**Beats 95%**\\n```\\n #define ll unsigned int\\n    ll lcm(ll a, ll b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n    int subarrayLCM(vector<int>& arr, int k) {\\n       ll n = arr.size();\\n       ll c= 0;\\n         for(ll i=0; i<n; i++)\\n         {\\n             ll curr = arr[i];\\n             for(ll j=i; j<n; j++)\\n             {\\n                 curr = lcm(curr,arr[j]);\\n                 if(curr==k) c++;\\n                 if(curr>k)break;\\n             }\\n         }\\n        return c;\\n      \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll unsigned int\\n    int subarrayLCM(vector<int>& nums, int k) {\\n     ll  res = 0;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int j = i, cur = 1; j < nums.size() && k % nums[j] == 0; ++j) {\\n            cur = lcm(cur, nums[j]);\\n            res += (cur == k);\\n        }\\n    return res;\\n      \\n    }\\n    \\n};\\n```\n```\\n #define ll unsigned int\\n    ll lcm(ll a, ll b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n    int subarrayLCM(vector<int>& arr, int k) {\\n       ll n = arr.size();\\n       ll c= 0;\\n         for(ll i=0; i<n; i++)\\n         {\\n             ll curr = arr[i];\\n             for(ll j=i; j<n; j++)\\n             {\\n                 curr = lcm(curr,arr[j]);\\n                 if(curr==k) c++;\\n                 if(curr>k)break;\\n             }\\n         }\\n        return c;\\n      \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809098,
                "title": "c-solution-lcm-gcd",
                "content": "\\t# upvote, if this helps u ... \\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint subarrayLCM(vector<int>& nums, int k) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tlong long ans = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// LCM * GCD = Product of nums\\n\\t\\t\\t\\t\\t// LCM = Product of nums/GCD\\n\\t\\t\\t\\t\\tlong long int p = 1; \\n\\t\\t\\t\\t\\tint lcm = 1;\\n\\t\\t\\t\\t\\tfor(int j = i; j < n; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp *= nums[j];\\n\\t\\t\\t\\t\\t\\tlcm = p/__gcd(lcm,nums[j]);\\n\\t\\t\\t\\t\\t\\tif(lcm == k)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tp = lcm;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint subarrayLCM(vector<int>& nums, int k) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tlong long ans = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// LCM * GCD = Product of nums\\n\\t\\t\\t\\t\\t// LCM = Product of nums/GCD\\n\\t\\t\\t\\t\\tlong long int p = 1; \\n\\t\\t\\t\\t\\tint lcm = 1;\\n\\t\\t\\t\\t\\tfor(int j = i; j < n; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp *= nums[j];\\n\\t\\t\\t\\t\\t\\tlcm = p/__gcd(lcm,nums[j]);\\n\\t\\t\\t\\t\\t\\tif(lcm == k)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2811996,
                "title": "python-very-easy-implementation",
                "content": "\\n    def gcd(a,b):\\n        while b:\\n            a,b = b, a%b\\n        return abs(a)\\n    def lcm(a,b):\\n        return a*b / gcd(a,b)\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        c=0\\n        l=len(nums)\\n        for i in range(l):\\n            x=nums[i]\\n            for j in range(i,l):\\n                x=lcm(x,nums[j])\\n                if x==k:\\n                    c+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def gcd(a,b):\\n        while b:\\n            a,b = b, a%b\\n        return abs(a)\\n    def lcm(a,b):\\n        return a*b / gcd(a,b)\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        c=0\\n        l=len(nums)\\n        for i in range(l):\\n            x=nums[i]\\n            for j in range(i,l):\\n                x=lcm(x,nums[j])\\n                if x==k:\\n                    c+=1\\n        return c",
                "codeTag": "Python3"
            },
            {
                "id": 2810071,
                "title": "leetcode-the-hard-way-rust-solution",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n```rs\\nuse std::cmp::{max, min};\\n\\nfn gcd(a: i32, b: i32) -> i32 {\\n    match ((a, b), (a & 1, b & 1)) {\\n        ((x, y), _) if x == y => y,\\n        ((0, x), _) | ((x, 0), _) => x,\\n        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),\\n        ((x, y), (0, 0)) => gcd(x >> 1, y >> 1) << 1,\\n        ((x, y), (1, 1)) => {\\n            let (x, y) = (min(x, y), max(x, y));\\n            gcd((y - x) >> 1, x)\\n        }\\n        _ => unreachable!(),\\n    }\\n}\\n\\nfn lcm(a: i32, b: i32) -> i32 {\\n    a * b / gcd(a, b)\\n}\\n\\nimpl Solution {\\n    pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut ans = 0;\\n        for i in 0 .. n {\\n            let mut l = 1;\\n            for j in i .. n {\\n                l = lcm(l, nums[j]);\\n                if l == k {\\n                    ans += 1;\\n                }\\n                if l > k {\\n                    break;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::cmp::{max, min};\\n\\nfn gcd(a: i32, b: i32) -> i32 {\\n    match ((a, b), (a & 1, b & 1)) {\\n        ((x, y), _) if x == y => y,\\n        ((0, x), _) | ((x, 0), _) => x,\\n        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),\\n        ((x, y), (0, 0)) => gcd(x >> 1, y >> 1) << 1,\\n        ((x, y), (1, 1)) => {\\n            let (x, y) = (min(x, y), max(x, y));\\n            gcd((y - x) >> 1, x)\\n        }\\n        _ => unreachable!(),\\n    }\\n}\\n\\nfn lcm(a: i32, b: i32) -> i32 {\\n    a * b / gcd(a, b)\\n}\\n\\nimpl Solution {\\n    pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut ans = 0;\\n        for i in 0 .. n {\\n            let mut l = 1;\\n            for j in i .. n {\\n                l = lcm(l, nums[j]);\\n                if l == k {\\n                    ans += 1;\\n                }\\n                if l > k {\\n                    break;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808874,
                "title": "python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            return math.gcd(a,b)\\n        def lcm(n1,n2):\\n            return (n1*n2)//gcd(n1,n2)\\n        n=len(nums)\\n        ans=0\\n        for i in range(n):\\n            lcmi=nums[i]\\n            for j in range(i,n):\\n                lcmi=lcm(lcmi,nums[j])\\n                if(lcmi==k):\\n                    ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            return math.gcd(a,b)\\n        def lcm(n1,n2):\\n            return (n1*n2)//gcd(n1,n2)\\n        n=len(nums)\\n        ans=0\\n        for i in range(n):\\n            lcmi=nums[i]\\n            for j in range(i,n):\\n                lcmi=lcm(lcmi,nums[j])\\n                if(lcmi==k):\\n                    ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811855,
                "title": "java-easy-o-n-k-time-o-1-space-easy-to-understand",
                "content": "if u like it kindly upvote it\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int c=0;\\n        int pre=-1;\\n        int st=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==k){\\n                c++;\\n            }\\n            if(k%nums[i]==0){\\n                if(pre!=-1 && lcm(pre,nums[i])==k ){\\n                     c+=i-st;\\n                }\\n               pre=nums[i];\\n            }else {\\n                st=i+1;\\n            }\\n        }\\n        return c;\\n    }\\n    public int lcm(int a,int b){\\n        int p=a,q=b;\\n        while(a!=b){\\n            if(a>b){\\n                a=a-b;\\n            }else{\\n                b=b-a;\\n            }\\n        }\\n        return (p*q)/a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int c=0;\\n        int pre=-1;\\n        int st=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==k){\\n                c++;\\n            }\\n            if(k%nums[i]==0){\\n                if(pre!=-1 && lcm(pre,nums[i])==k ){\\n                     c+=i-st;\\n                }\\n               pre=nums[i];\\n            }else {\\n                st=i+1;\\n            }\\n        }\\n        return c;\\n    }\\n    public int lcm(int a,int b){\\n        int p=a,q=b;\\n        while(a!=b){\\n            if(a>b){\\n                a=a-b;\\n            }else{\\n                b=b-a;\\n            }\\n        }\\n        return (p*q)/a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809231,
                "title": "easiest-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int size=nums.size(),count=0;\\n        for(int i=0;i<size;i++){\\n        int LCM=nums[i];\\n            for(int j=i;j<size;j++){\\n                LCM=lcm(LCM,nums[j]);\\n                if(LCM==k)\\n                    count++;\\n                else if(LCM>k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int size=nums.size(),count=0;\\n        for(int i=0;i<size;i++){\\n        int LCM=nums[i];\\n            for(int j=i;j<size;j++){\\n                LCM=lcm(LCM,nums[j]);\\n                if(LCM==k)\\n                    count++;\\n                else if(LCM>k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809126,
                "title": "bruteforce",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    int lcm(int a, int b) {\\n        return (a * b) / __gcd(a, b);\\n    }\\npublic:\\n    int subarrayLCM(vector<int> &nums, int k) {\\n        int res = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int g = nums[i];\\n            if (g == k) res++;\\n            for (int j = i + 1; j < n; j++) {\\n                g = lcm(g, nums[j]);\\n                if (g == k) res++;\\n                else if (g < k) continue;\\n                else break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    int lcm(int a, int b) {\\n        return (a * b) / __gcd(a, b);\\n    }\\npublic:\\n    int subarrayLCM(vector<int> &nums, int k) {\\n        int res = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int g = nums[i];\\n            if (g == k) res++;\\n            for (int j = i + 1; j < n; j++) {\\n                g = lcm(g, nums[j]);\\n                if (g == k) res++;\\n                else if (g < k) continue;\\n                else break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808795,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        for(int i = 0; i < nums.length ; i++){\\n            if(k % nums[i] != 0){\\n                nums[i] = -1;\\n            }\\n        }\\n        int i = 0;\\n        int j = 0;\\n        int lc = 1;\\n        int ans = 0;\\n        while(j < nums.length){\\n            if(nums[j] == -1){\\n                i = i+1;\\n                j = i;\\n                lc = 1;\\n                continue;\\n            }\\n            lc = lcm(nums[j],lc);\\n            if(lc < k){\\n                j++;\\n            }else if(lc == k){\\n                ans++;\\n                j++;\\n                if(j == nums.length){\\n                    i = i+1;\\n                    j = i;\\n                    lc = 1;\\n                }\\n            }else{\\n                i = i+1;\\n                j = i;\\n                lc = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n      static int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n     \\n    // method to return LCM of two numbers\\n    static int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        for(int i = 0; i < nums.length ; i++){\\n            if(k % nums[i] != 0){\\n                nums[i] = -1;\\n            }\\n        }\\n        int i = 0;\\n        int j = 0;\\n        int lc = 1;\\n        int ans = 0;\\n        while(j < nums.length){\\n            if(nums[j] == -1){\\n                i = i+1;\\n                j = i;\\n                lc = 1;\\n                continue;\\n            }\\n            lc = lcm(nums[j],lc);\\n            if(lc < k){\\n                j++;\\n            }else if(lc == k){\\n                ans++;\\n                j++;\\n                if(j == nums.length){\\n                    i = i+1;\\n                    j = i;\\n                    lc = 1;\\n                }\\n            }else{\\n                i = i+1;\\n                j = i;\\n                lc = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n      static int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n     \\n    // method to return LCM of two numbers\\n    static int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837002,
                "title": "lcm-function",
                "content": "# Intuition\\nWith such small contraints brute force works fine.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfunction `_lcm` to compute lcm of two numbers and use this funtion to calculate the lcm of a subarray.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n^2)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long _lcm(long a, long b) {\\n        return (a * b) / __gcd(a, b);\\n    }\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        long count = 0, lcm, n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            lcm = nums[i];\\n            for(int j = i; j < n; j++) {\\n                lcm = _lcm(lcm, nums[j]);\\n                if(lcm == k)\\n                    count++;\\n                if(lcm > k)\\n                    break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long _lcm(long a, long b) {\\n        return (a * b) / __gcd(a, b);\\n    }\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        long count = 0, lcm, n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            lcm = nums[i];\\n            for(int j = i; j < n; j++) {\\n                lcm = _lcm(lcm, nums[j]);\\n                if(lcm == k)\\n                    count++;\\n                if(lcm > k)\\n                    break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809678,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint subarrayLCM(vector<int>& nums, int k) {\\n\\t\\t\\t//if(nums.size()==1){if(nums[0]==k){return 1;}else{return 0;}}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tunsigned int a=nums[i];\\n\\t\\t\\t\\tfor(int j=i; j<nums.size(); j++){\\n\\t\\t\\t\\t\\ta=lcm(a, nums[j]);\\n\\t\\t\\t\\t\\tif(a==k){cnt++;}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint subarrayLCM(vector<int>& nums, int k) {\\n\\t\\t\\t//if(nums.size()==1){if(nums[0]==k){return 1;}",
                "codeTag": "Java"
            },
            {
                "id": 2809024,
                "title": "python-short-and-easy",
                "content": "This question is just a variant of  [2447](https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/description/) asked in recent contest\\n```\\nfrom math import gcd\\nclass Solution:\\n    \\n    def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)\\n\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n        size = len(nums)\\n        for ind in range(size) :\\n\\n            curLcm  = nums[ind]\\n\\n            for ind2 in range(ind, size) :\\n                curLcm = self.lcm(curLcm, nums[ind2])\\n                cnt += (curLcm  == k)\\n\\n        return cnt\\n```\\n\\nMy solution for 2447 for reference :\\n```\\nfrom math import gcd\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n        size = len(nums)\\n        for ind in range(size) :\\n\\n            curGcd  = 0\\n\\n            for ind2 in range(ind, size) :\\n                curGcd  = gcd(curGcd , nums[ind2])\\n\\n                cnt += (curGcd  == k)\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    \\n    def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)\\n\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n        size = len(nums)\\n        for ind in range(size) :\\n\\n            curLcm  = nums[ind]\\n\\n            for ind2 in range(ind, size) :\\n                curLcm = self.lcm(curLcm, nums[ind2])\\n                cnt += (curLcm  == k)\\n\\n        return cnt\\n```\n```\\nfrom math import gcd\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n        size = len(nums)\\n        for ind in range(size) :\\n\\n            curGcd  = 0\\n\\n            for ind2 in range(ind, size) :\\n                curGcd  = gcd(curGcd , nums[ind2])\\n\\n                cnt += (curGcd  == k)\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808955,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int curGCD = nums[i];\\n            if(curGCD == k) ans++;\\n            for(int j = i + 1; j < nums.length; j++){\\n                curGCD = lcm(nums[j], curGCD);\\n                if(curGCD == k) ans++;\\n                if (nums[j] > k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a%b);\\n    }\\n    \\n    public int lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int curGCD = nums[i];\\n            if(curGCD == k) ans++;\\n            for(int j = i + 1; j < nums.length; j++){\\n                curGCD = lcm(nums[j], curGCD);\\n                if(curGCD == k) ans++;\\n                if (nums[j] > k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a%b);\\n    }\\n    \\n    public int lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808866,
                "title": "2470-number-of-subarrays-with-lcm-equal-to-k-java",
                "content": "class Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int res = 0;\\n        int n = nums.length;\\n        for(int i=0; i<nums.length; i++){\\n            int currLcm = 1;\\n            for(int j=i; j<n; j++){\\n                currLcm = lcm(currLcm, nums[j]);\\n                \\n                res += (currLcm == k) ? 1 : 0;\\n            }   \\n        }\\n        return res;\\n    }\\n    public static int lcm(int a, int b){\\n    return (a * b) / gcd(a,b);\\n}\\n    public static int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b , a%b);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int res = 0;\\n        int n = nums.length;\\n        for(int i=0; i<nums.length; i++){\\n            int currLcm = 1;\\n            for(int j=i; j<n; j++){\\n                currLcm = lcm(currLcm, nums[j]);\\n                \\n                res += (currLcm == k) ? 1 : 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2808808,
                "title": "brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k){\\n         int ans = 0;\\n         for(int i=0;i<nums.size();i++){\\n             unsigned int res = nums[i];\\n             for(int j=i;j<nums.size();j++){\\n                 res = lcm(res,nums[j]);\\n                 if(res==k)ans++;\\n                 else if(res > k)break;\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k){\\n         int ans = 0;\\n         for(int i=0;i<nums.size();i++){\\n             unsigned int res = nums[i];\\n             for(int j=i;j<nums.size();j++){\\n                 res = lcm(res,nums[j]);\\n                 if(res==k)ans++;\\n                 else if(res > k)break;\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922592,
                "title": "c-javascript-easy-solution",
                "content": "# Approach\\nJust check how many subarrays have an LCM equal to a specific value k in a list of numbers. It does this by checking each element with the ones that come after it and counting the valid cases\\n\\n# Complexity\\n- Time complexity: O(n^2 * log(max(nums)))\\n- Space complexity: O(1)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int GCD(int A, int B) {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    long long LCM(int A, int B) {\\n        long long ans=(A*B);\\n        long long res=GCD(A,B);\\n        return ans/res;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n            long long lcm=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                long long res=LCM(lcm,nums[j]);\\n                if(res==k) ans++;\\n                lcm=res;\\n                if(res>k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function(nums, k) {\\n    const GCD=(A, B)=> {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    \\n    const LCM=(A, B)=> {\\n        return (A*B)/GCD(A,B);\\n    }\\n\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]===k) ans++;\\n        let lcm=nums[i];\\n        for(let j=i+1;j<nums.length;j++){\\n            let res=LCM(lcm,nums[j]);\\n            if(res==k) ans++;\\n            lcm=res;\\n            if(res>k) break;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GCD(int A, int B) {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    long long LCM(int A, int B) {\\n        long long ans=(A*B);\\n        long long res=GCD(A,B);\\n        return ans/res;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n            long long lcm=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                long long res=LCM(lcm,nums[j]);\\n                if(res==k) ans++;\\n                lcm=res;\\n                if(res>k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function(nums, k) {\\n    const GCD=(A, B)=> {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    \\n    const LCM=(A, B)=> {\\n        return (A*B)/GCD(A,B);\\n    }\\n\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]===k) ans++;\\n        let lcm=nums[i];\\n        for(let j=i+1;j<nums.length;j++){\\n            let res=LCM(lcm,nums[j]);\\n            if(res==k) ans++;\\n            lcm=res;\\n            if(res>k) break;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715349,
                "title": "easy-c-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int val = nums[i];\\n            if(val == k)      ans++;\\n            for(int j=i+1; j<nums.size() && k%nums[j]==0; j++){\\n                val = lcm(nums[j], val);\\n                if(val == k)\\n                    ans++; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int val = nums[i];\\n            if(val == k)      ans++;\\n            for(int j=i+1; j<nums.size() && k%nums[j]==0; j++){\\n                val = lcm(nums[j], val);\\n                if(val == k)\\n                    ans++; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519360,
                "title": "c-gcd-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are finding each subarray and simultaneously we are finding the lcm of that subarray. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint ans = 0;\\n int gcd(int num1, int num2)\\n{\\n    if (num2 == 0)\\n        return num1;\\n    return gcd(num2, num1 % num2);\\n}\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            int lcm = nums[i];\\n            if(lcm==k)ans++;\\n        for(int j=i+1;j<n;j++){                \\n        int num1 = lcm;\\n        int num2 = nums[j];\\n        int gcd_val = gcd(num1, num2);\\n        if(lcm>k){j=n;\\n        continue;}\\n        lcm = nums[j]*(lcm / gcd_val);\\n          if(lcm==k){ans++;}\\n         } \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint ans = 0;\\n int gcd(int num1, int num2)\\n{\\n    if (num2 == 0)\\n        return num1;\\n    return gcd(num2, num1 % num2);\\n}\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            int lcm = nums[i];\\n            if(lcm==k)ans++;\\n        for(int j=i+1;j<n;j++){                \\n        int num1 = lcm;\\n        int num2 = nums[j];\\n        int gcd_val = gcd(num1, num2);\\n        if(lcm>k){j=n;\\n        continue;}\\n        lcm = nums[j]*(lcm / gcd_val);\\n          if(lcm==k){ans++;}\\n         } \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251739,
                "title": "simplest-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long int gcd (long long int a,long long int b)\\n{\\n    if(a==0)\\n    return b ; \\n    else return gcd(b%a,a);\\n}\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int res = 0;\\n        for(int i = 0; i<nums.size();i++)\\n        {   long long int lcm = nums[i] ; \\n           if(lcm==k)\\n           res++ ; \\n            for(int j = i+1 ; j<nums.size();j++)\\n            {\\n                lcm = ((long long int)nums[j]*lcm)/gcd((long long int)nums[j],lcm);\\n                if(lcm>k)\\n                break;\\n                if(lcm==k)\\n                res++ ; \\n                 \\n            }\\n            \\n        } \\n       return res ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long int gcd (long long int a,long long int b)\\n{\\n    if(a==0)\\n    return b ; \\n    else return gcd(b%a,a);\\n}\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int res = 0;\\n        for(int i = 0; i<nums.size();i++)\\n        {   long long int lcm = nums[i] ; \\n           if(lcm==k)\\n           res++ ; \\n            for(int j = i+1 ; j<nums.size();j++)\\n            {\\n                lcm = ((long long int)nums[j]*lcm)/gcd((long long int)nums[j],lcm);\\n                if(lcm>k)\\n                break;\\n                if(lcm==k)\\n                res++ ; \\n                 \\n            }\\n            \\n        } \\n       return res ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927950,
                "title": "easy-c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            int num=nums[i];\\n            if(num==k){\\n                cnt++;\\n            }\\n            for(int j=i+1; j<n; j++){\\n                num=lcm(num, nums[j]);\\n                if(num==k){\\n                    cnt++;\\n                }\\n                if(num>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            int num=nums[i];\\n            if(num==k){\\n                cnt++;\\n            }\\n            for(int j=i+1; j<n; j++){\\n                num=lcm(num, nums[j]);\\n                if(num==k){\\n                    cnt++;\\n                }\\n                if(num>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820470,
                "title": "c-o-n-n-log-n-easy-explanation",
                "content": "You can begin by attempting the [Number of Subarrays With GCD Equal to K](https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/) problem. Then you would have a nice gist of the current problem.\\n\\nCheck my other detailed discussion [(CLICK HERE)](https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/discuss/2819517/c-onnlogn-easy-explanation)\\n\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            int lcm = nums[i];\\n            for(int j = i; j < n; j++){\\n                \\n                 lcm = (lcm*nums[j])/__gcd(nums[j],lcm);\\n                if(lcm==k){\\n                    ans++;}\\n                if(lcm>k){\\n                    break;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            int lcm = nums[i];\\n            for(int j = i; j < n; j++){\\n                \\n                 lcm = (lcm*nums[j])/__gcd(nums[j],lcm);\\n                if(lcm==k){\\n                    ans++;}\\n                if(lcm>k){\\n                    break;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813418,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function (nums, k) {\\n  let a = 0;\\n\\n  for (let i = 0; i <= nums.length; i++) {\\n    for (let j = 0; j <= nums.length; j++) {\\n      let b = nums.slice(i, j);\\n      if (b.every((x) => k % x === 0) && b.some((x) => x === k)) {\\n        a++;\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function (nums, k) {\\n  let a = 0;\\n\\n  for (let i = 0; i <= nums.length; i++) {\\n    for (let j = 0; j <= nums.length; j++) {\\n      let b = nums.slice(i, j);\\n      if (b.every((x) => k % x === 0) && b.some((x) => x === k)) {\\n        a++;\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2811171,
                "title": "c-easy-to-understand-o-n-d-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n * d(k))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(k%nums[i] !=0) continue;\\n            int prev_lcm=1;\\n            for(int j=i;j<nums.size();j++){\\n                if(k%nums[j] != 0)  break;\\n                prev_lcm = (prev_lcm*nums[j])/__gcd(prev_lcm,nums[j]);\\n                if(prev_lcm==k) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(k%nums[i] !=0) continue;\\n            int prev_lcm=1;\\n            for(int j=i;j<nums.size();j++){\\n                if(k%nums[j] != 0)  break;\\n                prev_lcm = (prev_lcm*nums[j])/__gcd(prev_lcm,nums[j]);\\n                if(prev_lcm==k) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810494,
                "title": "python-brute-force-with-early-return",
                "content": "https://leetcode.com/submissions/detail/842597229/\\n```\\nRuntime: 930 ms, faster than 71.43% of Python3 online submissions for Number of Subarrays With LCM Equal to K.\\nMemory Usage: 14.1 MB, less than 28.57% of Python3 online submissions for Number of Subarrays With LCM Equal to K.\\n```\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        def getLCM(a, b):\\n            if a>b: a,b=b,a\\n            ## search in the dictionary first\\n            if (a,b) in d: \\n                return d[(a,b)]\\n            ## if not in the dictionary, calculate the LCM\\n            return (a*b) // math.gcd(a,b)\\n            \\n        l, result = len(nums), 0\\n        for i in range(l-1):\\n            if nums[i]==k: result += 1\\n            has_lcm = False ## whether existing a pair of nums with lcm==k in this trajectory\\n            for j in range(i, l-1):\\n                if k%nums[j]!=0: break\\n                lcm = getLCM(nums[j], nums[j+1])\\n                if lcm>k or k%lcm!=0:\\n                    break\\n                elif lcm==k:\\n                    has_lcm = True\\n                    result += 1\\n                elif has_lcm:\\n                    result += 1\\n                elif i<j:\\n                    for h in range(i, j):\\n                        if getLCM(nums[h], nums[j+1])==k:\\n                            has_lcm = True\\n                            result += 1\\n                            break\\n                if j==l-2 and has_lcm==False:\\n                    return result\\n        if nums[-1]==k: result += 1 ## edge\\n        return result    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nRuntime: 930 ms, faster than 71.43% of Python3 online submissions for Number of Subarrays With LCM Equal to K.\\nMemory Usage: 14.1 MB, less than 28.57% of Python3 online submissions for Number of Subarrays With LCM Equal to K.\\n```\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        def getLCM(a, b):\\n            if a>b: a,b=b,a\\n            ## search in the dictionary first\\n            if (a,b) in d: \\n                return d[(a,b)]\\n            ## if not in the dictionary, calculate the LCM\\n            return (a*b) // math.gcd(a,b)\\n            \\n        l, result = len(nums), 0\\n        for i in range(l-1):\\n            if nums[i]==k: result += 1\\n            has_lcm = False ## whether existing a pair of nums with lcm==k in this trajectory\\n            for j in range(i, l-1):\\n                if k%nums[j]!=0: break\\n                lcm = getLCM(nums[j], nums[j+1])\\n                if lcm>k or k%lcm!=0:\\n                    break\\n                elif lcm==k:\\n                    has_lcm = True\\n                    result += 1\\n                elif has_lcm:\\n                    result += 1\\n                elif i<j:\\n                    for h in range(i, j):\\n                        if getLCM(nums[h], nums[j+1])==k:\\n                            has_lcm = True\\n                            result += 1\\n                            break\\n                if j==l-2 and has_lcm==False:\\n                    return result\\n        if nums[-1]==k: result += 1 ## edge\\n        return result    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810469,
                "title": "java-2-solutions",
                "content": "### **Please Upvote** :D\\n##### Approach 1:\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            int currLcm = nums[i];\\n\\n            for(int j = i; j < n; j++) {\\n                currLcm = lcm(currLcm, nums[j]);\\n                if (currLcm == k) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int lcm(int a, int b) {\\n        if (a == 0 || b == 0) return 0;\\n\\n        int absNumber1 = Math.abs(a);\\n        int absNumber2 = Math.abs(b);\\n\\n        int absHigherNumber = Math.max(absNumber1, absNumber2);\\n        int absLowerNumber = Math.min(absNumber1, absNumber2);\\n\\n        int lcm = absHigherNumber;\\n\\n        while (lcm % absLowerNumber != 0) {\\n            lcm += absHigherNumber;\\n        }\\n\\n        return lcm;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### Approach 2:\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            int currLcm = nums[i];\\n\\n            for(int j = i; j < n; j++) {\\n                currLcm = lcm(currLcm, nums[j]);\\n                if (currLcm == k) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int lcm(int a, int b) {\\n        return a * b / gcd(a, b);\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            int currLcm = nums[i];\\n\\n            for(int j = i; j < n; j++) {\\n                currLcm = lcm(currLcm, nums[j]);\\n                if (currLcm == k) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int lcm(int a, int b) {\\n        if (a == 0 || b == 0) return 0;\\n\\n        int absNumber1 = Math.abs(a);\\n        int absNumber2 = Math.abs(b);\\n\\n        int absHigherNumber = Math.max(absNumber1, absNumber2);\\n        int absLowerNumber = Math.min(absNumber1, absNumber2);\\n\\n        int lcm = absHigherNumber;\\n\\n        while (lcm % absLowerNumber != 0) {\\n            lcm += absHigherNumber;\\n        }\\n\\n        return lcm;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            int currLcm = nums[i];\\n\\n            for(int j = i; j < n; j++) {\\n                currLcm = lcm(currLcm, nums[j]);\\n                if (currLcm == k) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int lcm(int a, int b) {\\n        return a * b / gcd(a, b);\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810211,
                "title": "java-o-n-2-100-faster-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we have to simply calculate lcm of every possible sub-array and check if it equal to ```k```. \\n\\n- If yes, increment ```count```.\\n- Else if the lcm becomes greater than ```k```, we have to increment the sub-array\\'s first index to next position.\\n\\n**NOTE** -> To calculate lcm, we\\'ll use the following formula -> ```lcm(a,b) = (a*b) / gcd(a,b)```\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ - **Beats 100%**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(max(nums[i]))$$ - **Beats 92%** -> *Extra Space will be utilized for call stack $$(recursion)$$.*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0, lcm = 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            lcm = 1;\\n            for(int j = i; j < nums.length; j++) {\\n                lcm = lcm(lcm, nums[j]);\\n                if(lcm == k) count++;\\n                else if(lcm > k) break;\\n            }\\n        }\\n        return count;\\n    }\\n    //calculate gcd of 2 numbers\\n    public static int gcd(int a, int b) {\\n        return a==0 ? b : gcd(b%a, a);\\n    }\\n    //calculate lcm of 2 numbers\\n    public static int lcm(int a, int b) {\\n        return (a*b) / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```k```\n```count```\n```k```\n```lcm(a,b) = (a*b) / gcd(a,b)```\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0, lcm = 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            lcm = 1;\\n            for(int j = i; j < nums.length; j++) {\\n                lcm = lcm(lcm, nums[j]);\\n                if(lcm == k) count++;\\n                else if(lcm > k) break;\\n            }\\n        }\\n        return count;\\n    }\\n    //calculate gcd of 2 numbers\\n    public static int gcd(int a, int b) {\\n        return a==0 ? b : gcd(b%a, a);\\n    }\\n    //calculate lcm of 2 numbers\\n    public static int lcm(int a, int b) {\\n        return (a*b) / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810036,
                "title": "c-lcm-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int lm=nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                lm=lcm(lm,nums[j]);\\n                if(lm==k)\\n                    ans++;\\n                if(lm>k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int lm=nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                lm=lcm(lm,nums[j]);\\n                if(lm==k)\\n                    ans++;\\n                if(lm>k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810026,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            return math.gcd(a,b)\\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        c=0\\n        for i in range(len(nums)):\\n            d=nums[i]\\n            for j in range(i,len(nums)):\\n                d=lcm(d,nums[j])\\n                if d==k:\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            return math.gcd(a,b)\\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        c=0\\n        for i in range(len(nums)):\\n            d=nums[i]\\n            for j in range(i,len(nums)):\\n                d=lcm(d,nums[j])\\n                if d==k:\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809883,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long gcd(long long int a, long long int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    long long lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n    int subarrayLCM(vector<int> &nums, int k)\\n    {\\n        int cnt = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int l = 1;\\n            for (int j = i; j < n; j++)\\n            {\\n                l = lcm(l, nums[j]);\\n                if (l == k)\\n                    cnt++;\\n                if (l > k)\\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long gcd(long long int a, long long int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    long long lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n    int subarrayLCM(vector<int> &nums, int k)\\n    {\\n        int cnt = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int l = 1;\\n            for (int j = i; j < n; j++)\\n            {\\n                l = lcm(l, nums[j]);\\n                if (l == k)\\n                    cnt++;\\n                if (l > k)\\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809702,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            l = nums[i]\\n            for j in range(i,len(nums)):\\n                l = lcm(l,nums[j])\\n                if l > k:\\n                    break\\n                if l == k:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            l = nums[i]\\n            for j in range(i,len(nums)):\\n                l = lcm(l,nums[j])\\n                if l > k:\\n                    break\\n                if l == k:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809410,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince this is a subarray question with demands of simultaneous checking of lcm==k, the first thing that came into my mind was that it would require two loops and I would calculate gcd through euclid\\'s division method and lcm by the formula lcm=a*b/gcd(a,b);\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep in mind that lcm of three numbers=lcm(a,b)\\nwhere a=lcm of any two numbers out of the three numbers\\nb=the third number\\n\\nwith that said we would go through all the possible subarrays(the method to go through all the subarrays for 0->n (i) then for i->n (j) )  and would calculate lcm throughout by the above mentioned intuition.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(log(min(a,b)*n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(log(min(a,b))\\n# Code\\n```\\nclass Solution {\\n    static int lcm(int a,int b){\\nreturn a*b/gcd(a,b);\\n    }\\n    static int gcd(int a,int b){\\n\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            int g=-1;\\n            for(int j=i;j<nums.length;j++){\\nif(g==-1){\\n    g=nums[j];\\n}else{\\n    g=lcm(g,nums[j]);\\n}if(g==k){\\n    cnt++;\\n}\\nif(g>k){\\n    break;\\n}\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    static int lcm(int a,int b){\\nreturn a*b/gcd(a,b);\\n    }\\n    static int gcd(int a,int b){\\n\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            int g=-1;\\n            for(int j=i;j<nums.length;j++){\\nif(g==-1){\\n    g=nums[j];\\n}else{\\n    g=lcm(g,nums[j]);\\n}if(g==k){\\n    cnt++;\\n}\\nif(g>k){\\n    break;\\n}\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809120,
                "title": "python-simple-solution-for-beginner",
                "content": "**Time Complexity**: \\nO( n^2 log 1000 ) ~ O( n^2 )\\n\\nn^2 for nested two-level loops\\nlog 1000 for computation cost on gcd(x, y)\\n\\nNote: 1000 is the maximal input upperbound, defined in description\\n\\n\\n**Space Complexity**: \\nO( log 1000 ) ~ O( 1 )\\n\\nFor recursion stack depth in gcd(x, y)\\n\\n---\\n\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        \"\"\"\\n        Basic formula for gcd and lcm for any positive number x, y\\n        \\n        \\n        x * y = GCD(x, y) * LCM(x, y)\\n        \\n        and gcd(x, y) is a python standard library function\\n        \\n        \"\"\"\\n        \\n        \\n        def getLCM(x, y):\\n            \\n            return x * y // gcd(x, y)\\n        \\n        \\n        #-------------------------------------------\\n        \\n        count = 0\\n        \\n\\t\\t# scan each possible interval [i, j] inclusively, and catch valid subarray with interval LCM = K\\n        for i in range(len(nums)):\\n            \\n            curLCM = nums[i]\\n            \\n            for j in range(i, len(nums)):\\n                \\n                curLCM = getLCM(curLCM, nums[j] )\\n                \\n                if curLCM == k:\\n                    count += 1\\n                \\n                if curLCM > k:\\n                    # Early stop unnecessary iterations, beacuse current LCM grows larger than k\\n                    break\\n                    \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        \"\"\"\\n        Basic formula for gcd and lcm for any positive number x, y\\n        \\n        \\n        x * y = GCD(x, y) * LCM(x, y)\\n        \\n        and gcd(x, y) is a python standard library function\\n        \\n        \"\"\"\\n        \\n        \\n        def getLCM(x, y):\\n            \\n            return x * y // gcd(x, y)\\n        \\n        \\n        #-------------------------------------------\\n        \\n        count = 0\\n        \\n\\t\\t# scan each possible interval [i, j] inclusively, and catch valid subarray with interval LCM = K\\n        for i in range(len(nums)):\\n            \\n            curLCM = nums[i]\\n            \\n            for j in range(i, len(nums)):\\n                \\n                curLCM = getLCM(curLCM, nums[j] )\\n                \\n                if curLCM == k:\\n                    count += 1\\n                \\n                if curLCM > k:\\n                    # Early stop unnecessary iterations, beacuse current LCM grows larger than k\\n                    break\\n                    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809097,
                "title": "beginner-friendly-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long num1, long long num2){\\n    long long  temp, lcm, gcd;\\n    long long a = num1;  \\n    long long b = num2;      \\n    while (num2 != 0)  \\n     {  \\n        temp = num2;  \\n        num2 = num1 % num2;  \\n        num1 = temp;  \\n    }  \\n       \\n    gcd = num1;  \\n    lcm = (a * b) / gcd;\\n    return lcm;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int currlcm, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            currlcm = nums[i];\\n           for(int j = i; j < nums.size(); j++){\\n                   currlcm = lcm(currlcm, nums[j]);\\n                   if(currlcm == k){\\n                       cnt++;\\n                   }  \\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long num1, long long num2){\\n    long long  temp, lcm, gcd;\\n    long long a = num1;  \\n    long long b = num2;      \\n    while (num2 != 0)  \\n     {  \\n        temp = num2;  \\n        num2 = num1 % num2;  \\n        num1 = temp;  \\n    }  \\n       \\n    gcd = num1;  \\n    lcm = (a * b) / gcd;\\n    return lcm;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int currlcm, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            currlcm = nums[i];\\n           for(int j = i; j < nums.size(); j++){\\n                   currlcm = lcm(currlcm, nums[j]);\\n                   if(currlcm == k){\\n                       cnt++;\\n                   }  \\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808993,
                "title": "easy-100-java-solution-with-explanation",
                "content": "**Hey guy you are really determined and hardworking . One day you will become the best coder in the world all the best \\uD83D\\uDE03**\\n\\'\\'\\'\\nclass Solution {\\n\\n     int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n     \\n    // method to return LCM of two numbers\\n     int LCM(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int currLCM = nums[i];\\n            if(currLCM == k) // if element is equal to k, increment answer\\n                ans++;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if(nums[j] > k) // if nums[j] > k lcm can never be equal to k for this subarray\\n                    break;\\n                currLCM = LCM(nums[j], currLCM);\\n                if (currLCM == k)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\'\\'\\'\\n**Please upvote \\uD83D\\uDC4D**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n     int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2808943,
                "title": "beginners-approach",
                "content": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def find_lcm(num1, num2):\\n            if(num1>num2):\\n                num = num1\\n                den = num2\\n            else:\\n                num = num2\\n                den = num1\\n            rem = num % den\\n            while(rem != 0):\\n                num = den\\n                den = rem\\n                rem = num % den\\n            gcd = den\\n            lcm = int(int(num1 * num2)/int(gcd))\\n            return lcm\\n        count=0\\n        for i in range(len(nums)):\\n            lcm=1\\n            for j in range(i,len(nums)):\\n                lcm=find_lcm(nums[j],lcm)\\n                \\n                if lcm==k:\\n                    count+=1\\n                if lcm>k:\\n                    break\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def find_lcm(num1, num2):\\n            if(num1>num2):\\n                num = num1\\n                den = num2\\n            else:\\n                num = num2\\n                den = num1\\n            rem = num % den\\n            while(rem != 0):\\n                num = den\\n                den = rem\\n                rem = num % den\\n            gcd = den\\n            lcm = int(int(num1 * num2)/int(gcd))\\n            return lcm\\n        count=0\\n        for i in range(len(nums)):\\n            lcm=1\\n            for j in range(i,len(nums)):\\n                lcm=find_lcm(nums[j],lcm)\\n                \\n                if lcm==k:\\n                    count+=1\\n                if lcm>k:\\n                    break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808886,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int subarrayLCM(vector<int>&v, int k) {\\n        ll n=v.size(), ans=0;\\n        for(ll i=0;i<n;++i){\\n            ll lcm=v[i];\\n            for(ll j=i;j<n && lcm<=k;++j){\\n                ll gcd=__gcd(ll(v[j]), lcm), prod=lcm*v[j];\\n                lcm=prod/gcd;\\n                ans+=(lcm==k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int subarrayLCM(vector<int>&v, int k) {\\n        ll n=v.size(), ans=0;\\n        for(ll i=0;i<n;++i){\\n            ll lcm=v[i];\\n            for(ll j=i;j<n && lcm<=k;++j){\\n                ll gcd=__gcd(ll(v[j]), lcm), prod=lcm*v[j];\\n                lcm=prod/gcd;\\n                ans+=(lcm==k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808875,
                "title": "using-lcm-property",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=nums[i];\\n            if(l==k)\\n               res++;\\n            for(int j=i+1;j<n;j++)\\n            {\\n              l=(l*nums[j])/__gcd(l,nums[j]);\\n                if(l==k)\\n                    res++;\\n                if(l>k)\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n//   lcm(a,b)=(a*b)/gcd(a,b) using this property\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=nums[i];\\n            if(l==k)\\n               res++;\\n            for(int j=i+1;j<n;j++)\\n            {\\n              l=(l*nums[j])/__gcd(l,nums[j]);\\n                if(l==k)\\n                    res++;\\n                if(l>k)\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n//   lcm(a,b)=(a*b)/gcd(a,b) using this property\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808870,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int l = nums[i];\\n            if(l == k) count++;\\n            for(int j=i+1; j<nums.length; j++) {\\n                l = lcm(l, nums[j]);\\n                if(l == k) count++;\\n                if(l > k) break;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int lcm(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a%b == 0) {\\n            return b;\\n        }\\n        return gcd(b, a%b);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int l = nums[i];\\n            if(l == k) count++;\\n            for(int j=i+1; j<nums.length; j++) {\\n                l = lcm(l, nums[j]);\\n                if(l == k) count++;\\n                if(l > k) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2808815,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int result = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;        \\n        for (int i = 0; i < nums.length; i++) {\\n            int lcm = 1;\\n            for (int j = i; j < nums.length; j++) {\\n                lcm = getLcm(lcm, nums[j]);\\n                if (lcm == k) {\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    public int getLcm(int a, int b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n    public int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int result = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;        \\n        for (int i = 0; i < nums.length; i++) {\\n            int lcm = 1;\\n            for (int j = i; j < nums.length; j++) {\\n                lcm = getLcm(lcm, nums[j]);\\n                if (lcm == k) {\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    public int getLcm(int a, int b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n    public int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808811,
                "title": "c-gcd-simple-approach",
                "content": "```\\n// finds the lcm of two number\\n    int lcm(int a, int b)\\n    {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++){\\n\\n            // temp for storing running lcm\\n            int temp = nums[i];\\n            for(int j = i; j<n; j++){\\n\\n                temp = lcm(temp, nums[j]);\\n                if(temp == k){\\n                    ans++;\\n                }\\n                // LCM of two numbers cannot be less than the max(a, b) \\n                // so if the running lcm is greater than k break the loop\\n                else if(temp>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// finds the lcm of two number\\n    int lcm(int a, int b)\\n    {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++){\\n\\n            // temp for storing running lcm\\n            int temp = nums[i];\\n            for(int j = i; j<n; j++){\\n\\n                temp = lcm(temp, nums[j]);\\n                if(temp == k){\\n                    ans++;\\n                }\\n                // LCM of two numbers cannot be less than the max(a, b) \\n                // so if the running lcm is greater than k break the loop\\n                else if(temp>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067185,
                "title": "python3-following-the-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def gcd(a, b):\\n            if b==0: return a\\n            return gcd(b, a%b)\\n        N = len(nums)\\n        ans = 0\\n        for i in range(N):\\n            cur = nums[i]\\n            for j in range(i, N):\\n                nxt = cur*nums[j] / gcd(cur, nums[j])\\n                if nxt == k:\\n                    ans+=1\\n                elif nxt > k:\\n                    break\\n                cur = nxt\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        def gcd(a, b):\\n            if b==0: return a\\n            return gcd(b, a%b)\\n        N = len(nums)\\n        ans = 0\\n        for i in range(N):\\n            cur = nums[i]\\n            for j in range(i, N):\\n                nxt = cur*nums[j] / gcd(cur, nums[j])\\n                if nxt == k:\\n                    ans+=1\\n                elif nxt > k:\\n                    break\\n                cur = nxt\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027258,
                "title": "c-with-formula",
                "content": "\\n\\n`Time complexity => n^2 * logn\\n`\\n\\n\\n---\\n\\n\\n**Formula**\\n\\n\\n\\nLCM of two numbers\\n\\n```\\n               (a*b)\\nLCM(a, b) =  -----------\\n              GCD(a, b)\\n```\\n\\n\\nLCM of three numbers\\n \\n```\\n                       LCM(a,b)* c\\n LCM(a, b, c) =  ------------------------\\n                    gcd( LCM(a,b), c )\\n\\n```\\n\\n\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a , int b)\\n    {\\n        return b == 0 ? a : gcd(b, a%b);\\n    }\\n    int lcm(int a, int b)\\n    {\\n        int c;\\n        //a should be greater than b when finding GCD\\n        if( b > a)\\n        {\\n            c = b;\\n            b = a;\\n            a = c;\\n        }\\n        return (a*b)/gcd(a, b);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0, n = nums.size(), currLcm;\\n        for(int i=0; i<n; i++)\\n        {\\n            currLcm = 1;\\n            for(int j=i; j<n; j++)\\n            {\\n               currLcm = lcm(currLcm, nums[j]); \\n                if(currLcm == k)\\n                    count++;\\n                if(currLcm > k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n               (a*b)\\nLCM(a, b) =  -----------\\n              GCD(a, b)\\n```\n```\\n                       LCM(a,b)* c\\n LCM(a, b, c) =  ------------------------\\n                    gcd( LCM(a,b), c )\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a , int b)\\n    {\\n        return b == 0 ? a : gcd(b, a%b);\\n    }\\n    int lcm(int a, int b)\\n    {\\n        int c;\\n        //a should be greater than b when finding GCD\\n        if( b > a)\\n        {\\n            c = b;\\n            b = a;\\n            a = c;\\n        }\\n        return (a*b)/gcd(a, b);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0, n = nums.size(), currLcm;\\n        for(int i=0; i<n; i++)\\n        {\\n            currLcm = 1;\\n            for(int j=i; j<n; j++)\\n            {\\n               currLcm = lcm(currLcm, nums[j]); \\n                if(currLcm == k)\\n                    count++;\\n                if(currLcm > k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004741,
                "title": "easy-cpp-solution-naive-approach-using-stl-gcd-function",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n            int j = i, gcd = nums[i];\\n            int tcnt = 0;\\n            while(j<nums.size()){\\n                gcd = (1LL*gcd*nums[j]) / (__gcd(gcd, nums[j]));\\n                if(nums[j] <= k){\\n                    if(gcd == k) tcnt++;\\n                }\\n                else break;\\n                j++;\\n            }\\n            cnt += tcnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n            int j = i, gcd = nums[i];\\n            int tcnt = 0;\\n            while(j<nums.size()){\\n                gcd = (1LL*gcd*nums[j]) / (__gcd(gcd, nums[j]));\\n                if(nums[j] <= k){\\n                    if(gcd == k) tcnt++;\\n                }\\n                else break;\\n                j++;\\n            }\\n            cnt += tcnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898834,
                "title": "c-easy-to-understand-lcm-of-c-stl",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int counti=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=1;\\n            for(int j=i;j<nums.size();j++){\\n                temp=lcm(temp,nums[j]);\\n                if(temp==k)counti++;\\n                if(temp>k)break;\\n            }\\n        }\\n        return counti;\\n    }\\n};\\n```\\n![vote.png](https://assets.leetcode.com/users/images/38d05cde-8ea4-4588-b829-c3e8ff3ab62f_1691836989.6650407.png)\\n",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int counti=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=1;\\n            for(int j=i;j<nums.size();j++){\\n                temp=lcm(temp,nums[j]);\\n                if(temp==k)counti++;\\n                if(temp>k)break;\\n            }\\n        }\\n        return counti;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887241,
                "title": "python-3",
                "content": "# Complexity\\n- Time complexity: O(N^2 * log(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n\\n        cnt = 0\\n        for i in range(len(nums)):\\n            tmp = nums[i]\\n            for j in range(i, len(nums)):\\n\\n                tmp = (tmp * nums[j]) // gcd(tmp, nums[j])\\n                if tmp == k:\\n                    cnt += 1\\n\\n                if tmp > k:\\n                    break\\n\\n        return cnt\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n\\n        cnt = 0\\n        for i in range(len(nums)):\\n            tmp = nums[i]\\n            for j in range(i, len(nums)):\\n\\n                tmp = (tmp * nums[j]) // gcd(tmp, nums[j])\\n                if tmp == k:\\n                    cnt += 1\\n\\n                if tmp > k:\\n                    break\\n\\n        return cnt\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839874,
                "title": "easy-solution-o-n-2-accepted-simply-calculate-lcm-from-gcd",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            __uint128_t lcm = nums[i];\\n            int _gcd = nums[i];\\n            for(int j=i;j<n;j++){\\n                _gcd = gcd(lcm,nums[j]);\\n                lcm = nums[j]*(lcm/_gcd);\\n                if(lcm==k){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            __uint128_t lcm = nums[i];\\n            int _gcd = nums[i];\\n            for(int j=i;j<n;j++){\\n                _gcd = gcd(lcm,nums[j]);\\n                lcm = nums[j]*(lcm/_gcd);\\n                if(lcm==k){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817772,
                "title": "number-of-subarrays-with-lcm-equal-to-k-easy-and-simple-approach",
                "content": "\\n\\n# Code\\n```\\n\\n    class Solution {\\npublic:\\n  \\n    int subarrayLCM(vector<int>& nums, int k) \\n    {\\n    int cnt = 0;\\n        \\n    int n = nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int c  = 1;\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = lcm(c, nums[j]);\\n\\n                if(c == k)\\n                {\\n                    cnt++;\\n                }\\n                if(c>k)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\n\\n    class Solution {\\npublic:\\n  \\n    int subarrayLCM(vector<int>& nums, int k) \\n    {\\n    int cnt = 0;\\n        \\n    int n = nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int c  = 1;\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = lcm(c, nums[j]);\\n\\n                if(c == k)\\n                {\\n                    cnt++;\\n                }\\n                if(c>k)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698875,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int l = nums[i];\\n            if(l == k) count++;\\n            for(int j=i+1; j<nums.length; j++) {\\n                l = lcm(l, nums[j]);\\n                if(l == k) count++;\\n                if(l > k) break;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int lcm(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a%b == 0) {\\n            return b;\\n        }\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int l = nums[i];\\n            if(l == k) count++;\\n            for(int j=i+1; j<nums.length; j++) {\\n                l = lcm(l, nums[j]);\\n                if(l == k) count++;\\n                if(l > k) break;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int lcm(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a%b == 0) {\\n            return b;\\n        }\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683799,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlease Upvote if useful\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)\\n\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n        size = len(nums)\\n        for ind in range(size) :\\n\\n            curLcm  = nums[ind]\\n\\n            for ind2 in range(ind, size) :\\n                curLcm = self.lcm(curLcm, nums[ind2])\\n                cnt += (curLcm  == k)\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)\\n\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        cnt = 0\\n        size = len(nums)\\n        for ind in range(size) :\\n\\n            curLcm  = nums[ind]\\n\\n            for ind2 in range(ind, size) :\\n                curLcm = self.lcm(curLcm, nums[ind2])\\n                cnt += (curLcm  == k)\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660289,
                "title": "java-using-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long gcd(long a,long b){\\n        if(b!=0){\\n            return gcd(b,a%b);\\n        }\\n        else{\\n            return a;\\n        }\\n    }\\n    public long lcm(long n1,long n2){\\n        long ans=(n1*n2)/gcd(n1,n2);\\n        return ans;\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            long curr=1;\\n            for(int j=i;j<nums.length;j++){\\n                curr=lcm(curr,(long)nums[j]);\\n                if(curr==k){\\n                    count++;\\n                }\\n                if(nums[j]>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gcd(long a,long b){\\n        if(b!=0){\\n            return gcd(b,a%b);\\n        }\\n        else{\\n            return a;\\n        }\\n    }\\n    public long lcm(long n1,long n2){\\n        long ans=(n1*n2)/gcd(n1,n2);\\n        return ans;\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            long curr=1;\\n            for(int j=i;j<nums.length;j++){\\n                curr=lcm(curr,(long)nums[j]);\\n                if(curr==k){\\n                    count++;\\n                }\\n                if(nums[j]>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621948,
                "title": "lcm-a-b-gcd-a-b-a-b",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get the LCM of two numbers use one condition i.e \\n$$a*b = LCM(a,b) *GCD(a,b)$$\\nThis principle we have to anyway to solve this problem. And now to find the GCD of two number we can use Euclidean principle which states that GCD doesnt change if the one of the number is replaced with the diffrence of those two numbers. And its implementation is given in the code. Have a look :)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every possible subarray, check if the lcm is equal to k and count number of such subarrays.\\nTo get the LCM of a sub array, assume first element itself is its lcm. (ofcourse 1st element will be lcm of subarray of size 1).\\nNow go on traversing the whole subarray updating the LCM and at any point of time if LCM exceeds `k` just break the loop because LCM never decreases , it always increases or stays same whatever may be the incoming element. Hence also compare whenever the LCM equals the given `k`, increase the count because LCM is matched for that particular subarray i.e from `i` to that particular `j`.\\n# Complexity\\n- Time complexity: $O((n^2)*log(max(nums)))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            int lcm = nums[i];\\n            if(lcm==k) count++;\\n            for(int j=i+1;j<n;j++){\\n                lcm = (lcm*nums[j])/gcd(lcm,nums[j]);\\n                if(lcm>k) break;\\n                if(lcm==k) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            int lcm = nums[i];\\n            if(lcm==k) count++;\\n            for(int j=i+1;j<n;j++){\\n                lcm = (lcm*nums[j])/gcd(lcm,nums[j]);\\n                if(lcm>k) break;\\n                if(lcm==k) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599480,
                "title": "dynamic-programming-solution-with-detailed-explanation",
                "content": "# Intuition\\nThe idea behind this solution is very simple. We simply iterate over all possible subarrays. For each subarray, we calculate the LCM of its items and keep track of the `count` variable, which we use to hold the number of subarrays satisfying the requirement.\\n\\n# Approach\\nIn order to efficiently calculate the LCM of many numbers, we need to know this property:\\n$$ LCM(a, b, c, ..) = LCM(a, LCM(b, LCM(c, ...))) $$\\n\\nThat means, if we know the LCM all items from index `i` to index `j`, we can easily calculate LCM of items from `i` to `j + 1` by using the same formula: \\n\\n$$ LCM[i, j + 1] = LCM[LCM[i , j], \\\\space nums[j + 1]] $$\\n\\nThis can be easily implemented using a 2D array `LCM` where `LCM[i][j]` denotes the LCM of subarray starting from `i` and ending at `j`.\\n\\nAlso, to avoid overflow with many multiplications performed, we can add a simply check. If `a > k` or `b > k` then `LCM(a, b) > k`, and we can simply ignore this case and avoid calculating the LCM.\\n\\n# Complexity\\n- Time complexity: $$O(N^2logM)$$ with $$N$$ being the size of the input array `nums` and $$M$$ being the maximum values of `nums[i]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ with $$N$$ being the size of the input array `nums` since we are using a 2D array to cache values.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc min(nums ...int64) int64 {\\n\\tmin := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num < min {\\n\\t\\t\\tmin = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n\\nfunc max(nums ...int64) int64 {\\n\\tmax := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num > max {\\n\\t\\t\\tmax = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn max\\n}\\n\\nfunc gcd(a int64, b int64) int64 {\\n\\tsmaller := min(a, b)\\n\\tlarger := max(a, b)\\n\\n\\tfor smaller > 0 {\\n\\t\\ttemp := smaller\\n\\t\\tsmaller = larger % smaller\\n\\t\\tlarger = temp\\n\\t}\\n\\n\\treturn larger\\n}\\n\\nfunc lcm(a int64, b int64) int64 {\\n\\treturn int64(a) / int64(gcd(a, b)) * int64(b)\\n}\\n\\nfunc subarrayLCM(nums []int, k int) int {\\n\\tcount := 0\\n\\tn := len(nums)\\n\\tlcmArray := make([][]int64, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tlcmArray[i] = make([]int64, n)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := i; j < n; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tlcmArray[i][j] = int64(nums[i])\\n\\t\\t\\t} else if lcmArray[i][j - 1] <= int64(k) && nums[j] <= k {\\n\\t\\t\\t\\tlcmArray[i][j] = lcm(lcmArray[i][j - 1], int64(nums[j]))\\n\\t\\t\\t}\\n\\n\\t\\t\\tif lcmArray[i][j] == int64(k) {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Dynamic Programming",
                    "Number Theory"
                ],
                "code": "```\\nfunc min(nums ...int64) int64 {\\n\\tmin := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num < min {\\n\\t\\t\\tmin = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n\\nfunc max(nums ...int64) int64 {\\n\\tmax := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num > max {\\n\\t\\t\\tmax = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn max\\n}\\n\\nfunc gcd(a int64, b int64) int64 {\\n\\tsmaller := min(a, b)\\n\\tlarger := max(a, b)\\n\\n\\tfor smaller > 0 {\\n\\t\\ttemp := smaller\\n\\t\\tsmaller = larger % smaller\\n\\t\\tlarger = temp\\n\\t}\\n\\n\\treturn larger\\n}\\n\\nfunc lcm(a int64, b int64) int64 {\\n\\treturn int64(a) / int64(gcd(a, b)) * int64(b)\\n}\\n\\nfunc subarrayLCM(nums []int, k int) int {\\n\\tcount := 0\\n\\tn := len(nums)\\n\\tlcmArray := make([][]int64, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tlcmArray[i] = make([]int64, n)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := i; j < n; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tlcmArray[i][j] = int64(nums[i])\\n\\t\\t\\t} else if lcmArray[i][j - 1] <= int64(k) && nums[j] <= k {\\n\\t\\t\\t\\tlcmArray[i][j] = lcm(lcmArray[i][j - 1], int64(nums[j]))\\n\\t\\t\\t}\\n\\n\\t\\t\\tif lcmArray[i][j] == int64(k) {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520257,
                "title": "simple-nested-loop-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint gcd(int a,int b){\\n    if(b==0){\\n        return a;\\n    }\\n    return  gcd(b,a%b);\\n}\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size(),ans=0;\\n        /*for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                ans++;\\n            }\\n        }*/\\n\\n        for(int i=0;i<n;i++){\\n            long long cur=nums[i];\\n            for(int j=i;j<n;j++){\\n                cur=((cur*1LL*nums[j])/gcd(cur,1LL*nums[j]));\\n                if(cur>k){\\n                    break;\\n                }\\n                if(cur==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint gcd(int a,int b){\\n    if(b==0){\\n        return a;\\n    }\\n    return  gcd(b,a%b);\\n}\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size(),ans=0;\\n        /*for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                ans++;\\n            }\\n        }*/\\n\\n        for(int i=0;i<n;i++){\\n            long long cur=nums[i];\\n            for(int j=i;j<n;j++){\\n                cur=((cur*1LL*nums[j])/gcd(cur,1LL*nums[j]));\\n                if(cur>k){\\n                    break;\\n                }\\n                if(cur==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513202,
                "title": "python-47-ms-solution",
                "content": "Most py solutions use more than 1s. It is too much...\\n\\nUsing a dictionary to record lcm up to current position.\\n\\nReset it when the current number is greater than k.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def subarrayLCM(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def gcd(a, b):\\n            return a if b == 0 else gcd(b, a % b)\\n\\n        mem = defaultdict(int)\\n        res = 0\\n\\n        for n in nums:\\n            if n > k:\\n                mem = defaultdict(int)\\n                continue\\n\\n            tmp = defaultdict(int)\\n            for key in mem:\\n                lcm = key * n / gcd(key, n)\\n                if lcm <= k:\\n                    tmp[lcm] += mem[key]\\n            mem = tmp\\n            mem[n] += 1\\n            res += mem[k]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subarrayLCM(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def gcd(a, b):\\n            return a if b == 0 else gcd(b, a % b)\\n\\n        mem = defaultdict(int)\\n        res = 0\\n\\n        for n in nums:\\n            if n > k:\\n                mem = defaultdict(int)\\n                continue\\n\\n            tmp = defaultdict(int)\\n            for key in mem:\\n                lcm = key * n / gcd(key, n)\\n                if lcm <= k:\\n                    tmp[lcm] += mem[key]\\n            mem = tmp\\n            mem[n] += 1\\n            res += mem[k]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509516,
                "title": "c-solution-faster-than-100-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int gcd(int a,int b) => (b == 0) ? a : gcd(b,a % b);\\n        int res = 0;\\n        for(int i = 0; i < nums.Length;i++){\\n            int lcm = nums[i];\\n            if(lcm == k) res++;\\n            for(int j = i + 1; j < nums.Length;j++){            \\n                lcm = (lcm /  gcd(lcm,nums[j])) *  nums[j];\\n                if(lcm > k) break;\\n                if(lcm == k) res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int gcd(int a,int b) => (b == 0) ? a : gcd(b,a % b);\\n        int res = 0;\\n        for(int i = 0; i < nums.Length;i++){\\n            int lcm = nums[i];\\n            if(lcm == k) res++;\\n            for(int j = i + 1; j < nums.Length;j++){            \\n                lcm = (lcm /  gcd(lcm,nums[j])) *  nums[j];\\n                if(lcm > k) break;\\n                if(lcm == k) res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473767,
                "title": "rust-solution",
                "content": "# Code\\n```\\nfn gcd(a: usize, b: usize) -> usize {\\n  if b == 0 {\\n    return a\\n  }\\n  gcd(b, a % b)\\n}\\n\\nfn lcm(a: usize, b: usize) -> usize {\\n  a * b / gcd(a, b)\\n}\\n\\nimpl Solution {\\n  pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {\\n    let n = nums.len();\\n    let k = k as usize;\\n    let mut result = 0;\\n    for i in 0..n {\\n      let mut temp = nums[i] as usize;\\n      let start = if temp == k {\\n        i\\n      } else {\\n        i+1\\n      };\\n\\n      for j in start..n {\\n        temp = lcm(temp, nums[j] as usize);\\n        if temp == k {\\n          result += 1;\\n        } else if k < temp {\\n          break\\n        }\\n        \\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn gcd(a: usize, b: usize) -> usize {\\n  if b == 0 {\\n    return a\\n  }\\n  gcd(b, a % b)\\n}\\n\\nfn lcm(a: usize, b: usize) -> usize {\\n  a * b / gcd(a, b)\\n}\\n\\nimpl Solution {\\n  pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {\\n    let n = nums.len();\\n    let k = k as usize;\\n    let mut result = 0;\\n    for i in 0..n {\\n      let mut temp = nums[i] as usize;\\n      let start = if temp == k {\\n        i\\n      } else {\\n        i+1\\n      };\\n\\n      for j in start..n {\\n        temp = lcm(temp, nums[j] as usize);\\n        if temp == k {\\n          result += 1;\\n        } else if k < temp {\\n          break\\n        }\\n        \\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3401305,
                "title": "gcd-lcm-beginner-friendly-c-solution",
                "content": "# Intuition\\nlcm of two numbers will be \\nlcm = a*b/gcd(a,b)\\nso now we are having the lcm and constraints are saying you can done it in O(N^2)\\nlcm of two values can not be reduced only can be increased .\\nlcm(6,3) = 6\\nlcm(6,3,9) = 9.\\n# Approach\\nlets take an example\\n{3,6,2,7,1}\\nfor 3\\nlcm will be 3 but it is not equal to k.\\nfor 3,6\\nlcm(3,6) = 6 = k ans++.\\nlcm(3,6,2) = 6 = k ans++.\\nlcm(3,6,2,7) = 42  > k since now it can not be reduced so break the inner loop.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2 * logN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n\\n            int lcm = 1;\\n            for(int j=i;j<n;j++){\\n                int gcd = __gcd(lcm,arr[j]);\\n                lcm = (lcm*arr[j])/gcd;\\n                if(lcm == k)ans++;\\n                if(lcm > k)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nupvote please.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n\\n            int lcm = 1;\\n            for(int j=i;j<n;j++){\\n                int gcd = __gcd(lcm,arr[j]);\\n                lcm = (lcm*arr[j])/gcd;\\n                if(lcm == k)ans++;\\n                if(lcm > k)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364926,
                "title": "c-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int a=1;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                a=(nums[j]*a)/(gcd(nums[j],a));\\n                if(a==k)\\n                c++;\\n                else if(a>k) break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int a=1;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                a=(nums[j]*a)/(gcd(nums[j],a));\\n                if(a==k)\\n                c++;\\n                else if(a>k) break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274512,
                "title": "golang-30-ms-2-7-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc gcd(a, b int) int {\\n\\tfor b != 0 {\\n\\t\\ta, b = b, a%b\\n\\t}\\n\\treturn a\\n}\\n\\nfunc lcm(a, b int) int {\\n\\treturn a * b / gcd(a, b)\\n}\\n\\nfunc subarrayLCM(nums []int, k int) int {\\n\\tvar result int\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] == k {\\n\\t\\t\\tresult++\\n\\t\\t}\\n\\t\\tl := nums[i]\\n\\t\\tfor j := i + 1; j < len(nums); j++ {\\n\\t\\t\\tl = lcm(l, nums[j])\\n\\t\\t\\tif l == k {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t} else if l > k {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc gcd(a, b int) int {\\n\\tfor b != 0 {\\n\\t\\ta, b = b, a%b\\n\\t}\\n\\treturn a\\n}\\n\\nfunc lcm(a, b int) int {\\n\\treturn a * b / gcd(a, b)\\n}\\n\\nfunc subarrayLCM(nums []int, k int) int {\\n\\tvar result int\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] == k {\\n\\t\\t\\tresult++\\n\\t\\t}\\n\\t\\tl := nums[i]\\n\\t\\tfor j := i + 1; j < len(nums); j++ {\\n\\t\\t\\tl = lcm(l, nums[j])\\n\\t\\t\\tif l == k {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t} else if l > k {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3187495,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            int num=nums[i];\\n            if(num==k){\\n                cnt++;\\n            }\\n            for(int j=i+1; j<n; j++){\\n                num=lcm(num, nums[j]);\\n                if(num==k){\\n                    cnt++;\\n                }\\n                if(num>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            int num=nums[i];\\n            if(num==k){\\n                cnt++;\\n            }\\n            for(int j=i+1; j<n; j++){\\n                num=lcm(num, nums[j]);\\n                if(num==k){\\n                    cnt++;\\n                }\\n                if(num>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181303,
                "title": "easy-solution-in-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int a=0,n=nums.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            int c=1;\\n            for(int j=i;j<n;j++)\\n            {\\n                c=task(c, nums[j]);\\n                a+=(c==k)?1:0;\\n            }\\n        }\\n        return a;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int task(int a, int b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int a=0,n=nums.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            int c=1;\\n            for(int j=i;j<n;j++)\\n            {\\n                c=task(c, nums[j]);\\n                a+=(c==k)?1:0;\\n            }\\n        }\\n        return a;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int task(int a, int b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157877,
                "title": "c-golang-math",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    int gcd(int m, int n) {\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\n    int lcm(int m, int n) {\\n        return (m * 1L * n) / gcd(m, n);\\n    }\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {  \\n            int val = nums[i];\\n            for(int j = i; j < nums.size(); j++) {\\n                val = lcm(val, nums[j]);\\n                if(val > k) break;\\n                if(val == k) {\\n                    ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc gcd(m, n int) int {\\n    if n == 0 {return m}\\n    return gcd(n, m % n)\\n}\\n\\nfunc lcm(m, n int) int {\\n    return (m * n) / gcd(m, n)\\n}\\n\\nfunc subarrayLCM(nums []int, k int) int {\\n    var ans int = 0\\n    for i := 0; i < len(nums); i++ {  \\n        var val int = nums[i]\\n        for j := i; j < len(nums); j++ {\\n            val = lcm(val, nums[j])\\n            if val > k {break}\\n            if val == k {\\n                ans++\\n            }\\n        }   \\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    int gcd(int m, int n) {\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\n    int lcm(int m, int n) {\\n        return (m * 1L * n) / gcd(m, n);\\n    }\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {  \\n            int val = nums[i];\\n            for(int j = i; j < nums.size(); j++) {\\n                val = lcm(val, nums[j]);\\n                if(val > k) break;\\n                if(val == k) {\\n                    ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc gcd(m, n int) int {\\n    if n == 0 {return m}\\n    return gcd(n, m % n)\\n}\\n\\nfunc lcm(m, n int) int {\\n    return (m * n) / gcd(m, n)\\n}\\n\\nfunc subarrayLCM(nums []int, k int) int {\\n    var ans int = 0\\n    for i := 0; i < len(nums); i++ {  \\n        var val int = nums[i]\\n        for j := i; j < len(nums); j++ {\\n            val = lcm(val, nums[j])\\n            if val > k {break}\\n            if val == k {\\n                ans++\\n            }\\n        }   \\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147191,
                "title": "c-brute-force-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:`O(n^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        \\n        int n = nums.size() , ans = 0;\\n        int i = 0 ;\\n\\n        while(i < n){\\n            int curr_lcm = 1 , j = i++;\\n            while(j<n && k%nums[j] == 0){\\n                curr_lcm = lcm(curr_lcm,nums[j++]);\\n                if(k == curr_lcm) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        \\n        int n = nums.size() , ans = 0;\\n        int i = 0 ;\\n\\n        while(i < n){\\n            int curr_lcm = 1 , j = i++;\\n            while(j<n && k%nums[j] == 0){\\n                curr_lcm = lcm(curr_lcm,nums[j++]);\\n                if(k == curr_lcm) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139135,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int lcm = nums[i];\\n            if(lcm == k) ans++;\\n            for (int j = i+1; j < nums.length; j++) {\\n                lcm = findLcm(lcm, nums[j]);\\n                if(lcm == k) ans++;\\n                if(lcm > k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    int findGcd(int x, int y) {\\n        if (x == 0)\\n            return y;\\n        return findGcd(y % x, x);\\n    }\\n\\n    int findLcm(int x, int y) {\\n        return (x / findGcd(x, y)) * y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int lcm = nums[i];\\n            if(lcm == k) ans++;\\n            for (int j = i+1; j < nums.length; j++) {\\n                lcm = findLcm(lcm, nums[j]);\\n                if(lcm == k) ans++;\\n                if(lcm > k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    int findGcd(int x, int y) {\\n        if (x == 0)\\n            return y;\\n        return findGcd(y % x, x);\\n    }\\n\\n    int findLcm(int x, int y) {\\n        return (x / findGcd(x, y)) * y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118168,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=nums[i];\\n            if(temp==k) cnt++;\\n            for(int j=i+1;j<nums.size();j++){\\n                temp=lcm(temp,nums[j]);\\n                if(temp==k) cnt++;\\n                if(temp>k) break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=nums[i];\\n            if(temp==k) cnt++;\\n            for(int j=i+1;j<nums.size();j++){\\n                temp=lcm(temp,nums[j]);\\n                if(temp==k) cnt++;\\n                if(temp>k) break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091736,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                temp=lcm(temp,nums[j]);\\n                if(temp==k) ans++;\\n                if(temp>k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                temp=lcm(temp,nums[j]);\\n                if(temp==k) ans++;\\n                if(temp>k) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080217,
                "title": "java-simple-solution-using-gcd",
                "content": "\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            int prev=1;\\n            for(int j=i;j<nums.length && prev<=k;j++){\\n                prev=findLCM(prev,nums[j]);\\n                res+=(prev==k) ? 1:0;\\n            }\\n        }\\n        return res;\\n    }\\n    int findLCM(int a, int b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            int prev=1;\\n            for(int j=i;j<nums.length && prev<=k;j++){\\n                prev=findLCM(prev,nums[j]);\\n                res+=(prev==k) ? 1:0;\\n            }\\n        }\\n        return res;\\n    }\\n    int findLCM(int a, int b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051580,
                "title": "readable-code-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            int c = nums[i];\\n            for (int j = i; j < nums.length; j++){\\n                c = lcm(c,nums[j]);\\n                if (c == k){\\n                    ans++;\\n                }\\n                if (c > k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if (a == 0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n\\n    public int lcm(int a,int b){\\n        return (a*b)/(gcd(a,b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            int c = nums[i];\\n            for (int j = i; j < nums.length; j++){\\n                c = lcm(c,nums[j]);\\n                if (c == k){\\n                    ans++;\\n                }\\n                if (c > k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if (a == 0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n\\n    public int lcm(int a,int b){\\n        return (a*b)/(gcd(a,b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051233,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) \\n    {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==k)\\n            {c++;}\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int a=__gcd(nums[i],nums[j]);\\n                nums[i]=(nums[i]*nums[j])/a;\\n                if(nums[i]>k)\\n                {\\n                    break;\\n                }\\n                if(nums[i]==k)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) \\n    {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==k)\\n            {c++;}\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int a=__gcd(nums[i],nums[j]);\\n                nums[i]=(nums[i]*nums[j])/a;\\n                if(nums[i]>k)\\n                {\\n                    break;\\n                }\\n                if(nums[i]==k)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031880,
                "title": "easy-c-approach",
                "content": "\\n\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] == k)\\n            {\\n                count++;\\n            }\\n            for(int j = i+1; j < nums.size(); j++)\\n            {\\n                int x = __gcd(nums[i], nums[j]);\\n                nums[i] = (nums[i]*nums[j])/x;\\n                if(nums[i] > k)\\n                {\\n                    break;\\n                }\\n                if(nums[i] == k)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\nHit the Reputation if this helps\\uD83D\\uDE00\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] == k)\\n            {\\n                count++;\\n            }\\n            for(int j = i+1; j < nums.size(); j++)\\n            {\\n                int x = __gcd(nums[i], nums[j]);\\n                nums[i] = (nums[i]*nums[j])/x;\\n                if(nums[i] > k)\\n                {\\n                    break;\\n                }\\n                if(nums[i] == k)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\nHit the Reputation if this helps\\uD83D\\uDE00\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017918,
                "title": "2470-number-of-subarrays-with-lcm-equal-to-k",
                "content": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        \\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==k) \\n                c++;\\n            int xx=0;\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                \\n                if(j==i+1)\\n                {  \\n                    xx=(nums[i]*nums[j])/gcd(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    xx = (xx*nums[j])/gcd(xx, nums[j]);\\n                }\\n                \\n                if(xx==k)\\n                    {\\n                       c++;\\n                    }\\n                else if(xx > k) \\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n    static int gcd(int a,int b)\\n    {\\n        int x=a;\\n        int y=b;\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        \\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==k) \\n                c++;\\n            int xx=0;\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                \\n                if(j==i+1)\\n                {  \\n                    xx=(nums[i]*nums[j])/gcd(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    xx = (xx*nums[j])/gcd(xx, nums[j]);\\n                }\\n                \\n                if(xx==k)\\n                    {\\n                       c++;\\n                    }\\n                else if(xx > k) \\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n    static int gcd(int a,int b)\\n    {\\n        int x=a;\\n        int y=b;\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986806,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        if (b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0, temp;\\n        int n= nums.size();\\n        for (int i=0; i<n; i++) {\\n            temp = nums[i];\\n            for (int j=i; j<n; j++) {\\n                int g = gcd(temp, nums[j]);\\n                temp = (temp * nums[j]) / g;\\n                if (temp > k) break;\\n                if (temp == k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        if (b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0, temp;\\n        int n= nums.size();\\n        for (int i=0; i<n; i++) {\\n            temp = nums[i];\\n            for (int j=i; j<n; j++) {\\n                int g = gcd(temp, nums[j]);\\n                temp = (temp * nums[j]) / g;\\n                if (temp > k) break;\\n                if (temp == k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937940,
                "title": "simple-java-solution-faster-than-90-users",
                "content": "```\\nclass Solution {\\n\\n    static int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int m = nums[i];\\n            int g = nums[i];\\n            int l = nums[i];\\n            if (l == k) {\\n                ans++;\\n            }\\n            for (int j = i + 1; j < nums.length; j++) {\\n                g = gcd(l, nums[j]);\\n                m = l * nums[j];\\n                l = m / g;\\n                if (l == k) {\\n                    ans++;\\n                } else if (l > k) {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int m = nums[i];\\n            int g = nums[i];\\n            int l = nums[i];\\n            if (l == k) {\\n                ans++;\\n            }\\n            for (int j = i + 1; j < nums.length; j++) {\\n                g = gcd(l, nums[j]);\\n                m = l * nums[j];\\n                l = m / g;\\n                if (l == k) {\\n                    ans++;\\n                } else if (l > k) {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931983,
                "title": "c",
                "content": "```\\nint findGCD(int a, int b){\\n    int M , m;\\n    if(a >= b){\\n        M = a;\\n        m = b;\\n    }\\n    else{\\n        M = b;\\n        m = a;\\n    }\\n    int tmp;\\n    while(m > 0){\\n        tmp = M % m;\\n        M = m;\\n        m = tmp;\\n    }\\n    return M;\\n}\\nint findLCM(int a, int b){\\n    int gcd = findGCD(a, b);\\n    \\n    return a * b / gcd;\\n}\\nint subarrayLCM(int* nums, int numsSize, int k){\\n    int n = numsSize;\\n    int ans = 0;\\n        \\n    for(int i = 0; i < n; i++)\\n    {\\n        int LCM = nums[i];\\n        if(LCM == k)\\n            ans++;\\n        if(nums[i] > k || k % nums[i] != 0)\\n            continue;\\n        for(int j = i+1; j < n; j++){\\n            LCM = findLCM(LCM, nums[j]);\\n            if(LCM == k)\\n                ans++;\\n            if(LCM > k)\\n                break;\\n        }\\n    }\\n    return ans;    \\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint findGCD(int a, int b){\\n    int M , m;\\n    if(a >= b){\\n        M = a;\\n        m = b;\\n    }\\n    else{\\n        M = b;\\n        m = a;\\n    }\\n    int tmp;\\n    while(m > 0){\\n        tmp = M % m;\\n        M = m;\\n        m = tmp;\\n    }\\n    return M;\\n}\\nint findLCM(int a, int b){\\n    int gcd = findGCD(a, b);\\n    \\n    return a * b / gcd;\\n}\\nint subarrayLCM(int* nums, int numsSize, int k){\\n    int n = numsSize;\\n    int ans = 0;\\n        \\n    for(int i = 0; i < n; i++)\\n    {\\n        int LCM = nums[i];\\n        if(LCM == k)\\n            ans++;\\n        if(nums[i] > k || k % nums[i] != 0)\\n            continue;\\n        for(int j = i+1; j < n; j++){\\n            LCM = findLCM(LCM, nums[j]);\\n            if(LCM == k)\\n                ans++;\\n            if(LCM > k)\\n                break;\\n        }\\n    }\\n    return ans;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930254,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        let mut ans = 0;\\n        let mut arr = Vec::new();\\n        let mut i0 = -1;\\n        for (i, &num) in nums.iter().enumerate() {\\n            if k % num > 0 {\\n                arr.clear();\\n                i0 = i as i32;\\n                continue;\\n            }\\n            arr.push(vec![num, i as i32]);\\n            let mut j = 0;\\n            for k in 0..arr.len() {\\n                arr[k][0] = arr[k][0] / gcd(arr[k][0], num) * num;\\n                if arr[k][0] != arr[j][0] {\\n                    j += 1;\\n                    arr[j] = arr[k].clone();\\n                } else {\\n                    arr[j][1] = arr[k][1];\\n                }\\n            }\\n            arr.truncate(j + 1);\\n            if arr[0][0] == k {\\n                ans += arr[0][1] - i0;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        let mut ans = 0;\\n        let mut arr = Vec::new();\\n        let mut i0 = -1;\\n        for (i, &num) in nums.iter().enumerate() {\\n            if k % num > 0 {\\n                arr.clear();\\n                i0 = i as i32;\\n                continue;\\n            }\\n            arr.push(vec![num, i as i32]);\\n            let mut j = 0;\\n            for k in 0..arr.len() {\\n                arr[k][0] = arr[k][0] / gcd(arr[k][0], num) * num;\\n                if arr[k][0] != arr[j][0] {\\n                    j += 1;\\n                    arr[j] = arr[k].clone();\\n                } else {\\n                    arr[j][1] = arr[k][1];\\n                }\\n            }\\n            arr.truncate(j + 1);\\n            if arr[0][0] == k {\\n                ans += arr[0][1] - i0;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2870919,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbrute force\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int cur_lcm = nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                cur_lcm = lcm(cur_lcm, nums[j]);\\n                if(cur_lcm == k)\\n                    ans++;\\n                else if(cur_lcm > k)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int lcm(int a, int b){\\n        return a / gcd(a, b) * b;\\n    }\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a%b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int cur_lcm = nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                cur_lcm = lcm(cur_lcm, nums[j]);\\n                if(cur_lcm == k)\\n                    ans++;\\n                else if(cur_lcm > k)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int lcm(int a, int b){\\n        return a / gcd(a, b) * b;\\n    }\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a%b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837767,
                "title": "c-with-custom-lcm-function-b",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo through each contiguous subarray (nested loop) and calculate LCM. If it is equal to K, increase the counter, else if value of LCM increase the K, no need to iterate nested loop(it will grow).  \\n\\n# Approach\\nBrute-force, custom LCM function until we reach constraints \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int cnt = 0, N = nums.Length;\\n        for (int i = 0; i < N; i++) {\\n            int curLcm = nums[i];\\n     \\n            for (int j = i; j < N; j++) {\\n                curLcm = GetLcm(curLcm, nums[j]);\\n                \\n                if (curLcm == k) {\\n                    cnt++;\\n                }\\n\\n                if(curLcm > k) break;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public int GetLcm(int a, int b) {\\n        int addA = a, addB = b;\\n        while (a <= 2000 && b <= 2000 && a != b) {\\n            if (a < b) a += addA;\\n            else b += addB;\\n        }\\n\\n        return a;\\n    }\\n}\\n\\n```\\n\\nUpdated with using `GCD`: \\n```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int cnt = 0, N = nums.Length;\\n        for (int i = 0; i < N; i++) {\\n            int curLcm = nums[i];\\n     \\n            for (int j = i; j < N; j++) {\\n                curLcm = curLcm * nums[j] / GCD(curLcm, nums[j]);\\n                \\n                if (curLcm == k) {\\n                    cnt++;\\n                }\\n\\n                if(curLcm > k) break;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public int GCD(int a, int b) {\\n        return b == 0 ? a : GCD(b, a % b);\\n    }  \\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int cnt = 0, N = nums.Length;\\n        for (int i = 0; i < N; i++) {\\n            int curLcm = nums[i];\\n     \\n            for (int j = i; j < N; j++) {\\n                curLcm = GetLcm(curLcm, nums[j]);\\n                \\n                if (curLcm == k) {\\n                    cnt++;\\n                }\\n\\n                if(curLcm > k) break;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public int GetLcm(int a, int b) {\\n        int addA = a, addB = b;\\n        while (a <= 2000 && b <= 2000 && a != b) {\\n            if (a < b) a += addA;\\n            else b += addB;\\n        }\\n\\n        return a;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int cnt = 0, N = nums.Length;\\n        for (int i = 0; i < N; i++) {\\n            int curLcm = nums[i];\\n     \\n            for (int j = i; j < N; j++) {\\n                curLcm = curLcm * nums[j] / GCD(curLcm, nums[j]);\\n                \\n                if (curLcm == k) {\\n                    cnt++;\\n                }\\n\\n                if(curLcm > k) break;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public int GCD(int a, int b) {\\n        return b == 0 ? a : GCD(b, a % b);\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835262,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums, k):\\n        n, count = len(nums), 0\\n\\n        for i in range(n):\\n            temp = nums[i]\\n            for j in range(i,n):\\n                temp = math.lcm(temp,nums[j])\\n                if temp == k:\\n                    count += 1\\n                elif temp > k:\\n                    break\\n\\n        return count\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums, k):\\n        n, count = len(nums), 0\\n\\n        for i in range(n):\\n            temp = nums[i]\\n            for j in range(i,n):\\n                temp = math.lcm(temp,nums[j])\\n                if temp == k:\\n                    count += 1\\n                elif temp > k:\\n                    break\\n\\n        return count\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833422,
                "title": "c-gcd",
                "content": "```\\npublic class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int res = 0, n = nums.Length;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = 1;\\n            for(int j = i; j < n && c <= k; j++)\\n            {\\n                c = Task(c, nums[j]);\\n                res += (c == k) ? 1 : 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int GCD(int a, int b)\\n        => b == 0 ? a : GCD(b, a % b);\\n    \\n    private int Task(int a, int b)\\n        => (a * b) / (GCD(a, b));\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int SubarrayLCM(int[] nums, int k) {\\n        int res = 0, n = nums.Length;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = 1;\\n            for(int j = i; j < n && c <= k; j++)\\n            {\\n                c = Task(c, nums[j]);\\n                res += (c == k) ? 1 : 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2833416,
                "title": "awesome-solution-in-js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function(nums, k) {\\n    let ans = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        let lcm = nums[i];\\n        if(lcm == k) ans++;\\n        for(var j = i + 1; j < nums.length; j++){\\n            lcm = LCM(lcm, nums[j]);\\n            if(lcm == k) ans++;\\n            if(lcm > k) break;\\n        }\\n    }\\n    return ans;\\n};\\n\\nconst GCD = function(a, b){\\n    return a % b == 0 ? b : GCD(b, a % b);\\n}\\n\\nconst LCM = function(a, b){\\n    return (a * b) / GCD(a, b);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function(nums, k) {\\n    let ans = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        let lcm = nums[i];\\n        if(lcm == k) ans++;\\n        for(var j = i + 1; j < nums.length; j++){\\n            lcm = LCM(lcm, nums[j]);\\n            if(lcm == k) ans++;\\n            if(lcm > k) break;\\n        }\\n    }\\n    return ans;\\n};\\n\\nconst GCD = function(a, b){\\n    return a % b == 0 ? b : GCD(b, a % b);\\n}\\n\\nconst LCM = function(a, b){\\n    return (a * b) / GCD(a, b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831889,
                "title": "python-solution-lcm-contest-question",
                "content": "```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            x=nums[i]\\n            for j in range(i,len(nums)):\\n                x=math.lcm(x,nums[j])\\n                if x==k:\\n                    c+=1\\n        return c\\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            x=nums[i]\\n            for j in range(i,len(nums)):\\n                x=math.lcm(x,nums[j])\\n                if x==k:\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2828569,
                "title": "python-more-efficient-gcd-based-solution-the-best",
                "content": "# Approach\\nWe divide $$k$$ by each $$n \\\\in \\\\text{nums}$$, and then look for subarrays with $$\\\\gcd=1$$, stopping on numbers that do not divide $$k$$.\\n\\nThe Best!\\n\\n# Complexity\\n- Time complexity: $$O(n^2 + n\\\\log k)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def subarrayLCM(self, nums: list[int], k: int) -> int:\\n        coprime_count = 0\\n\\n        for subarray_end, n in enumerate(nums):\\n            nums[subarray_end] = k // n if k % n == 0 else None\\n            running_gcd = 0\\n\\n            for subarray_start in reversed(range(subarray_end + 1)):\\n                if not nums[subarray_start]:\\n                    break\\n\\n                running_gcd = gcd(running_gcd, nums[subarray_start])\\n                coprime_count += running_gcd == 1\\n\\n        return coprime_count\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def subarrayLCM(self, nums: list[int], k: int) -> int:\\n        coprime_count = 0\\n\\n        for subarray_end, n in enumerate(nums):\\n            nums[subarray_end] = k // n if k % n == 0 else None\\n            running_gcd = 0\\n\\n            for subarray_start in reversed(range(subarray_end + 1)):\\n                if not nums[subarray_start]:\\n                    break\\n\\n                running_gcd = gcd(running_gcd, nums[subarray_start])\\n                coprime_count += running_gcd == 1\\n\\n        return coprime_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827275,
                "title": "number-of-subarrays-with-lcm-equal-to-k",
                "content": "```\\nclass Solution {\\npublic: // TC=O(N^2)  SC=O(1) \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            int first=nums[i];\\n            if(first==k) res++; bool flag=0;\\n            for(int j=i+1;j<nums.size();j++){\\n                int temp;\\n                if(!flag)\\n                temp=lcm(nums[j],first),flag=1;\\n                else temp=lcm(temp,nums[j]);\\n                if(temp==k) res++;\\n                if(temp>k) break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: // TC=O(N^2)  SC=O(1) \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            int first=nums[i];\\n            if(first==k) res++; bool flag=0;\\n            for(int j=i+1;j<nums.size();j++){\\n                int temp;\\n                if(!flag)\\n                temp=lcm(nums[j],first),flag=1;\\n                else temp=lcm(temp,nums[j]);\\n                if(temp==k) res++;\\n                if(temp>k) break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826939,
                "title": "try-all-subarrays-optimisation",
                "content": "Try all subarrays.\\n\\n**Optimisation:**\\nAs you calculate the LCM of more numbers, it can only become greater. Once it becomes greater than k, you know that any larger subarrays containing all the current elements will not work.\\n\\n**C++ Code:**\\n```\\nclass Solution {\\n    int findLCM(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = findLCM(curr, nums[j]);\\n                if (curr == k) \\n                    ans++;\\n                else if (curr > k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSimilar problem:\\nhttps://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/\\n\\n**C++ Code for GCD Problem:**\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = gcd(curr, nums[j]);\\n                if (curr == k)\\n                    ans++;\\n                else if (curr < k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int findLCM(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = findLCM(curr, nums[j]);\\n                if (curr == k) \\n                    ans++;\\n                else if (curr > k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = gcd(curr, nums[j]);\\n                if (curr == k)\\n                    ans++;\\n                else if (curr < k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826521,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int lcm = nums[i];\\n            if(lcm == k)    count++;\\n            for(int end = i + 1; end < nums.length; end++){\\n                int gcd = __gcd(lcm, nums[end]);\\n                lcm = (lcm * nums[end]) / gcd;\\n\\n                if(lcm > k) break;\\n                if(lcm == k)    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private int __gcd(int a, int b) { \\n        return b == 0? a:__gcd(b, a % b);    \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int lcm = nums[i];\\n            if(lcm == k)    count++;\\n            for(int end = i + 1; end < nums.length; end++){\\n                int gcd = __gcd(lcm, nums[end]);\\n                lcm = (lcm * nums[end]) / gcd;\\n\\n                if(lcm > k) break;\\n                if(lcm == k)    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private int __gcd(int a, int b) { \\n        return b == 0? a:__gcd(b, a % b);    \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824509,
                "title": "o-n-2-log-n-approach-clean-code-with-comments-simple-and-easy-intuitive-brute",
                "content": "**This passed bcoz of low constraints: N ranges to 1000 only, so 10^3 means - less than N^3 sol goes in. So ours is that only.**\\n```\\n//O(N^2 Log N ) Time O(1) xtra space\\nclass Solution {\\npublic:\\n    \\n    int LCM(int a, int b){\\n        \\n        long prod = a*b;\\n        return prod/__gcd(a,b); // O(logn) __gcd(a,b) builtin STL \\n        \\n    }\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int ctr = 0;\\n        \\n        //3,6,2,7,1\\n        //3    3,6   3,6,2    3,6,2,7 .....\\n        // 6,   6,2   6,2,7  ...... this way we generate all sub arrays\\n        //Here 2 points \\n        // lcm of subarray = [1 2 3] lcm of ( (lcm of 1 and 2 ) and 3 ) - j loop takes care of it\\n        \\n        for(int i=0; i<N; i++){\\n            int lcm = nums[i];\\n            if(lcm == k) ctr++; // 1 num is iteslf k case\\n            \\n            for(int j=i+1; j<N; j++){\\n                lcm = LCM(lcm, nums[j]);\\n                if(lcm == k) ctr++;\\n                if(lcm > k) break;\\n                // as lcm is gonna stay same or increase, never gonna decrease\\n                // so once u find its more than k, no point in extending that subarray. Instead go for next i, that is start point is changed to next  \\n            }\\n            \\n        }\\n        \\n        return ctr;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//O(N^2 Log N ) Time O(1) xtra space\\nclass Solution {\\npublic:\\n    \\n    int LCM(int a, int b){\\n        \\n        long prod = a*b;\\n        return prod/__gcd(a,b); // O(logn) __gcd(a,b) builtin STL \\n        \\n    }\\n    \\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int ctr = 0;\\n        \\n        //3,6,2,7,1\\n        //3    3,6   3,6,2    3,6,2,7 .....\\n        // 6,   6,2   6,2,7  ...... this way we generate all sub arrays\\n        //Here 2 points \\n        // lcm of subarray = [1 2 3] lcm of ( (lcm of 1 and 2 ) and 3 ) - j loop takes care of it\\n        \\n        for(int i=0; i<N; i++){\\n            int lcm = nums[i];\\n            if(lcm == k) ctr++; // 1 num is iteslf k case\\n            \\n            for(int j=i+1; j<N; j++){\\n                lcm = LCM(lcm, nums[j]);\\n                if(lcm == k) ctr++;\\n                if(lcm > k) break;\\n                // as lcm is gonna stay same or increase, never gonna decrease\\n                // so once u find its more than k, no point in extending that subarray. Instead go for next i, that is start point is changed to next  \\n            }\\n            \\n        }\\n        \\n        return ctr;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824249,
                "title": "python-a-dp-approach",
                "content": "# Intuition\\nKinda like the longest palindrome substring dp. For the new state to be valid you\\'ll need the values between the window to be valid too.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the LCM result after each calculation.\\ndp[i][j] = The LCM result of nums[i:j]\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n     \\n        n = len(nums)\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        result = 0\\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(i, n):\\n                \\n                temp = math.lcm(nums[i], nums[j])\\n                \\n                if i + 1 == j or i == j:\\n                    dp[i][j] = temp\\n                \\n                else:\\n                    dp[i][j] = math.lcm(temp, dp[i+1][j-1])\\n                \\n                if dp[i][j] == k:\\n                    result += 1\\n                       \\n                    \\n        return result\\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n     \\n        n = len(nums)\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        result = 0\\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(i, n):\\n                \\n                temp = math.lcm(nums[i], nums[j])\\n                \\n                if i + 1 == j or i == j:\\n                    dp[i][j] = temp\\n                \\n                else:\\n                    dp[i][j] = math.lcm(temp, dp[i+1][j-1])\\n                \\n                if dp[i][j] == k:\\n                    result += 1\\n                       \\n                    \\n        return result\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824140,
                "title": "c-simple",
                "content": "# Intuition\\nWe\\'ll try to generate subarrays and check for each subarray that the lcm == k or not\\n\\n# Approach\\nWe\\'ll try to generate subarrays and check for each subarray that the lcm == k and if lcm == k we\\'ll increase the count\\n\\n# Complexity\\n- Time complexity:\\n   O(n^2)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            int lcm = 1;\\n            for(int j=i;j<n;j++){\\n                lcm = (lcm * nums[j])/(__gcd(lcm, nums[j]));\\n                if(lcm == k)\\n                    count++;\\n\\n                //  Once lcm becomes greater than k, we know that any larger          .\\n                //  subarrays containing all the current elements will not work\\n                // bcoz lcm will more greater as subarray size increases\\n                if(lcm > k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            int lcm = 1;\\n            for(int j=i;j<n;j++){\\n                lcm = (lcm * nums[j])/(__gcd(lcm, nums[j]));\\n                if(lcm == k)\\n                    count++;\\n\\n                //  Once lcm becomes greater than k, we know that any larger          .\\n                //  subarrays containing all the current elements will not work\\n                // bcoz lcm will more greater as subarray size increases\\n                if(lcm > k)\\n                    break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823889,
                "title": "easy-to-understand-cpp-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n         int ans = 0;\\n         int n = nums.size();\\n        \\n         for(int  i= 0;i<n;i++){\\n             int temp = nums[i];\\n             for(int j =  i;j<n;j++){\\n                 temp = lcm(temp,nums[j]);\\n                 if(temp ==k){\\n                     ans++;\\n                 }\\n                 if(temp>k){\\n                     break;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n         int ans = 0;\\n         int n = nums.size();\\n        \\n         for(int  i= 0;i<n;i++){\\n             int temp = nums[i];\\n             for(int j =  i;j<n;j++){\\n                 temp = lcm(temp,nums[j]);\\n                 if(temp ==k){\\n                     ans++;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2821784,
                "title": "c-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int lcm=nums[i];\\n            if(lcm==k) ans++;\\n            \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                lcm=(lcm*nums[j])/(__gcd(lcm,nums[j]));\\n                if(lcm>k) break;\\n                if(lcm==k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n/*as the constrains are low so optmization does\\'t matters during contest and also the for finding subarrays we used two for loops insted of doing recursevly \\nTC = O(N^2) */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int lcm=nums[i];\\n            if(lcm==k) ans++;\\n            \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                lcm=(lcm*nums[j])/(__gcd(lcm,nums[j]));\\n                if(lcm>k) break;\\n                if(lcm==k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n/*as the constrains are low so optmization does\\'t matters during contest and also the for finding subarrays we used two for loops insted of doing recursevly \\nTC = O(N^2) */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821382,
                "title": "best-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n       int re=0;\\n       for(int i=0;i<nums.size();i++){\\n           for(int j=i;j<nums.size();j++){\\n          nums[i]=lcm(nums[i],nums[j]);\\n          if(nums[j]>k||nums[i]>k)break;\\n          if(nums[i]==k)re++;\\n\\n           }\\n       } return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n       int re=0;\\n       for(int i=0;i<nums.size();i++){\\n           for(int j=i;j<nums.size();j++){\\n          nums[i]=lcm(nums[i],nums[j]);\\n          if(nums[j]>k||nums[i]>k)break;\\n          if(nums[i]==k)re++;\\n\\n           }\\n       } return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821074,
                "title": "java-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0,l = nums.length;\\n        for(int i=0;i<l;i++){\\n            long currLcm = nums[i];\\n            if(currLcm==k)count++;\\n            for(int j = i+1;j<l;j++){\\n                currLcm = (nums[j] * currLcm)/gcd((long)nums[j],currLcm);\\n                if(currLcm==(long)k)count++;\\n            }\\n        }\\n        return count;\\n    }\\n    static long gcd(long a, long b)\\n    {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0,l = nums.length;\\n        for(int i=0;i<l;i++){\\n            long currLcm = nums[i];\\n            if(currLcm==k)count++;\\n            for(int j = i+1;j<l;j++){\\n                currLcm = (nums[j] * currLcm)/gcd((long)nums[j],currLcm);\\n                if(currLcm==(long)k)count++;\\n            }\\n        }\\n        return count;\\n    }\\n    static long gcd(long a, long b)\\n    {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820812,
                "title": "python-lcm-n-2-log-min-nums",
                "content": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        N = len(nums)\\n        res = 0\\n        \\n        def gcd(x,y):\\n            if x==0:\\n                return y\\n            return gcd(y%x, x)\\n        \\n        def lcm(x,y):\\n            return x*y//gcd(x,y)\\n        \\n        #TC: n^2*log(n) 1000*1000*10 = 10^7\\n        #SC: O(1)\\n        \\n        for i in range(N):\\n            curLCM = nums[i]\\n            if curLCM == k:\\n                res+=1\\n            for j in range(i+1, N):\\n                newAdd = nums[j]\\n                curLCM = lcm(curLCM, newAdd) \\n                if curLCM == k:\\n                    res+=1\\n                elif curLCM >k:\\n                    break    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        \\n        N = len(nums)\\n        res = 0\\n        \\n        def gcd(x,y):\\n            if x==0:\\n                return y\\n            return gcd(y%x, x)\\n        \\n        def lcm(x,y):\\n            return x*y//gcd(x,y)\\n        \\n        #TC: n^2*log(n) 1000*1000*10 = 10^7\\n        #SC: O(1)\\n        \\n        for i in range(N):\\n            curLCM = nums[i]\\n            if curLCM == k:\\n                res+=1\\n            for j in range(i+1, N):\\n                newAdd = nums[j]\\n                curLCM = lcm(curLCM, newAdd) \\n                if curLCM == k:\\n                    res+=1\\n                elif curLCM >k:\\n                    break    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820253,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) \\n    {\\n    int j=0,count=0,var=-1;\\n    for(int i=0;i<nums.length;i++) \\n    {\\n     if(nums[i]==k)\\n     {\\n         count++;\\n     } \\n     if(k%nums[i]==0)\\n     {\\n         if(var!=-1 && LCM(var,nums[i])==k)//3,6//6,2\\n         {\\n          count+=i-j;\\n         }\\n     var=nums[i];\\n     }\\n    else\\n    {\\n        j=i+1; \\n    }\\n    \\n    }\\n    return count;   \\n    }\\n\\n   static int GCD(int u, int v)\\n    {\\n        if (u == 0)\\n            return v;\\n        return GCD(v % u, u);\\n    }\\n \\n    // LCM of two numbers\\n    static int LCM(int u, int v)\\n    {\\n        return (u / GCD(u, v)) * v;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) \\n    {\\n    int j=0,count=0,var=-1;\\n    for(int i=0;i<nums.length;i++) \\n    {\\n     if(nums[i]==k)\\n     {\\n         count++;\\n     } \\n     if(k%nums[i]==0)\\n     {\\n         if(var!=-1 && LCM(var,nums[i])==k)//3,6//6,2\\n         {\\n          count+=i-j;\\n         }\\n     var=nums[i];\\n     }\\n    else\\n    {\\n        j=i+1; \\n    }\\n    \\n    }\\n    return count;   \\n    }\\n\\n   static int GCD(int u, int v)\\n    {\\n        if (u == 0)\\n            return v;\\n        return GCD(v % u, u);\\n    }\\n \\n    // LCM of two numbers\\n    static int LCM(int u, int v)\\n    {\\n        return (u / GCD(u, v)) * v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819655,
                "title": "c-lcm-solution",
                "content": "**Approach**\\n Go for each and every subarray in which find lcm if lcm of current length subarray is **greater than k** break for that subarray\\n \\n **C++ code**\\n ````\\n int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int g=-1;\\n            for(int j=i;j<n;j++){\\n                if(g==-1){\\n                    g=nums[j];\\n                    if(g==k){\\n                        ans++;\\n                    }\\n                    continue;\\n                }\\n                \\n                g=lcm(g,nums[j]);\\n                if(g==k){\\n                    ans++;\\n                }\\n                if(g>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n ````\\n **Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int g=-1;\\n            for(int j=i;j<n;j++){\\n                if(g==-1){\\n                    g=nums[j];\\n                    if(g==k){\\n                        ans++;\\n                    }\\n                    continue;\\n                }\\n                \\n                g=lcm(g,nums[j]);\\n                if(g==k){\\n                    ans++;\\n                }\\n                if(g>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819514,
                "title": "swift-o-n2",
                "content": "# Intuition: \\n\\n> There is a catch, once the LCM is gone past a number (i.e increased from) it will never decrese\\nno matter how many numbers to keep on adding\\nhence there is no point checking futher if LCM is already surpassed k\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {\\n        var ans = 0\\n        for i in 0 ..< nums.count {\\n            var prev = nums[i]\\n            for j in i ..< nums.count {\\n                \\n                let inLCM = lcm(prev, nums[j])\\n                \\n                ans += inLCM == k ? 1 : 0\\n\\n                prev = inLCM\\n\\n                // no point checking futher if LCM is already surpassed k\\n                if inLCM > k {\\n                    break\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n    private func hcf(_ a: Int, _ b: Int) -> Int {\\n        if b == 0 {\\n            return a\\n        }\\n        return hcf(b, a%b)\\n    }\\n\\n    private func lcm(_ a: Int, _ b: Int) -> Int {\\n        return (a * b) / hcf(a, b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {\\n        var ans = 0\\n        for i in 0 ..< nums.count {\\n            var prev = nums[i]\\n            for j in i ..< nums.count {\\n                \\n                let inLCM = lcm(prev, nums[j])\\n                \\n                ans += inLCM == k ? 1 : 0\\n\\n                prev = inLCM\\n\\n                // no point checking futher if LCM is already surpassed k\\n                if inLCM > k {\\n                    break\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n    private func hcf(_ a: Int, _ b: Int) -> Int {\\n        if b == 0 {\\n            return a\\n        }\\n        return hcf(b, a%b)\\n    }\\n\\n    private func lcm(_ a: Int, _ b: Int) -> Int {\\n        return (a * b) / hcf(a, b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818860,
                "title": "when-k-6-case1-nums-1-then-ans-is-0-case-1-6-ans-is-2-please-explain",
                "content": "If number of subarrays from [1,6] is 2 assuming they are [6], [1,6] how about [1] ?\\nAlso 1 divides 6 right so for nums=[1] and k=6 ans should be 1 ?\\nI am missing something obvious",
                "solutionTags": [],
                "code": "If number of subarrays from [1,6] is 2 assuming they are [6], [1,6] how about [1] ?\\nAlso 1 divides 6 right so for nums=[1] and k=6 ans should be 1 ?\\nI am missing something obvious",
                "codeTag": "Unknown"
            },
            {
                "id": 2818085,
                "title": "java-easy-solution-using-lcm-of-every-subarray",
                "content": "As the question suggests, find the LCM of every subarray and when subarray LCM equals to the K then it is required subarray.\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int temp = 1;\\n            for(int j=i;j<nums.length;j++){\\n                temp = lcm(nums[j],temp);\\n                if(temp == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int lcm (int x,int y ){\\n        int max =Math.max(x,y);\\n        if(x==0 || y ==0 ){\\n            return 0;\\n        }\\n        if(max%x==0 && max%y==0){\\n            return max;\\n        }\\n        return x*y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int temp = 1;\\n            for(int j=i;j<nums.length;j++){\\n                temp = lcm(nums[j],temp);\\n                if(temp == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int lcm (int x,int y ){\\n        int max =Math.max(x,y);\\n        if(x==0 || y ==0 ){\\n            return 0;\\n        }\\n        if(max%x==0 && max%y==0){\\n            return max;\\n        }\\n        return x*y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818074,
                "title": "simple-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    long long lcm(long long a,long long b) \\n    {\\n    return (a*b)/(__gcd(a,b));\\n    }\\n\\n    int subarrayLCM(vector<int>& a, int k) \\n    {\\n        int i,j,sum,count=0,n=a.size();\\n        for(i=0;i<n;i++) \\n        {\\n            sum=a[i];\\n            if(sum==k) count++;\\n            for(j=i+1;j<n;j++) \\n            {\\n                sum=lcm(sum,a[j]);\\n                if(sum==k) count++;\\n            }\\n        }\\n        \\n        return\\xA0count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long lcm(long long a,long long b) \\n    {\\n    return (a*b)/(__gcd(a,b));\\n    }\\n\\n    int subarrayLCM(vector<int>& a, int k) \\n    {\\n        int i,j,sum,count=0,n=a.size();\\n        for(i=0;i<n;i++) \\n        {\\n            sum=a[i];\\n            if(sum==k) count++;\\n            for(j=i+1;j<n;j++) \\n            {\\n                sum=lcm(sum,a[j]);\\n                if(sum==k) count++;\\n            }\\n        }\\n        \\n        return\\xA0count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817199,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\nLcm of (a, b) = (a*b) / gcd(a, b) \\nhere a*b can give overflow to overcome this one can do \\nLcm of (a, b) = (a/gcd(a, b))*b\\n\\n# Approach\\nfor each subarray find lcm \\nif lcm becomes equal to k then increment count \\nif lcm becomes greater than k then just break the loop \\nwhy breaking loop?\\nsince this is point where we have a subarray that\\'s lcm not equal to k and if it is greater than k then it will affect upcoming lcm with other numbers, the upcoming lcms will be greater than k\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gcd(long long int a, long long int b){\\n       if (b == 0)\\n           return a;\\n        return gcd(b, a % b);\\n      }\\n    long long lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            int currentlcm=nums[i];\\n            for(int j=i; j<n; j++){\\n                currentlcm=lcm(currentlcm, nums[j]);\\n                if(currentlcm==k){\\n                    cnt++;\\n                }\\n                if(currentlcm>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcd(long long int a, long long int b){\\n       if (b == 0)\\n           return a;\\n        return gcd(b, a % b);\\n      }\\n    long long lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            int currentlcm=nums[i];\\n            for(int j=i; j<n; j++){\\n                currentlcm=lcm(currentlcm, nums[j]);\\n                if(currentlcm==k){\\n                    cnt++;\\n                }\\n                if(currentlcm>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816662,
                "title": "python-brute-force-approach-easy-to-understand",
                "content": "```\\nimport math\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        ans=0\\n        for i in range(n):\\n            temp=nums[i]\\n            for j in range(i,n):\\n                a=nums[j]\\n                temp=math.lcm(temp,a)\\n                if temp==k:\\n                    ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        ans=0\\n        for i in range(n):\\n            temp=nums[i]\\n            for j in range(i,n):\\n                a=nums[j]\\n                temp=math.lcm(temp,a)\\n                if temp==k:\\n                    ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816550,
                "title": "brute-force-java",
                "content": "```\\n    private int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);    }\\n    public int subarrayLCM(int[] nums, int k) {\\n     int n=nums.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int lcm=nums[i];\\n            if(lcm==k)count++;\\n            for(int j=i+1;j<n;j++){\\n                int g=gcd(lcm,nums[j]);\\n                lcm=(lcm*nums[j])/g;\\n                if(lcm>k)break;\\n                if(lcm==k)count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);    }\\n    public int subarrayLCM(int[] nums, int k) {\\n     int n=nums.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int lcm=nums[i];\\n            if(lcm==k)count++;\\n            for(int j=i+1;j<n;j++){\\n                int g=gcd(lcm,nums[j]);\\n                lcm=(lcm*nums[j])/g;\\n                if(lcm>k)break;\\n                if(lcm==k)count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2815707,
                "title": "java-easy-solution-easy-to-think-clean-code",
                "content": "```\\nclass Solution {\\n    static int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    static int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int l = nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                if(lcm(l,nums[j])>k || k%lcm(l,nums[j])!=0 ){\\n                    break;\\n                }\\n                if(lcm(l,nums[j])==k){\\n                    l = lcm(l,nums[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    static int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2815405,
                "title": "javascript",
                "content": "\\n```\\nconst gcd = (a, b) => {\\n    [a, b] = a > b ? [a, b] : [b, a];\\n    while (b !== 0) [a, b] = [b, a % b];\\n    return a;\\n};\\n\\nconst lcm = (a, b) => (a / gcd(a, b)) * b;\\n\\nconst subarrayLCM = (nums, k) => {\\n    let res = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        let subarray_lcm = nums[i];\\n        for (let j = i; j < nums.length; j++) {\\n            subarray_lcm = lcm(subarray_lcm, nums[j]);\\n            if (subarray_lcm === k) res++;\\n            if (subarray_lcm > k) break;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst gcd = (a, b) => {\\n    [a, b] = a > b ? [a, b] : [b, a];\\n    while (b !== 0) [a, b] = [b, a % b];\\n    return a;\\n};\\n\\nconst lcm = (a, b) => (a / gcd(a, b)) * b;\\n\\nconst subarrayLCM = (nums, k) => {\\n    let res = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        let subarray_lcm = nums[i];\\n        for (let j = i; j < nums.length; j++) {\\n            subarray_lcm = lcm(subarray_lcm, nums[j]);\\n            if (subarray_lcm === k) res++;\\n            if (subarray_lcm > k) break;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2814921,
                "title": "js-o-n-2-array-indexof-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function(nums, k) {\\n    let last = 0;\\n    let res = 0;\\n    while(nums.indexOf(k, last) >=0 ) {\\n        const i = nums.indexOf(k, last);\\n        let l = i-1;\\n        let left = 0;\\n        while(l>= last && nums[l] < k  && (k % nums[l] === 0)) {\\n            left++;\\n            l--;\\n        }\\n        l = i+1;\\n        let right = 0;\\n        while(l < nums.length && nums[l] <= k && (k % nums[l] === 0)) {\\n            right++;\\n            l++;\\n        }\\n        last = i+1;\\n        res += 1 + right + left + left * right;\\n    }\\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayLCM = function(nums, k) {\\n    let last = 0;\\n    let res = 0;\\n    while(nums.indexOf(k, last) >=0 ) {\\n        const i = nums.indexOf(k, last);\\n        let l = i-1;\\n        let left = 0;\\n        while(l>= last && nums[l] < k  && (k % nums[l] === 0)) {\\n            left++;\\n            l--;\\n        }\\n        l = i+1;\\n        let right = 0;\\n        while(l < nums.length && nums[l] <= k && (k % nums[l] === 0)) {\\n            right++;\\n            l++;\\n        }\\n        last = i+1;\\n        res += 1 + right + left + left * right;\\n    }\\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2814754,
                "title": "c-lcm",
                "content": "* If considering the last element the current **lcm is equal to k** add the count of the previous element.\\n* If considering the last element the current **lcm is a factor of k** add the count of the previous to a map.\\n*  Do remember to swap the maps since with the cache map cause we don\\'t need the element which is not a factor of  k.\\n\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        //contains all the previous subarrays ending at (i-1)th element \\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(auto &i:nums){\\n            m[i]++;\\n            //since we always consider (i-1)th element\\n            unordered_map<int,int>m1;\\n            for(auto [d,cnt]:m){\\n                int cur=lcm(i,d);\\n                if(cur==k)ans+=cnt;\\n                if(k%cur==0){\\n                    m1[cur]++;\\n                }\\n            }\\n            swap(m,m1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        //contains all the previous subarrays ending at (i-1)th element \\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(auto &i:nums){\\n            m[i]++;\\n            //since we always consider (i-1)th element\\n            unordered_map<int,int>m1;\\n            for(auto [d,cnt]:m){\\n                int cur=lcm(i,d);\\n                if(cur==k)ans+=cnt;\\n                if(k%cur==0){\\n                    m1[cur]++;\\n                }\\n            }\\n            swap(m,m1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814483,
                "title": "simple-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n\\n        int res = 0;\\n        int[][] dp = new int[nums.length][nums.length];\\n        for(int start = 0; start < nums.length; start++){\\n            for(int end = start; end < nums.length; end++){\\n                int temp = 1;\\n               if(start == end) {\\n                   dp[start][end] = nums[start];\\n                   temp = dp[start][end];\\n               }\\n               else {\\n                   temp = dp[start][end-1];\\n                   temp = lcm(temp, nums[end]);\\n                   dp[start][end] = temp;\\n               }\\n              \\n                if(temp==k) res++;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n\\n\\n    private int lcm(int a, int b){\\n        return a*b/gcd(a,b);\\n    }\\n\\n    private int gcd(int a, int b){\\n        return a%b == 0 ? b : gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n\\n        int res = 0;\\n        int[][] dp = new int[nums.length][nums.length];\\n        for(int start = 0; start < nums.length; start++){\\n            for(int end = start; end < nums.length; end++){\\n                int temp = 1;\\n               if(start == end) {\\n                   dp[start][end] = nums[start];\\n                   temp = dp[start][end];\\n               }\\n               else {\\n                   temp = dp[start][end-1];\\n                   temp = lcm(temp, nums[end]);\\n                   dp[start][end] = temp;\\n               }\\n              \\n                if(temp==k) res++;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n\\n\\n    private int lcm(int a, int b){\\n        return a*b/gcd(a,b);\\n    }\\n\\n    private int gcd(int a, int b){\\n        return a%b == 0 ? b : gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814365,
                "title": "easy-to-understand-with-explanation-judge-me-and-give-feedback-please",
                "content": "# Intuition\\njust like other subarray ques have to check every combination so sliding window.\\n\\n# Approach\\nused sliding window with try n error for edge cases.\\n\\n# Complexity\\n- Time complexity:\\nO(n*k)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    static int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    static int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        int start = 0;\\n        //using sliding window so start will always be same if lcm is matching \\n        while(start<nums.length){\\n            int curr = nums[start];\\n        // as the no. itself can be equal to k(edge case for me)\\n            if(curr==k)\\n                count++;\\n        //creating subarray until lcm is wrong(if start is last element it wont work so its fine)\\n        for(int j = start+1;j<nums.length;j++){\\n            int lcm = lcm(curr,nums[j]);\\n        //if lcm is matched we continue the subarray by setting the curr = to the lcm of elemnts(as lcm is fo 2 no.)\\n        if(lcm == k ){\\n            count++;\\n            curr = lcm;\\n        }\\n        //edge case 1 doest effect the lcm so if its 1 we include it in the subarray 1 1 5 ,k = 5 ...count  =3 (as 1 1 5, 1 5, 5 is all valid)\\n        else if(lcm == 1)\\n            curr = lcm;\\n        else\\n            break;\\n    }\\n            start++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    static int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    static int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        int start = 0;\\n        //using sliding window so start will always be same if lcm is matching \\n        while(start<nums.length){\\n            int curr = nums[start];\\n        // as the no. itself can be equal to k(edge case for me)\\n            if(curr==k)\\n                count++;\\n        //creating subarray until lcm is wrong(if start is last element it wont work so its fine)\\n        for(int j = start+1;j<nums.length;j++){\\n            int lcm = lcm(curr,nums[j]);\\n        //if lcm is matched we continue the subarray by setting the curr = to the lcm of elemnts(as lcm is fo 2 no.)\\n        if(lcm == k ){\\n            count++;\\n            curr = lcm;\\n        }\\n        //edge case 1 doest effect the lcm so if its 1 we include it in the subarray 1 1 5 ,k = 5 ...count  =3 (as 1 1 5, 1 5, 5 is all valid)\\n        else if(lcm == 1)\\n            curr = lcm;\\n        else\\n            break;\\n    }\\n            start++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814199,
                "title": "java-100-faster-lcm-gcd",
                "content": "**TC - O(N^2)**\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int lcm = nums[i];\\n            for(int j=i; j<nums.length; j++){\\n                lcm = (lcm*nums[j])/(gcd(lcm, nums[j]));\\n                if(lcm==k) ans++;\\n                if(k%lcm!=0) break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int gcd(int a, int b){\\n        return b==0 ? a : gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int lcm = nums[i];\\n            for(int j=i; j<nums.length; j++){\\n                lcm = (lcm*nums[j])/(gcd(lcm, nums[j]));\\n                if(lcm==k) ans++;\\n                if(k%lcm!=0) break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int gcd(int a, int b){\\n        return b==0 ? a : gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814012,
                "title": "c-prd-a-b-lcm-a-b-gcd-a-b-its-just-maths-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;int lcm;\\n        for(int i=0;i<n;i++)\\n        {\\n            lcm=nums[i];\\n            if(lcm==k)\\n                ans++;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                lcm=(lcm*nums[j])/__gcd(lcm,nums[j]);  //Maths Property.\\n                if(lcm==k)\\n                    ans++;\\n                if(lcm>k)  // lcm is increasing and never decreases.So why to consider higher ones.\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nAN UPVOTE FROM YOUR SIDE IS HIGHLY APPRECIATED :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;int lcm;\\n        for(int i=0;i<n;i++)\\n        {\\n            lcm=nums[i];\\n            if(lcm==k)\\n                ans++;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                lcm=(lcm*nums[j])/__gcd(lcm,nums[j]);  //Maths Property.\\n                if(lcm==k)\\n                    ans++;\\n                if(lcm>k)  // lcm is increasing and never decreases.So why to consider higher ones.\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813877,
                "title": "easy-understanding-function-calling",
                "content": "```\\nclass Solution\\n{ \\n    public:\\n        int subarrayLCM(vector<int>& a, int k) \\n        {\\n            int res=0;\\n            for(int i=0;i<a.size();i++)\\n            {\\n                int c=a[i];\\n                for(int j=i;j<a.size();j++)\\n                {\\n                    c=(c/(long long)__gcd(c,a[j]))*a[j];\\n                    if(c==k)res++;\\n                }\\n            }\\n            return res;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{ \\n    public:\\n        int subarrayLCM(vector<int>& a, int k) \\n        {\\n            int res=0;\\n            for(int i=0;i<a.size();i++)\\n            {\\n                int c=a[i];\\n                for(int j=i;j<a.size();j++)\\n                {\\n                    c=(c/(long long)__gcd(c,a[j]))*a[j];\\n                    if(c==k)res++;\\n                }\\n            }\\n            return res;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813736,
                "title": "c-time-o-nlogk",
                "content": "**1. Reducing lcm calculating times.** \\nRecall the typical O(n^2) algorithm:\\n* loop for each element as the \\'beginning\\' num[i]\\n* from the \\'beginning\\' calculating the accumulated **LCM = lcm(LCM, num[j]), j = i, i+1, ...** until **k % num[j] != 0 or LCM > k**, and add the output results by the count which **LCM == k**\\n\\nNote that when **num[j] | k** and **LCM==k**, **lcm(LCM, num[j])** will remain to be k, so the calculation of \"consecutive k factors begin at num[j]\" can be pre-computed first. When LCM==k, we can directly add the consecutive number of k factors, instead of performing the lcm calculation forward.\\nThe code for this step is as followed:\\n```\\nclass Solution\\n{\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int output = 0;\\n        vector<int> k_factor_count(nums.size(), 0); //consecutive k factors numbers\\n        int count = 0, LCM, j;\\n        for (int i = (int)nums.size() - 1; i >= 0; i--)\\n        {\\n            if (k % nums[i] != 0) count = 0;\\n            else\\n            {\\n                count++;\\n                k_factor_count[i] = count;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (k_factor_count[i] == 0) continue;\\n            LCM = nums[i];\\n            j = i + 1;\\n            while (LCM < k && j < nums.size() && k_factor_count[j] != 0)\\n            {\\n                LCM = lcm(LCM, nums[j]);\\n                j++;\\n            }\\n            if (LCM < k && j == nums.size()) return output;\\n            if (LCM == k) output += k_factor_count[j - 1];\\n        }\\n        return output;\\n    }\\n};\\n```\\n**2. Further reducing lcm calculating times and reaching O(nlogk).** \\nThe above algorithm will still fall into O(n^2) for data like num=={3, 3, 3, 3, 3, 3, ..., 3, 6} and k = 6. Let\\'s denote **lcm (num[i], num[i+1], ..., num[h])** as **lcm_accum(i, h)**. Here we still assume num[i], num[i+1], ..., num[h] are k\\'s factors (if **k % num[...] != 0** we can directly stop here).\\nNote that when **lcm_accum(i, j) == lcm_accum(i+1, j)**, the remaining **lcm_accum(i+1, j+1), lcm_accum(i+1, j+2)...** should be the same as **lcm_accum(i, j+1), lcm_accum(i, j+2)...**, and we don\\'t have to do the calculation anymore.\\nSo we can set up a vector storing **lcm_accum(?, j)**, which is a vector sharing the same size with num. After calculating for num[i] beginning, the elements of the vector would be updated for num[i+1] until the first **lcm_accum(i, j) == lcm_accum(i+1, j)** moment, and the updating time for each lcm_accum element would be no more than the number of k\\'s factors, which should be **log k**.\\nThe code is as follows:\\n```\\nclass Solution\\n{\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int output = 0;\\n        vector<int> k_factor_count(nums.size(), 0); //consecutive k factors numbers\\n        int count = 0, j, temp;\\n        for (int i = (int)nums.size() - 1; i >= 0; i--)\\n        {\\n            if (k % nums[i] == 0)\\n            {\\n                count++;\\n                k_factor_count[i] = count;\\n            }\\n            else count = 0;\\n        }\\n        vector<int> LCM(nums.size(), 0);\\n        int last_count = 0;\\n        bool flag_duplicate = false;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (k_factor_count[i] == 0) continue;\\n            j = i;\\n            LCM[j] = nums[j];\\n            while (LCM[j] < k && j + 1 < nums.size() && k_factor_count[j + 1] != 0)\\n            {\\n                temp = lcm(LCM[j], nums[j + 1]);\\n                if (LCM[j + 1] == temp)\\n                {\\n                    flag_duplicate = true;\\n                    break;\\n                }\\n                LCM[j + 1] = temp;\\n                j++;\\n            }\\n            if (flag_duplicate) output += last_count;\\n            if (j == nums.size() - 1 && LCM[j] < k) return output;\\n            if (LCM[j] == k)\\n            {\\n                output += k_factor_count[j];\\n                last_count = k_factor_count[j];\\n            }\\n            else last_count = 0;\\n        }\\n        return output;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int output = 0;\\n        vector<int> k_factor_count(nums.size(), 0); //consecutive k factors numbers\\n        int count = 0, LCM, j;\\n        for (int i = (int)nums.size() - 1; i >= 0; i--)\\n        {\\n            if (k % nums[i] != 0) count = 0;\\n            else\\n            {\\n                count++;\\n                k_factor_count[i] = count;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (k_factor_count[i] == 0) continue;\\n            LCM = nums[i];\\n            j = i + 1;\\n            while (LCM < k && j < nums.size() && k_factor_count[j] != 0)\\n            {\\n                LCM = lcm(LCM, nums[j]);\\n                j++;\\n            }\\n            if (LCM < k && j == nums.size()) return output;\\n            if (LCM == k) output += k_factor_count[j - 1];\\n        }\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int output = 0;\\n        vector<int> k_factor_count(nums.size(), 0); //consecutive k factors numbers\\n        int count = 0, j, temp;\\n        for (int i = (int)nums.size() - 1; i >= 0; i--)\\n        {\\n            if (k % nums[i] == 0)\\n            {\\n                count++;\\n                k_factor_count[i] = count;\\n            }\\n            else count = 0;\\n        }\\n        vector<int> LCM(nums.size(), 0);\\n        int last_count = 0;\\n        bool flag_duplicate = false;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (k_factor_count[i] == 0) continue;\\n            j = i;\\n            LCM[j] = nums[j];\\n            while (LCM[j] < k && j + 1 < nums.size() && k_factor_count[j + 1] != 0)\\n            {\\n                temp = lcm(LCM[j], nums[j + 1]);\\n                if (LCM[j + 1] == temp)\\n                {\\n                    flag_duplicate = true;\\n                    break;\\n                }\\n                LCM[j + 1] = temp;\\n                j++;\\n            }\\n            if (flag_duplicate) output += last_count;\\n            if (j == nums.size() - 1 && LCM[j] < k) return output;\\n            if (LCM[j] == k)\\n            {\\n                output += k_factor_count[j];\\n                last_count = k_factor_count[j];\\n            }\\n            else last_count = 0;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813643,
                "title": "golang-simple-solution",
                "content": "```\\nfunc subarrayLCM(nums []int, k int) int {\\n\\tn := len(nums)\\n\\tresult := 0\\n\\tfor idx := range nums {\\n\\t\\ttempLCM := 1\\n\\t\\tfor jdx := idx; jdx < n; jdx++ {\\n\\t\\t\\ttempLCM = lcm2470(tempLCM, nums[jdx])\\n\\t\\t\\tif tempLCM == k {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc lcm2470(a, b int) int {\\n\\tlcm := (a * b) / gcd2470(a, b)\\n\\n\\treturn lcm\\n}\\n\\nfunc gcd2470(a, b int) int {\\n\\tif a == 0 {\\n\\t\\treturn b\\n\\t}\\n\\n\\treturn gcd2447(b%a, a)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subarrayLCM(nums []int, k int) int {\\n\\tn := len(nums)\\n\\tresult := 0\\n\\tfor idx := range nums {\\n\\t\\ttempLCM := 1\\n\\t\\tfor jdx := idx; jdx < n; jdx++ {\\n\\t\\t\\ttempLCM = lcm2470(tempLCM, nums[jdx])\\n\\t\\t\\tif tempLCM == k {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc lcm2470(a, b int) int {\\n\\tlcm := (a * b) / gcd2470(a, b)\\n\\n\\treturn lcm\\n}\\n\\nfunc gcd2470(a, b int) int {\\n\\tif a == 0 {\\n\\t\\treturn b\\n\\t}\\n\\n\\treturn gcd2447(b%a, a)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812982,
                "title": "python-solution-time-o-nlogk-o-n",
                "content": "This python solution follows the solution of 2447 [HERE](https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/discuss/2812875/Python-solution-or-Count-GCD-or-O(N)).\\n\\nYou can see that the code is ALMOST SAME except modifying gcd to lcm.\\n\\n```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n\\tpre, ans = defaultdict(int), 0\\n\\tfor n in nums:\\n\\t\\tcur = defaultdict(int)\\n\\t\\tif k%n==0: \\n\\t\\t\\tpre[n] += 1\\n\\t\\t\\tfor x in pre:\\n\\t\\t\\t\\tcur[lcm(x, n)] += pre[x]\\n\\t\\tans += cur[k]\\n\\t\\tpre = cur\\n\\treturn ans\\n```\\n\\nWhy the time is O(N)?\\n```\\nGiven previous lcm x and a new element, the lcm may keep the same OR \"change into AT LEAST x*2\".\\nMeanwhile, the lcm should be LESS or EQUAL to k.\\nAs a result, the size of \\'pre\\' in previous code will be \\'log(k)\\'.\\nThe max possible k will be 1000, so the max time for loop cost log(1000) = 3 - O(1) time! \\nSo the total time cost will be O(NlogK) = O(N)\\n```",
                "solutionTags": [],
                "code": "```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n\\tpre, ans = defaultdict(int), 0\\n\\tfor n in nums:\\n\\t\\tcur = defaultdict(int)\\n\\t\\tif k%n==0: \\n\\t\\t\\tpre[n] += 1\\n\\t\\t\\tfor x in pre:\\n\\t\\t\\t\\tcur[lcm(x, n)] += pre[x]\\n\\t\\tans += cur[k]\\n\\t\\tpre = cur\\n\\treturn ans\\n```\n```\\nGiven previous lcm x and a new element, the lcm may keep the same OR \"change into AT LEAST x*2\".\\nMeanwhile, the lcm should be LESS or EQUAL to k.\\nAs a result, the size of \\'pre\\' in previous code will be \\'log(k)\\'.\\nThe max possible k will be 1000, so the max time for loop cost log(1000) = 3 - O(1) time! \\nSo the total time cost will be O(NlogK) = O(N)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2812966,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> prime(){\\n        int n = 1000;\\n        vector<int> ans;\\n        vector<int> visit(1000,false);\\n        for(int i=2;i<1000;i++){\\n            if(!visit[i]){\\n                ans.push_back(i);\\n                for(int j=i*i;j<1000;j+=i) visit[j] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> func(vector<int> v1,int x){\\n        int n = v1.size();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            while(x%v1[i]==0) {\\n                x /= v1[i];\\n                cnt++;\\n            }\\n            freq[i] = cnt;\\n        }\\n        return freq;\\n    }\\n    void func1(vector<int>& v1, vector<int>& v2){\\n        for(int i=0;i<v1.size();i++) v1[i] =max(v1[i],v2[i]);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        vector<int> pr = prime();\\n        vector<int> v = func(pr,k);\\n        vector<vector<int>> mat;\\n        for(int i=0;i<nums.size();i++) mat.push_back(func(pr,nums[i]));\\n        for(int i=0;i<nums.size();i++){\\n            if(k%nums[i]!=0) continue;\\n            vector<int> v1 = mat[i];\\n            if(nums[i]==k) ans++;\\n            for(int j=i+1;j<nums.size() && k%nums[j]==0;j++){\\n                if(v1!=v){\\n                    vector<int> v2 = mat[j];\\n                    func1(v1,v2);\\n                }\\n                if(v1==v) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> prime(){\\n        int n = 1000;\\n        vector<int> ans;\\n        vector<int> visit(1000,false);\\n        for(int i=2;i<1000;i++){\\n            if(!visit[i]){\\n                ans.push_back(i);\\n                for(int j=i*i;j<1000;j+=i) visit[j] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> func(vector<int> v1,int x){\\n        int n = v1.size();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            while(x%v1[i]==0) {\\n                x /= v1[i];\\n                cnt++;\\n            }\\n            freq[i] = cnt;\\n        }\\n        return freq;\\n    }\\n    void func1(vector<int>& v1, vector<int>& v2){\\n        for(int i=0;i<v1.size();i++) v1[i] =max(v1[i],v2[i]);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        vector<int> pr = prime();\\n        vector<int> v = func(pr,k);\\n        vector<vector<int>> mat;\\n        for(int i=0;i<nums.size();i++) mat.push_back(func(pr,nums[i]));\\n        for(int i=0;i<nums.size();i++){\\n            if(k%nums[i]!=0) continue;\\n            vector<int> v1 = mat[i];\\n            if(nums[i]==k) ans++;\\n            for(int j=i+1;j<nums.size() && k%nums[j]==0;j++){\\n                if(v1!=v){\\n                    vector<int> v2 = mat[j];\\n                    func1(v1,v2);\\n                }\\n                if(v1==v) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812962,
                "title": "c-solution-very-simple-and-easy-solution-with-explanation",
                "content": "\\n# Code and ******If you like the solution - Up Vote it******\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int currentLCM = 1;\\n            for(int j=i;j<n;j++)\\n            {\\n                currentLCM = lcm(currentLCM,nums[j]);\\n                if(currentLCM ==k)\\n                {\\n                    ans++;\\n                }\\n                if(currentLCM>k)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int currentLCM = 1;\\n            for(int j=i;j<n;j++)\\n            {\\n                currentLCM = lcm(currentLCM,nums[j]);\\n                if(currentLCM ==k)\\n                {\\n                    ans++;\\n                }\\n                if(currentLCM>k)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812838,
                "title": "easy-c-solution-gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n         int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            int lcm = nums[i];\\n            if(lcm == k) cnt++;\\n            \\n            for(int j=i+1;j<n;j++){\\n                int gcd = __gcd(lcm,nums[j]);\\n                lcm = (lcm*nums[j])/gcd;\\n                if(lcm>k) break;\\n                if(lcm == k) cnt++;\\n          \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n         int n = nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            int lcm = nums[i];\\n            if(lcm == k) cnt++;\\n            \\n            for(int j=i+1;j<n;j++){\\n                int gcd = __gcd(lcm,nums[j]);\\n                lcm = (lcm*nums[j])/gcd;\\n                if(lcm>k) break;\\n                if(lcm == k) cnt++;\\n          \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812552,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] a, int k) {\\n        int count = 0, n = a.length;\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            for(int j = i; j < n; j++){\\n                int lcm = lcmOfArray(a, i, j+1, map);\\n                //System.out.println(\"i = \" + i + \" j = \" + j + \"lcm is \" + lcm);\\n                if (lcm == k){\\n                    count++;\\n                } else if (lcm > k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private int lcmOfArray(int[] a, int u, int v, Map<String,Integer> map){\\n        int n = a.length;\\n        String key = u + \"$\" + v;\\n        if (map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        if (u == v-1){\\n            map.put(key, a[u]);\\n            return map.get(key);\\n        }\\n        int fst = a[u];\\n        int lst = lcmOfArray(a, u+1, v, map);\\n        int lcm = (int)fst * lst / gcd(fst,lst);\\n        map.put(key, lcm);\\n        return map.get(key);\\n    }\\n    private int gcd(int u, int v){\\n        if (v == 0)\\n            return u;\\n        return gcd(v, u%v);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] a, int k) {\\n        int count = 0, n = a.length;\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            for(int j = i; j < n; j++){\\n                int lcm = lcmOfArray(a, i, j+1, map);\\n                //System.out.println(\"i = \" + i + \" j = \" + j + \"lcm is \" + lcm);\\n                if (lcm == k){\\n                    count++;\\n                } else if (lcm > k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private int lcmOfArray(int[] a, int u, int v, Map<String,Integer> map){\\n        int n = a.length;\\n        String key = u + \"$\" + v;\\n        if (map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        if (u == v-1){\\n            map.put(key, a[u]);\\n            return map.get(key);\\n        }\\n        int fst = a[u];\\n        int lst = lcmOfArray(a, u+1, v, map);\\n        int lcm = (int)fst * lst / gcd(fst,lst);\\n        map.put(key, lcm);\\n        return map.get(key);\\n    }\\n    private int gcd(int u, int v){\\n        if (v == 0)\\n            return u;\\n        return gcd(v, u%v);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812510,
                "title": "python-the-fastest-solution-i-guess",
                "content": "I got the very fast solution here.\\n\\nThe major weapon is downgrade the quantity.\\n\\nA) To this end, a fact should be pointed out:\\n  if a number is not a factor of k, it will make any subarray invalid.\\nBreak the array into pieces by remove them.\\nfor example, nums=[2,5,3,2] k =6\\n\\t6 % 5 == 1 ( this equals 5 is not a factor of 6)\\nremove 5, got [2],  [3,2] each of them is smaller then original array\\n\\nB) another fact:\\n if k is in the array, it will make any subarray valid.\\nfor example, nums=[2,6,3,2] k =6\\nIn this case, the array could be break into multiple arrayes\\n [2], [6], [3,2] I name them a, b, c\\nI classify them into 2 types, b is type of only a single k, a, c are type of non-k \\ncount the possible subarray from non-k ones, \\nthen count any subarray contains at least one k\\nAs when as there are any k, the cost will be saved.\\n\\nI use gcd instead  lcm. I like smaller numbers. \\nif a,b,c are all factors of k,\\n(lcm(a,b,c) == k)  equals (gcd(a,b,c) == 1)\\n\\uFF08proof ignore\\uFF09\\n\\nYes, after all of those breakdown, I use BP.\\n\\nfull code\\n```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int: \\n        def sLCM1(d):\\n            # all numbers in d are factors of k\\n            # no 1 in d\\n            if len(d) < 2:\\n                return 0\\n            i = k \\n            for j in d:\\n                i = gcd(i, j) \\n            if i != 1:\\n                return 0 \\n            res = 0\\n            c = Counter()\\n            for j in d:\\n                c1 = Counter()\\n                for i, v in c.items():\\n                    c1[gcd(i, j)] += v\\n                c1[j] += 1\\n                c = c1\\n                res += c[1]\\n            return res # \\'to be done\\'\\n        def sLCM(d):\\n            # all numbers in d are factors of k\\n            if  k == 1:\\n                return len(d) * (len(d) + 1) // 2\\n            if 1 not in d:\\n                return sLCM1(d)                \\n            res = 0\\n            a = 0\\n            q = 0\\n            t = []\\n            for i in d:\\n                if i == 1:\\n                    res += sLCM1(t)      \\n                    t = []\\n                    q += a + 1\\n                    a = 0\\n                else:\\n                    t.append(i)\\n                    a += 1\\n                res += q\\n            \\n            return res\\n        res = 0\\n        t = []\\n        for n in nums:\\n            if k % n == 0:\\n                t.append(k // n)\\n            elif t:\\n                res += sLCM(t)\\n                t = []\\n        else:\\n            if t:\\n                res += sLCM(t)\\n        return res\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int: \\n        def sLCM1(d):\\n            # all numbers in d are factors of k\\n            # no 1 in d\\n            if len(d) < 2:\\n                return 0\\n            i = k \\n            for j in d:\\n                i = gcd(i, j) \\n            if i != 1:\\n                return 0 \\n            res = 0\\n            c = Counter()\\n            for j in d:\\n                c1 = Counter()\\n                for i, v in c.items():\\n                    c1[gcd(i, j)] += v\\n                c1[j] += 1\\n                c = c1\\n                res += c[1]\\n            return res # \\'to be done\\'\\n        def sLCM(d):\\n            # all numbers in d are factors of k\\n            if  k == 1:\\n                return len(d) * (len(d) + 1) // 2\\n            if 1 not in d:\\n                return sLCM1(d)                \\n            res = 0\\n            a = 0\\n            q = 0\\n            t = []\\n            for i in d:\\n                if i == 1:\\n                    res += sLCM1(t)      \\n                    t = []\\n                    q += a + 1\\n                    a = 0\\n                else:\\n                    t.append(i)\\n                    a += 1\\n                res += q\\n            \\n            return res\\n        res = 0\\n        t = []\\n        for n in nums:\\n            if k % n == 0:\\n                t.append(k // n)\\n            elif t:\\n                res += sLCM(t)\\n                t = []\\n        else:\\n            if t:\\n                res += sLCM(t)\\n        return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812025,
                "title": "python-o-n-log-k-99ms-faster-than-100",
                "content": "Uses the following fact:\\n\\n![image](https://assets.leetcode.com/users/images/64b214ae-4f35-42e7-b8aa-60da1e5a649a_1668367254.926522.png)\\n\\n```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n        # special case for 1\\n        if k == 1:\\n            ret = 0\\n            cs = 0\\n            for i in nums:\\n                if i == 1:\\n                    cs += 1\\n                else:\\n                    ret += cs*(cs+1)//2\\n                    cs = 0\\n            ret += cs*(cs+1)//2\\n            return ret\\n        # prime factorization of k\\n        pfac = defaultdict(int)\\n        i = 2\\n        tk = k\\n        while i*i <= tk:\\n            while tk%i == 0:\\n                pfac[i] += 1\\n                tk //= i\\n            i += 1\\n        if tk != 1:\\n            pfac[tk] += 1\\n        # can get relevant prime factors of all other nums in log(k) \\n        # because we only care about prime factors of k (of which there are O(log(k)))\\n        def fac(n,p):\\n            k = 1\\n            while n%(p**k) == 0:\\n                k += 1\\n            return k - 1\\n        pfacs = [{p:fac(i,p) for p in pfac} for i in nums]\\n        # split array into segments where all nums can divide k \\n        # because these are the only ones that can be contained in a subarray with LCM k\\n        segments = []\\n        currs = []\\n        for i,v in enumerate(nums):\\n            if k%v == 0:\\n                currs += [pfacs[i]]\\n            elif currs:\\n                segments.append(currs)\\n                currs = []\\n        if currs: segments.append(currs)\\n        ret = 0\\n        # slide window along each segment\\n        # compute for each left boundary of a subarray,\\n        # what is the minimum right boundary with lcm = k\\n        # with this minimum, we can find how many subarrays start with left boundary l\\n        for seg in segments:\\n            cnt = {p:0 for p in pfac}\\n            r = -1\\n            for pf in seg:\\n                while r < len(seg)-1 and any(v == 0 for v in cnt.values()):\\n                    r += 1\\n                    for f, v in seg[r].items():\\n                        if v == pfac[f]:\\n                            cnt[f] += 1\\n                if all(v > 0 for v in cnt.values()):\\n                    ret += len(seg)-r\\n                for f,v in pf.items():\\n                    if v == pfac[f]:\\n                        cnt[f] -= 1\\n        return ret\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n        # special case for 1\\n        if k == 1:\\n            ret = 0\\n            cs = 0\\n            for i in nums:\\n                if i == 1:\\n                    cs += 1\\n                else:\\n                    ret += cs*(cs+1)//2\\n                    cs = 0\\n            ret += cs*(cs+1)//2\\n            return ret\\n        # prime factorization of k\\n        pfac = defaultdict(int)\\n        i = 2\\n        tk = k\\n        while i*i <= tk:\\n            while tk%i == 0:\\n                pfac[i] += 1\\n                tk //= i\\n            i += 1\\n        if tk != 1:\\n            pfac[tk] += 1\\n        # can get relevant prime factors of all other nums in log(k) \\n        # because we only care about prime factors of k (of which there are O(log(k)))\\n        def fac(n,p):\\n            k = 1\\n            while n%(p**k) == 0:\\n                k += 1\\n            return k - 1\\n        pfacs = [{p:fac(i,p) for p in pfac} for i in nums]\\n        # split array into segments where all nums can divide k \\n        # because these are the only ones that can be contained in a subarray with LCM k\\n        segments = []\\n        currs = []\\n        for i,v in enumerate(nums):\\n            if k%v == 0:\\n                currs += [pfacs[i]]\\n            elif currs:\\n                segments.append(currs)\\n                currs = []\\n        if currs: segments.append(currs)\\n        ret = 0\\n        # slide window along each segment\\n        # compute for each left boundary of a subarray,\\n        # what is the minimum right boundary with lcm = k\\n        # with this minimum, we can find how many subarrays start with left boundary l\\n        for seg in segments:\\n            cnt = {p:0 for p in pfac}\\n            r = -1\\n            for pf in seg:\\n                while r < len(seg)-1 and any(v == 0 for v in cnt.values()):\\n                    r += 1\\n                    for f, v in seg[r].items():\\n                        if v == pfac[f]:\\n                            cnt[f] += 1\\n                if all(v > 0 for v in cnt.values()):\\n                    ret += len(seg)-r\\n                for f,v in pf.items():\\n                    if v == pfac[f]:\\n                        cnt[f] -= 1\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2811971,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "```class Solution {\\npublic:\\n    \\n    // Arithmetic sum of ints from 1 to n\\n\\t// https://www.cuemath.com/sum-of-arithmetic-sequence-formula/\\n    int nSum (int n)\\n    {\\n        return (n * (n + 1)) / 2;\\n    }\\n    \\n    // Takes the total artithmetic sum for the run\\n    // Subtracts the artimetic sum of the sub arrays which don\\'t contain k\\n    int countSubarray(vector<int>& nums, int start, int end, int k)\\n    {\\n        int sum = nSum(end - start + 1);\\n        int i = start;\\n        while (i <= end)\\n        {\\n            if (nums[i] == k)\\n            {\\n                sum -= nSum(i - start);\\n                start = i + 1;\\n            }\\n            i++;\\n        }\\n        sum -= nSum(i-start);\\n        return sum;\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        \\n        // Algorithm:\\n        // 1. Find a run containing k and factors of k\\n        // 2. Calculat sum(run_len)\\n        // 3. For every sub-run in between the k\\'s calculate sum(sub_run_len)\\n        // 4. Sum = step 2 - (sum of step 3)\\n        // 5. Repeat until string end\\n        \\n        int start = -1;\\n        int count = 0;\\n        for (int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (k % nums[i] == 0)\\n            {\\n                if (start == -1)\\n                    start = i;\\n                continue;\\n            }\\n            \\n            if (start != -1)\\n            {\\n                count += countSubarray(nums, start, i-1, k);\\n            }\\n            start = -1;\\n        }\\n        \\n        if (start != -1)\\n            count += countSubarray(nums, start, nums.size() - 1, k);\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // Arithmetic sum of ints from 1 to n\\n\\t// https://www.cuemath.com/sum-of-arithmetic-sequence-formula/\\n    int nSum (int n)\\n    {\\n        return (n * (n + 1)) / 2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2811956,
                "title": "c-lcm-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) \\n    {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int curr_lcm=1;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                curr_lcm=lcm(curr_lcm,nums[j]);\\n                if(curr_lcm==k) ans++;\\n                if(curr_lcm>k) break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) \\n    {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int curr_lcm=1;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                curr_lcm=lcm(curr_lcm,nums[j]);\\n                if(curr_lcm==k) ans++;\\n                if(curr_lcm>k) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2811916,
                "title": "c-easy-solution-clean-code",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();++i){\\n            int prod = 1,gcd=nums[i],lcm = nums[i];\\n            for(int j=i;j<nums.size();++j){\\n                prod = lcm;\\n                prod *= nums[j];\\n                gcd = __gcd(nums[j],lcm);\\n                lcm = prod/gcd;\\n                if(lcm==k)ans += 1;\\n                if(lcm>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();++i){\\n            int prod = 1,gcd=nums[i],lcm = nums[i];\\n            for(int j=i;j<nums.size();++j){\\n                prod = lcm;\\n                prod *= nums[j];\\n                gcd = __gcd(nums[j],lcm);\\n                lcm = prod/gcd;\\n                if(lcm==k)ans += 1;\\n                if(lcm>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811915,
                "title": "simple-c-bruite-force-with-explanation-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry finding all the possible subarrays using bruite force and check if it is equal to k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse the two for loops and try finding lcm for every element in subarray,also check if that lcm is equal to k or not\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        //hum saare subarrays nikalenge like [3,6,2,7,1] 3 & 3 ka lcm fir 3 & 6 ka lcm nd so on..\\n        //Nd after every new lcm value we will check if that element we found is equal to k or\\n        //not \\n        int count = 0;\\n        for(int i=0; i< nums.size(); i++){\\n            //try all subarrays\\n            int num = nums[i];\\n\\n            for(int j=i; j<nums.size(); j++){\\n                //find lcm of every element\\n                num = lcm(num,nums[j]);\\n\\n                // Uncomment this below line and try to see how it is working\\n                // cout<<\"i = \"<<i<<\" j = \"<<j<<endl;\\n                // cout<<\"num = \"<<num<<endl;\\n\\n                if(num == k){\\n                    count++;\\n                }\\n                //it means we cannot have least common factor (bada number mil gya h)\\n                if(num>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        //hum saare subarrays nikalenge like [3,6,2,7,1] 3 & 3 ka lcm fir 3 & 6 ka lcm nd so on..\\n        //Nd after every new lcm value we will check if that element we found is equal to k or\\n        //not \\n        int count = 0;\\n        for(int i=0; i< nums.size(); i++){\\n            //try all subarrays\\n            int num = nums[i];\\n\\n            for(int j=i; j<nums.size(); j++){\\n                //find lcm of every element\\n                num = lcm(num,nums[j]);\\n\\n                // Uncomment this below line and try to see how it is working\\n                // cout<<\"i = \"<<i<<\" j = \"<<j<<endl;\\n                // cout<<\"num = \"<<num<<endl;\\n\\n                if(num == k){\\n                    count++;\\n                }\\n                //it means we cannot have least common factor (bada number mil gya h)\\n                if(num>k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2811805,
                "title": "c-easy-solution-lcm",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int lcm=1;\\n            for(int j=i;j<nums.size();j++){\\n                lcm=(lcm*nums[j])/__gcd(lcm,nums[j]);\\n                if(lcm==k) ans++;\\n                else if(k%lcm!=0) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n//Please upvote if you like the code",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int lcm=1;\\n            for(int j=i;j<nums.size();j++){\\n                lcm=(lcm*nums[j])/__gcd(lcm,nums[j]);\\n                if(lcm==k) ans++;\\n                else if(k%lcm!=0) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811666,
                "title": "brute-force-c-solution",
                "content": "**\\u2B06\\uFE0FDO UPVOTE\\u2B06\\uFE0F**\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i;\\n            int lcm=nums[i];\\n            if(lcm==k)ans++;\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                lcm=lcm*nums[j]/__gcd(lcm,nums[j]);\\n                if(lcm>k)break;\\n                if(lcm==k)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please, please do \\u2B06\\uFE0F upvote \\u2B06\\uFE0F if you found it helpful, it keeps me motivated to post more of such solutions :) and feel free to ask in comments if you have any queries/doubts :)***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i;\\n            int lcm=nums[i];\\n            if(lcm==k)ans++;\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                lcm=lcm*nums[j]/__gcd(lcm,nums[j]);\\n                if(lcm>k)break;\\n                if(lcm==k)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811648,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {\\n\\n        func gcd(_ a: Int, _ b: Int) -> Int {\\n            if b == 0 {\\n                return a\\n            }\\n            return gcd(b, a % b)\\n        }\\n        \\n        func lcm(_ a: Int, _ b: Int) -> Int {\\n            return (a / gcd(a,b)) * b\\n        }\\n        \\n        var ans = 0\\n        let n = nums.count\\n        for i in 0..<n {\\n            var temp = nums[i]\\n            for j in i..<n {\\n                temp = lcm(temp, nums[j])\\n                if temp > k {\\n                    break\\n                } else if temp == k {\\n                    ans += 1\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {\\n\\n        func gcd(_ a: Int, _ b: Int) -> Int {\\n            if b == 0 {\\n                return a\\n            }\\n            return gcd(b, a % b)\\n        }\\n        \\n        func lcm(_ a: Int, _ b: Int) -> Int {\\n            return (a / gcd(a,b)) * b\\n        }\\n        \\n        var ans = 0\\n        let n = nums.count\\n        for i in 0..<n {\\n            var temp = nums[i]\\n            for j in i..<n {\\n                temp = lcm(temp, nums[j])\\n                if temp > k {\\n                    break\\n                } else if temp == k {\\n                    ans += 1\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811625,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef subarrayLCM(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tfor j in range(i,len(nums)):\\n\\t\\t\\t\\t\\tnums[i]= lcm(nums[i],nums[j])\\n\\t\\t\\t\\t\\tif nums[i] == k:\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\treturn count",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef subarrayLCM(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tfor j in range(i,len(nums)):\\n\\t\\t\\t\\t\\tnums[i]= lcm(nums[i],nums[j])\\n\\t\\t\\t\\t\\tif nums[i] == k:\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 2811344,
                "title": "c-easy-solution-time-complexity-o-n-2-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        unsigned int n = nums.size();\\n        \\n        unsigned int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            unsigned int LCM = nums[i];\\n            for(int j=i; j<n; j++) {\\n                LCM = lcm(LCM, nums[j]);\\n                if(LCM == k) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        unsigned int n = nums.size();\\n        \\n        unsigned int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            unsigned int LCM = nums[i];\\n            for(int j=i; j<n; j++) {\\n                LCM = lcm(LCM, nums[j]);\\n                if(LCM == k) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811260,
                "title": "simple-solution",
                "content": "# Code\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef subarray_lcm(nums, k)\\n  count = 0\\n  for i in 0...nums.length\\n    current_lcm = 1\\n    for j in i...nums.length\\n      current_lcm = nums[j].lcm(current_lcm)\\n      count += 1 if current_lcm == k\\n      break if current_lcm > k\\n    end\\n  end\\n  count\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Math"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef subarray_lcm(nums, k)\\n  count = 0\\n  for i in 0...nums.length\\n    current_lcm = 1\\n    for j in i...nums.length\\n      current_lcm = nums[j].lcm(current_lcm)\\n      count += 1 if current_lcm == k\\n      break if current_lcm > k\\n    end\\n  end\\n  count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2811150,
                "title": "c-array-lcm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse two for loops to find lcm of every sub array. \\nIf lcm>k, then stop/break.\\nif lcm==k, then check the k must be divisible by num, else break.\\nelse if nums is divisible by lcm, lcm=nums, otherwise find lcm of lcm and nums.\\nif(lcm==k) , increase count.\\nreturn count;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int lcm=nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                if(lcm>k) break; \\n                if(lcm==k)\\n                {\\n                    if(k%nums[j]==0) count++;\\n                    else break;\\n                }\\n                else {\\n                    if(lcm%nums[j]==0) lcm=lcm;\\n                    else if(nums[j]%lcm==0) lcm=nums[j];\\n                    else lcm = findLCM(lcm,nums[j]);\\n                    if(lcm==k) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int findLCM(int a, int b)\\n    {\\n        if(a==1) return b;\\n        if(b==1) return a;\\n        int i=2;\\n        int lcm=1;\\n        while(i<=max(a,b))\\n        {\\n            if(a%i==0 || b%i==0)\\n            {\\n                lcm*=i;\\n                if(a%i==0) a/=i;\\n                if(b%i==0) b/=i;\\n            }\\n            else i++;\\n        }\\n        return lcm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int lcm=nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                if(lcm>k) break; \\n                if(lcm==k)\\n                {\\n                    if(k%nums[j]==0) count++;\\n                    else break;\\n                }\\n                else {\\n                    if(lcm%nums[j]==0) lcm=lcm;\\n                    else if(nums[j]%lcm==0) lcm=nums[j];\\n                    else lcm = findLCM(lcm,nums[j]);\\n                    if(lcm==k) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int findLCM(int a, int b)\\n    {\\n        if(a==1) return b;\\n        if(b==1) return a;\\n        int i=2;\\n        int lcm=1;\\n        while(i<=max(a,b))\\n        {\\n            if(a%i==0 || b%i==0)\\n            {\\n                lcm*=i;\\n                if(a%i==0) a/=i;\\n                if(b%i==0) b/=i;\\n            }\\n            else i++;\\n        }\\n        return lcm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811074,
                "title": "c-time-complexity-o-n-2-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(k==nums[i])\\n                c++;\\n            int l=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                l=(l*nums[j])/(__gcd(l,nums[j]));\\n                if(l==k)\\n                    c++;\\n                else if(l>k)\\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(k==nums[i])\\n                c++;\\n            int l=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                l=(l*nums[j])/(__gcd(l,nums[j]));\\n                if(l==k)\\n                    c++;\\n                else if(l>k)\\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810900,
                "title": "easy-c-python-stl-lcm-gcd-formula-explained",
                "content": "```\\nint subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int curr = nums[i];\\n            for(int j = i;j< nums.size();j++){\\n                curr = lcm(curr, nums[j]);\\n                if(curr>k)\\n                    break;\\n                if(curr == k)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nlcm is an inbuilt function for finding the lcm available in c++ 17+ versions and python 3.9, so it may not work in older versions.\\n\\n```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            curr = nums[i]\\n            for j in range(i, len(nums)):\\n                curr = curr* nums[j] // gcd(curr, nums[j])\\n                # curr = lcm(curr, nums[j])     \\n                if curr > k:\\n                    break\\n                if curr == k:\\n                    count +=1\\n        return count\\n```\\n\\nIn the above code I used GCD function instead of LCM function to calculate the LCM, both works perfectly fine.\\n***Note:***\\nThe least common multiple (LCM) of two integers is the smallest positive integer that is a multiple of both. The greatest common divisor (GCD) of two integers is the largest positive integer dividing both. **The product of the two numbers is the product of the LCM and the GCD** , i.e,\\nLCM( a,b ) * GCD( a,b ) = a*b\\ni.e, LCM( a,b )  = a*b // GCD( a,b ), i.e, the second formula we used.",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint subarrayLCM(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int curr = nums[i];\\n            for(int j = i;j< nums.size();j++){\\n                curr = lcm(curr, nums[j]);\\n                if(curr>k)\\n                    break;\\n                if(curr == k)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            curr = nums[i]\\n            for j in range(i, len(nums)):\\n                curr = curr* nums[j] // gcd(curr, nums[j])\\n                # curr = lcm(curr, nums[j])     \\n                if curr > k:\\n                    break\\n                if curr == k:\\n                    count +=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2810544,
                "title": "java-solution-understandable",
                "content": "lcm(a,b) = a*b/gcd(a,b)\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans =0;\\n        int n= nums.length;\\n        for(int i=0; i< n; i++){\\n            int currLCM = 1;\\n            for(int j =i; j<n && k%nums[j]==0; j++){\\n                currLCM = currLCM * nums[j]/(gcd(nums[j], currLCM));\\n                if(currLCM == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    private int gcd(int a, int b){\\n        return b== 0? a: gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int ans =0;\\n        int n= nums.length;\\n        for(int i=0; i< n; i++){\\n            int currLCM = 1;\\n            for(int j =i; j<n && k%nums[j]==0; j++){\\n                currLCM = currLCM * nums[j]/(gcd(nums[j], currLCM));\\n                if(currLCM == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    private int gcd(int a, int b){\\n        return b== 0? a: gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810532,
                "title": "o-n-logn-c-hcf-lcm",
                "content": "# Intuition \\nLCM of three numbers is the lcm of first two and the third. And, if the lcm of first two is k, lcm of three numbers can only be >=k.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n^2logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hcf(int a, int b){\\n        int rem = a%b;\\n        if(rem == 0) return b;\\n        return hcf(b,rem);\\n        \\n    }\\n    int lcm(int a){ return a; }\\n    int lcm(int a, int b){\\n        if(a>b) return (a*b)/hcf(a,b);  // a*b = hcf*lcm\\n        return (a*b)/hcf(b,a);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int l = lcm(nums[i]);\\n            if(l == k) ans++;\\n            for(int j=i+1; j<nums.size(); j++){\\n                l = lcm(l, nums[j]);\\n                if(l == k) ans++;\\n                if(l > k) break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hcf(int a, int b){\\n        int rem = a%b;\\n        if(rem == 0) return b;\\n        return hcf(b,rem);\\n        \\n    }\\n    int lcm(int a){ return a; }\\n    int lcm(int a, int b){\\n        if(a>b) return (a*b)/hcf(a,b);  // a*b = hcf*lcm\\n        return (a*b)/hcf(b,a);\\n    }\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int l = lcm(nums[i]);\\n            if(l == k) ans++;\\n            for(int j=i+1; j<nums.size(); j++){\\n                l = lcm(l, nums[j]);\\n                if(l == k) ans++;\\n                if(l > k) break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810508,
                "title": "java-simple-solution-explained-hashmap",
                "content": "# Hey leetcoders, this question is pretty much similar to the previously asked question ...\\n\\uD83D\\uDC49 2447. https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/\\n\\nSolution : https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/discuss/2810594/Java-Simple-Solution-(explained)-HashMap\\n---\\n\\n# ***Explanation \\uD83D\\uDC47***\\n* Create a map `Map<Integer,Integer> map` storing `nums[i]` as key and `frequency[nums[i]]` as value\\n* Create a `count` variable to store the subarray count\\n* Iterate over the nums array and store `nums[i]` with its frequency in `map`\\n* Create another map to `Map<Integer,Integer> lcm ` store the lcm of every 2 numbers\\n*  Now, to get lcm of 2 number we can create a `gcd(a,b)` function and do it with simple mathematics : `lcm(a,b) = gcd(a,b) / a*b`\\n* So if our `lcm(a,b) == k` then we will increase `count` with `freq` as that value will be included everytime same duplicate element is reached\\n* Now if same duplicate element is reached i.e `k % lcm(a,b) == 0` then just put `lcm(a,b)` in the `lcm` map with its `count`\\n* Here lastly our `map` becomes `lcm` and `return count`\\n---\\n\\n# \\u2615 *Java Code \\uD83D\\uDC47*\\n```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            Map<Integer,Integer> map2 = new HashMap<>();\\n            for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n                int key = entry.getKey();\\n                int value = entry.getValue();\\n                \\n                int lcm = (key * nums[i]) / gcd(key,nums[i]);\\n                if(lcm ==  k) count += value;\\n                if(k % lcm == 0) map2.put(lcm,map2.getOrDefault(lcm,0)+value);\\n                map = map2;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    static int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```\\n\\n# *Complexity Analysis \\uD83D\\uDC47*\\n\\n\\u2705 **Time Complexity ~ O(n * d(k))**\\n\\u2705 **Space Complexity ~ O(n * d(k))**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            Map<Integer,Integer> map2 = new HashMap<>();\\n            for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n                int key = entry.getKey();\\n                int value = entry.getValue();\\n                \\n                int lcm = (key * nums[i]) / gcd(key,nums[i]);\\n                if(lcm ==  k) count += value;\\n                if(k % lcm == 0) map2.put(lcm,map2.getOrDefault(lcm,0)+value);\\n                map = map2;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    static int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810436,
                "title": "c-math",
                "content": "```\\n\\tpublic int SubarrayLCM(int[] nums, int k) {\\n        var res = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            var lcm = 1;\\n            for (int j = i; j < nums.Length; j++) {\\n                lcm = LCM(lcm, nums[j]);\\n                if (lcm == k)\\n                    res++;\\n                else if (lcm > k)\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int GCD(int num1, int num2) {\\n        return num2 == 0 ? num1 : GCD(num2, num1 % num2);\\n    }\\n\\n    public int LCM(int num1, int num2) {\\n        return num1 * num2 / GCD(num1, num2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int SubarrayLCM(int[] nums, int k) {\\n        var res = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            var lcm = 1;\\n            for (int j = i; j < nums.Length; j++) {\\n                lcm = LCM(lcm, nums[j]);\\n                if (lcm == k)\\n                    res++;\\n                else if (lcm > k)\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int GCD(int num1, int num2) {\\n        return num2 == 0 ? num1 : GCD(num2, num1 % num2);\\n    }\\n\\n    public int LCM(int num1, int num2) {\\n        return num1 * num2 / GCD(num1, num2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2810281,
                "title": "c-easy-explanation-n-2",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHi All,\\n\\nFirst thought process would be as below :\\n\\n1) Nested loop traversal.\\n2) Check if the LCM is k.\\n3) If valid increment counter.\\n\\nPFB detailed approach, please do upvote if this was helpful.\\n\\nThanks,\\nAK\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int cnt=0;\\n        long mult=1;\\n    \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //resetting multipe to 1 for next subarray\\n            for(int j=i,mult=1;j<nums.size();j++) \\n            {\\n                //returns the lowest common multiple \\n                mult = lcm(mult,nums[j]);\\n\\n                //if the multiple is k it a valid subarray\\n                if(mult == k) \\n                    //for every valid element counter increases\\n                    // and also for contiguous non-empty sequence \\n                    cnt++;\\n                //if lowest multiple is greater than k\\n                // then continuing the subarray will alway give mutiple above k\\n                if(mult>k) \\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k)\\n    {\\n        int cnt=0;\\n        long mult=1;\\n    \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //resetting multipe to 1 for next subarray\\n            for(int j=i,mult=1;j<nums.size();j++) \\n            {\\n                //returns the lowest common multiple \\n                mult = lcm(mult,nums[j]);\\n\\n                //if the multiple is k it a valid subarray\\n                if(mult == k) \\n                    //for every valid element counter increases\\n                    // and also for contiguous non-empty sequence \\n                    cnt++;\\n                //if lowest multiple is greater than k\\n                // then continuing the subarray will alway give mutiple above k\\n                if(mult>k) \\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810248,
                "title": "c-quadratic-time-const-space",
                "content": "# Intuition\\ncompute lcm (lowest common multiple) for each subarray.\\n\\n# Approach\\n1. compute lcm for subarray[i,i], [i, i + 1], ... [i, n-1] for each i from 0 -> n-1.\\n2. don\\'t look further if current lcm is greater than k.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n\\n    int lcm(int a, int b){\\n        return a / gcd(a, b) * b;\\n    }\\n\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt = 0;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int m = 1;\\n            for (size_t j = i; j < nums.size() && m <= k; ++j) {\\n                m = lcm(m, nums[j]);\\n                if (m == k) {\\n                    ++cnt;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n\\n    int lcm(int a, int b){\\n        return a / gcd(a, b) * b;\\n    }\\n\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int cnt = 0;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int m = 1;\\n            for (size_t j = i; j < nums.size() && m <= k; ++j) {\\n                m = lcm(m, nums[j]);\\n                if (m == k) {\\n                    ++cnt;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810208,
                "title": "python-implementation-similar-to-the-question-regarding-gcd",
                "content": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ret = 0\\n        for i in range(n):\\n            temp = nums[i]\\n            \\n            for j in range(i, n):\\n                temp = math.lcm(temp, nums[j])\\n                if temp == k:\\n                    ret+=1\\n                elif temp > k:\\n                    break\\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ret = 0\\n        for i in range(n):\\n            temp = nums[i]\\n            \\n            for j in range(i, n):\\n                temp = math.lcm(temp, nums[j])\\n                if temp == k:\\n                    ret+=1\\n                elif temp > k:\\n                    break\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810059,
                "title": "2470-leetcode-solution-in-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gcd(long long int a, long long int b)\\n     {\\n       if (b == 0)\\n           return a;\\n        return gcd(b, a % b);\\n      }\\n \\n      long long lcm(int a, int b)\\n      {\\n        return (a / gcd(a, b)) * b;\\n       }\\n  \\n    int subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n        \\n    int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int c  = nums[i];\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = lcm(c, nums[j]);\\n\\n                if(c == k){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcd(long long int a, long long int b)\\n     {\\n       if (b == 0)\\n           return a;\\n        return gcd(b, a % b);\\n      }\\n \\n      long long lcm(int a, int b)\\n      {\\n        return (a / gcd(a, b)) * b;\\n       }\\n  \\n    int subarrayLCM(vector<int>& nums, int k) {\\n    int cnt = 0;\\n        \\n    int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int c  = nums[i];\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = lcm(c, nums[j]);\\n\\n                if(c == k){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810048,
                "title": "swift-solution-with-explanation-o-n-2",
                "content": "**Approach:**\\n1. We create all possible arrays that can be the answer. \\n2. We check all our subarrays for 2 conditions.\\n\\tA. If the maximum number in the array == k\\n\\tB. If the number k is divisible by any element of the array without a remainder\\n\\n**Solution:**\\n```\\nclass Solution {\\n    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {\\n        var result = 0\\n        \\n        for i in 0..<nums.count {\\n            for j in i..<nums.count {\\n                let array = i == j ? [nums[i]] : nums[i...j]\\n\\t\\t\\t\\tguard array.allSatisfy ({ (k % $0) == 0 }) else { break }\\n                guard array.max()! == k else { continue }\\n                result += 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {\\n        var result = 0\\n        \\n        for i in 0..<nums.count {\\n            for j in i..<nums.count {\\n                let array = i == j ? [nums[i]] : nums[i...j]\\n\\t\\t\\t\\tguard array.allSatisfy ({ (k % $0) == 0 }) else { break }\\n                guard array.max()! == k else { continue }\\n                result += 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809956,
                "title": "c-easy-solution-explained",
                "content": "# Approach\\n- Checking If The LCM of Subarrays Are Equal To K , Hence We Check The LCM of Every ith element with other element\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        unsigned int x = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n         unsigned int temp = nums[i];\\n             for(int j=i;j<nums.size();j++)\\n             {\\n                temp=lcm(temp,nums[j]);\\n                 if(temp==k)\\n                     x++;\\n             }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        unsigned int x = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n         unsigned int temp = nums[i];\\n             for(int j=i;j<nums.size();j++)\\n             {\\n                temp=lcm(temp,nums[j]);\\n                 if(temp==k)\\n                     x++;\\n             }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1681920,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I did what the hint says calculate lcm of all subarrays and if lcm is greater than k for any subarray, exit the loop. But I still got TLE. Why??"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "[@CODEX47](/CODEX47) Welcome"
                    },
                    {
                        "username": "CODEX47",
                        "content": "[@SATI-IVIK](/SATI-IVIK) Thank you so much, My solution was also stuck in that same testcase and I got frustrated."
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "I got TLE for an array with 1000 elements where all the elements were = 1. In this case(or in any other case where length of the array is large and all the array elements are equal, lets say equal to x) the break statement that was used to exit the loop when lcm > k will never be executed because LCM of any subarray of such array will always be 1 in this case(or x in general if x is the only element in the array). So if k <= x then LCM of all possible subarrays is checked thus making the break statement useless in such case. This approach worked for array of size 1000 where the array had more than 1 unique element."
                    },
                    {
                        "username": "nicolaskagami",
                        "content": "I suggest to add a few more test cases.\\nOne of the fastest accepted solutions, which caught my eye for being O(n), is actually incorrect.\\n\\nThe simple test case which could be added: nums = [7,2,1,1,3,7], k = 6"
                    },
                    {
                        "username": "user2325D",
                        "content": "[3,6,2,7,1]\\n[3,6,2,1]\\n[3,6,2]\\n[3,6,1]\\n[3,2]\\n[3,1]\\nand so on there are many subarrays.\\nam I wrong anywhere?"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "A subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nContiguous means the elements should be adjacent to each other."
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who finds this type of questions boring?"
                    },
                    {
                        "username": "acerunner",
                        "content": "# A helpful fact of least common multiples (lcm): \\na, b, c are positive integers. \\nThe lcm(a, b, c) = lcm(lcm(a, b), c)\\nI will leave the proof for you, but this fact may help with a solution. "
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "This is what I wrote for LCM question. Can someone explain why it's giving wrong answers for few test cases?\n `\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def compute_lcm(x, y):\n            if x > y:\n                greater = x\n            else:\n                greater = y\n\n            while(True):\n                if((greater % x == 0) and (greater % y == 0)):\n                    lcm = greater\n                    break\n                greater += 1\n\n            return lcm\n        \n        res = 0\n    \n        for i in range(len(nums)):\n            x = nums[i]\n            if x == k:\n                res += 1\n                \n            for j in range(i + 1, len(nums)):\n                y = compute_lcm(x, nums[j])\n                \n                if y == k:\n                    res += 1\n                elif y > k:\n                    break\n    \n        return res\n            `"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "In line y = compute_lcm(x,nums[j])\nyou are actually taking lcm of first and last element of subarray .\nSo suppose there is some element within this subarray such that lcm of x and that element is lower than k\nthan your loop will continue, now even lcm of your first and last element is k but if you include those middle elements \nlcm will be > k and hence your answer is wrong.\n\n\nFor example.\nConsider [2,5,12] , and k = 12\nSo for element 2 and 5 lcm is 10 which is lower than 12 so your loop will continue.\nNow for 2 and 12 , lcm is 12 so you will take it an answer, but actually lcm of 2,5 and 12 is 60.\n\n1. way to fix it is to update x after each lcm calculation.\nso something like x = y after lcm calculation or\nx = compute_lcm(x,nums[j]) and comparing x with k.\nBut this will time out.\n\n\nHope it is clear.\nLet me know in case of doubt."
                    },
                    {
                        "username": "Shashi3k",
                        "content": "In the second for loop you are considering the elements after i+1 but what about the elements before that. Get it?"
                    }
                ]
            },
            {
                "id": 1710274,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I did what the hint says calculate lcm of all subarrays and if lcm is greater than k for any subarray, exit the loop. But I still got TLE. Why??"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "[@CODEX47](/CODEX47) Welcome"
                    },
                    {
                        "username": "CODEX47",
                        "content": "[@SATI-IVIK](/SATI-IVIK) Thank you so much, My solution was also stuck in that same testcase and I got frustrated."
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "I got TLE for an array with 1000 elements where all the elements were = 1. In this case(or in any other case where length of the array is large and all the array elements are equal, lets say equal to x) the break statement that was used to exit the loop when lcm > k will never be executed because LCM of any subarray of such array will always be 1 in this case(or x in general if x is the only element in the array). So if k <= x then LCM of all possible subarrays is checked thus making the break statement useless in such case. This approach worked for array of size 1000 where the array had more than 1 unique element."
                    },
                    {
                        "username": "nicolaskagami",
                        "content": "I suggest to add a few more test cases.\\nOne of the fastest accepted solutions, which caught my eye for being O(n), is actually incorrect.\\n\\nThe simple test case which could be added: nums = [7,2,1,1,3,7], k = 6"
                    },
                    {
                        "username": "user2325D",
                        "content": "[3,6,2,7,1]\\n[3,6,2,1]\\n[3,6,2]\\n[3,6,1]\\n[3,2]\\n[3,1]\\nand so on there are many subarrays.\\nam I wrong anywhere?"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "A subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nContiguous means the elements should be adjacent to each other."
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who finds this type of questions boring?"
                    },
                    {
                        "username": "acerunner",
                        "content": "# A helpful fact of least common multiples (lcm): \\na, b, c are positive integers. \\nThe lcm(a, b, c) = lcm(lcm(a, b), c)\\nI will leave the proof for you, but this fact may help with a solution. "
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "This is what I wrote for LCM question. Can someone explain why it's giving wrong answers for few test cases?\n `\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def compute_lcm(x, y):\n            if x > y:\n                greater = x\n            else:\n                greater = y\n\n            while(True):\n                if((greater % x == 0) and (greater % y == 0)):\n                    lcm = greater\n                    break\n                greater += 1\n\n            return lcm\n        \n        res = 0\n    \n        for i in range(len(nums)):\n            x = nums[i]\n            if x == k:\n                res += 1\n                \n            for j in range(i + 1, len(nums)):\n                y = compute_lcm(x, nums[j])\n                \n                if y == k:\n                    res += 1\n                elif y > k:\n                    break\n    \n        return res\n            `"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "In line y = compute_lcm(x,nums[j])\nyou are actually taking lcm of first and last element of subarray .\nSo suppose there is some element within this subarray such that lcm of x and that element is lower than k\nthan your loop will continue, now even lcm of your first and last element is k but if you include those middle elements \nlcm will be > k and hence your answer is wrong.\n\n\nFor example.\nConsider [2,5,12] , and k = 12\nSo for element 2 and 5 lcm is 10 which is lower than 12 so your loop will continue.\nNow for 2 and 12 , lcm is 12 so you will take it an answer, but actually lcm of 2,5 and 12 is 60.\n\n1. way to fix it is to update x after each lcm calculation.\nso something like x = y after lcm calculation or\nx = compute_lcm(x,nums[j]) and comparing x with k.\nBut this will time out.\n\n\nHope it is clear.\nLet me know in case of doubt."
                    },
                    {
                        "username": "Shashi3k",
                        "content": "In the second for loop you are considering the elements after i+1 but what about the elements before that. Get it?"
                    }
                ]
            },
            {
                "id": 1983424,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I did what the hint says calculate lcm of all subarrays and if lcm is greater than k for any subarray, exit the loop. But I still got TLE. Why??"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "[@CODEX47](/CODEX47) Welcome"
                    },
                    {
                        "username": "CODEX47",
                        "content": "[@SATI-IVIK](/SATI-IVIK) Thank you so much, My solution was also stuck in that same testcase and I got frustrated."
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "I got TLE for an array with 1000 elements where all the elements were = 1. In this case(or in any other case where length of the array is large and all the array elements are equal, lets say equal to x) the break statement that was used to exit the loop when lcm > k will never be executed because LCM of any subarray of such array will always be 1 in this case(or x in general if x is the only element in the array). So if k <= x then LCM of all possible subarrays is checked thus making the break statement useless in such case. This approach worked for array of size 1000 where the array had more than 1 unique element."
                    },
                    {
                        "username": "nicolaskagami",
                        "content": "I suggest to add a few more test cases.\\nOne of the fastest accepted solutions, which caught my eye for being O(n), is actually incorrect.\\n\\nThe simple test case which could be added: nums = [7,2,1,1,3,7], k = 6"
                    },
                    {
                        "username": "user2325D",
                        "content": "[3,6,2,7,1]\\n[3,6,2,1]\\n[3,6,2]\\n[3,6,1]\\n[3,2]\\n[3,1]\\nand so on there are many subarrays.\\nam I wrong anywhere?"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "A subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nContiguous means the elements should be adjacent to each other."
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who finds this type of questions boring?"
                    },
                    {
                        "username": "acerunner",
                        "content": "# A helpful fact of least common multiples (lcm): \\na, b, c are positive integers. \\nThe lcm(a, b, c) = lcm(lcm(a, b), c)\\nI will leave the proof for you, but this fact may help with a solution. "
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "This is what I wrote for LCM question. Can someone explain why it's giving wrong answers for few test cases?\n `\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def compute_lcm(x, y):\n            if x > y:\n                greater = x\n            else:\n                greater = y\n\n            while(True):\n                if((greater % x == 0) and (greater % y == 0)):\n                    lcm = greater\n                    break\n                greater += 1\n\n            return lcm\n        \n        res = 0\n    \n        for i in range(len(nums)):\n            x = nums[i]\n            if x == k:\n                res += 1\n                \n            for j in range(i + 1, len(nums)):\n                y = compute_lcm(x, nums[j])\n                \n                if y == k:\n                    res += 1\n                elif y > k:\n                    break\n    \n        return res\n            `"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "In line y = compute_lcm(x,nums[j])\nyou are actually taking lcm of first and last element of subarray .\nSo suppose there is some element within this subarray such that lcm of x and that element is lower than k\nthan your loop will continue, now even lcm of your first and last element is k but if you include those middle elements \nlcm will be > k and hence your answer is wrong.\n\n\nFor example.\nConsider [2,5,12] , and k = 12\nSo for element 2 and 5 lcm is 10 which is lower than 12 so your loop will continue.\nNow for 2 and 12 , lcm is 12 so you will take it an answer, but actually lcm of 2,5 and 12 is 60.\n\n1. way to fix it is to update x after each lcm calculation.\nso something like x = y after lcm calculation or\nx = compute_lcm(x,nums[j]) and comparing x with k.\nBut this will time out.\n\n\nHope it is clear.\nLet me know in case of doubt."
                    },
                    {
                        "username": "Shashi3k",
                        "content": "In the second for loop you are considering the elements after i+1 but what about the elements before that. Get it?"
                    }
                ]
            },
            {
                "id": 1806558,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I did what the hint says calculate lcm of all subarrays and if lcm is greater than k for any subarray, exit the loop. But I still got TLE. Why??"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "[@CODEX47](/CODEX47) Welcome"
                    },
                    {
                        "username": "CODEX47",
                        "content": "[@SATI-IVIK](/SATI-IVIK) Thank you so much, My solution was also stuck in that same testcase and I got frustrated."
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "I got TLE for an array with 1000 elements where all the elements were = 1. In this case(or in any other case where length of the array is large and all the array elements are equal, lets say equal to x) the break statement that was used to exit the loop when lcm > k will never be executed because LCM of any subarray of such array will always be 1 in this case(or x in general if x is the only element in the array). So if k <= x then LCM of all possible subarrays is checked thus making the break statement useless in such case. This approach worked for array of size 1000 where the array had more than 1 unique element."
                    },
                    {
                        "username": "nicolaskagami",
                        "content": "I suggest to add a few more test cases.\\nOne of the fastest accepted solutions, which caught my eye for being O(n), is actually incorrect.\\n\\nThe simple test case which could be added: nums = [7,2,1,1,3,7], k = 6"
                    },
                    {
                        "username": "user2325D",
                        "content": "[3,6,2,7,1]\\n[3,6,2,1]\\n[3,6,2]\\n[3,6,1]\\n[3,2]\\n[3,1]\\nand so on there are many subarrays.\\nam I wrong anywhere?"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "A subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nContiguous means the elements should be adjacent to each other."
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who finds this type of questions boring?"
                    },
                    {
                        "username": "acerunner",
                        "content": "# A helpful fact of least common multiples (lcm): \\na, b, c are positive integers. \\nThe lcm(a, b, c) = lcm(lcm(a, b), c)\\nI will leave the proof for you, but this fact may help with a solution. "
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "This is what I wrote for LCM question. Can someone explain why it's giving wrong answers for few test cases?\n `\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def compute_lcm(x, y):\n            if x > y:\n                greater = x\n            else:\n                greater = y\n\n            while(True):\n                if((greater % x == 0) and (greater % y == 0)):\n                    lcm = greater\n                    break\n                greater += 1\n\n            return lcm\n        \n        res = 0\n    \n        for i in range(len(nums)):\n            x = nums[i]\n            if x == k:\n                res += 1\n                \n            for j in range(i + 1, len(nums)):\n                y = compute_lcm(x, nums[j])\n                \n                if y == k:\n                    res += 1\n                elif y > k:\n                    break\n    \n        return res\n            `"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "In line y = compute_lcm(x,nums[j])\nyou are actually taking lcm of first and last element of subarray .\nSo suppose there is some element within this subarray such that lcm of x and that element is lower than k\nthan your loop will continue, now even lcm of your first and last element is k but if you include those middle elements \nlcm will be > k and hence your answer is wrong.\n\n\nFor example.\nConsider [2,5,12] , and k = 12\nSo for element 2 and 5 lcm is 10 which is lower than 12 so your loop will continue.\nNow for 2 and 12 , lcm is 12 so you will take it an answer, but actually lcm of 2,5 and 12 is 60.\n\n1. way to fix it is to update x after each lcm calculation.\nso something like x = y after lcm calculation or\nx = compute_lcm(x,nums[j]) and comparing x with k.\nBut this will time out.\n\n\nHope it is clear.\nLet me know in case of doubt."
                    },
                    {
                        "username": "Shashi3k",
                        "content": "In the second for loop you are considering the elements after i+1 but what about the elements before that. Get it?"
                    }
                ]
            },
            {
                "id": 1765388,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I did what the hint says calculate lcm of all subarrays and if lcm is greater than k for any subarray, exit the loop. But I still got TLE. Why??"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "[@CODEX47](/CODEX47) Welcome"
                    },
                    {
                        "username": "CODEX47",
                        "content": "[@SATI-IVIK](/SATI-IVIK) Thank you so much, My solution was also stuck in that same testcase and I got frustrated."
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "I got TLE for an array with 1000 elements where all the elements were = 1. In this case(or in any other case where length of the array is large and all the array elements are equal, lets say equal to x) the break statement that was used to exit the loop when lcm > k will never be executed because LCM of any subarray of such array will always be 1 in this case(or x in general if x is the only element in the array). So if k <= x then LCM of all possible subarrays is checked thus making the break statement useless in such case. This approach worked for array of size 1000 where the array had more than 1 unique element."
                    },
                    {
                        "username": "nicolaskagami",
                        "content": "I suggest to add a few more test cases.\\nOne of the fastest accepted solutions, which caught my eye for being O(n), is actually incorrect.\\n\\nThe simple test case which could be added: nums = [7,2,1,1,3,7], k = 6"
                    },
                    {
                        "username": "user2325D",
                        "content": "[3,6,2,7,1]\\n[3,6,2,1]\\n[3,6,2]\\n[3,6,1]\\n[3,2]\\n[3,1]\\nand so on there are many subarrays.\\nam I wrong anywhere?"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "A subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nContiguous means the elements should be adjacent to each other."
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who finds this type of questions boring?"
                    },
                    {
                        "username": "acerunner",
                        "content": "# A helpful fact of least common multiples (lcm): \\na, b, c are positive integers. \\nThe lcm(a, b, c) = lcm(lcm(a, b), c)\\nI will leave the proof for you, but this fact may help with a solution. "
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "This is what I wrote for LCM question. Can someone explain why it's giving wrong answers for few test cases?\n `\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def compute_lcm(x, y):\n            if x > y:\n                greater = x\n            else:\n                greater = y\n\n            while(True):\n                if((greater % x == 0) and (greater % y == 0)):\n                    lcm = greater\n                    break\n                greater += 1\n\n            return lcm\n        \n        res = 0\n    \n        for i in range(len(nums)):\n            x = nums[i]\n            if x == k:\n                res += 1\n                \n            for j in range(i + 1, len(nums)):\n                y = compute_lcm(x, nums[j])\n                \n                if y == k:\n                    res += 1\n                elif y > k:\n                    break\n    \n        return res\n            `"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "In line y = compute_lcm(x,nums[j])\nyou are actually taking lcm of first and last element of subarray .\nSo suppose there is some element within this subarray such that lcm of x and that element is lower than k\nthan your loop will continue, now even lcm of your first and last element is k but if you include those middle elements \nlcm will be > k and hence your answer is wrong.\n\n\nFor example.\nConsider [2,5,12] , and k = 12\nSo for element 2 and 5 lcm is 10 which is lower than 12 so your loop will continue.\nNow for 2 and 12 , lcm is 12 so you will take it an answer, but actually lcm of 2,5 and 12 is 60.\n\n1. way to fix it is to update x after each lcm calculation.\nso something like x = y after lcm calculation or\nx = compute_lcm(x,nums[j]) and comparing x with k.\nBut this will time out.\n\n\nHope it is clear.\nLet me know in case of doubt."
                    },
                    {
                        "username": "Shashi3k",
                        "content": "In the second for loop you are considering the elements after i+1 but what about the elements before that. Get it?"
                    }
                ]
            },
            {
                "id": 1682013,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I did what the hint says calculate lcm of all subarrays and if lcm is greater than k for any subarray, exit the loop. But I still got TLE. Why??"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "[@CODEX47](/CODEX47) Welcome"
                    },
                    {
                        "username": "CODEX47",
                        "content": "[@SATI-IVIK](/SATI-IVIK) Thank you so much, My solution was also stuck in that same testcase and I got frustrated."
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "I got TLE for an array with 1000 elements where all the elements were = 1. In this case(or in any other case where length of the array is large and all the array elements are equal, lets say equal to x) the break statement that was used to exit the loop when lcm > k will never be executed because LCM of any subarray of such array will always be 1 in this case(or x in general if x is the only element in the array). So if k <= x then LCM of all possible subarrays is checked thus making the break statement useless in such case. This approach worked for array of size 1000 where the array had more than 1 unique element."
                    },
                    {
                        "username": "nicolaskagami",
                        "content": "I suggest to add a few more test cases.\\nOne of the fastest accepted solutions, which caught my eye for being O(n), is actually incorrect.\\n\\nThe simple test case which could be added: nums = [7,2,1,1,3,7], k = 6"
                    },
                    {
                        "username": "user2325D",
                        "content": "[3,6,2,7,1]\\n[3,6,2,1]\\n[3,6,2]\\n[3,6,1]\\n[3,2]\\n[3,1]\\nand so on there are many subarrays.\\nam I wrong anywhere?"
                    },
                    {
                        "username": "SATI-IVIK",
                        "content": "A subarray is a \"contiguous\" non-empty sequence of elements within an array.\\n\\nContiguous means the elements should be adjacent to each other."
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who finds this type of questions boring?"
                    },
                    {
                        "username": "acerunner",
                        "content": "# A helpful fact of least common multiples (lcm): \\na, b, c are positive integers. \\nThe lcm(a, b, c) = lcm(lcm(a, b), c)\\nI will leave the proof for you, but this fact may help with a solution. "
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "This is what I wrote for LCM question. Can someone explain why it's giving wrong answers for few test cases?\n `\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def compute_lcm(x, y):\n            if x > y:\n                greater = x\n            else:\n                greater = y\n\n            while(True):\n                if((greater % x == 0) and (greater % y == 0)):\n                    lcm = greater\n                    break\n                greater += 1\n\n            return lcm\n        \n        res = 0\n    \n        for i in range(len(nums)):\n            x = nums[i]\n            if x == k:\n                res += 1\n                \n            for j in range(i + 1, len(nums)):\n                y = compute_lcm(x, nums[j])\n                \n                if y == k:\n                    res += 1\n                elif y > k:\n                    break\n    \n        return res\n            `"
                    },
                    {
                        "username": "biltharesatyendra",
                        "content": "In line y = compute_lcm(x,nums[j])\nyou are actually taking lcm of first and last element of subarray .\nSo suppose there is some element within this subarray such that lcm of x and that element is lower than k\nthan your loop will continue, now even lcm of your first and last element is k but if you include those middle elements \nlcm will be > k and hence your answer is wrong.\n\n\nFor example.\nConsider [2,5,12] , and k = 12\nSo for element 2 and 5 lcm is 10 which is lower than 12 so your loop will continue.\nNow for 2 and 12 , lcm is 12 so you will take it an answer, but actually lcm of 2,5 and 12 is 60.\n\n1. way to fix it is to update x after each lcm calculation.\nso something like x = y after lcm calculation or\nx = compute_lcm(x,nums[j]) and comparing x with k.\nBut this will time out.\n\n\nHope it is clear.\nLet me know in case of doubt."
                    },
                    {
                        "username": "Shashi3k",
                        "content": "In the second for loop you are considering the elements after i+1 but what about the elements before that. Get it?"
                    }
                ]
            }
        ]
    }
]