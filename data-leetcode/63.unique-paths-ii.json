[
    {
        "title": "Unique Paths II",
        "question_content": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\n&nbsp;\nExample 1:\n\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\nExample 2:\n\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tm == obstacleGrid.length\n\tn == obstacleGrid[i].length\n\t1 <= m, n <= 100\n\tobstacleGrid[i][j] is 0 or 1.",
        "solutions": [
            {
                "id": 23250,
                "title": "short-java-solution",
                "content": "    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int width = obstacleGrid[0].length;\\n        int[] dp = new int[width];\\n        dp[0] = 1;\\n        for (int[] row : obstacleGrid) {\\n            for (int j = 0; j < width; j++) {\\n                if (row[j] == 1)\\n                    dp[j] = 0;\\n                else if (j > 0)\\n                    dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[width - 1];\\n    }",
                "solutionTags": [],
                "code": "    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int width = obstacleGrid[0].length;\\n        int[] dp = new int[width];\\n        dp[0] = 1;\\n        for (int[] row : obstacleGrid) {\\n            for (int j = 0; j < width; j++) {\\n                if (row[j] == 1)\\n                    dp[j] = 0;\\n                else if (j > 0)\\n                    dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[width - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23248,
                "title": "my-c-dp-solution-very-simple",
                "content": "just use dp to find the answer , if there is a obstacle at (i,j), then dp[i][j] = 0. \\ntime is O(n*m) , space is O(n*m) . \\nhere is my code:\\n\\n    class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n            int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n            vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n            dp[0][1] = 1;\\n            for(int i = 1 ; i <= m ; ++i)\\n                for(int j = 1 ; j <= n ; ++j)\\n                    if(!obstacleGrid[i-1][j-1])\\n                        dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n            return dp[m][n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n            int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n            vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n            dp[0][1] = 1;\\n            for(int i = 1 ; i <= m ; ++i)\\n                for(int j = 1 ; j <= n ; ++j)\\n                    if(!obstacleGrid[i-1][j-1])\\n                        dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n            return dp[m][n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 23252,
                "title": "4ms-o-n-dp-solution-in-c-with-explanations",
                "content": "Well, this problem is similar to **Unique Paths**. The introduction of obstacles only changes the boundary conditions and make some points unreachable (simply set to `0`).\\n\\nDenote the number of paths to arrive at point `(i, j)` to be `P[i][j]`, the state equation is `P[i][j] = P[i - 1][j] + P[i][j - 1]` if `obstacleGrid[i][j] != 1` and `0` otherwise. \\n\\nNow let's finish the boundary conditions. In the **Unique Paths** problem, we initialize `P[0][j] = 1, P[i][0] = 1` for all valid `i, j`. Now, due to obstacles, some boundary points are no longer reachable and need to be initialized to `0`. For example, if `obstacleGrid` is like `[0, 0, 1, 0, 0]`, then the last three points are not reachable and need to be initialized to be `0`. The result is `[1, 1, 0, 0, 0]`.\\n\\nNow we can write down the following (unoptimized) code. Note that we pad the `obstacleGrid` by `1` and initialize `dp[0][1] = 1` to unify the boundary cases. \\n\\n    class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n            vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));\\n            dp[0][1] = 1;\\n            for (int i = 1; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (!obstacleGrid[i - 1][j - 1])\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            return dp[m][n];\\n        } \\n    };\\n\\nWell, the code is accepted but it has some obvious redundancy. There are two major concerns:\\n\\n 1. Each time when we update `path[i][j]`, we only need `path[i  - 1][j]` (at the same column) and `path[i][j - 1]` (at the left column), so it is unnecessary to maintain the full `m*n` matrix. Maintaining two columns is enough.\\n 2. There are some cases that the loop can be terminated earlier. Suppose `obstacleGrid = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]`, then we can see that it is impossible to reach the bottom-right corner after updating the second column since the number of paths to reach each element in the second column is `0`.\\n\\nTaken these into considerations, we write down the following optimized code.\\n    \\n    class Solution {\\n    public: \\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n            vector<int> pre(m, 0);\\n            vector<int> cur(m, 0);\\n            for (int i = 0; i < m; i++) {\\n                if (!obstacleGrid[i][0])\\n                    pre[i] = 1;\\n                else break;\\n            }\\n            for (int j = 1; j < n; j++) {\\n                bool flag = false;\\n                if (!obstacleGrid[0][j]) {\\n                    cur[0] = pre[0];\\n                    if (cur[0]) flag = true; \\n                }\\n                else cur[0] = 0;\\n                for (int i = 1; i < m; i++) {\\n                    if (!obstacleGrid[i][j]) {\\n                        cur[i] = cur[i - 1] + pre[i];\\n                        if (cur[i]) flag = true;\\n                    }\\n                    else cur[i] = 0;\\n                }\\n                if (!flag) return 0;\\n                swap(pre, cur);\\n            }\\n            return pre[m - 1];\\n        }\\n    }; \\n\\nFurther inspecting the above code, keeping two vectors only serve for the purpose of recovering `pre[i]`, which is simply `cur[i]` before its update. So we can use only one vector and the space is further optimized.\\n\\n    class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n            vector<int> cur(m, 0);\\n            for (int i = 0; i < m; i++) {\\n                if (!obstacleGrid[i][0])\\n                    cur[i] = 1;\\n                else break;\\n            }\\n            for (int j = 1; j < n; j++) {\\n                bool flag = false;\\n                if (obstacleGrid[0][j])\\n                    cur[0] = 0;\\n                else flag = true;\\n                for (int i = 1; i < m; i++) {\\n                    if (!obstacleGrid[i][j]) {\\n                        cur[i] += cur[i - 1]; \\n                        if (cur[i]) flag = true;\\n                    }\\n                    else cur[i] = 0; \\n                }\\n                if (!flag) return 0;\\n            }\\n            return cur[m - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n            vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));\\n            dp[0][1] = 1;\\n            for (int i = 1; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (!obstacleGrid[i - 1][j - 1])\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            return dp[m][n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1180249,
                "title": "easy-solutions-w-explanation-comments-optimization-from-brute-force-approach",
                "content": "We start at the top-left of the **`obstacleGrid`** and for each cell in the grid, we can either move right or down. We can\\'t land at an obstacle. We need to return the number of unique paths to reach the bottom-right of grid.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [Rejected]***\\n\\nLet\\'s build our solution starting from the brute force approach. Let\\'s directly apply what\\'s given in the problem statement.  At each cell, we have two choices -\\n\\n&emsp;&emsp;\\u2726 *Go Right*\\n&emsp;&emsp;\\u2726 *Go Down*\\n\\nSo, we can recursively build up our solution as -.\\n\\n1. At each cell, explore the two choices available to us - go right & go down (**Recursive function**).\\n\\n2. If we reach the bottom-right cell of the grid, we have found a unique path (**Base Condition - I**). \\n\\n3. If at any time, we reach a cell with value 1, it is an **obstacle cell** and we can\\'t move any further. So, we just stop exploring further paths from this cell (**Base Condition - II**).  \\n\\n\\nWe will accumulate all such unique paths.\\n\\n**C++**\\n```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Recursive version) [Accepted]***\\n\\nWe can observe that there are a lot of cells that are revisited in the above appraoch and the whole path is recursed till the bottom-right cell is reached for each cell again and again. We don\\'t need to recalculate this everytime if we just store the previously calculated result for a given cell.\\n\\nWe can do this by maintaining a 2d DP array. Here *`dp[i][j]`* will denote the number of unique paths to reach the bottom-right corner of the grid starting from the cell - *`obstacleGrid[i][j]`*.\\n\\n**C++**\\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Iterative version) [Accepted]***\\n\\nWe can also solve it iteratively. We have 1 way in which we can start from *`grid[0][0]`* and for rest of the cells, we could have reached here from the top cell or the left cell. So, we can maintain *`dp[i][j]`* and iteratively accumulate unique paths for current cell by adding *`dp[i - 1][j]`* (number of ways we reached top cell) and *`dp[i][j - 1]`* (number of ways we reached left cell).\\n\\nHere, I am using padded row and column in *`dp`* to simplify the code. In this solution, *`dp[i][j]`*, will denote the number of unique paths to reach the cell *`grid[i-1][j-1]`* (since padded row and column used in dp at start) from the start. \\n\\nThus, we can iterate over the whole grid and at last return **`dp[m][n]`** which will be the number of unique paths to reach bottom-right of grid from the start.\\n\\nHere, *`dp[0][1]`* (or *`dp[1][0]`*) needs to be set to 1 at the start, so that *`dp[1][1]`* will become 1 in our loop (denoting we have one way to reach the starting cell `grid[0][0]`).\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Space Optimized) [Accepted]***\\n\\nWe can see that in the above solution, we are only ever accessing the current and previous rows of the dp array. So, we don\\'t need to maintain the whole *`M*N`* DP array and the space usage can be optimized by maintaining just 2 rows.\\n\\nA common way of doing this with most dp problems is to declare a two rows dp matrix and just alternate between the rows at each iteration. We can alternate between the rows by doing a parity check while indexing a row of dp. Thus, we can use `dp[0]` at even indices and `dp[1]` and odd indices of iteration.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution V - (In-Place) [Accepted]***\\n\\nWe can also choose to modify the given input grid itself (if input modification is allowed). This solution is similar to *`Solution - III`*, with just the change that we are using *`grid`* itself instead of auxillary space for **`dp`**.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i in range(1, n):\\n\\t\\tgrid[0][i] = grid[0][i - 1] & (not grid[0][i])\\n\\tfor j in range(1, m):\\n\\t\\tgrid[j][0] = grid[j - 1][0] & (not grid[j][0])\\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i in range(1, n):\\n\\t\\tgrid[0][i] = grid[0][i - 1] & (not grid[0][i])\\n\\tfor j in range(1, m):\\n\\t\\tgrid[j][0] = grid[j - 1][0] & (not grid[j][0])\\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 23410,
                "title": "python-different-solutions-o-m-n-o-n-in-place",
                "content": "        \\n    # O(m*n) space\\n    def uniquePathsWithObstacles1(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            dp[i][0] = dp[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            dp[0][i] = dp[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) * (1 - obstacleGrid[i][j])\\n        return dp[-1][-1]\\n        \\n    # O(n) space\\n    def uniquePathsWithObstacles2(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        cur = [0] * c\\n        cur[0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, c):\\n            cur[i] = cur[i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            cur[0] *= (1 - obstacleGrid[i][0])\\n            for j in xrange(1, c):\\n                cur[j] = (cur[j-1] + cur[j]) * (1 - obstacleGrid[i][j])\\n        return cur[-1]\\n    \\n    # in place\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            obstacleGrid[0][i] = obstacleGrid[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                obstacleGrid[i][j] = (obstacleGrid[i-1][j] + obstacleGrid[i][j-1]) * (1 - obstacleGrid[i][j])\\n        return obstacleGrid[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(m*n) space\\n    def uniquePathsWithObstacles1(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            dp[i][0] = dp[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            dp[0][i] = dp[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) * (1 - obstacleGrid[i][j])\\n        return dp[-1][-1]\\n        \\n    # O(n) space\\n    def uniquePathsWithObstacles2(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        cur = [0] * c\\n        cur[0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, c):\\n            cur[i] = cur[i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            cur[0] *= (1 - obstacleGrid[i][0])\\n            for j in xrange(1, c):\\n                cur[j] = (cur[j-1] + cur[j]) * (1 - obstacleGrid[i][j])\\n        return cur[-1]\\n    \\n    # in place\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            obstacleGrid[0][i] = obstacleGrid[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                obstacleGrid[i][j] = (obstacleGrid[i-1][j] + obstacleGrid[i][j-1]) * (1 - obstacleGrid[i][j])\\n        return obstacleGrid[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23395,
                "title": "java-simple-and-clean-dp-solution-easy-to-understand",
                "content": "   \\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint m = obstacleGrid.length, n = obstacleGrid[0].length;\\n\\t\\tint[][] path = new int[m][n];\\n\\t\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (obstacleGrid[i][0] == 1)  {\\n\\t\\t\\t\\tpath[i][0] = 0;\\n\\t\\t\\t\\t//on the first column, if there is an obstacle, the rest are blocked. \\n\\t\\t\\t\\t//no need to continue.\\n\\t\\t\\t\\tbreak;  \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[i][0] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (obstacleGrid[0][j] == 1)  {\\n\\t\\t\\t\\tpath[0][j] = 0;\\n\\t\\t\\t\\t//First row, once obstacle found, the rest are blocked.\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[0][j] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (obstacleGrid[i][j] == 1) \\n\\t\\t\\t\\t\\tpath[i][j] = 0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tpath[i][j] = path[i-1][j] + path[i][j-1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn path[m-1][n-1];\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "   \\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint m = obstacleGrid.length, n = obstacleGrid[0].length;\\n\\t\\tint[][] path = new int[m][n];\\n\\t\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (obstacleGrid[i][0] == 1)  {\\n\\t\\t\\t\\tpath[i][0] = 0;\\n\\t\\t\\t\\t//on the first column, if there is an obstacle, the rest are blocked. \\n\\t\\t\\t\\t//no need to continue.\\n\\t\\t\\t\\tbreak;  \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[i][0] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (obstacleGrid[0][j] == 1)  {\\n\\t\\t\\t\\tpath[0][j] = 0;\\n\\t\\t\\t\\t//First row, once obstacle found, the rest are blocked.\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[0][j] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (obstacleGrid[i][j] == 1) \\n\\t\\t\\t\\t\\tpath[i][j] = 0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tpath[i][j] = path[i-1][j] + path[i][j-1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn path[m-1][n-1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2055409,
                "title": "beginner-friendly-recursion-to-dp-intuition-explained-python",
                "content": "Here, we have an obstacleGrid (say ***obs***) of size m* n. We can traverse through this grid by going down and/or right only.\\n**Idea:** We start travering the array from` start index (0, 0)`.\\n* We consider a `path to be valid`, if it has reached the last index (m-1, n-1).\\n* We consider a `path to be invalid`, if either it exceeds the boundary of the ***obs*** grid or the current position in the ***obs*** grid has an obstacle in it.\\n\\nThe above two conditions serves as the **base condition of our recursion**, \\n* for **valid** cases we `return 1` saying that consider this path, and \\n* for **invalid** cases we `return 0` saying that do not consider this path.\\n\\nNow coming to **the recursive part**: We want to traverse the matrix in both right and down direction. So, we recursively call this function for both the right `(i + 1, j)` and down `(i, j+1)` indices. \\n\\n***How does this work?***\\n\\nSee consider you are currently at any arbitrary index in the matrix `(i, j)` . Your goal is to return the `max number of valid paths from (i, j) to (m-1, n-1)`.\\n\\n`From (m-1, n-1) to (m-1, n-1)`, we have just one valid path so return 1 directly from the base condition.\\n...\\n`From (i, j) to (m-1, n-1)`, let us assume there was **1** possible path to go from the downside and **1** possible path to go from the rightside, so total number of ways to reach (m-1, n-1) from (i, j) becomes 1 + 1 **= 2**. \\n\\nIn general, if there was **x** possible path to go from the downside and **y** possible path to go from the rightside, so total number of ways to reach (m-1, n-1) from (i, j) becomes **x + y**.\\n\\nSimilarly, If we compute it for index (0, 0) to (m-1, n-1), we will get all possible ways to reach from start index to the end index.\\n\\nThe recursive code (***not working, TLE***) is given below:\\n\\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        def solve(i , j):\\n            # base condition for recursion\\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            # the down and right recursive calls respectively\\n            return solve(i + 1, j) + solve(i, j+1)\\n        \\n        return solve(0,0)\\n```\\n\\nNo doubt, the above solution runs perfectly fine. But it doesnot match the expected time complexity, hence results in generating a TLE error. \\n\\n***Why TLE?*** =>Here there are total **m * n** grids and each having **2** possiblities : has obstacles or clear path (does not have a obstacle). We will be recursively traversing through the grid considering both the possibilites. Hence, time complexity = O(2 ^ (m * n)) = O(2 ^ (100 * 100)) = O(2 ^ 10000) = O(10 ^12) nearly.\\n\\nThus, **time complexity > O(10 ^ 8)**. and hence ***Time Limit Exceeded*** as Python generally caps the complexity at O(10^8), meaning you cannot exceed it. \\n\\n**Can we do any better?** \\n\\nSee generally when you have TLE for recursive solutions, you can always memoize it (it\\'s just a random observation). But this is not a good reason to say to the interviewers. xD\\n\\n**How to identify a DP problem?** Analyze the problem and Check for overlapping subproblems, so that we can memoize it.\\n\\nConsider the first example as shown below: (indexes of each element is given in *(i, j)* format).\\n![image](https://assets.leetcode.com/users/images/f366ba68-adf7-4e50-9667-49190b5a86e4_1653007809.711647.png)\\n\\nLet\\'s say we are at (0, 1), so by our recursive apporach we would calculate the value of (1,1) , i.e., down and (0, 2), i.e., right indices.\\nNow, let\\'s say we reached (1, 0), here also we will need to calulate (2, 0) and (1, 1). \\n\\nBut haven\\'t we already calulated the number of paths for (1, 1) earlier? **Yes, we did** right (when we were traversing down from (0, 1) index). \\n\\nSo, why not **store it some where** so that we can use it later without the need of recomputing it.\\nJust store the previously computed value and return it whenever the (already computed) index (1, 0) is called. Similarly, do the same for all indices that requires recomputation.\\n\\nThis process of finding overlapping subproblems, storing the computed value, reusing the previously computed value and reducing the recomputation complexity is called **Memoization** or **Top Down Dynamic Programming Approach** (this is specific to recursion, it\\'s nearly equivalent *Bottom up approach or Tabulation* is achieved using iteration).\\n\\nThe Memoized Code: (**Top Down DP**) => **ACCEPTED**.\\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[-1]*n for _ in range(m)]\\n        \\n        def solve(i , j):\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            \\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            \\n            \\n            # if the value of dp[i][j] is updated then directly return the updated value\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            # else compute the value of dp[i][j] for the first time ever\\n            # and return it saying that the returned number (dp[i][j]) of ways are possible from\\n            # (i, j) to the end index.\\n            dp[i][j] = solve(i + 1, j) + solve(i, j+1)\\n            return dp[i][j]\\n        \\n        return solve(0,0)\\n```\\n\\n**Time and Space Complexity Analysis:** (for Top Down DP)\\nHere, each of the successful recursive calls (whose value will be inserted in the dp matrix) will exactly be called once, because later it will take it directly from the dp array in constant time. And the unsuccessful recursive calls will return from the base condition in constant time. But we are traversing through the matrix of size \\'m * n\\' through nested loops (simultaneously). Thus, **optimized time complexity = O(m * n)** owing to the traversal of matrix.\\n\\nNow, we have used only one variable sized space that is dp array of size \\'m * n\\'. Apart from that all other variables are constant sized like n, m, ans, etc.. are fixed sized 32 - bit integer variables. So, no need to consider that, as their size will always be fixed and will not change with respect to change in input variable. Hence, **Space complexity = O(m * n)** owing to the dp array.\\n\\nNow, we know that, any code that is written in **Top Down DP can be easlily converted to Bottom-up DP**. \\n\\n**Is there any advantage of doing so?** or Is it just a waste of time to convert the recursive code to Iterative code?\\n\\nSee, whenever there is recursion involved we use some extra memory in the stack region of the main memory (RAM) to store the functions that are being called recursively one after another.\\n\\nThis stack space is not considered while calculating the output space complexity. So, **asymptotically, it does not** matter whether you convert recursion into iteration or not. But **practically it does matter**.\\n\\n***Let\\'s see how*** => The max depth of recursion will be O(m + n) as in the worst case **either** we will go fully towards right then fully towards down **or** we will first go fully towards down then move straight fully to the right, till we reach the end index. (It will not be anything more than O(m + n)) as we do not traverse back (i.e., top or left) ever. \\n\\nHence **Stack Space =** max number of recursive functions called at a stretch = max depth of recursion **= O(m + n)**. \\n\\nThus, by coverting the Top Down DP to Bottom Up DP, we can further reduce this practical execution space. Thus, keeping our main memory little bit free for storing other data, hence reduing page faults (ignore it for now, if you don\\'t know).\\n\\nThe Tabulation Method (**Bottom Up Dp**): => Definitely **accepted**..... xD\\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[0]*n for _ in range(m)]\\n        \\n        if obs[0][0] == 1 or obs[-1][-1] == 1:\\n            return 0\\n        \\n        # initialize the first row first column of dp\\n        # assign the clear path = 1 and obstacles = 0 value in dp based in obstacle_grid\\n        # we did this because we want to add clear paths and not add obstacles path.\\n        dp[0][0] = 1\\n        for i in range(1,m):\\n            dp[i][0] = 1 if obs[i][0]==0 and dp[i-1][0]==1 else 0\\n            \\n        for j in range(1,n):\\n            dp[0][j] = 1 if obs[0][j]==0  and dp[0][j-1]==1 else 0\\n        \\n        # add clear paths if no obstacles are found.\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obs[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        print(dp)\\n        return dp[m-1][n-1]\\n```\\n\\nI am leaving the above code for you to understand yourself as it will help you analyze deeper. For hints, I have given a few comments in the code.\\n\\nAlso, **note that** in Top Down DP we returned dp[0][0] but in Bottom Up DP Approach we returned dp[-1][-1]. Why??? - Brainstorm a little first, and do comment down below, your findings regrading this.\\n\\nTime Complexity = Space Complexity = O(m * n)  for Bottom Up DP (in this case).\\n***Can we further reduce the space complexity?*** Yes, we can use the obstacle grid itself inplace of DP array to reduce the space complexity to O(1). But generally, modfying the input itself is not considered a wise choice, until and unless an inplace solution is required, where you do not need to return anything, just modify the input array as per conditions and the main function will access it using reference of the input variable. So, no need to return. Hence, inplace. But when nothing such is mentioned and, in real life scenerio if we modify our input array, there might be a possiblilty that this array may be used further somewhere in the program. But by modifying it, we lost the original array, which may not be a good practice.\\n\\nIf this helps you, then **Please UPVOTE**.\\n\\n***Similar Problems with detailed intuitions explained:***\\n\\n* *Leetcode 329. Longest Increasing Path in a Matrix: https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/2052360/python-beginner-friendly-recursion-to-dp-intuition-explained*\\n\\n* *Leetcode 576. Out of Boundary Paths: https://leetcode.com/problems/out-of-boundary-paths/discuss/1293697/python-easy-to-understand-explanation-recursion-and-memoization-with-time-and-space-complexity*\\n\\n* *Leetcode 792. Number of Matching Subsequences: https://leetcode.com/problems/number-of-matching-subsequences/discuss/1289549/python-explained-all-possible-solutions-with-time-and-space-complexity*",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        def solve(i , j):\\n            # base condition for recursion\\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            # the down and right recursive calls respectively\\n            return solve(i + 1, j) + solve(i, j+1)\\n        \\n        return solve(0,0)\\n```\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[-1]*n for _ in range(m)]\\n        \\n        def solve(i , j):\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            \\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            \\n            \\n            # if the value of dp[i][j] is updated then directly return the updated value\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            # else compute the value of dp[i][j] for the first time ever\\n            # and return it saying that the returned number (dp[i][j]) of ways are possible from\\n            # (i, j) to the end index.\\n            dp[i][j] = solve(i + 1, j) + solve(i, j+1)\\n            return dp[i][j]\\n        \\n        return solve(0,0)\\n```\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[0]*n for _ in range(m)]\\n        \\n        if obs[0][0] == 1 or obs[-1][-1] == 1:\\n            return 0\\n        \\n        # initialize the first row first column of dp\\n        # assign the clear path = 1 and obstacles = 0 value in dp based in obstacle_grid\\n        # we did this because we want to add clear paths and not add obstacles path.\\n        dp[0][0] = 1\\n        for i in range(1,m):\\n            dp[i][0] = 1 if obs[i][0]==0 and dp[i-1][0]==1 else 0\\n            \\n        for j in range(1,n):\\n            dp[0][j] = 1 if obs[0][j]==0  and dp[0][j-1]==1 else 0\\n        \\n        # add clear paths if no obstacles are found.\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obs[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        print(dp)\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23291,
                "title": "java-solution-using-dynamic-programming-o-1-space",
                "content": "    public class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            \\n            //Empty case\\n            if(obstacleGrid.length == 0) return 0;\\n            \\n            int rows = obstacleGrid.length;\\n            int cols = obstacleGrid[0].length;\\n            \\n            for(int i = 0; i < rows; i++){\\n                for(int j = 0; j < cols; j++){\\n                    if(obstacleGrid[i][j] == 1)\\n                        obstacleGrid[i][j] = 0;\\n                    else if(i == 0 && j == 0)\\n                        obstacleGrid[i][j] = 1;\\n                    else if(i == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1\\n                    else if(j == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1\\n                    else\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                }\\n            }\\n            \\n            return obstacleGrid[rows - 1][cols - 1];\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            \\n            //Empty case\\n            if(obstacleGrid.length == 0) return 0;\\n            \\n            int rows = obstacleGrid.length;\\n            int cols = obstacleGrid[0].length;\\n            \\n            for(int i = 0; i < rows; i++){\\n                for(int j = 0; j < cols; j++){\\n                    if(obstacleGrid[i][j] == 1)\\n                        obstacleGrid[i][j] = 0;\\n                    else if(i == 0 && j == 0)\\n                        obstacleGrid[i][j] = 1;\\n                    else if(i == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1\\n                    else if(j == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1\\n                    else\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 146073,
                "title": "python-dp-beat-100-python-submissions",
                "content": "Thanks to leetcode\\'s new servers :)\\n\\n\\ndp formule is very easy below:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/joezhow777/image_1530876896.png)\\n\\n```\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n\\n        for i in range(len(obstacleGrid)):\\n            for j in range(len(obstacleGrid[0])):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i-1>=0:\\n                        dp[i][j] += dp[i-1][j]\\n                    if j-1>=0:\\n                         dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n\\n        for i in range(len(obstacleGrid)):\\n            for j in range(len(obstacleGrid[0])):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i-1>=0:\\n                        dp[i][j] += dp[i-1][j]\\n                    if j-1>=0:\\n                         dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1180311,
                "title": "js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every path with a **recursive** **depth first search** (**DFS**) approach. That would involve duplicating the processing used for repeating subpaths, however, which would quickly lead to a **TLE** result. When faced with repeating subproblems, we should be thinking of a **dynamic programming** (**DP**) approach to store completed subproblem and avoid any unnecessary duplication of processing.\\n\\nIn this situation, we can create a DP matrix (**dp**) in the same dimensions as our input matrix (**OG**). (_**Note**: We can choose to use an **in-place** approach here and use **OG** as our DP matrix in order to reduce the **space complexity** of our solution to **O(1)**._) Each cell in **dp** will represent the number of paths that lead to the corresponding cell in **OG**. Since the robot can only move either to the right or down, we can perform a **bottom-up** DP solution, working from the initial cell and iterating downward and rightward through **OG**.\\n\\nEach cell in **OG** (**OG[i][j]**) can potentially reached by only two previously-visited cells (**OG[i-1][j]** & **OG[i][j-1]**), so the number of ways to reach the current cell (**dp[i][j]**) should be the sum of the ways to reach those other two cells (**dp[i-1][j] + dp[i][j-1]**), should they exist.\\n\\nSince any cell representing an obstacle cannot be a part of a path, its value in **dp** should be **0**. We\\'ll also need to seed the initial starting position with a value of **1** to represent the single initial path. Once we\\'re done building **dp**, the value of the bottom-right cell should be our answer.\\n\\n - _**Time Complexity: O(N * M)** where **N** and **M** are the dimensions of the input matrix_\\n - _**Space Complexity: O(N * M)** for the DP matrix_\\n    - _or **O(1)** if we use an **in-place** approach for the DP matrix_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can opt to use @lru_cache instead of a standard DP matrix; the standard approach is shown below.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.6MB** (beats 100% / 96%).\\n```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 94% / 84%).\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 67%).\\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.7MB** (beats 100% / 46%).\\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896905,
                "title": "100-dynamic-programming-video-optimal-solution",
                "content": "# Problem Understanding\\n\\nIn the \"Unique Paths II\" problem, we are presented with a grid filled with obstacles and open paths. Starting from the top-left corner, the goal is to find the number of unique paths that lead to the bottom-right corner. We can only move right or down at any point in time. If a cell has an obstacle, we cannot pass through it.\\n\\nFor example, consider the following grid:\\n\\n$$\\n\\\\begin{array}{ccc}\\n0 & 0 & 0 \\\\\\\\\\n0 & 1 & 0 \\\\\\\\\\n0 & 0 & 0 \\\\\\\\\\n\\\\end{array}\\n$$\\n\\n![63_tsa.png](https://assets.leetcode.com/users/images/ec5e79ee-d2e3-47aa-adaf-aa07efa4b36b_1691802199.0146625.png)\\n\\n\\n- The grid cells with obstacles are colored in red.\\n- The two unique paths from the top-left to the bottom-right corner are represented by the blue and green dashed lines.\\n\\nFrom the plot, you can see the two possible routes:\\n\\n- The blue path goes Right -> Right -> Down -> Down.\\n- The green path goes Down -> Down -> Right -> Right.\\n\\n---\\n\\n# Live Coding\\nhttps://youtu.be/pJ40_FmXAfo\\n\\n- [in Python \\uD83D\\uDC0D](https://youtu.be/pJ40_FmXAfo)\\n- [in Rust \\uD83E\\uDD80](https://youtu.be/xt_1OzCH_NA)\\n\\n# Approach\\n\\n## The Basic Idea\\n\\nThe underlying concept is rooted in dynamic programming. Essentially, for any cell `(i, j)`, the number of ways you can reach it is the sum of the ways you can reach the cell directly above it `(i-1, j)` and the cell directly to its left `(i, j-1)`. However, this is only true if the cell `(i, j)` does not have an obstacle. If it does, then the number of ways to reach this cell is 0 because it\\'s inaccessible.\\n\\n### 2D Transition:\\nIn a 2D dynamic programming approach, you would have a `dp` array of size `m x n`, where ` dp[i][j] ` represents the number of ways to reach cell ` (i, j) `.\\n\\nThe transition formula would be:\\n$$ dp[i][j] = \\n\\\\begin{cases} \\n0 & \\\\text{if } obstacleGrid[i][j] = 1 \\\\\\\\\\ndp[i-1][j] + dp[i][j-1] & \\\\text{otherwise}\\n\\\\end{cases}\\n$$\\n\\nSo, for each cell ` (i, j) `, if there\\'s no obstacle, its value would be the sum of the cell above it and the cell to its left.\\n\\n### Translation to 1D:\\n\\nNow, given the 2D transition, notice how for any cell \\\\( (i, j) \\\\), we only need values from the current row and the previous row. This observation allows us to reduce our 2D `dp` array to two 1D arrays, `previous` and `current`.\\n\\nThe transition formula in 1D would be analogous to the 2D version but slightly adjusted:\\n\\nFor the first column (`j = 0`):\\n$$ current[0] = \\n\\\\begin{cases} \\n0 & \\\\text{if } obstacleGrid[i][0] = 1 \\\\\\\\\\nprevious[0] & \\\\text{otherwise}\\n\\\\end{cases}\\n$$\\n\\nFor other columns:\\n$$ current[j] = \\n\\\\begin{cases} \\n0 & \\\\text{if } obstacleGrid[i][j] = 1 \\\\\\\\\\nprevious[j] + current[j-1] & \\\\text{otherwise}\\n\\\\end{cases}\\n$$\\n\\nHere, `previous` is analogous to `dp[i-1]` and `current` is analogous to `dp[i]` from our 2D approach. After processing each row, we\\'ll swap `previous` and `current` to roll over to the next iteration.\\n\\nThe transition remains conceptually the same between the 2D and 1D versions. The 1D optimization simply leverages the observation that for each cell, we only need data from the current and previous rows. This reduces space complexity from $$ O(m \\\\times n) $$ to $$ O(n) $$.\\n\\nThis rolling array technique is a common optimization strategy in dynamic programming problems involving grids.\\n\\n### Step-by-step Breakdown:\\n\\n1. **Initialization**:\\n   - We initialize the `previous` array with zeros. This array represents the number of ways to reach each cell in the previous row.\\n   - We set `previous[0]` to 1 because there\\'s only one way to get to the starting cell (by starting there!).\\n   \\n2. **Iterate through the Grid**:\\n   - For each row, we consider each cell:\\n     - If the cell has an obstacle, it\\'s unreachable, so the number of ways to get there (`current[j]`) is 0.\\n     - Otherwise, the number of ways to reach the cell is the sum of the ways to reach the cell above and the cell to the left. This translates to `current[j-1] + previous[j]`.\\n   - Once we\\'ve processed a row, we set `previous` to `current`, preparing for the next iteration.\\n\\n3. **Result**:\\n   - Once we\\'ve processed all rows, `previous[n-1]` gives us the number of unique paths to the bottom-right corner of the grid.\\n\\n## Example\\n\\nUsing the earlier example:\\n\\n$$\\n\\\\begin{array}{ccc}\\n0 & 0 & 0 \\\\\\\\\\n0 & 1 & 0 \\\\\\\\\\n0 & 0 & 0 \\\\\\\\\\n\\\\end{array}\\n$$\\n\\nHere\\'s how the `previous` and `current` arrays evolve:\\n\\nThe function\\'s output matches the example description:\\n\\n**Initial State**:\\n- `previous`: $$[1, 0, 0]$$\\n- `current`: $$[0, 0, 0]$$\\n\\n**After processing row 0**:\\n- `previous`: $$[1, 0, 0]$$\\n- `current`: $$[1, 1, 1]$$\\n\\n**After processing row 1**:\\n- `previous`: $$[1, 1, 1]$$\\n- `current`: $$[1, 0, 1]$$\\n\\n**After processing row 2**:\\n- `previous`: $$[1, 0, 1]$$\\n- `current`: $$[1, 1, 2]$$\\n\\nFrom the final state of the `previous` array, we can infer that there are 2 unique paths from the top-left to the bottom-right corner, avoiding obstacles. This matches the expected result.\\n\\n# Complexity\\n\\n**Time Complexity:** $$O(m \\\\times n)$$\\n**Space Complexity:** $$O(n)$$\\n\\nThis solution is optimal in terms of both time and space complexity. It efficiently computes the number of unique paths by building upon previous calculations.\\n\\n# Performance\\n\\n| Language    | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|-------------|--------------|------------------|-------------|-----------------|\\n| Go          | 0            | 100%             | 2.4         | 71.38%          |\\n| C++         | 0            | 100%             | 7.6         | 81.25%          |\\n| Java        | 0            | 100%             | 40.5        | 72.53%          |\\n| Rust        | 1            | 85%              | 2           | 87.50%          |\\n| Python3     | 38           | 99.30%           | 16.3        | 82.98%          |\\n| JavaScript  | 47           | 97.40%           | 41.6        | 97.86%          |\\n| C#          | 81           | 80.72%           | 38.7        | 63.25%          |\\n\\n![perf_518.png](https://assets.leetcode.com/users/images/3cb0ceab-f4d0-4cad-9711-d0e194aad604_1691801587.1220236.png)\\n\\n\\n---\\n\\n# Code\\n\\n``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        previous = [0] * n\\n        current = [0] * n\\n        previous[0] = 1\\n        \\n        for i in range(m):\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            for j in range(1, n):\\n                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]\\n            previous[:] = current\\n        \\n        return previous[n-1]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(std::vector<std::vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n        \\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        std::vector<int> previous(n, 0);\\n        std::vector<int> current(n, 0);\\n        previous[0] = 1;\\n        \\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            previous = current;\\n        }\\n        \\n        return previous[n-1];\\n    }\\n};\\n```\\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    previous[0] = 1\\n\\n    for i := 0; i < m; i++ {\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        for j := 1; j < n; j++ {\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        previous, current = current, previous\\n    }\\n    return previous[n-1]\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        for row in &obstacleGrid {\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        previous[n-1]\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            System.arraycopy(current, 0, previous, 0, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid.length || !obstacleGrid[0].length || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    let m = obstacleGrid.length;\\n    let n = obstacleGrid[0].length;\\n\\n    let previous = new Array(n).fill(0);\\n    let current = new Array(n).fill(0);\\n    previous[0] = 1;\\n\\n    for (let i = 0; i < m; i++) {\\n        current[0] = obstacleGrid[i][0] === 1 ? 0 : previous[0];\\n        for (let j = 1; j < n; j++) {\\n            current[j] = obstacleGrid[i][j] === 1 ? 0 : current[j-1] + previous[j];\\n        }\\n        previous = [...current];\\n    }\\n\\n    return previous[n-1];\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.Length == 0 || obstacleGrid[0].Length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            Array.Copy(current, previous, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```\\n\\n# Conclusion\\n\\nThe \"Unique Paths II\" problem showcases how dynamic programming can help find solutions to combinatorial problems in a structured and efficient manner. By understanding the relationship between subproblems, we can incrementally build the solution and avoid redundant computations. \\n\\nAs with any algorithmic challenge, practice and understanding the underlying principles are key. Don\\'t hesitate to tweak, optimize, and experiment with the solution to deepen your understanding!\\n\\n# Live Coding in Rust\\nhttps://youtu.be/xt_1OzCH_NA",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        previous = [0] * n\\n        current = [0] * n\\n        previous[0] = 1\\n        \\n        for i in range(m):\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            for j in range(1, n):\\n                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]\\n            previous[:] = current\\n        \\n        return previous[n-1]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(std::vector<std::vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n        \\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        std::vector<int> previous(n, 0);\\n        std::vector<int> current(n, 0);\\n        previous[0] = 1;\\n        \\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            previous = current;\\n        }\\n        \\n        return previous[n-1];\\n    }\\n};\\n```\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    previous[0] = 1\\n\\n    for i := 0; i < m; i++ {\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        for j := 1; j < n; j++ {\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        previous, current = current, previous\\n    }\\n    return previous[n-1]\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        for row in &obstacleGrid {\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        previous[n-1]\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            System.arraycopy(current, 0, previous, 0, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid.length || !obstacleGrid[0].length || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    let m = obstacleGrid.length;\\n    let n = obstacleGrid[0].length;\\n\\n    let previous = new Array(n).fill(0);\\n    let current = new Array(n).fill(0);\\n    previous[0] = 1;\\n\\n    for (let i = 0; i < m; i++) {\\n        current[0] = obstacleGrid[i][0] === 1 ? 0 : previous[0];\\n        for (let j = 1; j < n; j++) {\\n            current[j] = obstacleGrid[i][j] === 1 ? 0 : current[j-1] + previous[j];\\n        }\\n        previous = [...current];\\n    }\\n\\n    return previous[n-1];\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.Length == 0 || obstacleGrid[0].Length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            Array.Copy(current, previous, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180225,
                "title": "python-short-dp-solution-explained",
                "content": "This is a classical **dynamic programming** problem. Let `dp[i][j]` be the number of paths to reach coordinate `(i, j)`.  Then first of all we check if we can reach `(0, 0)` coordinate. Then for each cell we check two neighbours: one above and one to the left and add this number of ways to answer. In the end we return `dp[-1][-1]`\\n\\n#### Complexity\\nTime complexity is `O(mn)`, because we have `mn` states and two transactions from one to another. Space complexity is the same.\\n\\n\\n#### Code\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, M):\\n        m, n = len(M), len(M[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = int(M[0][0] == 0)\\n        for i, j in product(range(m), range(n)):\\n            if M[i][j] == 1: continue\\n            if i > 0: dp[i][j] += dp[i-1][j]\\n            if j > 0: dp[i][j] += dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, M):\\n        m, n = len(M), len(M[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = int(M[0][0] == 0)\\n        for i, j in product(range(m), range(n)):\\n            if M[i][j] == 1: continue\\n            if i > 0: dp[i][j] += dp[i-1][j]\\n            if j > 0: dp[i][j] += dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527282,
                "title": "python-dfs-dp-explained-solution",
                "content": "This solution is just a variation of the standard solution provided by leetcode, but I think it\\'s easier to understand. So basically the map is a acyclic directed graph, and we just need to find the total number of paths from start to end.\\n\\nNormally DFS is sufficient for this kind of problem, however since we only need to report a single number, we can record the number of paths starting from a cell *u* once we completed the DFS starting from *u*. Next time when we hit *u* again, we know exactly the DFS result starting from *u*, so we don\\'t have to do it again.\\n\\nNote: `lru_cache`([doc](https://docs.python.org/3/library/functools.html?highlight=lru_cache#functools.lru_cache)) helps store the returned result of every distinct method call. It functions like a `dict` here, and you can also use a `dict` to do the same thing.\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        M, N = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i, j):\\n            if obstacleGrid[i][j]:      # hit an obstacle\\n                return 0\\n            if i == M-1 and j == N-1:   # reach the end\\n                return 1\\n            count = 0\\n            if i < M-1:\\n                count += dfs(i+1, j)    # go down\\n            if j < N-1:\\n                count += dfs(i, j+1)    # go right\\n            return count\\n        \\n        return dfs(0, 0)\\n```\\nThe time and space complexity are both O(MN).\\n\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        M, N = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i, j):\\n            if obstacleGrid[i][j]:      # hit an obstacle\\n                return 0\\n            if i == M-1 and j == N-1:   # reach the end\\n                return 1\\n            count = 0\\n            if i < M-1:\\n                count += dfs(i+1, j)    # go down\\n            if j < N-1:\\n                count += dfs(i, j+1)    # go right\\n            return count\\n        \\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055343,
                "title": "c-8-line-solution",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\n int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n\\t\\t\\t\\t//2 way is possible go right or down\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];",
                "solutionTags": [
                    "C"
                ],
                "code": "PLEASE UPVOTE IF YOU LIKE\\n```\\n int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n\\t\\t\\t\\t//2 way is possible go right or down\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];",
                "codeTag": "Unknown"
            },
            {
                "id": 23411,
                "title": "c-o-mn-time-o-1-space-use-obstaclegrid",
                "content": "use obstacleGrid to save result\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int h = obstacleGrid.size();\\n        if(h == 0) return 0;\\n        int w = obstacleGrid[0].size();\\n        if(w == 0) return 0;\\n        if(obstacleGrid[0][0]) return 0;\\n        \\n        // first cell has 1 path\\n        obstacleGrid[0][0] = 1;\\n        \\n        // first row all are '1' until obstacle (from left only)\\n        for(int i=1; i<w; i++){\\n            obstacleGrid[0][i] = obstacleGrid[0][i] ? 0 : obstacleGrid[0][i-1];\\n        }\\n\\n        for(int j=1; j<h; j++){\\n            // first column is like first row (from top only)\\n            obstacleGrid[j][0] = obstacleGrid[j][0] ? 0 : obstacleGrid[j-1][0];\\n            \\n            // others are up+left\\n            for(int i=1; i<w; i++){\\n                obstacleGrid[j][i] = obstacleGrid[j][i] ? 0 : obstacleGrid[j-1][i] + obstacleGrid[j][i-1];\\n            }\\n        }\\n        \\n        return obstacleGrid[h-1][w-1];\\n    }",
                "solutionTags": [],
                "code": "use obstacleGrid to save result\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int h = obstacleGrid.size();\\n        if(h == 0) return 0;\\n        int w = obstacleGrid[0].size();\\n        if(w == 0) return 0;\\n        if(obstacleGrid[0][0]) return 0;\\n        \\n        // first cell has 1 path\\n        obstacleGrid[0][0] = 1;\\n        \\n        // first row all are '1' until obstacle (from left only)\\n        for(int i=1; i<w; i++){\\n            obstacleGrid[0][i] = obstacleGrid[0][i] ? 0 : obstacleGrid[0][i-1];\\n        }\\n\\n        for(int j=1; j<h; j++){\\n            // first column is like first row (from top only)\\n            obstacleGrid[j][0] = obstacleGrid[j][0] ? 0 : obstacleGrid[j-1][0];\\n            \\n            // others are up+left\\n            for(int i=1; i<w; i++){\\n                obstacleGrid[j][i] = obstacleGrid[j][i] ? 0 : obstacleGrid[j-1][i] + obstacleGrid[j][i-1];\\n            }\\n        }\\n        \\n        return obstacleGrid[h-1][w-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2055375,
                "title": "python-easy-dp-2-approaches-beats-99",
                "content": "The code is using a DP array to solve the problem. The two approaches listed below varies on Space complexity. Both the approaches take **O(m*n)**  time.\\n1. ##### **Space O(m*n)**\\n\\nThe extra space is for the `DP` array.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        dp=[[0] * (n+1) for _ in range(m+1)]        \\n        dp[0][1]=1\\n                        \\n        for row in range(1, m+1):\\n            for col in range(1, n+1):\\n                if not obstacleGrid[row-1][col-1]:\\n                    dp[row][col] = dp[row-1][col] + dp[row][col-1]\\n         \\n        return dp[-1][-1]\\n```\\n\\n2.  ##### **Space O(1)**\\n\\nHere the code will be using the input array as the DP array. In most cases, mutating the input is not recommended. It creates [side-effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) in your code. But this approach is a fun exercise on exploring other alternative solutions within the given problem constraints.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        obstacleGrid[0][0] = 1\\n        for i in range(1,m):\\n            obstacleGrid[i][0] = 1 if obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1 else 0\\n        \\n        for i in range(1,n):\\n            obstacleGrid[0][i] = 1 if obstacleGrid[0][i] == 0 and obstacleGrid[0][i-1] == 1 else 0\\n            \\n        \\n        for row in range(1, m):\\n            for col in range(1, n):                \\n                obstacleGrid[row][col] = obstacleGrid[row-1][col] + obstacleGrid[row][col-1] if obstacleGrid[row][col] == 0 else 0\\n         \\n        return obstacleGrid[-1][-1]\\n```\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        dp=[[0] * (n+1) for _ in range(m+1)]        \\n        dp[0][1]=1\\n                        \\n        for row in range(1, m+1):\\n            for col in range(1, n+1):\\n                if not obstacleGrid[row-1][col-1]:\\n                    dp[row][col] = dp[row-1][col] + dp[row][col-1]\\n         \\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        obstacleGrid[0][0] = 1\\n        for i in range(1,m):\\n            obstacleGrid[i][0] = 1 if obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1 else 0\\n        \\n        for i in range(1,n):\\n            obstacleGrid[0][i] = 1 if obstacleGrid[0][i] == 0 and obstacleGrid[0][i-1] == 1 else 0\\n            \\n        \\n        for row in range(1, m):\\n            for col in range(1, n):                \\n                obstacleGrid[row][col] = obstacleGrid[row-1][col] + obstacleGrid[row][col-1] if obstacleGrid[row][col] == 0 else 0\\n         \\n        return obstacleGrid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513891,
                "title": "java-tc-o-r-c-sc-o-min-r-c-space-optimized-dynamic-programming-solution",
                "content": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * current cell = top cell + left cell. If there is an obstacle at current cell,\\n * then current cell = 0;\\n *\\n * Time Complexity: O(R * C).\\n *\\n * Space Complexity = O(min(R, C)). Either one column or one row is used for dp.\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[rows - 1][cols - 1] == 1) {\\n            return 0;\\n        }\\n        if (rows == 1 && cols == 1) {\\n            return 1;\\n        }\\n\\n        if (rows >= cols) {\\n            return uniquePathHelper(obstacleGrid, rows, cols, true);\\n        } else {\\n            return uniquePathHelper(obstacleGrid, cols, rows, false);\\n        }\\n    }\\n\\n    private int uniquePathHelper(int[][] obstacleGrid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        dp[0] = 1;\\n        for (int i = 0; i < big; i++) {\\n            if ((isColsSmall && obstacleGrid[i][0] == 1) || (!isColsSmall && obstacleGrid[0][i] == 1)) {\\n                dp[0] = 0;\\n            }\\n            for (int j = 1; j < small; j++) {\\n                if ((isColsSmall && obstacleGrid[i][j] == 1) || (!isColsSmall && obstacleGrid[j][i] == 1)) {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/discuss/1513899/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * current cell = top cell + left cell. If there is an obstacle at current cell,\\n * then current cell = 0;\\n *\\n * Time Complexity: O(R * C).\\n *\\n * Space Complexity = O(min(R, C)). Either one column or one row is used for dp.\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[rows - 1][cols - 1] == 1) {\\n            return 0;\\n        }\\n        if (rows == 1 && cols == 1) {\\n            return 1;\\n        }\\n\\n        if (rows >= cols) {\\n            return uniquePathHelper(obstacleGrid, rows, cols, true);\\n        } else {\\n            return uniquePathHelper(obstacleGrid, cols, rows, false);\\n        }\\n    }\\n\\n    private int uniquePathHelper(int[][] obstacleGrid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        dp[0] = 1;\\n        for (int i = 0; i < big; i++) {\\n            if ((isColsSmall && obstacleGrid[i][0] == 1) || (!isColsSmall && obstacleGrid[0][i] == 1)) {\\n                dp[0] = 0;\\n            }\\n            for (int j = 1; j < small; j++) {\\n                if ((isColsSmall && obstacleGrid[i][j] == 1) || (!isColsSmall && obstacleGrid[j][i] == 1)) {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23436,
                "title": "easy-java-solution-in-place-dp",
                "content": "   \\nThe idea is simple, set all obstacles to be 0 while doing the DP. No extra space is used.\\n\\n     public class Solution {\\n            public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n                int m = obstacleGrid.length;\\n                int n = obstacleGrid[0].length;\\n        \\n                obstacleGrid[0][0]^=1;\\n                for(int i = 1;i<m;i++){\\n                    obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0];\\n                }\\n                \\n                for(int j = 1;j<n;j++){\\n                    obstacleGrid[0][j] =(obstacleGrid[0][j]==1)? 0: obstacleGrid[0][j-1];\\n                }\\n                for(int i = 1;i<m;i++){\\n                    for(int j =1;j<n;j++){\\n                        obstacleGrid[i][j] =(obstacleGrid[i][j]==1)? 0: obstacleGrid[i-1][j]+obstacleGrid[i][j-1];\\n                    }\\n                }\\n                return obstacleGrid[m-1][n-1];\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n                int m = obstacleGrid.length;\\n                int n = obstacleGrid[0].length;\\n        \\n                obstacleGrid[0][0]^=1;\\n                for(int i = 1;i<m;i++){\\n                    obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1181058,
                "title": "interview-experience-memoized-tabulation",
                "content": "**RECURSIVE + MEMOIZED SOLUTION :**\\n*   let say  you are at (0,0) and somebody ask you number of ways to reach out (0,0) your answer will be 1 not 0 . because there is 1 way to reach (0,0) which is dont make any move . [this is going to help us in thinking base case]\\n*   You can see by making a recursion tree that calls are repeating . [In generall whenever we do make more than one recursion call calls do  repeat in almost every case].\\n*   have a faith on recursion function that it will give me no of unique paths from intermediate to destination.\\n*   I can go down or right . So just paas them on recursion function having faith it will bring answer from themself to destination .\\n*   just add the number of unique ways from down and right this is the total no of unique ways.\\n*   I have used bottom-up in my solution you can use top to bottom also.\\n\\n**CODE:**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        return paths(0,0,obstacleGrid.length-1,obstacleGrid[0].length-1,obstacleGrid,new int[obstacleGrid.length][obstacleGrid[0].length]);\\n    }\\n\\t\\n\\t //sr:source row , sc: source column\\n     //dr: destination row , dc: destination column \\n\\t //qb: question bank to ask question have we solved this row and col before ? if yes then why to solve again\\n\\t \\n    public static int paths(int sr,int sc,int dr,int dc,int[][] grid,int[][] qb){\\n        if(sr==dr && sc==dc && grid[sr][sc]==0) return 1;\\n        \\n        if(sr>dr || sc>dc || grid[sr][sc]==1) return 0; // if \\n\\t\\t\\n        if(qb[sr][sc]!=0) return qb[sr][sc];\\n\\t\\t\\n        int iv=paths(sr+1,sc,dr,dc,grid,qb); //iv: intermediate vertical\\n        int ih=paths(sr,sc+1,dr,dc,grid,qb); // intermediate horizontal\\n        \\n        int tp=iv+ ih; //tp: total path\\n        qb[sr][sc]=tp;\\n        return tp;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n`Time:O(n^2) and Space:O(n^2)`\\n\\n**Iterative [Tabulation] :**\\n* I am Starting from dr,dc and building the answer. \\n* First solve those (r,c) whom you are going to use to get your answer. \\n**CODE:**\\n```\\n public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n          int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length];\\n           \\n           int dr=dp.length-1;\\n           int dc=dp[0].length-1;\\n        \\n          for(int r=dr;r>=0;r--){\\n            for(int c=dc;c>=0;c--){\\n                int rp1=r+1;  //rp1: row plus 1\\n                int cp1=c+1; //cp1 : col plus 1\\n                \\n                if(obstacleGrid[r][c]==1){  //if obstacle means block\\n                    dp[r][c]=0;\\n                }else if(r==dr && c==dc){\\n                     dp[r][c]=1;  // if i am at dr,dc number of ways =1 dont make any move\\n                }else if(r==dr){\\n                     dp[r][c]=dp[r][cp1];  // last row means can move only horizontal vertical moves are not valid\\n                }else if(c==dc){\\n                      dp[r][c]=dp[rp1][c];\\n                }else{\\n                    dp[r][c]=dp[rp1][c] + dp[r][cp1];\\n                }\\n            }  \\n          }\\n        return dp[0][0];\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n^2) and Space:O(n^2)`\\n\\n\\n\\n**Interview Experience:**\\nI have got this  question at UNDOSTRES final interview. My final interview went for 4 hours but unluckily 0 selection from our college this time maybe because of Covid. This was my 1st International Interview . Those who dont know about undostres its like paytm in MEXICO. They only hire for MEXICO location . \\nwhen interviewer gave me this question dont know why but I smiled then he asked have you solved this question before . I told maybe yes not sure but i have solved similar questions. then I have wrote tabulation code and it got passed in one go. but maybe interviewer got an idea that i have solved this before so he gave another question after this.\\nInterview started at 8:00 pm and  ended at 11:48 PM .\\nBut It was great fun interviewing with them .Interviewer want me to give chance thats why he strecthed interview so much .\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.\\n\\nI would highly recommend to follow **PEPCODING** dp Playlist on youtube if you want a expertie in this kind fo questions.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        return paths(0,0,obstacleGrid.length-1,obstacleGrid[0].length-1,obstacleGrid,new int[obstacleGrid.length][obstacleGrid[0].length]);\\n    }\\n\\t\\n\\t //sr:source row , sc: source column\\n     //dr: destination row , dc: destination column \\n\\t //qb: question bank to ask question have we solved this row and col before ? if yes then why to solve again\\n\\t \\n    public static int paths(int sr,int sc,int dr,int dc,int[][] grid,int[][] qb){\\n        if(sr==dr && sc==dc && grid[sr][sc]==0) return 1;\\n        \\n        if(sr>dr || sc>dc || grid[sr][sc]==1) return 0; // if \\n\\t\\t\\n        if(qb[sr][sc]!=0) return qb[sr][sc];\\n\\t\\t\\n        int iv=paths(sr+1,sc,dr,dc,grid,qb); //iv: intermediate vertical\\n        int ih=paths(sr,sc+1,dr,dc,grid,qb); // intermediate horizontal\\n        \\n        int tp=iv+ ih; //tp: total path\\n        qb[sr][sc]=tp;\\n        return tp;\\n    }\\n}\\n```\n```\\n public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n          int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length];\\n           \\n           int dr=dp.length-1;\\n           int dc=dp[0].length-1;\\n        \\n          for(int r=dr;r>=0;r--){\\n            for(int c=dc;c>=0;c--){\\n                int rp1=r+1;  //rp1: row plus 1\\n                int cp1=c+1; //cp1 : col plus 1\\n                \\n                if(obstacleGrid[r][c]==1){  //if obstacle means block\\n                    dp[r][c]=0;\\n                }else if(r==dr && c==dc){\\n                     dp[r][c]=1;  // if i am at dr,dc number of ways =1 dont make any move\\n                }else if(r==dr){\\n                     dp[r][c]=dp[r][cp1];  // last row means can move only horizontal vertical moves are not valid\\n                }else if(c==dc){\\n                      dp[r][c]=dp[rp1][c];\\n                }else{\\n                    dp[r][c]=dp[rp1][c] + dp[r][cp1];\\n                }\\n            }  \\n          }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860422,
                "title": "c-dp-solution-almost-same-code-as-unique-paths-i",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(m==0||n==0) return 0;\\n        int dp[m][n];\\n         memset(dp,0,sizeof(dp));\\n        for(int i=0;i<m;i++)\\n        {   if(obstacleGrid[i][0]!=1) dp[i][0]=1;\\n            else break;\\n        }\\n        for(int j=0;j<n;j++)\\n        {   if(obstacleGrid[0][j]!=1) dp[0][j]=1;\\n            else break;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                if(obstacleGrid[i][j]!=1)\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(m==0||n==0) return 0;\\n        int dp[m][n];\\n         memset(dp,0,sizeof(dp));\\n        for(int i=0;i<m;i++)\\n        {   if(obstacleGrid[i][0]!=1) dp[i][0]=1;\\n            else break;\\n        }\\n        for(int j=0;j<n;j++)\\n        {   if(obstacleGrid[0][j]!=1) dp[0][j]=1;\\n            else break;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                if(obstacleGrid[i][j]!=1)\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500734,
                "title": "java-recursion-memoization-dp-solutions",
                "content": "**Recursion : TLE**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        return helper(obstacleGrid,0,0,m,n);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        return helper(grid,r+1,c,m,n)+helper(grid,r,c+1,m,n);\\n    }\\n}\\n```\\n**Memoization : \\n41 / 41 test cases passed.\\nStatus: Accepted\\nRuntime: 4 ms\\nMemory Usage: 38.5 MB**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        return helper(obstacleGrid,0,0,m,n,dp);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n,int[][] dp){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        if(dp[r][c] > 0)return dp[r][c];\\n        return dp[r][c] = helper(grid,r+1,c,m,n,dp)+helper(grid,r,c+1,m,n,dp);\\n    }\\n}\\n```\\n**DP :\\n41 / 41 test cases passed.\\nStatus: Accepted\\nRuntime: 0 ms\\nMemory Usage: 38 MB**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m-1;i>=0;i--){\\n            for(int j = n-1;j>=0;j--){\\n                if(i == m-1 && j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = 1;\\n                }else if(i == m-1 || j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else if(i == m-1)dp[i][j] = dp[i][j+1];\\n                    else if(j == n-1)dp[i][j] = dp[i+1][j];\\n                }else{\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        return helper(obstacleGrid,0,0,m,n);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        return helper(grid,r+1,c,m,n)+helper(grid,r,c+1,m,n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        return helper(obstacleGrid,0,0,m,n,dp);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n,int[][] dp){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        if(dp[r][c] > 0)return dp[r][c];\\n        return dp[r][c] = helper(grid,r+1,c,m,n,dp)+helper(grid,r,c+1,m,n,dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m-1;i>=0;i--){\\n            for(int j = n-1;j>=0;j--){\\n                if(i == m-1 && j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = 1;\\n                }else if(i == m-1 || j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else if(i == m-1)dp[i][j] = dp[i][j+1];\\n                    else if(j == n-1)dp[i][j] = dp[i+1][j];\\n                }else{\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23430,
                "title": "bottom-up-iterative-solution-o-mn-no-extra-space",
                "content": "     public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        \\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (obstacleGrid[r][c] == 1) obstacleGrid[r][c] = 0;\\n                else {\\n                    if (r == m - 1 && c == n - 1) obstacleGrid[r][c] = 1;\\n                    else if (r == m - 1) obstacleGrid[r][c] = obstacleGrid[r][c + 1];\\n                    else if (c == n - 1) obstacleGrid[r][c] = obstacleGrid[r + 1][c];\\n                    else obstacleGrid[r][c] = obstacleGrid[r][c + 1] + obstacleGrid[r + 1][c];\\n                }\\n            }\\n        }\\n        \\n        return obstacleGrid[0][0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        \\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (obstacleGrid[r][c] == 1) obstacleGrid[r][c] = 0;\\n                else {\\n                    if (r == m - 1 && c == n - 1) obstacleGrid[r][c] = 1;\\n                    else if (r == m - 1) obstacleGrid[r][c] = obstacleGrid[r][c + 1];\\n                    else if (c == n - 1) obstacleGrid[r][c] = obstacleGrid[r + 1][c];\\n                    else obstacleGrid[r][c] = obstacleGrid[r][c + 1] + obstacleGrid[r + 1][c];\\n                }\\n            }\\n        }\\n        \\n        return obstacleGrid[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23273,
                "title": "accepted-simple-python-in-place-solution",
                "content": "As below. Any comments on how to make it shorter? Thx!\\n\\n    class Solution:\\n        # @param obstacleGrid, a list of lists of integers\\n        # @return an integer\\n        def uniquePathsWithObstacles(self, obstacleGrid):\\n            m = len(obstacleGrid)\\n            n = len(obstacleGrid[0])\\n            obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n            \\n            for i in range(1, n):\\n                if not obstacleGrid[0][i]:\\n                    obstacleGrid[0][i] = obstacleGrid[0][i-1]\\n                else:\\n                    obstacleGrid[0][i] = 0\\n                    \\n            for i in range(1, m):\\n                if not obstacleGrid[i][0]:\\n                    obstacleGrid[i][0] = obstacleGrid[i-1][0]\\n                else:\\n                    obstacleGrid[i][0] = 0\\n                    \\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    if not obstacleGrid[i][j]:\\n                        obstacleGrid[i][j] = obstacleGrid[i][j-1]+obstacleGrid[i-1][j]\\n                    else:\\n                        obstacleGrid[i][j] = 0\\n                        \\n            return obstacleGrid[-1][-1]",
                "solutionTags": [],
                "code": "As below. Any comments on how to make it shorter? Thx!\\n\\n    class Solution:\\n        # @param obstacleGrid, a list of lists of integers\\n        # @return an integer\\n        def uniquePathsWithObstacles(self, obstacleGrid):\\n            m = len(obstacleGrid)\\n            n = len(obstacleGrid[0])\\n            obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n            \\n            for i in range(1, n):\\n                if not obstacleGrid[0][i]:\\n                    obstacleGrid[0][i] = obstacleGrid[0][i-1]\\n                else:\\n                    obstacleGrid[0][i] = 0\\n                    \\n            for i in range(1, m):\\n                if not obstacleGrid[i][0]:\\n                    obstacleGrid[i][0] = obstacleGrid[i-1][0]\\n                else:\\n                    obstacleGrid[i][0] = 0\\n                    \\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    if not obstacleGrid[i][j]:\\n                        obstacleGrid[i][j] = obstacleGrid[i][j-1]+obstacleGrid[i-1][j]\\n                    else:\\n                        obstacleGrid[i][j] = 0\\n                        \\n            return obstacleGrid[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 3896989,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nMain goal is to determine the count of unique paths from the top-left corner to the bottom-right corner of a grid while accounting for obstacles in the grid. It uses dynamic programming to iteratively calculate the paths, avoiding obstacles and utilizing previously computed values to efficiently arrive at the final count.\\n\\nThis python solution beats 96%.\\n![Screen Shot 2023-08-12 at 21.13.22.png](https://assets.leetcode.com/users/images/74f201be-a679-4119-857c-162c270611f0_1691842439.115498.png)\\n\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 244 videos as of August 12th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/-nVmLvqo5qc\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Define the class `Solution` which contains the method `uniquePathsWithObstacles` that takes `obstacleGrid` as input and returns the number of unique paths.\\n\\n2. Check if `obstacleGrid` is empty or if the starting cell (0, 0) is an obstacle (marked as 1). If either of these conditions is met, return 0, as there is no way to reach the destination.\\n\\n3. Get the number of rows and columns in the `obstacleGrid` and store them in `rows` and `cols` variables, respectively.\\n\\n4. Create an array `dp` of size `cols` to store the number of unique paths for each column. Initialize all values in `dp` to 0.\\n\\n5. Set `dp[0]` to 1, representing the number of ways to reach the starting cell (0, 0).\\n\\n6. Iterate through each row (`r`) in the `obstacleGrid`:\\n\\n   a. For each row, iterate through each column (`c`) in the `obstacleGrid`:\\n\\n      - If the current cell (`obstacleGrid[r][c]`) contains an obstacle (marked as 1), set `dp[c]` to 0, indicating that there are no paths to reach this obstacle cell.\\n\\n      - Otherwise, if the current cell is not an obstacle:\\n\\n        - Check if `c` is greater than 0 (i.e., not in the leftmost column). If true, update `dp[c]` by adding the value of `dp[c - 1]`. This accounts for the paths coming from the cell above (`dp[c]`) and the cell to the left (`dp[c - 1]`).\\n\\n7. After iterating through all the cells in the grid, return the value of `dp[cols - 1]`, which represents the number of unique paths to reach the bottom-right cell (rows - 1, cols - 1).\\n\\nIn summary, this algorithm uses dynamic programming to calculate the number of unique paths from the top-left corner to the bottom-right corner of the grid while avoiding obstacles. The `dp` array is updated iteratively, taking into account the paths from the cell above and the cell to the left.\\n\\n# How solution code works\\n`[0, 0, 0]`\\n`[0, 1, 0]`\\n`[0, 0, 0]`\\n\\nBefore starting nested loop, `dp` is `[1, 0, 0]`.\\n\\n1. iterating the first row and using `[1, 0, 0]`(previous result). In the end dp should be `[1, 1, 1]`\\n    - check `uniquePathsWithObstacles[0][0]` \\u2192 `dp = [1, 0, 0]`\\n    - check `uniquePathsWithObstacles[0][1]` \\u2192 `dp = [1, 1, 0]`\\n    - check `uniquePathsWithObstacles[0][2]` \\u2192 `dp = [1, 1, 1]`\\n\\n2. iterating the second row and using `[1, 1, 1]`(previous result). In the end dp should be `[1, 0, 1]`\\n    - check `uniquePathsWithObstacles[1][0]` \\u2192 `dp = [1, 1, 1]`\\n    - check `uniquePathsWithObstacles[1][1]` \\u2192 `dp = [1, 0, 1]`\\n    - check `uniquePathsWithObstacles[1][2]` \\u2192 `dp = [1, 0, 1]`\\n\\n3. iterating the thrid row and using `[1, 0, 1]`(previous result). In the end dp should be `[1, 1, 2]`\\n    - check `uniquePathsWithObstacles[2][0]` \\u2192 `dp = [1, 0, 1]`\\n    - check `uniquePathsWithObstacles[2][1]` \\u2192 `dp = [1, 1, 1]`\\n    - check `uniquePathsWithObstacles[2][2]` \\u2192 `dp = [1, 1, 2]` \\n\\nOutput should be `2`.\\n\\n# Complexity\\n- Time complexity: O(rows * cols)\\n\\n- Space complexity: O(cols)\\n\\n```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        rows, cols = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [0] * cols\\n        dp[0] = 1\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                if obstacleGrid[r][c] == 1:\\n                    dp[c] = 0\\n                else:\\n                    if c > 0:\\n                        dp[c] += dp[c - 1]\\n\\n        return dp[cols - 1] \\n```\\n```javascript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    const rows = obstacleGrid.length;\\n    const cols = obstacleGrid[0].length;\\n    const dp = new Array(cols).fill(0);\\n    dp[0] = 1;\\n\\n    for (let r = 0; r < rows; r++) {\\n        for (let c = 0; c < cols; c++) {\\n            if (obstacleGrid[r][c] === 1) {\\n                dp[c] = 0;\\n            } else {\\n                if (c > 0) {\\n                    dp[c] += dp[c - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[cols - 1];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        int[] dp = new int[cols];\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.size();\\n        int cols = obstacleGrid[0].size();\\n        vector<int> dp(cols, 0);\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n};\\n```\\n\\n# Related video\\nI have an video for Unique Path I. Please check if you like.\\n\\nhttps://youtu.be/6NorAYw7NMU\\n\\nThank you for reading. Please upvote this article and don\\'t forget to subscribe to my youtube channel!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        rows, cols = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [0] * cols\\n        dp[0] = 1\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                if obstacleGrid[r][c] == 1:\\n                    dp[c] = 0\\n                else:\\n                    if c > 0:\\n                        dp[c] += dp[c - 1]\\n\\n        return dp[cols - 1] \\n```\n```javascript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    const rows = obstacleGrid.length;\\n    const cols = obstacleGrid[0].length;\\n    const dp = new Array(cols).fill(0);\\n    dp[0] = 1;\\n\\n    for (let r = 0; r < rows; r++) {\\n        for (let c = 0; c < cols; c++) {\\n            if (obstacleGrid[r][c] === 1) {\\n                dp[c] = 0;\\n            } else {\\n                if (c > 0) {\\n                    dp[c] += dp[c - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[cols - 1];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        int[] dp = new int[cols];\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.size();\\n        int cols = obstacleGrid[0].size();\\n        vector<int> dp(cols, 0);\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225310,
                "title": "finding-unique-paths-in-a-grid-with-obstacles-a-dynamic-programming-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the number of unique paths from the top-left corner of a matrix to the bottom-right corner. The matrix contains obstacles which are represented by 1 and free spaces represented by 0. If there is an obstacle at a cell, we cannot go through that cell. Our intuition should be to use Dynamic Programming (DP) to solve this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a DP matrix `dp` of the same size as the input `obstacleGrid`. The value of `dp[i][j]` represents the number of unique paths to reach the cell at `(i, j)` in `obstacleGrid`.\\n\\nWe can initialize the `dp` matrix with `0`s. For the top-left corner of `obstacleGrid`, if there is an obstacle, then there are no unique paths to reach that cell. Hence, we set `dp[0][0]` to `0`. Otherwise, there is only one unique path to reach that cell, so we set `dp[0][0]` to `1`.\\n\\nNext, we can consider the first row and first column of `obstacleGrid`. If there is an obstacle in any cell in the first row or first column, we cannot move right or down, respectively. Hence, we set the corresponding `dp` value to `0`. Otherwise, we can only move either right or down in these cells, and hence there is only one unique path to reach these cells. We set the corresponding `dp` value to `1`.\\n\\nWe then iterate over the remaining cells in `obstacleGrid`, and for each cell, we check if there is an obstacle in that cell. If there is an obstacle, we set the corresponding dp value to 0, as we cannot go through that cell. Otherwise, the number of unique paths to reach that cell is the sum of the number of unique paths to reach the cell above it and the cell to the left of it. Hence, we set `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.\\n\\nFinally, the number of unique paths to reach the bottom-right corner of `obstacleGrid` is `dp[m-1][n-1]`, where `m` and `n` are the number of rows and columns in `obstacleGrid`, respectively.\\n# Complexity\\n- Time complexity:  The algorithm iterates over each cell in `obstacleGrid` exactly once, and for each cell, it performs a constant number of operations. Hence, the time complexity of this algorithm is $$O(mn)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The algorithm uses a DP matrix `dp` of size `m` x `n`, which requires $$O(mn)$$ space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        for i in range(1, m):\\n            if obstacleGrid[i][0] == 0:\\n                dp[i][0] = dp[i-1][0]\\n        for j in range(1, n):\\n            if obstacleGrid[0][j] == 0:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obstacleGrid[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        for i in range(1, m):\\n            if obstacleGrid[i][0] == 0:\\n                dp[i][0] = dp[i-1][0]\\n        for j in range(1, n):\\n            if obstacleGrid[0][j] == 0:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obstacleGrid[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165962,
                "title": "c-dp-recursion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>&grid){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        \\n        int up=solve(i-1,j,grid);\\n        int left=solve(i,j-1,grid);\\n        \\n        return up+left;\\n    }\\n    int solveMemo(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=solveMemo(i-1,j,grid,dp);\\n        int left=solveMemo(i,j-1,grid,dp);\\n        \\n        return dp[i][j]=up+left;\\n    }\\n     int solveTabu(int m,int n,vector<vector<int>>&grid){\\n                vector<vector<int>>dp(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) dp[i][j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=dp[i-1][j];\\n                     if(j>0) left=dp[i][j-1];\\n                     \\n                     dp[i][j]=up+left;\\n                 }\\n             }\\n         }\\n         return dp[m-1][n-1];\\n\\n    }\\n    int solveTabuSo(int m,int n,vector<vector<int>>&grid){\\n                vector<int>prev(n,0);\\n        \\n         for(int i=0;i<m;i++){\\n             vector<int>cur(n,0);\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) cur[j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=prev[j];\\n                     if(j>0) left=cur[j-1];\\n                     \\n                    cur[j]=up+left;\\n                 }\\n             }\\n             prev=cur;\\n         }\\n         return prev[n-1];\\n\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // return solve(m-1,n-1,grid);\\n        // vector<vector<int>>dp(m,vector<int>(n,-1));\\n        // return solveMemo(m-1,n-1,grid,dp);\\n        // return solveTabu(m,n,grid);\\n        return solveTabuSo(m,n,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>&grid){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        \\n        int up=solve(i-1,j,grid);\\n        int left=solve(i,j-1,grid);\\n        \\n        return up+left;\\n    }\\n    int solveMemo(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=solveMemo(i-1,j,grid,dp);\\n        int left=solveMemo(i,j-1,grid,dp);\\n        \\n        return dp[i][j]=up+left;\\n    }\\n     int solveTabu(int m,int n,vector<vector<int>>&grid){\\n                vector<vector<int>>dp(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) dp[i][j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=dp[i-1][j];\\n                     if(j>0) left=dp[i][j-1];\\n                     \\n                     dp[i][j]=up+left;\\n                 }\\n             }\\n         }\\n         return dp[m-1][n-1];\\n\\n    }\\n    int solveTabuSo(int m,int n,vector<vector<int>>&grid){\\n                vector<int>prev(n,0);\\n        \\n         for(int i=0;i<m;i++){\\n             vector<int>cur(n,0);\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) cur[j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=prev[j];\\n                     if(j>0) left=cur[j-1];\\n                     \\n                    cur[j]=up+left;\\n                 }\\n             }\\n             prev=cur;\\n         }\\n         return prev[n-1];\\n\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // return solve(m-1,n-1,grid);\\n        // vector<vector<int>>dp(m,vector<int>(n,-1));\\n        // return solveMemo(m-1,n-1,grid,dp);\\n        // return solveTabu(m,n,grid);\\n        return solveTabuSo(m,n,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056525,
                "title": "c-easy-recursion-dp-simple-daily-leetcoding-challenge-may-day-20",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& obstacleGrid,int i,int j,vector<vector<int>> &dp,int m ,int n)\\n    {\\n        // if current cell value is not inside the boundary then we can not proceed further return 0\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1)\\n            return 0;\\n        \\n        // if we have already computed the value then no need to calvulate it again\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        // if we have on last cell then tsake it as a path and return 1\\n        if(i==m-1 && j==n-1)\\n        {    \\n            return 1;\\n        }\\n        \\n        // now call the same function for right move and down move and add that\\n        // first this function will go for the right move and calculate it paths\\n        // then after backtrack it will go to down and calculate their paths\\n        // and at the end add up both the paths and return\\n        //                      (right move)             (down move)\\n        return dp[i][j]=dfs(obstacleGrid,i,j+1,dp,m,n)+dfs(obstacleGrid,i+1,j,dp,m,n);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();      // no. of rows\\n        int n=obstacleGrid[0].size();   // no. of columns\\n        \\n        // set all values as -1 for dp\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        // return the possible paths\\n        return dfs(obstacleGrid,0,0,dp,m,n);   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& obstacleGrid,int i,int j,vector<vector<int>> &dp,int m ,int n)\\n    {\\n        // if current cell value is not inside the boundary then we can not proceed further return 0\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1)\\n            return 0;\\n        \\n        // if we have already computed the value then no need to calvulate it again\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        // if we have on last cell then tsake it as a path and return 1\\n        if(i==m-1 && j==n-1)\\n        {    \\n            return 1;\\n        }\\n        \\n        // now call the same function for right move and down move and add that\\n        // first this function will go for the right move and calculate it paths\\n        // then after backtrack it will go to down and calculate their paths\\n        // and at the end add up both the paths and return\\n        //                      (right move)             (down move)\\n        return dp[i][j]=dfs(obstacleGrid,i,j+1,dp,m,n)+dfs(obstacleGrid,i+1,j,dp,m,n);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();      // no. of rows\\n        int n=obstacleGrid[0].size();   // no. of columns\\n        \\n        // set all values as -1 for dp\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        // return the possible paths\\n        return dfs(obstacleGrid,0,0,dp,m,n);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915667,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: obstacleGrid[0].count), count: obstacleGrid.count)\\n        \\n        matrix[0][0] = 1\\n        for i in 0..<obstacleGrid.count {\\n            for j in 0..<obstacleGrid[0].count {\\n                if i > 0 { matrix[i][j] += matrix[i - 1][j] }\\n                if j > 0 { matrix[i][j] += matrix[i][j - 1] }\\n                if obstacleGrid[i][j] == 1 { matrix[i][j] = 0 }\\n            }\\n        }\\n        \\n        return matrix[obstacleGrid.count - 1][obstacleGrid[0].count - 1]\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: obstacleGrid[0].count), count: obstacleGrid.count)\\n        \\n        matrix[0][0] = 1\\n        for i in 0..<obstacleGrid.count {\\n            for j in 0..<obstacleGrid[0].count {\\n                if i > 0 { matrix[i][j] += matrix[i - 1][j] }\\n                if j > 0 { matrix[i][j] += matrix[i][j - 1] }\\n                if obstacleGrid[i][j] == 1 { matrix[i][j] = 0 }\\n            }\\n        }\\n        \\n        return matrix[obstacleGrid.count - 1][obstacleGrid[0].count - 1]\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180265,
                "title": "c-super-simple-and-clean-dynamic-programming-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid[0][0] == 1) \\n            return 0;\\n        \\n        obstacleGrid[0][0] = 1;\\n        \\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        for (int i = 1; i < n; i++)\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i-1][0] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < m; i++)\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i-1] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 : obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\\n        \\n        return obstacleGrid[n-1][m-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid[0][0] == 1) \\n            return 0;\\n        \\n        obstacleGrid[0][0] = 1;\\n        \\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        for (int i = 1; i < n; i++)\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i-1][0] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < m; i++)\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i-1] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 : obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\\n        \\n        return obstacleGrid[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056536,
                "title": "simple-c-code-dp-both-recursive-and-iterative-approach",
                "content": "Recursive Approach\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(grid[x][y]==1) return 0;\\n        if(x==0 && y==0) return 1;\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = 0;\\n        if(x>0) ans += fun(x-1, y, grid);\\n        if(y>0) ans += fun(x, y-1, grid);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();   \\n        dp.resize(m, vector<int>(n, -1));\\n        return fun(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\nIterative Approach\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1) return 0;\\n        int m = grid.size(), n = grid[0].size();   \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        dp[0][0] = 1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                dp[i][j] = 0;\\n                if(grid[i][j]==1) continue;\\n                if(i>0) dp[i][j] += dp[i-1][j];\\n                if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(grid[x][y]==1) return 0;\\n        if(x==0 && y==0) return 1;\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = 0;\\n        if(x>0) ans += fun(x-1, y, grid);\\n        if(y>0) ans += fun(x, y-1, grid);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();   \\n        dp.resize(m, vector<int>(n, -1));\\n        return fun(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1) return 0;\\n        int m = grid.size(), n = grid[0].size();   \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        dp[0][0] = 1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                dp[i][j] = 0;\\n                if(grid[i][j]==1) continue;\\n                if(i>0) dp[i][j] += dp[i-1][j];\\n                if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23434,
                "title": "python-recursive-solution-with-cache-54ms",
                "content": "    class Solution:\\n        # @param {integer[][]} obstacleGrid\\n        # @return {integer}\\n        def uniquePathsWithObstacles(self, obstacleGrid):\\n            if not len(obstacleGrid) or not len(obstacleGrid[0]):\\n                return 0\\n    \\n            cache = {}\\n            m, n = len(obstacleGrid) - 1, len(obstacleGrid[0]) - 1\\n    \\n            return self.findPath(obstacleGrid, m, n, cache)\\n    \\n        def findPath(self, obstacleGrid, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m < 0 or n < 0 or obstacleGrid[m][n] == 1:\\n                return 0\\n            elif m == 0 and n == 0:\\n                return 1\\n    \\n            cache[(m, n)] = self.findPath(obstacleGrid, m - 1, n, cache) + self.findPath(obstacleGrid, m, n - 1, cache)\\n    \\n            return cache[(m, n)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 2975563,
                "title": "c-easy-to-understand-recursion-memoization-tabulation",
                "content": "**1. Recursion**\\n\\n```\\nint solveRec(int m,int n,vector<vector<int>>& obstacleGrid){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;    \\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;                                           \\n        int down=solveRec(m+1,n,obstacleGrid);\\n        int right=solveRec(m,n+1,obstacleGrid);\\n        int ans=down+right;\\n        return ans;\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveRec(0,0,obstacleGrid);\\n  }\\n```\\n\\n**2. Memoization**\\n\\n```\\nint solveMem(int m,int n,vector<vector<int>>& obstacleGrid,vector<vector<int>>&dp){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;\\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int down=solveMem(m+1,n,obstacleGrid,dp);\\n        int right=solveMem(m,n+1,obstacleGrid,dp);\\n        int ans=down+right;\\n        return dp[m][n]=ans;  \\n    }\\n  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n         vector<vector<int>>dp(obstacleGrid.size(),vector<int>(obstacleGrid[0].size(),-1));\\n         return solveMem(0,0,obstacleGrid,dp);\\n  }\\n```\\n**3. Tabulation**\\n\\n```\\nint solveTab(vector<vector<int>>& obstacleGrid){\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1) return 0;\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        dp[0][0]=1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                \\n                if(obstacleGrid[i][j]==0){ // if there is no obstacle present in the grid\\n                    \\n                    int moveUp=0;\\n                    int moveleft=0;\\n                    \\n                    if(i-1>=0){\\n                        moveUp=dp[i-1][j];\\n                    }\\n                    if(j-1>=0){\\n                        moveleft=dp[i][j-1];\\n                    }\\n                    dp[i][j]=moveUp+moveleft;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveTab(obstacleGrid);\\n  }\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nint solveRec(int m,int n,vector<vector<int>>& obstacleGrid){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;    \\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;                                           \\n        int down=solveRec(m+1,n,obstacleGrid);\\n        int right=solveRec(m,n+1,obstacleGrid);\\n        int ans=down+right;\\n        return ans;\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveRec(0,0,obstacleGrid);\\n  }\\n```\n```\\nint solveMem(int m,int n,vector<vector<int>>& obstacleGrid,vector<vector<int>>&dp){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;\\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int down=solveMem(m+1,n,obstacleGrid,dp);\\n        int right=solveMem(m,n+1,obstacleGrid,dp);\\n        int ans=down+right;\\n        return dp[m][n]=ans;  \\n    }\\n  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n         vector<vector<int>>dp(obstacleGrid.size(),vector<int>(obstacleGrid[0].size(),-1));\\n         return solveMem(0,0,obstacleGrid,dp);\\n  }\\n```\n```\\nint solveTab(vector<vector<int>>& obstacleGrid){\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1) return 0;\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        dp[0][0]=1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                \\n                if(obstacleGrid[i][j]==0){ // if there is no obstacle present in the grid\\n                    \\n                    int moveUp=0;\\n                    int moveleft=0;\\n                    \\n                    if(i-1>=0){\\n                        moveUp=dp[i-1][j];\\n                    }\\n                    if(j-1>=0){\\n                        moveleft=dp[i][j-1];\\n                    }\\n                    dp[i][j]=moveUp+moveleft;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveTab(obstacleGrid);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897008,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ra9n-M2OzDM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int [][] ans = new int[n][m];\\n        for(int i = 0;i<n;i++){\\n            if(A[i][0] == 0) ans[i][0] = 1;\\n            else break;\\n        }\\n        for(int j = 0;j<m;j++){\\n            if(A[0][j] == 0) ans[0][j] = 1;\\n            else break;\\n        }\\n\\n        for(int i = 1;i<n;i++){\\n            for(int j = 1;j<m;j++){\\n                if(A[i][j]==0) ans[i][j] = ans[i-1][j]+ans[i][j-1];\\n            }\\n        }\\n        return ans[n-1][m-1];\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (A[i][0] == 0)\\n                ans[i][0] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int j = 0; j < m; j++) {\\n            if (A[0][j] == 0)\\n                ans[0][j] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                if (A[i][j] == 0)\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1];\\n            }\\n        }\\n        \\n        return ans[n-1][m-1];\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        m = len(A[0])\\n        ans = [[0] * m for _ in range(n)]\\n        \\n        for i in range(n):\\n            if A[i][0] == 0:\\n                ans[i][0] = 1\\n            else:\\n                break\\n        \\n        for j in range(m):\\n            if A[0][j] == 0:\\n                ans[0][j] = 1\\n            else:\\n                break\\n        \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if A[i][j] == 0:\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1]\\n        \\n        return ans[n-1][m-1]\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int [][] ans = new int[n][m];\\n        for(int i = 0;i<n;i++){\\n            if(A[i][0] == 0) ans[i][0] = 1;\\n            else break;\\n        }\\n        for(int j = 0;j<m;j++){\\n            if(A[0][j] == 0) ans[0][j] = 1;\\n            else break;\\n        }\\n\\n        for(int i = 1;i<n;i++){\\n            for(int j = 1;j<m;j++){\\n                if(A[i][j]==0) ans[i][j] = ans[i-1][j]+ans[i][j-1];\\n            }\\n        }\\n        return ans[n-1][m-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (A[i][0] == 0)\\n                ans[i][0] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int j = 0; j < m; j++) {\\n            if (A[0][j] == 0)\\n                ans[0][j] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                if (A[i][j] == 0)\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1];\\n            }\\n        }\\n        \\n        return ans[n-1][m-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        m = len(A[0])\\n        ans = [[0] * m for _ in range(n)]\\n        \\n        for i in range(n):\\n            if A[i][0] == 0:\\n                ans[i][0] = 1\\n            else:\\n                break\\n        \\n        for j in range(m):\\n            if A[0][j] == 0:\\n                ans[0][j] = 1\\n            else:\\n                break\\n        \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if A[i][j] == 0:\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1]\\n        \\n        return ans[n-1][m-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386610,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        if(g[0][0])return 0;\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(g[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            if(g[0][j])dp[0][j]=0;\\n            else dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(g[i][j])dp[i][j]=0;\\n                else\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/67f7a904-7321-42be-bd91-a472984d957a_1680787983.9002156.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        if(g[0][0])return 0;\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(g[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            if(g[0][j])dp[0][j]=0;\\n            else dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(g[i][j])dp[i][j]=0;\\n                else\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855384,
                "title": "python-96-09-faster-dp-recursive-memoization",
                "content": "**Recursive Solution but it will give TLE :**\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1 :\\n                return 0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                return 1\\n            return countPath(i+1,j) + countPath(i,j+1)\\n        return countPath(0,0)\\n```\\n**Recursive + Memoiztion Solution (Top Down Approach) :**\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1:\\n                dp[i][j]=0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                dp[i][j]=1\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            dp[i][j] = countPath(i+1,j) + countPath(i,j+1)\\n            return dp[i][j]\\n        dp=[[-1 for i in range(n+1)] for j in range(m+1)]\\n        return countPath(0,0)\\n```\\n\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1 :\\n                return 0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                return 1\\n            return countPath(i+1,j) + countPath(i,j+1)\\n        return countPath(0,0)\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1:\\n                dp[i][j]=0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                dp[i][j]=1\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            dp[i][j] = countPath(i+1,j) + countPath(i,j+1)\\n            return dp[i][j]\\n        dp=[[-1 for i in range(n+1)] for j in range(m+1)]\\n        return countPath(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585191,
                "title": "python-simple-approach-dp-approach-explained-in-a-super-simple-manner",
                "content": "This problem is almost a spitting image of  [62. Unique Paths](https://leetcode.com/problems/unique-paths/).\\n\\nLet\\'s think of this problem in a super simple manner.\\n\\nOne important thing to remember is you can only walk right and down.\\nNotation I am going to use (row, column).\\n\\nFirst, I create a placeholder 2d array, called `arr_path`, with 0s.\\n\\nWe are going to walk over the cells (the two for loops in the code). And each time we step on a cell, we are going to ask a question to ourself, how many unique paths are there to get to this cell? Well, for the first cell (0,0) we would only have 1 unique path. So we will start off with that.\\n\\nNext, think of walking over cell (0,1). How many unique paths are there to get to this cell? Well, it is too simple since we can only have 1 unique path to get to (0,1) from (0,0). This behavior is same for all the cells in the topmost row.\\n\\nNow, we get to the second row, we ask the same qustion for the cell in (1,0). How many unique paths are there to get from (0,0)? This is too simple since there is only one path to get to (1,0) from (0,0). But now, when we get to (1,1), we have to add the unique path to get to (1,0) and unique path to get to (0,1), so there are 2 unique paths to get to (1,1) from (0,0).\\n\\nThat\\'s all you gotta do. And whenever you step on the cell, you just need to sum up the unique path to get to the cell which is above your current cell and the unique path to get to the cell which is left of your current cell (both of which has been computed before). We are accumulating the unique paths of every grid cell as we walk over the grid.\\n\\nSo now, when you see an obstacle, simply skip upading `arr_path` for that cell. When you get to the next cell, you will look for previous cells (up and left) in `arr_path` and you will add up the paths. Since you skipped updating `arr_path` when you saw an obstacle, that value will remain 0 and you are just adding up 0 with whatever number the other previous cell has (it can be 0 too, if both of the previous cells are obstacles).\\n\\nFinally you just return the unique path which you get for the cell which is at the bottom-right corner! This can be 0 too if there is an obstacle there. Since `arr_path` is initialized with all 0s, if there is an obstacle in the final cell, you will just return 0.\\n\\nAnd, this basically is dynamic programming.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if len(obstacleGrid) == 0 or obstacleGrid is None or obstacleGrid[0][0] == 1: # All the edge cases, including the case where the starting position has obstacle\\n            return 0\\n        \\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        arr_paths = [[0 for _ in range(cols)] for _ in range(rows)]\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r == 0 and c == 0:\\n                    arr_paths[r][c] = 1 # There is one way to get from starting position to starting position\\n                    continue\\n                    \\n                if obstacleGrid[r][c] == 1: # obstacle, don\\'t count\\n                    continue\\n                    \\n                if r-1 < 0:  # For topmost row\\n                    arr_paths[r][c] = arr_paths[r][c-1]\\n                elif c-1 < 0: # For leftmost column\\n                    arr_paths[r][c] = arr_paths[r-1][c] \\n                else:\\n                    arr_paths[r][c] = arr_paths[r][c-1] + arr_paths[r-1][c]\\n                \\n        return arr_paths[r][c] # Even if the ending position has obstacle, it will return 0 since the placeholder array is initialized with all 0s\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if len(obstacleGrid) == 0 or obstacleGrid is None or obstacleGrid[0][0] == 1: # All the edge cases, including the case where the starting position has obstacle\\n            return 0\\n        \\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        arr_paths = [[0 for _ in range(cols)] for _ in range(rows)]\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r == 0 and c == 0:\\n                    arr_paths[r][c] = 1 # There is one way to get from starting position to starting position\\n                    continue\\n                    \\n                if obstacleGrid[r][c] == 1: # obstacle, don\\'t count\\n                    continue\\n                    \\n                if r-1 < 0:  # For topmost row\\n                    arr_paths[r][c] = arr_paths[r][c-1]\\n                elif c-1 < 0: # For leftmost column\\n                    arr_paths[r][c] = arr_paths[r-1][c] \\n                else:\\n                    arr_paths[r][c] = arr_paths[r][c-1] + arr_paths[r-1][c]\\n                \\n        return arr_paths[r][c] # Even if the ending position has obstacle, it will return 0 since the placeholder array is initialized with all 0s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23373,
                "title": "simple-java-dp-solution",
                "content": "    public class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] s = new int[m][n];\\n        s[0][0] = obstacleGrid[0][0]==0 ? 1:0;\\n        if(s[0][0] == 0) return 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(obstacleGrid[i][j] == 1) s[i][j] = 0;\\n                else if(i==0){\\n                    if(j>0) s[i][j] = s[i][j-1];\\n                }\\n                else if(j==0){\\n                    if(i>0) s[i][j] = s[i-1][j];\\n                }\\n                else s[i][j] = s[i-1][j] + s[i][j-1];\\n            }\\n        }\\n        return s[m-1][n-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] s = new int[m][n];\\n        s[0][0] = obstacleGrid[0][0]==0 ? 1:0;\\n        if(s[0][0] == 0) return 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(obstacleGrid[i][j] == 1) s[i][j] = 0;\\n                else if(i==0){\\n                    if(j>0) s[i][j] = s[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3897357,
                "title": "c-dp-iterative-day-12",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int n = v.size(),m =v[0].size();\\n        if(v[0][0] || v[n-1][m-1])return 0;\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(v[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            if(v[0][i])dp[0][i]=0;\\n            else dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(!v[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c2e14538-66fb-4295-9705-0184793a06e1_1691815281.1305342.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int n = v.size(),m =v[0].size();\\n        if(v[0][0] || v[n-1][m-1])return 0;\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(v[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            if(v[0][i])dp[0][i]=0;\\n            else dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(!v[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898972,
                "title": "0-ms-100-faster-java-solution-2-ways-dp-and-no-extra-space",
                "content": "# Approach 1 : Using Dynamic Programming\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every cell that is not an obstacle,\\nThe number of ways to reach it is the sum of\\n`Number of ways to reach the cell to its left`\\nAnd `the number of ways to reach the cell above it`\\n\\n`ways[row][column]` = `ways[row - 1][column]` + `ways[row][column - 1]`\\n\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n![Screenshot (3903).png](https://assets.leetcode.com/users/images/81a61705-4980-4d59-802d-393543a5383d_1691837260.698575.png)\\n```java []\\nclass Solution // 100.00% faster, 0 ms solution\\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\\n        int dp[][] = new int [m+1][n+1];\\n        if(obstacleGrid[0][0] != 1)\\n        dp[1][1] = 1;\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n}\\n```\\n```cpp []\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Unique Paths II.\\n// Memory Usage: 7.9 MB, less than 25.25% of C++ online submissions for Unique Paths II.\\nclass Solution\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        // If the starting point is an obstacle\\n        // there is no way to reach th e bottom- right cell\\n        if (obstacleGrid[0][0] == 1)\\n            dp[1][1] = 1;\\n        // Set the starting point as 1\\n        // Always 1 way to reach this cell, in case its not an obstacle\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n# Approach 2 : No extra Space\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```cpp []\\nclass Solution // Runtime: 3 ms, faster than 80.74% of C++ online submissions for Unique Paths II.\\n               // Memory Usage: 7.5 MB, less than 90.13% of C++ online submissions for Unique Paths II.\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        // If the starting cell is an obstacle\\n        // There will be no way to reach the bottom-right cell\\n        // Hence return 0\\n        if (obstacleGrid[0][0])\\n            return 0;\\n        // For any given cell best a robot can do is to\\n        // Go down or go right\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        obstacleGrid[0][0] = 1;\\n\\n        for (int i = 1; i < m; i++)     // For the top row, cells can only be reached from the left (previous column)\\n            // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n            // Otherwise Set it equal the cell just left of it\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0) ? obstacleGrid[0][i - 1] : 0;\\n\\n        for (int i = 1; i < n; i++) \\n        // Similarily for the leftmost column, only way to travel is down\\n        // And therefore it can only be reached from the up (previous row)\\n        obstacleGrid[i][0] = (obstacleGrid[i][0] == 0) ? obstacleGrid[i - 1][0] : 0;\\n\\n        for (int i = 1; i < n; i++)     // For any other cell, the number of ways to reach it is equal to the number of ways to\\n            for (int j = 1; j < m; j++) // reach the cell to its left and the cell above it\\n                if (obstacleGrid[i][j]) // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n                    obstacleGrid[i][j] = 0;\\n                else                                                                      // The number of ways to reach the cell is equal to the number of ways to\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; // reach the cell above it + the number of ways to reach the cell to its left\\n\\n        return obstacleGrid[n - 1][m - 1];\\n    }\\n};\\n```\\n\\n![upvote.png](https://assets.leetcode.com/users/images/d077ccad-9321-4c34-a4a8-b8b79ffd4031_1691838956.8384304.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```java []\\nclass Solution // 100.00% faster, 0 ms solution\\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\\n        int dp[][] = new int [m+1][n+1];\\n        if(obstacleGrid[0][0] != 1)\\n        dp[1][1] = 1;\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n}\\n```\n```cpp []\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Unique Paths II.\\n// Memory Usage: 7.9 MB, less than 25.25% of C++ online submissions for Unique Paths II.\\nclass Solution\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        // If the starting point is an obstacle\\n        // there is no way to reach th e bottom- right cell\\n        if (obstacleGrid[0][0] == 1)\\n            dp[1][1] = 1;\\n        // Set the starting point as 1\\n        // Always 1 way to reach this cell, in case its not an obstacle\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n};\\n```\n```cpp []\\nclass Solution // Runtime: 3 ms, faster than 80.74% of C++ online submissions for Unique Paths II.\\n               // Memory Usage: 7.5 MB, less than 90.13% of C++ online submissions for Unique Paths II.\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        // If the starting cell is an obstacle\\n        // There will be no way to reach the bottom-right cell\\n        // Hence return 0\\n        if (obstacleGrid[0][0])\\n            return 0;\\n        // For any given cell best a robot can do is to\\n        // Go down or go right\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        obstacleGrid[0][0] = 1;\\n\\n        for (int i = 1; i < m; i++)     // For the top row, cells can only be reached from the left (previous column)\\n            // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n            // Otherwise Set it equal the cell just left of it\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0) ? obstacleGrid[0][i - 1] : 0;\\n\\n        for (int i = 1; i < n; i++) \\n        // Similarily for the leftmost column, only way to travel is down\\n        // And therefore it can only be reached from the up (previous row)\\n        obstacleGrid[i][0] = (obstacleGrid[i][0] == 0) ? obstacleGrid[i - 1][0] : 0;\\n\\n        for (int i = 1; i < n; i++)     // For any other cell, the number of ways to reach it is equal to the number of ways to\\n            for (int j = 1; j < m; j++) // reach the cell to its left and the cell above it\\n                if (obstacleGrid[i][j]) // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n                    obstacleGrid[i][j] = 0;\\n                else                                                                      // The number of ways to reach the cell is equal to the number of ways to\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; // reach the cell above it + the number of ways to reach the cell to its left\\n\\n        return obstacleGrid[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056705,
                "title": "c-2-approaches-recusion-and-bottom-up-approach-use-dp-explanation-with-comments",
                "content": "**Please upvote if you find this solution helpful ;)**\\n\\n**Approach-1 : Use recursion and dynamic programming\\nTC- O(MxN), recursion \\nSC- O(MxN), dp/mxn matrix\\nAuxiliary Space - O(M+N), recursion call**\\n\\n```\\n//We can use recursion but it takes too much time and we get TLE\\n//So, we implement dynamic programming with recursion/dp\\nclass Solution {\\npublic:\\n    \\n    int findPath(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        //boudary and obstacle condition\\n        if(r>=grid.size() || c>=grid[0].size() || grid[r][c]==1) return 0;\\n        \\n        //if we reach right bottom, we get 1 path and return it\\n        if(r==grid.size()-1 && c==grid[0].size()-1) return 1;\\n        \\n        //if path is already store in dp we return it\\n        if(dp[r][c]!=-1) return dp[r][c];\\n        \\n        //calculate the no. of path by moving down and right and return it\\n        //and store it into the dp\\n        return dp[r][c]= (findPath(r+1, c, grid, dp) + findPath(r, c+1, grid, dp));\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, -1)); //create mxn matrix dp and initialize it with -1\\n        return findPath(0,0, obstacleGrid, dp); calling the function to find no. of unique path\\n    }\\n};\\n```\\n\\n**Approach-2 : Use bottom-up approach and dynamic programming\\nTC- O(MxN), iteration \\nSC- O(MxN), dp/mxn matrix**\\n\\n```\\n//Use bottom-up approach to save the auxiliary space taken by recursion\\nclass Solution {\\npublic:\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        //if top-left corner has value 1 it means there in no path\\n        if(obstacleGrid[0][0]==1) return 0;\\n        \\n        //store no. of rows and columns\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        \\n        //create dp and initialize it with 0\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        \\n        //base condition for bottom-up approach\\n        dp[0][0] = 1;\\n        \\n        //traverse through the matrix\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                //if we are at top-left corner(0,0) we don\\'t have left(0,-1) and up(-1,0,) cell\\n                //so to avoid this condition we continue at 0,0\\n                if(i==0 && j==0) continue;\\n                \\n                //if there is no obstacle\\n                if(obstacleGrid[i][j]==0)\\n                {\\n                    int up=0, left=0;\\n\\n                    //store top cell value\\n                    if(i-1 >=0)\\n                        up = dp[i-1][j];\\n\\n                    //store left cell value\\n                    if(j-1 >=0)\\n                        left = dp[i][j-1];\\n                \\n                    //and add them for current cell to get no. of unique paths \\n                    //to reach at current position\\n                    dp[i][j] = up + left;\\n                }\\n            }\\n        }\\n        //return dp at (m-1, n-1) that will be the no. of unique paths\\n        //to reach at bottom right corner\\n        return dp[m-1][n-1];\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n//We can use recursion but it takes too much time and we get TLE\\n//So, we implement dynamic programming with recursion/dp\\nclass Solution {\\npublic:\\n    \\n    int findPath(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        //boudary and obstacle condition\\n        if(r>=grid.size() || c>=grid[0].size() || grid[r][c]==1) return 0;\\n        \\n        //if we reach right bottom, we get 1 path and return it\\n        if(r==grid.size()-1 && c==grid[0].size()-1) return 1;\\n        \\n        //if path is already store in dp we return it\\n        if(dp[r][c]!=-1) return dp[r][c];\\n        \\n        //calculate the no. of path by moving down and right and return it\\n        //and store it into the dp\\n        return dp[r][c]= (findPath(r+1, c, grid, dp) + findPath(r, c+1, grid, dp));\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, -1)); //create mxn matrix dp and initialize it with -1\\n        return findPath(0,0, obstacleGrid, dp); calling the function to find no. of unique path\\n    }\\n};\\n```\n```\\n//Use bottom-up approach to save the auxiliary space taken by recursion\\nclass Solution {\\npublic:\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        //if top-left corner has value 1 it means there in no path\\n        if(obstacleGrid[0][0]==1) return 0;\\n        \\n        //store no. of rows and columns\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        \\n        //create dp and initialize it with 0\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        \\n        //base condition for bottom-up approach\\n        dp[0][0] = 1;\\n        \\n        //traverse through the matrix\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                //if we are at top-left corner(0,0) we don\\'t have left(0,-1) and up(-1,0,) cell\\n                //so to avoid this condition we continue at 0,0\\n                if(i==0 && j==0) continue;\\n                \\n                //if there is no obstacle\\n                if(obstacleGrid[i][j]==0)\\n                {\\n                    int up=0, left=0;\\n\\n                    //store top cell value\\n                    if(i-1 >=0)\\n                        up = dp[i-1][j];\\n\\n                    //store left cell value\\n                    if(j-1 >=0)\\n                        left = dp[i][j-1];\\n                \\n                    //and add them for current cell to get no. of unique paths \\n                    //to reach at current position\\n                    dp[i][j] = up + left;\\n                }\\n            }\\n        }\\n        //return dp at (m-1, n-1) that will be the no. of unique paths\\n        //to reach at bottom right corner\\n        return dp[m-1][n-1];\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420437,
                "title": "clean-and-easy-o-1-space",
                "content": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    const m = obstacleGrid.length, n = obstacleGrid[0].length \\n    \\n    if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return false\\n    \\n    for(let i = 0; i < m; i++) {\\n        for(let j = 0; j < n; j++) {\\n            if(i === 0 && j === 0) {\\n                obstacleGrid[i][j] = 1\\n                continue\\n            }\\n            \\n            if(obstacleGrid[i][j] === 1) {\\n                obstacleGrid[i][j] = 0\\n                continue\\n            }\\n            \\n            if(i === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i][j - 1]\\n                continue\\n            }\\n            \\n            if(j === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j]\\n                continue\\n            }\\n            \\n            obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\\n        }\\n    }\\n    \\n    \\n    return obstacleGrid[m - 1][n - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    const m = obstacleGrid.length, n = obstacleGrid[0].length \\n    \\n    if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return false\\n    \\n    for(let i = 0; i < m; i++) {\\n        for(let j = 0; j < n; j++) {\\n            if(i === 0 && j === 0) {\\n                obstacleGrid[i][j] = 1\\n                continue\\n            }\\n            \\n            if(obstacleGrid[i][j] === 1) {\\n                obstacleGrid[i][j] = 0\\n                continue\\n            }\\n            \\n            if(i === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i][j - 1]\\n                continue\\n            }\\n            \\n            if(j === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j]\\n                continue\\n            }\\n            \\n            obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\\n        }\\n    }\\n    \\n    \\n    return obstacleGrid[m - 1][n - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351467,
                "title": "simple-python-recursion-solution",
                "content": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        \\n        def rec(grid, i, j, d):\\n            if i > len(grid)-1 or j > len(grid[0])-1:\\n                return 0\\n            if grid[i][j] == 1:\\n                return 0\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return 1\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            \\n            down = rec(grid, i+1, j, d)\\n            right = rec(grid, i, j+1, d)\\n            \\n            d[(i,j)] = down + right\\n            return d[(i,j)]\\n            \\n        return rec(obstacleGrid, 0, 0, {})\\n```\\n\\nfirst we check for base cases which are:\\n1. out of bounds\\n2. obstacle \\n3. win \\n4. already calculated it \\n\\nthen do recursion on down and right, add them up and get the result :)",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        \\n        def rec(grid, i, j, d):\\n            if i > len(grid)-1 or j > len(grid[0])-1:\\n                return 0\\n            if grid[i][j] == 1:\\n                return 0\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return 1\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            \\n            down = rec(grid, i+1, j, d)\\n            right = rec(grid, i, j+1, d)\\n            \\n            d[(i,j)] = down + right\\n            return d[(i,j)]\\n            \\n        return rec(obstacleGrid, 0, 0, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180316,
                "title": "unique-paths-ii-js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every path with a **recursive** **depth first search** (**DFS**) approach. That would involve duplicating the processing used for repeating subpaths, however, which would quickly lead to a **TLE** result. When faced with repeating subproblems, we should be thinking of a **dynamic programming** (**DP**) approach to store completed subproblem and avoid any unnecessary duplication of processing.\\n\\nIn this situation, we can create a DP matrix (**dp**) in the same dimensions as our input matrix (**OG**). (_**Note**: We can choose to use an **in-place** approach here and use **OG** as our DP matrix in order to reduce the **space complexity** of our solution to **O(1)**._) Each cell in **dp** will represent the number of paths that lead to the corresponding cell in **OG**. Since the robot can only move either to the right or down, we can perform a **bottom-up** DP solution, working from the initial cell and iterating downward and rightward through **OG**.\\n\\nEach cell in **OG** (**OG[i][j]**) can potentially reached by only two previously-visited cells (**OG[i-1][j]** & **OG[i][j-1]**), so the number of ways to reach the current cell (**dp[i][j]**) should be the sum of the ways to reach those other two cells (**dp[i-1][j] + dp[i][j-1]**), should they exist.\\n\\nSince any cell representing an obstacle cannot be a part of a path, its value in **dp** should be **0**. We\\'ll also need to seed the initial starting position with a value of **1** to represent the single initial path. Once we\\'re done building **dp**, the value of the bottom-right cell should be our answer.\\n\\n - _**Time Complexity: O(N * M)** where **N** and **M** are the dimensions of the input matrix_\\n - _**Space Complexity: O(N * M)** for the DP matrix_\\n    - _or **O(1)** if we use an **in-place** approach for the DP matrix_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can opt to use @lru_cache instead of a standard DP matrix; the standard approach is shown below.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.6MB** (beats 100% / 96%).\\n```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 94% / 84%).\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 67%).\\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.7MB** (beats 100% / 46%).\\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859669,
                "title": "c-dp-bfs-non-overflowing-solution-explained-97-time-80-space",
                "content": "Premise: I love a good challenge. But that is usually properly specced, not just letting people submit until they figure out what is expected.\\n\\nAs it was the case here, since we are not given any information about the maximum size of the map, number of obstacles, etc. All things that in an interview you would not be told initially, since they are also assessing you on how much and how soon you ask about the constraint. While here you will just have to go through a pointless trial and error.\\n\\nSad.\\n\\nOkay, enough with the ranting.\\n\\nI decided to have a DP-BFS hybrid approach to solve it (after my plain DFS solution failed miserably, see the extra goodie at the bottom).\\n\\nSo, first of all I check if I am getting either empty columns or empty rows - because nobody bothered to tell us if we would, but okay, I will cut it now -, and in case return `0`.\\n\\nIf not we set down a few helper variables:\\n* `x` and `y`, matching our destination goal;\\n* `qLen`, that we will use soon after, but can confidently initialise to `1`.\\n\\nOther edge case (last one!), and we exit if either the starting or the finishing point are blocked, again returning `0`.\\n\\nIf we are still in the game, we need to clone `grid` into another container made of `long`s, because reasons and because so some languages get a \"fair\" extra challenge, in order to avoid overflow.\\n\\nAfter all this unrequested chores, we can finally start doing something more substantial, like declaring our queue `nextLayer`, made of pairs of `int`s to store the coordinate of the next points we are going to visit and then push up inside `x` and `y`, our starting point (I decide to take this problem bottom-up, also because I found it nicer to handle with the conditionals later).\\n\\nAlso note that I set the initial value of our starting point to `-1`: this way we do not have to be concerned about the `1`s we will find, as obstacles, otherwise wasting more memory to switch values while filling in `dp`.\\n\\nAnd then the BFS begins: we are going to loop until `qLen` is truthy, which means until we have at least one more cell to visit.\\n\\nWe will then loop `qLen` times, doing this:\\n* getting updated `x` and `y` values from the front of the queue;\\n* popping the used node out of the queue;\\n* then we move left, checking if we did not go off the bonds (`x > 0`) and if it is a valid, unblocked cell (`dp[y][x] < 1`, see note above about using negative values to represent our potential paths); if so, we push the new coordinates into the queue only if the cell was not visited before (ie: still at value `0`), in order to avoid duplicates, and update its value with the value of all the possible paths we inherited from the previous one;\\n* same logic for the `y` coordinate moving up, but this time always inserting the values in the queue (we already checked left, so we cannot put a duplicate just moving up).\\n\\nAfter this is all done, we update `qLen` and are ready for the next loop.\\n\\nIn the end we return `-dp[0][0]` (remember we used the trick to store the results as negative numbers) and are done :)\\n\\nTo help you visualise how the DP part would work, a visual example with this starting situation (remember that `1` are walls, while we keep track of the possible paths up to a specific cells with its negative value):\\n\\n```cpp\\n// initial map\\n0  1  0  0  1  0\\n0  0  0  0  0  0\\n0  0  1  0  0  0\\n```\\n\\nLet\\'s flag our starting point with `-` the amount of paths up to that cell, by definition `1` for the first step:\\n\\n```cpp\\n// we start\\n 0  0  0  0  1  0\\n 1  0  0  0  0  0\\n 0  0  1  0  0 -1\\n```\\n\\nAnd then let\\'s proceed with our BFS approach:\\n\\n```cpp\\n// second step\\n 0  0  0  0  1  0\\n 1  0  0  0  0 -1\\n 0  0  1  0 -1 -1\\n\\n// third step\\n 0  0  0  0  1 -1\\n 1  0  0  0 -2 -1 //note: first cell we can reach from 2 different paths\\n 0  0  1 -1 -1 -1\\n\\n// fourth step\\n 0  0  0  0  1 -1\\n 1  0  0 -3 -2 -1 //note: first cell we can reach from 3 different paths and first paths blocked\\n 0  0  1 -1 -1 -1\\n\\n// fifth step\\n 0  0  0 -3  1 -1\\n 1  0 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// sixth step\\n 0  0 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// seventh step\\n 0 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// eight and last step\\n-6 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// we would then return -dp[0][0] == 6 possible paths!\\n```\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case - empty columns or rows\\n        if (!grid.size() || !grid[0].size()) return 0;\\n        int x = grid[0].size() - 1, y = grid.size() - 1, qLen = 1;\\n        // edge cases - destination or starting point blocked\\n        if (grid[y][x] || grid[0][0]) return 0;\\n        // annoyingly necessarily cloned grid here\\n        long dp[y + 1][x + 1];\\n        for (int _y = 0; _y <= y; _y++) {\\n            for (int _x = 0; _x <= x; _x++) dp[_y][_x] = grid[_y][_x];\\n        }\\n        queue<pair<int, int>> nextLayer;\\n        nextLayer.push({x, y});\\n        dp[y][x] = -1;\\n        while (qLen) {\\n            for (int i = 0; i < qLen; i++ ) {\\n                x = nextLayer.front().first;\\n                y = nextLayer.front().second;\\n                // removing the used cell\\n                nextLayer.pop();\\n                // checking the cell on left of the current one\\n                if (x > 0 && dp[y][x - 1] < 1) {\\n                    if (dp[y][x - 1] == 0) nextLayer.push({x - 1, y});\\n                    dp[y][x - 1] += dp[y][x];\\n                }\\n                // checking the cell on top of the current one\\n                if (y > 0 && dp[y - 1][x] < 1) {\\n                    nextLayer.push({x, y - 1});\\n                    dp[y - 1][x] += dp[y][x];\\n                }\\n            }\\n            // preparing for the next run\\n            qLen = nextLayer.size();\\n        }\\n        return -dp[0][0];\\n    }\\n};\\n```\\n\\nExtra goodie - my original DFS code, not passing because the author of this problem did not bother putting a single number about the limits we were going to face, but still good for smaller maps:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xLen, yLen, res = 0;\\n    void dfs(vector<vector<int>> &grid, int x = 0, int y = 0) {\\n        // exit for out of bonds cases or obstacle found\\n        if (x < 0 || y < 0 || x > xLen || y > yLen || grid[y][x]) return;\\n        // goal reached\\n        if (x == xLen && y == yLen) {\\n            res++;\\n            return;\\n        }\\n        // marking the cell as visited\\n        grid[y][x] = 1;\\n        // exploring north, east, south, west\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        // backtracking the cell as visitable\\n        grid[y][x] = 0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case\\n        if (!grid.size() || !grid[0].size()) return res;\\n        // updating class variables\\n        xLen = grid[0].size() - 1;\\n        yLen = grid.size() - 1;\\n        dfs(grid);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\n// initial map\\n0  1  0  0  1  0\\n0  0  0  0  0  0\\n0  0  1  0  0  0\\n```\n```cpp\\n// we start\\n 0  0  0  0  1  0\\n 1  0  0  0  0  0\\n 0  0  1  0  0 -1\\n```\n```cpp\\n// second step\\n 0  0  0  0  1  0\\n 1  0  0  0  0 -1\\n 0  0  1  0 -1 -1\\n\\n// third step\\n 0  0  0  0  1 -1\\n 1  0  0  0 -2 -1 //note: first cell we can reach from 2 different paths\\n 0  0  1 -1 -1 -1\\n\\n// fourth step\\n 0  0  0  0  1 -1\\n 1  0  0 -3 -2 -1 //note: first cell we can reach from 3 different paths and first paths blocked\\n 0  0  1 -1 -1 -1\\n\\n// fifth step\\n 0  0  0 -3  1 -1\\n 1  0 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// sixth step\\n 0  0 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// seventh step\\n 0 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// eight and last step\\n-6 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// we would then return -dp[0][0] == 6 possible paths!\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case - empty columns or rows\\n        if (!grid.size() || !grid[0].size()) return 0;\\n        int x = grid[0].size() - 1, y = grid.size() - 1, qLen = 1;\\n        // edge cases - destination or starting point blocked\\n        if (grid[y][x] || grid[0][0]) return 0;\\n        // annoyingly necessarily cloned grid here\\n        long dp[y + 1][x + 1];\\n        for (int _y = 0; _y <= y; _y++) {\\n            for (int _x = 0; _x <= x; _x++) dp[_y][_x] = grid[_y][_x];\\n        }\\n        queue<pair<int, int>> nextLayer;\\n        nextLayer.push({x, y});\\n        dp[y][x] = -1;\\n        while (qLen) {\\n            for (int i = 0; i < qLen; i++ ) {\\n                x = nextLayer.front().first;\\n                y = nextLayer.front().second;\\n                // removing the used cell\\n                nextLayer.pop();\\n                // checking the cell on left of the current one\\n                if (x > 0 && dp[y][x - 1] < 1) {\\n                    if (dp[y][x - 1] == 0) nextLayer.push({x - 1, y});\\n                    dp[y][x - 1] += dp[y][x];\\n                }\\n                // checking the cell on top of the current one\\n                if (y > 0 && dp[y - 1][x] < 1) {\\n                    nextLayer.push({x, y - 1});\\n                    dp[y - 1][x] += dp[y][x];\\n                }\\n            }\\n            // preparing for the next run\\n            qLen = nextLayer.size();\\n        }\\n        return -dp[0][0];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int xLen, yLen, res = 0;\\n    void dfs(vector<vector<int>> &grid, int x = 0, int y = 0) {\\n        // exit for out of bonds cases or obstacle found\\n        if (x < 0 || y < 0 || x > xLen || y > yLen || grid[y][x]) return;\\n        // goal reached\\n        if (x == xLen && y == yLen) {\\n            res++;\\n            return;\\n        }\\n        // marking the cell as visited\\n        grid[y][x] = 1;\\n        // exploring north, east, south, west\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        // backtracking the cell as visitable\\n        grid[y][x] = 0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case\\n        if (!grid.size() || !grid[0].size()) return res;\\n        // updating class variables\\n        xLen = grid[0].size() - 1;\\n        yLen = grid.size() - 1;\\n        dfs(grid);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374664,
                "title": "simple-easy-to-understand-though-process-explanation-4-solutions-uniquepath-i-extension",
                "content": "This question is extension of Unique Path I; \\nUnique path 1 solution [https://leetcode.com/problems/unique-paths/discuss/374561/100-or-5-Solutions-or-Step-by-Step-optimisation-or-Dp-thought-process] \\n\\nI just extends all the solution presented above here with minimal changes\\n\\n**Backtracking**\\n\\n```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b) we can\\'t go through obstacles\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIIBacktracking {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            maze[sx][sy] = -1; //not available for next round\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = 0; // available for next round\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == -1 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n\\n```\\n\\n**DP: Top Down; cache backtraking solutions**\\n\\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.6 MB, less than 30.77% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathIIDPTopDown {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int dp[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(dp[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, dp, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int dp[][], int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n            if (sx == dx && sy == dy)\\n                return dp[sx][sy] = 1;\\n\\n            if (dp[sx][sy] != -1)\\n                return dp[sx][sy];\\n\\n            return dp[sx][sy] =\\n                    uniquePaths(maze, dp, m, n, sx + 1, sy, dx, dy)  //down\\n                            +\\n                            uniquePaths(maze, dp, m, n, sx, sy + 1, dx, dy);//right\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**DP: Bottom up [2 variation ]**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.9 MB, less than 16.92% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUp {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[i][j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[i][j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i][j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i - 1][j];\\n                else\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n\\n\\n    /**\\n     * Build using pre-check base cases\\n     *\\n     * @param obstacleGrid\\n     * @return\\n     */\\n    public int uniquePathsWithObstaclesLong(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n\\n        for (int i = 0; i < m; i++)\\n            if (obstacleGrid[i][0] != 1)\\n                dp[i][0] = 1;\\n            else\\n                break;\\n\\n\\n        for (int j = 0; j < n; j++)\\n            if (obstacleGrid[0][j] != 1)\\n                dp[0][j] = 1;\\n            else\\n                break;\\n\\n        for (int i = 1; i < m; i++) {\\n\\n            for (int j = 1; j < n; j++) {\\n\\n                if (obstacleGrid[i][j] != 1) {\\n\\n                    if (obstacleGrid[i - 1][j] != 1)\\n                        dp[i][j] = dp[i - 1][j];\\n\\n                    if (obstacleGrid[i][j - 1] != 1)\\n                        dp[i][j] += dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m - 1][n - 1];\\n\\n\\n    }\\n\\n}\\n\\n```\\n\\n**DP: Bottom up; Space optimized**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 39.6 MB, less than 58.46% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[] = new int[n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j];\\n                else\\n                    dp[j] = dp[j] + dp[j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n\\n}\\n```\\n\\nRef: Unique path 1 solution [https://leetcode.com/problems/unique-paths/discuss/374561/100-or-5-Solutions-or-Step-by-Step-optimisation-or-Dp-thought-process]",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b) we can\\'t go through obstacles\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIIBacktracking {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            maze[sx][sy] = -1; //not available for next round\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = 0; // available for next round\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == -1 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n\\n```\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.6 MB, less than 30.77% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathIIDPTopDown {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int dp[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(dp[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, dp, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int dp[][], int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n            if (sx == dx && sy == dy)\\n                return dp[sx][sy] = 1;\\n\\n            if (dp[sx][sy] != -1)\\n                return dp[sx][sy];\\n\\n            return dp[sx][sy] =\\n                    uniquePaths(maze, dp, m, n, sx + 1, sy, dx, dy)  //down\\n                            +\\n                            uniquePaths(maze, dp, m, n, sx, sy + 1, dx, dy);//right\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.9 MB, less than 16.92% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUp {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[i][j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[i][j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i][j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i - 1][j];\\n                else\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n\\n\\n    /**\\n     * Build using pre-check base cases\\n     *\\n     * @param obstacleGrid\\n     * @return\\n     */\\n    public int uniquePathsWithObstaclesLong(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n\\n        for (int i = 0; i < m; i++)\\n            if (obstacleGrid[i][0] != 1)\\n                dp[i][0] = 1;\\n            else\\n                break;\\n\\n\\n        for (int j = 0; j < n; j++)\\n            if (obstacleGrid[0][j] != 1)\\n                dp[0][j] = 1;\\n            else\\n                break;\\n\\n        for (int i = 1; i < m; i++) {\\n\\n            for (int j = 1; j < n; j++) {\\n\\n                if (obstacleGrid[i][j] != 1) {\\n\\n                    if (obstacleGrid[i - 1][j] != 1)\\n                        dp[i][j] = dp[i - 1][j];\\n\\n                    if (obstacleGrid[i][j - 1] != 1)\\n                        dp[i][j] += dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m - 1][n - 1];\\n\\n\\n    }\\n\\n}\\n\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 39.6 MB, less than 58.46% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[] = new int[n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j];\\n                else\\n                    dp[j] = dp[j] + dp[j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896890,
                "title": "c-o-n-m-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        if(grid[0][0]==1) return 0;\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        \\n        // 0th row: movement from left -> right\\n        for(int i=0, j=0;j<m;j++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        // 0th col: movement from top -> bottom\\n        for(int j=0, i=0;i<n;i++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(grid[i][j]==1) continue;\\n                dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        if(grid[0][0]==1) return 0;\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        \\n        // 0th row: movement from left -> right\\n        for(int i=0, j=0;j<m;j++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        // 0th col: movement from top -> bottom\\n        for(int j=0, i=0;i<n;i++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(grid[i][j]==1) continue;\\n                dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867104,
                "title": "c-recursion-memoization-tabulation-space-optimization-striver",
                "content": "**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n\\t\\tif(m==0 && n==0) return 1;\\n        int left=f(m,n-1,grid);\\n        int up=f(m-1,n,grid);\\n        return left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m-1,n-1,grid);\\n    }\\n};\\n```\\n\\n**memoization:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n        if(m==0 && n==0) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int left=f(m,n-1,grid,dp);\\n        int up=f(m-1,n,grid,dp);\\n        return dp[m][n]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return f(m-1,n-1,grid,dp); \\n    }\\n};\\n```\\n\\n**tabulation:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[i][j]=0;\\n                else if(i==0 && j==0) dp[i][j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[i][j-1];\\n                    if(i-1>=0) up=dp[i-1][j];\\n                    dp[i][j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\t\\tint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        return f(m,n,grid); \\n    }\\n};\\n```\\n**space optimization:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[j]=0;\\n                else if(i==0 && j==0) dp[j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[j-1];\\n                    if(i-1>=0) up=dp[j];\\n                    dp[j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m,n,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n\\t\\tif(m==0 && n==0) return 1;\\n        int left=f(m,n-1,grid);\\n        int up=f(m-1,n,grid);\\n        return left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m-1,n-1,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n        if(m==0 && n==0) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int left=f(m,n-1,grid,dp);\\n        int up=f(m-1,n,grid,dp);\\n        return dp[m][n]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return f(m-1,n-1,grid,dp); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[i][j]=0;\\n                else if(i==0 && j==0) dp[i][j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[i][j-1];\\n                    if(i-1>=0) up=dp[i-1][j];\\n                    dp[i][j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\t\\tint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        return f(m,n,grid); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[j]=0;\\n                else if(i==0 && j==0) dp[j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[j-1];\\n                    if(i-1>=0) up=dp[j];\\n                    dp[j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m,n,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693697,
                "title": "c-easy-fast-and-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& grid)\\n    {\\n        if(grid[i][j]==1) return 0;\\n        \\n        if(i==0 and j==0) return 1;\\n        if(i==0) return dp[i][j-1];\\n        if(j==0) return dp[i-1][j]; \\n            \\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[n-1][m-1]==1) return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp, obstacleGrid);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& grid)\\n    {\\n        if(grid[i][j]==1) return 0;\\n        \\n        if(i==0 and j==0) return 1;\\n        if(i==0) return dp[i][j-1];\\n        if(j==0) return dp[i-1][j]; \\n            \\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[n-1][m-1]==1) return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp, obstacleGrid);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180639,
                "title": "python-go-o-mn-by-dp-w-hint",
                "content": "Python/Go O(mn) by DP\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/65114931fd89780001ce87f5)\\n\\n---\\n\\nHint:\\n\\n#1. Remember to **update source point as 1** (one valid path) to start traversal if source point is not blocked by obstacle\\n\\n#2. Here, we use **in-place update** to avoid extra space usage\\n\\n\\n#3-a. If current grid is blocked by obstacle, then path count = 0\\n\\n#3-b. Otherwise, **path count to current position** = **Path count one step from left** + **Path count one step from top**.\\n\\n---\\n\\n**Implementation** by DP in Python:\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        allow_to_visit = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if h * w == 0 or not allow_to_visit(0, 0):\\n            \\n            # Quick response for invalid cases\\n            return 0\\n        \\n        \\n        # update [0][0] as start point with one valid path\\n        obstacleGrid[0][0] = 1\\n        \\n        ## base case: leftmost column\\n        for y in range(1, h):\\n            obstacleGrid[y][0] = obstacleGrid[y-1][0] * allow_to_visit(0, y)\\n        \\n        \\n        ## base case: top row\\n        for x in range(1, w):\\n            obstacleGrid[0][x] = obstacleGrid[0][x-1] * allow_to_visit(x, 0)\\n        \\n        \\n        ## general cases\\n        for y in range(1, h):\\n            for x in range(1, w):\\n                \\n                # update path count from left and top\\n                obstacleGrid[y][x] = (obstacleGrid[y][x-1] + obstacleGrid[y-1][x]) * allow_to_visit(x, y)\\n        \\n        return obstacleGrid[h-1][w-1]\\n```\\n\\n---\\n\\nShare another implementation by top-down DP in Python\\n\\n```\\n                  \\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        can_walk = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        dp = {}\\n\\n        def walk(x, y):\\n            \\n            if (x, y) in dp:\\n                # look-up DP table\\n                return dp[x, y]\\n\\n            if not 0 <= x < w or not 0 <= y < h or not can_walk(x, y) :\\n                # out-of-board, or cannot walk through\\n                dp[x, y] = 0\\n                return 0\\n\\n            if (x, y) == (0, 0):\\n                # Starting point, aka base case\\n                dp[x, y] = 1\\n                return 1\\n\\n            # General cases\\n            dp[x, y] = walk(x-1, y) + walk(x, y-1)\\n            return dp[(x, y)]\\n                    \\n```\\n\\n---\\n\\n**Implementation** by DP in Golang:\\n\\n```\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    \\n    // helper function\\n    var allowToVisit func (x, y int) int\\n    \\n    allowToVisit = func(x, y int) int{\\n        // 1 : allow to visit\\n        // 0 : can not visit due to obstacle\\n        return 1 - obstacleGrid[y][x]\\n    }\\n    \\n    h, w := len(obstacleGrid), len(obstacleGrid[0])\\n    \\n    if h * w == 0 || allowToVisit(0, 0) == 0 {\\n        // Quick response for invalid cases\\n        return 0\\n    }\\n    \\n    // update [0][0] as start point with one valid path\\n    obstacleGrid[0][0] = 1\\n    \\n    // base case: leftmost column\\n    for y := 1 ; y < h ; y++{\\n        obstacleGrid[y][0] = obstacleGrid[y-1][0] * allowToVisit(0, y)\\n    }\\n    \\n    // base case: top row\\n    for x := 1 ; x < w ; x++{\\n        obstacleGrid[0][x] = obstacleGrid[0][x-1] * allowToVisit(x, 0)\\n    }    \\n    \\n    // general cases:\\n    for y := 1 ; y < h ; y++{\\n        for x := 1 ; x < w ; x ++{\\n            \\n            // update path count form left and top\\n            obstacleGrid[y][x] = ( obstacleGrid[y][x-1] + obstacleGrid[y-1][x] ) * allowToVisit(x, y)\\n        }\\n    }\\n    \\n    return obstacleGrid[h-1][w-1]\\n}\\n```\\n\\n---\\n\\n\\nRelated Leetcode challenge:\\n\\n[Leetcode #62 Unique Paths](https://leetcode.com/problems/unique-paths)\\n\\n[Leetcode #63 Unique Paths II](https://leetcode.com/problems/unique-paths-ii)\\n\\n[Leetcode #980 Unique Paths III](https://leetcode.com/problems/unique-paths-iii)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        allow_to_visit = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if h * w == 0 or not allow_to_visit(0, 0):\\n            \\n            # Quick response for invalid cases\\n            return 0\\n        \\n        \\n        # update [0][0] as start point with one valid path\\n        obstacleGrid[0][0] = 1\\n        \\n        ## base case: leftmost column\\n        for y in range(1, h):\\n            obstacleGrid[y][0] = obstacleGrid[y-1][0] * allow_to_visit(0, y)\\n        \\n        \\n        ## base case: top row\\n        for x in range(1, w):\\n            obstacleGrid[0][x] = obstacleGrid[0][x-1] * allow_to_visit(x, 0)\\n        \\n        \\n        ## general cases\\n        for y in range(1, h):\\n            for x in range(1, w):\\n                \\n                # update path count from left and top\\n                obstacleGrid[y][x] = (obstacleGrid[y][x-1] + obstacleGrid[y-1][x]) * allow_to_visit(x, y)\\n        \\n        return obstacleGrid[h-1][w-1]\\n```\n```\\n                  \\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        can_walk = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        dp = {}\\n\\n        def walk(x, y):\\n            \\n            if (x, y) in dp:\\n                # look-up DP table\\n                return dp[x, y]\\n\\n            if not 0 <= x < w or not 0 <= y < h or not can_walk(x, y) :\\n                # out-of-board, or cannot walk through\\n                dp[x, y] = 0\\n                return 0\\n\\n            if (x, y) == (0, 0):\\n                # Starting point, aka base case\\n                dp[x, y] = 1\\n                return 1\\n\\n            # General cases\\n            dp[x, y] = walk(x-1, y) + walk(x, y-1)\\n            return dp[(x, y)]\\n                    \\n```\n```\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    \\n    // helper function\\n    var allowToVisit func (x, y int) int\\n    \\n    allowToVisit = func(x, y int) int{\\n        // 1 : allow to visit\\n        // 0 : can not visit due to obstacle\\n        return 1 - obstacleGrid[y][x]\\n    }\\n    \\n    h, w := len(obstacleGrid), len(obstacleGrid[0])\\n    \\n    if h * w == 0 || allowToVisit(0, 0) == 0 {\\n        // Quick response for invalid cases\\n        return 0\\n    }\\n    \\n    // update [0][0] as start point with one valid path\\n    obstacleGrid[0][0] = 1\\n    \\n    // base case: leftmost column\\n    for y := 1 ; y < h ; y++{\\n        obstacleGrid[y][0] = obstacleGrid[y-1][0] * allowToVisit(0, y)\\n    }\\n    \\n    // base case: top row\\n    for x := 1 ; x < w ; x++{\\n        obstacleGrid[0][x] = obstacleGrid[0][x-1] * allowToVisit(x, 0)\\n    }    \\n    \\n    // general cases:\\n    for y := 1 ; y < h ; y++{\\n        for x := 1 ; x < w ; x ++{\\n            \\n            // update path count form left and top\\n            obstacleGrid[y][x] = ( obstacleGrid[y][x-1] + obstacleGrid[y-1][x] ) * allowToVisit(x, y)\\n        }\\n    }\\n    \\n    return obstacleGrid[h-1][w-1]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115058,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic: int dp[102][102];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(i>=m || j>=n ) return 0;\\n        if(grid[i][j]==1 ) return 0;\\n        if(i==m-1 && j==n-1 ) return 1;\\n        \\n        \\n        if(dp[i][j]!=-1)  return dp[i][j];\\n        \\n        int temp=solve(grid,i+1,j) +solve(grid,i,j+1);\\n        \\n        return dp[i][j]=temp;\\n        \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(grid,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: int dp[102][102];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(i>=m || j>=n ) return 0;\\n        if(grid[i][j]==1 ) return 0;\\n        if(i==m-1 && j==n-1 ) return 1;\\n        \\n        \\n        if(dp[i][j]!=-1)  return dp[i][j];\\n        \\n        int temp=solve(grid,i+1,j) +solve(grid,i,j+1);\\n        \\n        return dp[i][j]=temp;\\n        \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(grid,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112600,
                "title": "c-dp-unique-paths-2",
                "content": "```int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1 || obstacleGrid[n-1][m-1] == 1){\\n            return 0;\\n        }\\n        \\n        long long dp[n][m];\\n        dp[n-1][m-1] = 1;\\n        bool b = true;\\n        for(int  i=n-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[i][m-1] == 1){\\n                dp[i][m-1] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[i][m-1] = 1;\\n            }\\n            else{\\n                dp[i][m-1] = 0;\\n            }\\n        }\\n        b=true;\\n        for(int  i=m-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[n-1][i] == 1){\\n                dp[n-1][i] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[n-1][i] = 1;\\n            }\\n            else{\\n                dp[n-1][i] = 0;\\n            }\\n        }\\n        for(int  i = n-2 ; i >= 0 ; i--){\\n            for(int  j = m-2 ; j >= 0 ; j--){\\n                if(obstacleGrid[i][j] != 1){\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0][0];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1 || obstacleGrid[n-1][m-1] == 1){\\n            return 0;\\n        }\\n        \\n        long long dp[n][m];\\n        dp[n-1][m-1] = 1;\\n        bool b = true;\\n        for(int  i=n-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[i][m-1] == 1){\\n                dp[i][m-1] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[i][m-1] = 1;\\n            }\\n            else{\\n                dp[i][m-1] = 0;\\n            }\\n        }\\n        b=true;\\n        for(int  i=m-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[n-1][i] == 1){\\n                dp[n-1][i] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[n-1][i] = 1;\\n            }\\n            else{\\n                dp[n-1][i] = 0;\\n            }\\n        }\\n        for(int  i = n-2 ; i >= 0 ; i--){\\n            for(int  j = m-2 ; j >= 0 ; j--){\\n                if(obstacleGrid[i][j] != 1){\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 804081,
                "title": "python-easy-simple-dp-solution-time-o-m-n",
                "content": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        dp = [[0] * len(obstacleGrid[0]) for i in range(len(obstacleGrid))]          # DP Matrix of size m*n intialized to 0\\n        dp[0][0] = 1\\n\\n        for r in range(len(obstacleGrid)):\\n            for c in range(len(obstacleGrid[0])):\\n                if obstacleGrid[r][c] == 0:\\n                    dp[r][c] += dp[r - 1][c] if r - 1 >= 0 else 0\\n                    dp[r][c] += dp[r][c - 1] if c - 1 >= 0 else 0\\n                    \\n        return dp[-1][-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        dp = [[0] * len(obstacleGrid[0]) for i in range(len(obstacleGrid))]          # DP Matrix of size m*n intialized to 0\\n        dp[0][0] = 1\\n\\n        for r in range(len(obstacleGrid)):\\n            for c in range(len(obstacleGrid[0])):\\n                if obstacleGrid[r][c] == 0:\\n                    dp[r][c] += dp[r - 1][c] if r - 1 >= 0 else 0\\n                    dp[r][c] += dp[r][c - 1] if c - 1 >= 0 else 0\\n                    \\n        return dp[-1][-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898276,
                "title": "python-easy-solution",
                "content": "# Intuition\\nYou can solve this problem using dynamic programming.\\n\\n# Approach\\nYou can solve this problem using dynamic programming. The idea is to create a 2D DP array where each cell `(i, j)` represents the number of unique paths to reach that cell. If the cell contains an obstacle, then the number of paths to that cell is 0. Otherwise, you can calculate the number of paths by adding the number of paths from the cell above `(i-1, j)` and the cell to the left `(i, j-1)`.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n    \\n        # Create a DP array initialized with 0\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the starting point\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        \\n        # Fill in the DP array\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i > 0:\\n                        dp[i][j] += dp[i - 1][j]\\n                    if j > 0:\\n                        dp[i][j] += dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n    \\n        # Create a DP array initialized with 0\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the starting point\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        \\n        # Fill in the DP array\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i > 0:\\n                        dp[i][j] += dp[i - 1][j]\\n                    if j > 0:\\n                        dp[i][j] += dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896976,
                "title": "fast-dp-in-rust-go-python",
                "content": "# Intuition \\uD83E\\uDD14\\nWhen faced with the \"Unique Paths II\" problem, the first thought that might come to mind is to navigate through the grid cell by cell. However, with obstacles in our path, a simple traversal won\\'t cut it. We need to remember our past (paths) and make informed decisions as we move. The good news? Dynamic programming is here to save the day (and our robot)!\\n\\n---\\n\\n# Approach \\uD83D\\uDE80\\nUsing dynamic programming, we keep track of the number of ways to reach each cell. The number of paths to a cell is the sum of the paths from the cell above and the cell on the left. However, if there\\'s an obstacle, that cell is a no-go zone (0 paths). \\n\\nTo keep our memory usage in check, we use two 1D arrays, `previous` and `current`, instead of a 2D matrix. As we traverse each row, we update the `current` array and then move on to the next row, making `current` our `previous` and starting fresh.\\n\\nThis rolling array technique is efficient and does the job without hogging memory.\\n\\n---\\n\\n# Complexity \\uD83E\\uDDEE\\n- **Time complexity:** $$O(m \\\\times n)$$ \\n  - We traverse through each cell of the grid once, where \\\\(m\\\\) is the number of rows and \\\\(n\\\\) is the number of columns.\\n\\n- **Space complexity:** $$O(n)$$\\n  - We use two 1D arrays to keep track of our paths, irrespective of the grid\\'s size.\\n\\n---\\n\\n# Code \\uD83E\\uDD80\\n```rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        // Basic checks\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        // Initialize our trusty path trackers\\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        // Traverse each row in the grid\\n        for row in &obstacleGrid {\\n            // Set the starting cell for the row\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                // If there\\'s an obstacle, it\\'s a dead end\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    // Otherwise, the paths are the sum from above and left\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            // Roll the arrays for the next row\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        // Our answer lies in the bottom-right corner\\n        previous[n-1]\\n    }\\n}\\n```\\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    // Handle edge cases: empty grid or start cell has an obstacle\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    // Initialize two 1D arrays to keep track of the number of paths\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    \\n    // The top-left corner has only one way to be reached (start point)\\n    previous[0] = 1\\n\\n    // Loop through each row of the grid\\n    for i := 0; i < m; i++ {\\n        // If there\\'s an obstacle at the beginning of the row, no way to get there\\n        // Otherwise, it inherits the path count from the previous row\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        // Loop through the remaining cells in the current row\\n        for j := 1; j < n; j++ {\\n            // If there\\'s an obstacle, no paths to this cell\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                // Number of paths is the sum of paths from the top and the left\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        \\n        // Swap current and previous arrays for the next iteration\\n        previous, current = current, previous\\n    }\\n    \\n    // Return the number of paths to the bottom-right corner\\n    return previous[n-1]\\n}\\n\\n```\\n``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # Handle edge cases: empty grid or start cell has an obstacle\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # Initialize two 1D arrays to keep track of the number of paths\\n        previous = [0] * n\\n        current = [0] * n\\n        \\n        # The top-left corner has only one way to be reached (start point)\\n        previous[0] = 1\\n        \\n        # Loop through each row of the grid\\n        for i in range(m):\\n            # If there\\'s an obstacle at the beginning of the row, no way to get there\\n            # Otherwise, it inherits the path count from the previous row\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            \\n            # Loop through the remaining cells in the current row\\n            for j in range(1, n):\\n                # If there\\'s an obstacle, no paths to this cell\\n                if obstacleGrid[i][j] == 1:\\n                    current[j] = 0\\n                else:\\n                    # Number of paths is the sum of paths from the top and the left\\n                    current[j] = current[j-1] + previous[j]\\n            \\n            # Update previous array for the next iteration\\n            previous[:] = current\\n        \\n        # Return the number of paths to the bottom-right corner\\n        return previous[n-1]\\n\\n```\\n---\\n\\n**Final Thoughts:** With dynamic programming and our crabby companion \\uD83E\\uDD80, we\\'ve efficiently solved this intriguing grid problem. Embrace the power of Rust and keep exploring! If you ever feel lost in a grid full of obstacles, just remember: every step you take is building towards the solution. Happy coding! \\uD83D\\uDE80",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        // Basic checks\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        // Initialize our trusty path trackers\\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        // Traverse each row in the grid\\n        for row in &obstacleGrid {\\n            // Set the starting cell for the row\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                // If there\\'s an obstacle, it\\'s a dead end\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    // Otherwise, the paths are the sum from above and left\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            // Roll the arrays for the next row\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        // Our answer lies in the bottom-right corner\\n        previous[n-1]\\n    }\\n}\\n```\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    // Handle edge cases: empty grid or start cell has an obstacle\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    // Initialize two 1D arrays to keep track of the number of paths\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    \\n    // The top-left corner has only one way to be reached (start point)\\n    previous[0] = 1\\n\\n    // Loop through each row of the grid\\n    for i := 0; i < m; i++ {\\n        // If there\\'s an obstacle at the beginning of the row, no way to get there\\n        // Otherwise, it inherits the path count from the previous row\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        // Loop through the remaining cells in the current row\\n        for j := 1; j < n; j++ {\\n            // If there\\'s an obstacle, no paths to this cell\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                // Number of paths is the sum of paths from the top and the left\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        \\n        // Swap current and previous arrays for the next iteration\\n        previous, current = current, previous\\n    }\\n    \\n    // Return the number of paths to the bottom-right corner\\n    return previous[n-1]\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # Handle edge cases: empty grid or start cell has an obstacle\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # Initialize two 1D arrays to keep track of the number of paths\\n        previous = [0] * n\\n        current = [0] * n\\n        \\n        # The top-left corner has only one way to be reached (start point)\\n        previous[0] = 1\\n        \\n        # Loop through each row of the grid\\n        for i in range(m):\\n            # If there\\'s an obstacle at the beginning of the row, no way to get there\\n            # Otherwise, it inherits the path count from the previous row\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            \\n            # Loop through the remaining cells in the current row\\n            for j in range(1, n):\\n                # If there\\'s an obstacle, no paths to this cell\\n                if obstacleGrid[i][j] == 1:\\n                    current[j] = 0\\n                else:\\n                    # Number of paths is the sum of paths from the top and the left\\n                    current[j] = current[j-1] + previous[j]\\n            \\n            # Update previous array for the next iteration\\n            previous[:] = current\\n        \\n        # Return the number of paths to the bottom-right corner\\n        return previous[n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896889,
                "title": "c-recursive-dp-1d-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a DP question. Use DP in a standard way!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere is a similar question which can be solved by using Pascal traingle.\\n[Leetcode 62. Unique Paths](https://leetcode.com/problems/unique-paths/solutions/3602735/python-c-solutions-use-math-pascal-triangle-dp-beats-100/)\\n\\nBut in this question there are so many obstacleGrids, the direct applying of Math trick like Pascal Triangle is is not easy and does not bring benefits( language like python which has packages for computing combinations). It is suggested to use standardard DP to solve.\\n\\nIn fact, it is not difficult to know that\\n```\\nif (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n```\\nIn second approach, optimized 1D iterative DP is implemented which beats 100%.\\n\\nThe space complexity is reduced. Consider the transforms\\n```\\ndp[j]<-dp[i][j]\\nprev[j]<-dp[i-1][j]\\n```\\nBefore the next iteration, don\\'t forget ```prev=dp```! Such tricks are used  in such Pascal-triangle-like problems(Leetcode 118. Pascal\\'s Triangle)\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/paoJGMYEEhA](https://youtu.be/paoJGMYEEhA)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)\\\\to O(m)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<long long>> dp;\\n    long long numsPaths(int i, int j, vector<vector<int>>& obstacleGrid)\\n    {       \\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n        long long ans=0;\\n        if (i>0) ans+=numsPaths(i-1, j, obstacleGrid);\\n        if (j>0) ans+=numsPaths(i, j-1, obstacleGrid);\\n        if (i==0 && j==0) ans=(obstacleGrid[0][0]==0)?1:0;\\n        return dp[i][j]=ans;     \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        n=obstacleGrid.size();\\n        m=obstacleGrid[0].size();\\n        dp.assign(n, vector<long long>(m, -1));\\n\\n        return numsPaths(n-1, m-1, obstacleGrid);\\n    }\\n};\\n```\\n# Buttom up Approach using 1D arrays beating 100%\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size();\\n        int m=obstacleGrid[0].size();\\n        vector<int> dp(m, 0), prev(m, 0);\\n        \\n        //Deal with 0th row \\n        for(int j=0; j<m; j++){\\n            if (obstacleGrid[0][j]==1) break;\\n            else dp[j]=1;\\n        }\\n        prev=dp;\\n            \\n        for(int i=1; i<n; i++){\\n            if (obstacleGrid[i][0]==1) dp[0]=0;\\n            else dp[0]=prev[0];\\n            for(int j=1; j<m; j++){\\n                if (obstacleGrid[i][j]==1) dp[j]=0;\\n                else dp[j]=prev[j]+dp[j-1];\\n            }\\n            prev=dp;\\n        }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nif (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n```\n```\\ndp[j]<-dp[i][j]\\nprev[j]<-dp[i-1][j]\\n```\n```prev=dp```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<long long>> dp;\\n    long long numsPaths(int i, int j, vector<vector<int>>& obstacleGrid)\\n    {       \\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n        long long ans=0;\\n        if (i>0) ans+=numsPaths(i-1, j, obstacleGrid);\\n        if (j>0) ans+=numsPaths(i, j-1, obstacleGrid);\\n        if (i==0 && j==0) ans=(obstacleGrid[0][0]==0)?1:0;\\n        return dp[i][j]=ans;     \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        n=obstacleGrid.size();\\n        m=obstacleGrid[0].size();\\n        dp.assign(n, vector<long long>(m, -1));\\n\\n        return numsPaths(n-1, m-1, obstacleGrid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size();\\n        int m=obstacleGrid[0].size();\\n        vector<int> dp(m, 0), prev(m, 0);\\n        \\n        //Deal with 0th row \\n        for(int j=0; j<m; j++){\\n            if (obstacleGrid[0][j]==1) break;\\n            else dp[j]=1;\\n        }\\n        prev=dp;\\n            \\n        for(int i=1; i<n; i++){\\n            if (obstacleGrid[i][0]==1) dp[0]=0;\\n            else dp[0]=prev[0];\\n            for(int j=1; j<m; j++){\\n                if (obstacleGrid[i][j]==1) dp[j]=0;\\n                else dp[j]=prev[j]+dp[j-1];\\n            }\\n            prev=dp;\\n        }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847624,
                "title": "c-clean-and-easy-explanation-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem is same as to take that path or not.(take, not take kinda)\\n- We are storing tatal paths of the grid indexes.(by checking one by on in left direction and down).\\n- If there\\'s a obstacle we\\'ll store 0 paths for that.\\n- If we are at destination, simply return.\\n- Otherwise take action in either direction and add both total ways.\\n- Store it in dp table for space optimization.\\n\\n# Complexity\\n- Time complexity: O(2^n) : exponential due to recursive calls\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n\\xB2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int i, int j, int t[101][101]){\\n        if(i==grid.size() || j==grid[0].size()) return 0; // base case\\n        if(grid[i][j]==1)return 0; // obstacle\\n        if(i==grid.size()-1 && j==grid[0].size()-1)return 1; // destiny\\n        if(t[i][j]!=-1)return t[i][j]; // already calculated\\n        return t[i][j] = helper(grid, i+1, j, t) + helper(grid, i, j+1, t);\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int t[101][101];\\n        memset(t, -1, sizeof t);\\n        return helper(grid, 0, 0, t);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int i, int j, int t[101][101]){\\n        if(i==grid.size() || j==grid[0].size()) return 0; // base case\\n        if(grid[i][j]==1)return 0; // obstacle\\n        if(i==grid.size()-1 && j==grid[0].size()-1)return 1; // destiny\\n        if(t[i][j]!=-1)return t[i][j]; // already calculated\\n        return t[i][j] = helper(grid, i+1, j, t) + helper(grid, i, j+1, t);\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int t[101][101];\\n        memset(t, -1, sizeof t);\\n        return helper(grid, 0, 0, t);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050410,
                "title": "beats-100-most-efficient-solution-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        long long mod = 2e9+7;\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                \\n                if(i>=0 && j>=0 && grid[i][j] == 1){\\n                   curr[j] = 0;\\n                    // continue;\\n                } \\n                else if(i==0 && j==0){\\n                    curr[j] = 1;\\n                    // continue;\\n                } \\n                else{\\n                int up=0,left =0;\\n               if(i>0){\\n                   up = prev[j];\\n               }\\n               if(j>0){\\n                   left =curr[j-1];\\n               } \\n                curr[j] = ( up + left) % mod ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        long long mod = 2e9+7;\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                \\n                if(i>=0 && j>=0 && grid[i][j] == 1){\\n                   curr[j] = 0;\\n                    // continue;\\n                } \\n                else if(i==0 && j==0){\\n                    curr[j] = 1;\\n                    // continue;\\n                } \\n                else{\\n                int up=0,left =0;\\n               if(i>0){\\n                   up = prev[j];\\n               }\\n               if(j>0){\\n                   left =curr[j-1];\\n               } \\n                curr[j] = ( up + left) % mod ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974536,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nl, ml, a[105][105], dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml and a[x][y] == 0) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        memset(dp, -1, sizeof(dp));\\n        nl = obstacleGrid.size(), ml = obstacleGrid[0].size();\\n        for(int i=0; i<nl; i++) for(int j=0; j<ml; j++) a[i][j] = obstacleGrid[i][j];\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nl, ml, a[105][105], dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml and a[x][y] == 0) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        memset(dp, -1, sizeof(dp));\\n        nl = obstacleGrid.size(), ml = obstacleGrid[0].size();\\n        for(int i=0; i<nl; i++) for(int j=0; j<ml; j++) a[i][j] = obstacleGrid[i][j];\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057572,
                "title": "easy-recursion-optimizing-recursion-using-memoization",
                "content": "\\n#### **RECURSION**\\n*  For every (i, j), there are two possibilites of movement : DOWN (i+1, j) & RIGHT (i, j+1)\\n\\n* **INVALID BASE CASES:**\\n\\t1. \\tIf index i or index j is out of bounds.\\n\\t\\n\\t2. \\tIf (i, j) cell has an obstacle.\\n\\t\\n\\t\\t***In all these cases, the number of unique paths is 0.***\\n\\t\\n*  **VALID BASE CASE:**\\n      \\n\\t1. If (i, j) cell is our destination cell(m-1, n-1), \\n\\t\\n\\t      ***The number of unique path is 1.***\\n\\t\\n\\n\\nUnique paths for Down Move = func(i+1, j) \\nUnique paths for Right Move = func(i, j+1)\\n\\t\\t\\t***Total unique paths = Down Moves + Right Moves = func(i+1, j) + func(i, j+1)***\\n\\n\\n```\\n class Solution {\\n    int m,n;\\n    int[][] grid;\\n    public int recurse(int i, int j) {\\n        if(i==m || j==n || grid[i][j]==1)\\n            return 0; // Invalid case\\n        if(m-1==i && j==n-1)\\n            return 1; //Valid case\\n        return recurse(i, j+1)+recurse(i+1, j);\\n    }\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        m = obstacleGrid.length;\\n        n = obstacleGrid[0].length;\\n        grid = obstacleGrid;\\n        return recurse(0, 0);\\n    }\\n}\\n```\\nThis will have exponential time complexity. \\n\\n#### **Optimization using Memoization (Top-Down)**\\nThere are many cells for which the value is computed more than once.\\n\\nSo, after the value for a certain cell (i, j) is computed, we can store the value and return that value later on.\\n\\n```\\nclass Solution {\\n    Integer dp[][];\\n    int m,n;\\n    int[][] grid;\\n    public int recurse(int i, int j) {\\n        if(i == m || j == n || grid[i][j] == 1)\\n            return 0;\\n\\t\\tif(dp[i][j] != null)\\n            return dp[i][j]; //return the already computed value for cell (i, j)\\n        if(m-1 == i && j == n-1)\\n            return dp[i][j] = 1;\\n        return dp[i][j] = recurse(i, j+1) + recurse(i+1, j); //store value for cell (i, j)\\n    }\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        m = obstacleGrid.length;\\n        n = obstacleGrid[0].length;\\n        grid = obstacleGrid;\\n        dp = new Integer[m][n];\\n        return recurse(0, 0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n    int m,n;\\n    int[][] grid;\\n    public int recurse(int i, int j) {\\n        if(i==m || j==n || grid[i][j]==1)\\n            return 0; // Invalid case\\n        if(m-1==i && j==n-1)\\n            return 1; //Valid case\\n        return recurse(i, j+1)+recurse(i+1, j);\\n    }\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        m = obstacleGrid.length;\\n        n = obstacleGrid[0].length;\\n        grid = obstacleGrid;\\n        return recurse(0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057114,
                "title": "unique-paths-ii-javascript-clean-solution",
                "content": "if you start write your Recursive solution you will get TLE (Time Limit Exceed) \\nso we need to have some way of Cache the result of Every Recursive Call so this technique is called \\nMemomization we will have a Array called **memo** to store our Recursive Result and cache it\\n\\n```javascript\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\n var uniquePathsWithObstacles = function (obstacleGrid) {\\n  const M = obstacleGrid.length;\\n  const N = obstacleGrid[0].length;\\n  const memo = new Array(M).fill(0).map((v) => new Array(N).fill(0)); // 1-memo Array to Cache the Result\\n\\n  const traverse = (x, y) => {\\n    if (obstacleGrid[x] === undefined || obstacleGrid[x][y] === undefined || obstacleGrid[x][y] === 1) return 0; // 2-check is there is Obstacle\\n\\n    if (x === M - 1 && y === N - 1) return 1; // 3-if we reach the Target we need\\n\\n    if (memo[x][y] === 0) { // 4-start to traverse at this point if === 0\\n      memo[x][y] = traverse(x + 1, y) + traverse(x, y + 1);\\n    }\\n    return memo[x][y]; // 5-Return the result\\n  };\\n\\n  return traverse(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\n var uniquePathsWithObstacles = function (obstacleGrid) {\\n  const M = obstacleGrid.length;\\n  const N = obstacleGrid[0].length;\\n  const memo = new Array(M).fill(0).map((v) => new Array(N).fill(0)); // 1-memo Array to Cache the Result\\n\\n  const traverse = (x, y) => {\\n    if (obstacleGrid[x] === undefined || obstacleGrid[x][y] === undefined || obstacleGrid[x][y] === 1) return 0; // 2-check is there is Obstacle\\n\\n    if (x === M - 1 && y === N - 1) return 1; // 3-if we reach the Target we need\\n\\n    if (memo[x][y] === 0) { // 4-start to traverse at this point if === 0\\n      memo[x][y] = traverse(x + 1, y) + traverse(x, y + 1);\\n    }\\n    return memo[x][y]; // 5-Return the result\\n  };\\n\\n  return traverse(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2055624,
                "title": "c-0ms-runtime-faster-than-100-just-5-line-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1833335,
                "title": "c-follow-up-question-solution-combination-solving-big-n-m-with-limited-size-obstables",
                "content": "**Follow Up** : \\n\\nGiven the **h * w** matrix where **1 <= h <= 10000, 1 <= w <= 10000**\\nAlso given the positions of the **n** obstacles where **0 <= n <= 1000**\\nFind how many ways **from (0, 0) to (h - 1, w - 1)**\\n<br/><br/>\\n\\n**Part1 : Combination :**\\n* Since the answer for that follow up is very large, we should use a **mod** instead\\n* We know that, if there is 0 obstables, we have **C(h + w - 2, h - 1)** ways from (1, 1) => (h , w). **C** denotes for combinations\\n* Now we want to calculate how many **bad ways** !! The **answer** is **C(h + w - 2, h - 1) - total badways**\\n* Let\\'s choose a starting obstacle, let\\'s say it is **(r1, c1)**\\n* If (r1, c1) is the starting obstcles, we have **(number of ways without touching any obstacle from (1, 1) to (r1, c1)) * C(h - r1 + w - c1, h - r1)** bad ways \\n* Total badways is the sum of if we choose each obstable as a staring obstcle\\n<br/><br/><br/>\\n\\n**Part2 : DP**\\n* But there may be duplication, in this case, we can solve it by using dp. (We first need to sort our obstacles)\\n* Let **dp[i]** denotes number of ways from (1, 1) to obstacle[i] without touching any other obstacles.\\n* **dp[i] = C(r1 + c1 - 2, r1 - c1) - Sum(dp[j])** if *obstacles[j].r <= obstacles[i].r and obstacles[j].c <= obstacles[i].c*\\n* Now, If (r1, c1) is the starting obstcles, we have **(dp[i]) * C(h - r1 + w - c1, h - r1)** bad ways for each choosen starting obstacle\\n\\n**Time : O(max(n ^ 2), log(h + w) (h + w))**\\n**Space : O(max(n ^ 2), log(h + w) (h + w))**\\n\\n```\\nusing ll = long long;\\n#define pb push_back\\n#define f first\\n#define se second\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\n\\n\\n\\nint MOD = 998244353;\\nll mod = 2000000033ll;\\nint INF = INT_MAX;\\n\\nll fact[10000 + 50];\\nll inv[10000 + 50];\\n\\nll C(int n, int r) {\\n    return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\\n}\\n\\nll modInverse(ll a, ll m){\\n    ll m0 = m;\\n    ll y = 0, x = 1;\\n\\n    if (m == 1)\\n        return 0;\\n    \\n    while (a > 1) {\\n        ll q = a / m;\\n        ll t = m;\\n        m = a % m;\\n        a = t;\\n        t = y;\\n        y = x - q * y;\\n        x = t;\\n    }\\n    if (x < 0)\\n        x += m0;\\n    return x;\\n}\\n\\nvoid init() {\\n  fact[0] = fact[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n    fact[i] = fact[i - 1] * i;\\n    fact[i] %= mod;\\n  }\\n\\n  inv[0] = inv[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n      inv[i] = modInverse(i,mod) * inv[i-1];\\n      inv[i] %=mod;\\n  }\\n}\\n\\nbool com(pair<int, int>& a, pair<int, int>& b) {\\n  if(a.f == b.f) {\\n    return a.se < b.se;\\n  }\\n  return a.f < b.f;\\n}\\n\\n\\nll solve(int h, int w, ve<pair<int, int>>& a) {\\n  init();\\n  ll total = C(h + w - 2, h - 1);\\n  ll res = 0;\\n  sort(a.begin(), a.end(), com);\\n  ve<ll> dp(a.size());\\n  FOR(i, 0, a.size()) {\\n    int r1 = a[i].f, c1 = a[i].se;\\n    ll ways = C(r1 + c1 - 2, r1 - 1);//(1, 1) => (r1, c1)\\n    for(int j =  i - 1; j >= 0; j--) {\\n      int r2 = a[j].f, c2 = a[j].se;\\n      if(r2 <= r1 && c2 <= c1) {//j -> i\\n        ll x = C(r1 + c1 - r2 - c2, r1 - r2);\\n        ll y = dp[j];\\n        x *= y;\\n        x %= mod;\\n        ways -= x;\\n        ways += mod;\\n        ways %= mod;\\n      }\\n    }\\n    dp[i] = ways;\\n    ll x = C(h - r1 + w - c1, h - r1);\\n    ll y = ways;\\n    ll add = x * y;\\n    add %= mod;\\n    res += add;\\n    res %= mod;\\n  }\\n  return (total - res + mod) % mod;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(ve<ve<int>>& a) {\\n        int h = a.size(), w = a[0].size();\\n        ve<pair<int, int>> b;\\n        FOR(i, 0, h) {\\n            FOR(j, 0, w) {\\n                if(a[i][j] == 1) {\\n                    b.pb({i + 1, j + 1});\\n                }\\n            }\\n        }\\n        ll res = solve(h, w, b);\\n        return (int)(res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\n#define pb push_back\\n#define f first\\n#define se second\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\n\\n\\n\\nint MOD = 998244353;\\nll mod = 2000000033ll;\\nint INF = INT_MAX;\\n\\nll fact[10000 + 50];\\nll inv[10000 + 50];\\n\\nll C(int n, int r) {\\n    return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\\n}\\n\\nll modInverse(ll a, ll m){\\n    ll m0 = m;\\n    ll y = 0, x = 1;\\n\\n    if (m == 1)\\n        return 0;\\n    \\n    while (a > 1) {\\n        ll q = a / m;\\n        ll t = m;\\n        m = a % m;\\n        a = t;\\n        t = y;\\n        y = x - q * y;\\n        x = t;\\n    }\\n    if (x < 0)\\n        x += m0;\\n    return x;\\n}\\n\\nvoid init() {\\n  fact[0] = fact[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n    fact[i] = fact[i - 1] * i;\\n    fact[i] %= mod;\\n  }\\n\\n  inv[0] = inv[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n      inv[i] = modInverse(i,mod) * inv[i-1];\\n      inv[i] %=mod;\\n  }\\n}\\n\\nbool com(pair<int, int>& a, pair<int, int>& b) {\\n  if(a.f == b.f) {\\n    return a.se < b.se;\\n  }\\n  return a.f < b.f;\\n}\\n\\n\\nll solve(int h, int w, ve<pair<int, int>>& a) {\\n  init();\\n  ll total = C(h + w - 2, h - 1);\\n  ll res = 0;\\n  sort(a.begin(), a.end(), com);\\n  ve<ll> dp(a.size());\\n  FOR(i, 0, a.size()) {\\n    int r1 = a[i].f, c1 = a[i].se;\\n    ll ways = C(r1 + c1 - 2, r1 - 1);//(1, 1) => (r1, c1)\\n    for(int j =  i - 1; j >= 0; j--) {\\n      int r2 = a[j].f, c2 = a[j].se;\\n      if(r2 <= r1 && c2 <= c1) {//j -> i\\n        ll x = C(r1 + c1 - r2 - c2, r1 - r2);\\n        ll y = dp[j];\\n        x *= y;\\n        x %= mod;\\n        ways -= x;\\n        ways += mod;\\n        ways %= mod;\\n      }\\n    }\\n    dp[i] = ways;\\n    ll x = C(h - r1 + w - c1, h - r1);\\n    ll y = ways;\\n    ll add = x * y;\\n    add %= mod;\\n    res += add;\\n    res %= mod;\\n  }\\n  return (total - res + mod) % mod;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(ve<ve<int>>& a) {\\n        int h = a.size(), w = a[0].size();\\n        ve<pair<int, int>> b;\\n        FOR(i, 0, h) {\\n            FOR(j, 0, w) {\\n                if(a[i][j] == 1) {\\n                    b.pb({i + 1, j + 1});\\n                }\\n            }\\n        }\\n        ll res = solve(h, w, b);\\n        return (int)(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398160,
                "title": "simple-c-faster-than-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]==1){\\n            return 0;\\n        }\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int** dp = new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        dp[0][0]=1;\\n        //filling m-2 rows and n-2 colm\\n        for(int i=0;i<m-1;i++){\\n            for(int j=0;j<n-1;j++){\\n                int val=dp[i][j];\\n                if(obstacleGrid[i+1][j]!=1)dp[i+1][j]+=val;\\n                if(obstacleGrid[i][j+1]!=1)dp[i][j+1]+=val;\\n            }\\n        }\\n        //filling last row\\n        for(int j=0;j<n-1;j++){\\n            int val=dp[m-1][j];\\n            if(obstacleGrid[m-1][j+1]!=1)dp[m-1][j+1]+=val;\\n        }\\n        //filling last column\\n        for(int i=0;i<m-1;i++){\\n            int val=dp[i][n-1];\\n            if(obstacleGrid[i+1][n-1]!=1)dp[i+1][n-1]+=val;\\n        }\\n        return dp[m-1][n-1];\\n        \\n        \\n        \\n        \\n        \\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]==1){\\n            return 0;\\n        }\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int** dp = new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        dp[0][0]=1;\\n        //filling m-2 rows and n-2 colm\\n        for(int i=0;i<m-1;i++){\\n            for(int j=0;j<n-1;j++){\\n                int val=dp[i][j];\\n                if(obstacleGrid[i+1][j]!=1)dp[i+1][j]+=val;\\n                if(obstacleGrid[i][j+1]!=1)dp[i][j+1]+=val;\\n            }\\n        }\\n        //filling last row\\n        for(int j=0;j<n-1;j++){\\n            int val=dp[m-1][j];\\n            if(obstacleGrid[m-1][j+1]!=1)dp[m-1][j+1]+=val;\\n        }\\n        //filling last column\\n        for(int i=0;i<m-1;i++){\\n            int val=dp[i][n-1];\\n            if(obstacleGrid[i+1][n-1]!=1)dp[i+1][n-1]+=val;\\n        }\\n        return dp[m-1][n-1];\\n        \\n        \\n        \\n        \\n        \\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879300,
                "title": "java-100-fast-dp-solution",
                "content": "```\\nclass Solution \\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m=obstacleGrid.length;\\n        int n=obstacleGrid[0].length;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        if(obstacleGrid[0][0]==1)\\n        {\\n            return 0;\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==0)\\n            {\\n                dp[i][0]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==0)\\n            {\\n                dp[0][i]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n\\n\\n//  1 1 1 1 1 X 0 0\\n//  1 2 3 4\\n//\\n//\\n//\\n//",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m=obstacleGrid.length;\\n        int n=obstacleGrid[0].length;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        if(obstacleGrid[0][0]==1)\\n        {\\n            return 0;\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==0)\\n            {\\n                dp[i][0]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==0)\\n            {\\n                dp[0][i]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23364,
                "title": "easy-to-understand-java-solution",
                "content": "    public class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                }\\n                else {\\n                    if(i == 0 && j == 0) obstacleGrid[i][j] = 1;\\n                    else if(i == 0 && j > 0) obstacleGrid[i][j] = obstacleGrid[i][j-1];\\n                    else if(i > 0 && j == 0) obstacleGrid[i][j] = obstacleGrid[i-1][j];\\n                    else obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\\n                }\\n            }\\n        }\\n        return obstacleGrid[m-1][n-1];\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 23381,
                "title": "java-dp-solutions-o-n-n-o-n-space",
                "content": "  \\n\\n       \\n    // O(n*n) space\\n    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[][] = new int[row][col];\\n        dp[0][0] = 1-obstacleGrid[0][0];\\n        for (int i=1; i<row; i++)\\n            dp[i][0] = dp[i-1][0]*(1-obstacleGrid[i][0]);\\n        for (int j=1; j<col; j++)\\n            dp[0][j] = dp[0][j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) \\n            for (int j=1; j<col; j++)\\n                dp[i][j] = (dp[i-1][j]+dp[i][j-1])*(1-obstacleGrid[i][j]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[] = new int[col];\\n        dp[0] = 1-obstacleGrid[0][0];\\n        for (int j=1; j<col; j++)\\n            dp[j] = dp[j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) {\\n            dp[0] *= 1-obstacleGrid[i][0];\\n            for (int j=1; j<col; j++) \\n                dp[j] = (dp[j-1]+dp[j])*(1-obstacleGrid[i][j]);\\n        }\\n        return dp[col-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "  \\n\\n       \\n    // O(n*n) space\\n    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[][] = new int[row][col];\\n        dp[0][0] = 1-obstacleGrid[0][0];\\n        for (int i=1; i<row; i++)\\n            dp[i][0] = dp[i-1][0]*(1-obstacleGrid[i][0]);\\n        for (int j=1; j<col; j++)\\n            dp[0][j] = dp[0][j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) \\n            for (int j=1; j<col; j++)\\n                dp[i][j] = (dp[i-1][j]+dp[i][j-1])*(1-obstacleGrid[i][j]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[] = new int[col];\\n        dp[0] = 1-obstacleGrid[0][0];\\n        for (int j=1; j<col; j++)\\n            dp[j] = dp[j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) {\\n            dp[0] *= 1-obstacleGrid[i][0];\\n            for (int j=1; j<col; j++) \\n                dp[j] = (dp[j-1]+dp[j])*(1-obstacleGrid[i][j]);\\n        }\\n        return dp[col-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23348,
                "title": "i-saw-many-answers-are-using-2-d-vector-which-is-unnecessary-check-my-1-d-vector-solution",
                "content": "\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int width = obstacleGrid[0].size();\\n        vector<int> result(width, 0);\\n        result[0] = 1;\\n\\n        for (int i = 0; i <  obstacleGrid.size(); ++i) {\\n            for (int j = 0; j < width; ++j) {\\n                if (obstacleGrid[i][j] == 1)\\n                    result[j] = 0;\\n                else if (j > 0)\\n                    result[j] += result[j-1];\\n            }\\n        }\\n        return result[width-1];\\n    }",
                "solutionTags": [],
                "code": "\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int width = obstacleGrid[0].size();\\n        vector<int> result(width, 0);\\n        result[0] = 1;\\n\\n        for (int i = 0; i <  obstacleGrid.size(); ++i) {\\n            for (int j = 0; j < width; ++j) {\\n                if (obstacleGrid[i][j] == 1)\\n                    result[j] = 0;\\n                else if (j > 0)\\n                    result[j] += result[j-1];\\n            }\\n        }\\n        return result[width-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23443,
                "title": "share-my-java-solution-o-m-n-time-complexity-no-extra-space",
                "content": "Obviously, this is a DP problem.\\n\\nLet F(i,j) denotes the paths from top left to cell (i,j).\\n\\n\\nIf cell (i,j) has an obstacle, then F(i,j) = 0.\\nelse \\n\\n\\nfor j>0, F(0,j) = F(0,j-1)\\n   \\n\\nfor i>0, F(i,0) = F(i-1,0)\\n    \\n\\nfor i>0&&j>0, F(i,j) = F(i-1,j)+F(i,j-1)\\n\\nWe can take advantage of the obstacle array without using extra space.         \\n\\n        if(obstacleGrid==null||obstacleGrid.length==0)\\n        \\treturn 0;\\n\\n        for(int i=0;i<obstacleGrid.length;i++)\\n        \\tfor(int j=0;j<obstacleGrid[0].length;j++)\\n        \\t{\\n        \\t\\tif(i==0)\\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[0][0] = 1 - obstacleGrid[0][0];\\n        \\t\\t\\telse\\n        \\t\\t\\t\\tobstacleGrid[0][j] = obstacleGrid[0][j]==1?0:obstacleGrid[0][j-1];\\n        \\t\\t}\\n        \\t\\telse \\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[i][0] = obstacleGrid[i][0]==1?0:obstacleGrid[i-1][0];\\n        \\t\\t\\telse \\n        \\t\\t\\t\\tobstacleGrid[i][j] = obstacleGrid[i][j]==1?0:(obstacleGrid[i-1][j]+obstacleGrid[i][j-1]);\\n\\t\\t\\t\\t}\\n        \\t}\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[0].length-1];",
                "solutionTags": [],
                "code": "Obviously, this is a DP problem.\\n\\nLet F(i,j) denotes the paths from top left to cell (i,j).\\n\\n\\nIf cell (i,j) has an obstacle, then F(i,j) = 0.\\nelse \\n\\n\\nfor j>0, F(0,j) = F(0,j-1)\\n   \\n\\nfor i>0, F(i,0) = F(i-1,0)\\n    \\n\\nfor i>0&&j>0, F(i,j) = F(i-1,j)+F(i,j-1)\\n\\nWe can take advantage of the obstacle array without using extra space.         \\n\\n        if(obstacleGrid==null||obstacleGrid.length==0)\\n        \\treturn 0;\\n\\n        for(int i=0;i<obstacleGrid.length;i++)\\n        \\tfor(int j=0;j<obstacleGrid[0].length;j++)\\n        \\t{\\n        \\t\\tif(i==0)\\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[0][0] = 1 - obstacleGrid[0][0];\\n        \\t\\t\\telse\\n        \\t\\t\\t\\tobstacleGrid[0][j] = obstacleGrid[0][j]==1?0:obstacleGrid[0][j-1];\\n        \\t\\t}\\n        \\t\\telse \\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[i][0] = obstacleGrid[i][0]==1?0:obstacleGrid[i-1][0];\\n        \\t\\t\\telse \\n        \\t\\t\\t\\tobstacleGrid[i][j] = obstacleGrid[i][j]==1?0:(obstacleGrid[i-1][j]+obstacleGrid[i][j-1]);\\n\\t\\t\\t\\t}\\n        \\t}\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[0].length-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 23444,
                "title": "java-solution-modified-form-uniquepath-i",
                "content": "modified form uniquePath I;\\nset the upper and left boundary of the answer matrix to 1 until blocked;\\nset any blocks to 0\\n\\n\\n    public class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int width = obstacleGrid[0].length;\\n            int lines = obstacleGrid.length;\\n            int [][] answer = new int[lines][width];\\n            \\n           \\n            \\n            for(int j=0;j<width;j++){\\n                if(obstacleGrid[0][j]==1){if(lines==1) return 0; break;}\\n                else answer[0][j]=1;\\n            }\\n            \\n            for(int i=0;i<lines;i++){\\n                if(obstacleGrid[i][0]==1){if(width==1) return 0; break;}\\n                else answer[i][0]=1;\\n            }\\n            \\n            for(int i=1;i<lines;i++){\\n                for(int j=1;j<width;j++){\\n                    if(obstacleGrid[i][j]!=1){\\n                        answer[i][j]=answer[i-1][j]+answer[i][j-1];\\n                    }\\n                }\\n            }\\n            \\n            return answer[lines-1][width-1];\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int width = obstacleGrid[0].length;\\n            int lines = obstacleGrid.length;\\n            int [][] answer = new int[lines][width];\\n            \\n           \\n            \\n            for(int j=0;j<width;j++){\\n                if(obstacleGrid[0][j]==1){if(lines==1) return 0; break;}",
                "codeTag": "Java"
            },
            {
                "id": 3898076,
                "title": "easy-solution-python3-c-with-image-beats-r-m-96-77-78-09",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "C#"
                ],
                "code": "```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328251,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^S)$$ --> S = m * n\\n\\n- Space complexity:\\n$$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;     \\n        int left = solve(row, col-1, obstacleGrid);  \\n        int up = solve(row-1, col, obstacleGrid);  \\n        return left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        return solve(m-1, n-1, obstacleGrid);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;   \\n        if (dp[row][col] != -1)\\n            return dp[row][col];      \\n        int left = solve(row, col-1, obstacleGrid, dp);  \\n        int up = solve(row-1, col, obstacleGrid, dp);  \\n        return dp[row][col] = left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = dp[i][j-1];\\n                if (i > 0)\\n                    up = dp[i-1][j];    \\n                dp[i][j] = left + up;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    cur[j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    cur[j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = cur[j-1];\\n                if (i > 0)\\n                    up = prev[j];    \\n                cur[j] = left + up;\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;     \\n        int left = solve(row, col-1, obstacleGrid);  \\n        int up = solve(row-1, col, obstacleGrid);  \\n        return left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        return solve(m-1, n-1, obstacleGrid);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;   \\n        if (dp[row][col] != -1)\\n            return dp[row][col];      \\n        int left = solve(row, col-1, obstacleGrid, dp);  \\n        int up = solve(row-1, col, obstacleGrid, dp);  \\n        return dp[row][col] = left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = dp[i][j-1];\\n                if (i > 0)\\n                    up = dp[i-1][j];    \\n                dp[i][j] = left + up;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution { \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    cur[j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    cur[j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = cur[j-1];\\n                if (i > 0)\\n                    up = prev[j];    \\n                cur[j] = left + up;\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163373,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674229,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    # top down dp\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # memo for dp\\n        memo = [[None for _ in range(n)] for __ in range(m)]\\n        \\n        # edge case\\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        # we want to fill first row and column with 0 if we find an obstacle from that point to the end of the row or column. This way we can return 0 to indicate that a path is not possible because an obstacle blocks it\\n        row_fill = 1\\n        col_fill = 1\\n        for r in range(m):\\n            if obstacleGrid[r][0] == 1:\\n                row_fill = 0\\n            obstacleGrid[r][0] = row_fill\\n            \\n        for c in range(1, n):\\n            if obstacleGrid[0][c] == 1:\\n                col_fill = 0\\n            obstacleGrid[0][c] = col_fill\\n\\n        # recursive function for top down dp\\n        def dp(r, c):\\n            # if we first row or col we return 1 if there is no blocking path\\n            if r == 0 or c == 0:\\n                return obstacleGrid[r][c]\\n            # if we reach an obstacle there is no possible path\\n            elif obstacleGrid[r][c] == 1:\\n                return 0\\n            # update memo if not cached\\n            if memo[r][c] is None:\\n                memo[r][c] = dp(r, c-1) + dp(r-1, c)\\n            return memo[r][c]\\n    \\n        return dp(m - 1, n - 1)\\n```\\n\\nTime: O(m * n) we only need to visit each matrix entry once\\nSpace: O(m * n) for memo array",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    # top down dp\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # memo for dp\\n        memo = [[None for _ in range(n)] for __ in range(m)]\\n        \\n        # edge case\\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        # we want to fill first row and column with 0 if we find an obstacle from that point to the end of the row or column. This way we can return 0 to indicate that a path is not possible because an obstacle blocks it\\n        row_fill = 1\\n        col_fill = 1\\n        for r in range(m):\\n            if obstacleGrid[r][0] == 1:\\n                row_fill = 0\\n            obstacleGrid[r][0] = row_fill\\n            \\n        for c in range(1, n):\\n            if obstacleGrid[0][c] == 1:\\n                col_fill = 0\\n            obstacleGrid[0][c] = col_fill\\n\\n        # recursive function for top down dp\\n        def dp(r, c):\\n            # if we first row or col we return 1 if there is no blocking path\\n            if r == 0 or c == 0:\\n                return obstacleGrid[r][c]\\n            # if we reach an obstacle there is no possible path\\n            elif obstacleGrid[r][c] == 1:\\n                return 0\\n            # update memo if not cached\\n            if memo[r][c] is None:\\n                memo[r][c] = dp(r, c-1) + dp(r-1, c)\\n            return memo[r][c]\\n    \\n        return dp(m - 1, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058561,
                "title": "simple-recursion-memoization-solution-ii-dp-ii-faster-than-100-00",
                "content": "Same Approach Like [Unique Paths](https://leetcode.com/problems/unique-paths/)\\n[Solution](https://leetcode.com/problems/unique-paths/discuss/2058560/Simple-Recursion-%2B-Memoization-Solution-II-DP-II-Faster-than-100.00)\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid,int x,int y,int m,int n)\\n    {\\n        if(x>=m || y>=n || obstacleGrid[x][y]==1)\\n            return 0;\\n        if(x==m-1 && y==n-1)\\n            return 1;\\n        \\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        else\\n            dp[x][y] = solve(obstacleGrid,x+1,y,m,n)+solve(obstacleGrid,x,y+1,m,n);\\n        return dp[x][y];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid,0,0,m,n);\\n    }\\n};\\n```\\n\\n**Please Upvote** if you liked the approach.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid,int x,int y,int m,int n)\\n    {\\n        if(x>=m || y>=n || obstacleGrid[x][y]==1)\\n            return 0;\\n        if(x==m-1 && y==n-1)\\n            return 1;\\n        \\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        else\\n            dp[x][y] = solve(obstacleGrid,x+1,y,m,n)+solve(obstacleGrid,x,y+1,m,n);\\n        return dp[x][y];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid,0,0,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057813,
                "title": "c-straight-forward-dp-solution",
                "content": "```\\nclass Solution {\\n    \\n    int row;\\n    int col;\\n    \\npublic:\\n    int dfs(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        \\n        //base cases\\n        if(i < 0 || j < 0\\n          || i >= row\\n          || j >= col)\\n            return 0;\\n        \\n        if(grid[i][j]){\\n            dp[i][j] = 0;\\n            return dp[i][j];\\n        }\\n        \\n        if(i == row - 1 && j == col - 1)\\n            return 1;\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        dp[i][j] = dfs(grid, i + 1, j, dp) + dfs(grid, i, j + 1, dp);\\n        \\n        return dp[i][j];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        row = obstacleGrid.size();\\n        col = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(row, vector<int>(col, 0));\\n        \\n        return dfs(obstacleGrid, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int row;\\n    int col;\\n    \\npublic:\\n    int dfs(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        \\n        //base cases\\n        if(i < 0 || j < 0\\n          || i >= row\\n          || j >= col)\\n            return 0;\\n        \\n        if(grid[i][j]){\\n            dp[i][j] = 0;\\n            return dp[i][j];\\n        }\\n        \\n        if(i == row - 1 && j == col - 1)\\n            return 1;\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        dp[i][j] = dfs(grid, i + 1, j, dp) + dfs(grid, i, j + 1, dp);\\n        \\n        return dp[i][j];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        row = obstacleGrid.size();\\n        col = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(row, vector<int>(col, 0));\\n        \\n        return dfs(obstacleGrid, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057478,
                "title": "dp-is-new-love",
                "content": "well simple we have two path to go we use dp array, we choose any one and add it them to the asnwere\\n```class Solution {\\npublic int fun(int x,int y, int[][]g,int [][]dp){\\n   \\n    if(x<0||y<0)return 0;\\n     if(dp[x][y]!=-1)return dp[x][y];\\n    if(g[x][y]==1)return dp[x][y]=0;\\n    if(x==0&&y==0)return dp[x][y]= 1;\\n    return dp[x][y]=fun(x-1,y,g,dp)+fun(x,y-1,g,dp);\\n}\\n    public int uniquePathsWithObstacles(int[][] g) {\\n        int dp[][]=new int[g.length][g[0].length];\\n        for(int i=0;i<g.length;i++){\\n            for(int j=0;j<g[0].length;j++)dp[i][j]=-1;\\n            \\n        }\\n        if(g[0][0]==1||g[g.length-1][g[0].length-1]==1)return 0;\\n        int a= fun(g.length-1,g[0].length-1,g,dp);\\n        return dp[g.length-1][g[0].length-1];\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```class Solution {\\npublic int fun(int x,int y, int[][]g,int [][]dp){\\n   \\n    if(x<0||y<0)return 0;\\n     if(dp[x][y]!=-1)return dp[x][y];\\n    if(g[x][y]==1)return dp[x][y]=0;\\n    if(x==0&&y==0)return dp[x][y]= 1;\\n    return dp[x][y]=fun(x-1,y,g,dp)+fun(x,y-1,g,dp);\\n}\\n    public int uniquePathsWithObstacles(int[][] g) {\\n        int dp[][]=new int[g.length][g[0].length];\\n        for(int i=0;i<g.length;i++){\\n            for(int j=0;j<g[0].length;j++)dp[i][j]=-1;\\n            \\n        }\\n        if(g[0][0]==1||g[g.length-1][g[0].length-1]==1)return 0;\\n        int a= fun(g.length-1,g[0].length-1,g,dp);\\n        return dp[g.length-1][g[0].length-1];\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2056894,
                "title": "are-you-tired-of-getting-tle-using-recursive-solution-c-dp-solution-dlc-may20",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, -1));      //stores no of paths at each point\\n        \\n        //return no. of unique paths\\n        return helper(obstacleGrid, dp, 0, 0);\\n    }\\n    \\n    int helper(vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp, int i, int j){\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1) //out of boundary\\n             return 0;\\n        \\n        if(dp[i][j] != -1)      //if already have the valuem, use that to calc no of paths\\n            return dp[i][j];\\n        \\n        if(i==m-1 && j==n-1)    //if reached to correct pos, got 1 path\\n             return 1;\\n        \\n        //Now we need to calc the no of unique paths, in right and bottom direction\\n        return dp[i][j] = helper(obstacleGrid, dp, i, j+1) + helper(obstacleGrid, dp, i+1, j);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, -1));      //stores no of paths at each point\\n        \\n        //return no. of unique paths\\n        return helper(obstacleGrid, dp, 0, 0);\\n    }\\n    \\n    int helper(vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp, int i, int j){\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1) //out of boundary\\n             return 0;\\n        \\n        if(dp[i][j] != -1)      //if already have the valuem, use that to calc no of paths\\n            return dp[i][j];\\n        \\n        if(i==m-1 && j==n-1)    //if reached to correct pos, got 1 path\\n             return 1;\\n        \\n        //Now we need to calc the no of unique paths, in right and bottom direction\\n        return dp[i][j] = helper(obstacleGrid, dp, i, j+1) + helper(obstacleGrid, dp, i+1, j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056591,
                "title": "concise-one-pass-in-place-solution-with-no-recursion",
                "content": "With `switch`:\\n```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tg[i][j] = (g[i][j], i, j) switch\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t(1, _, _) => 0,\\n\\t\\t\\t\\t\\t(_, 0, 0) => 1,\\n\\t\\t\\t\\t\\t(_, 0, _) => g[i][j - 1] * 1,\\n\\t\\t\\t\\t\\t(_, _, 0) => g[i - 1][j] * 1,\\n\\t\\t\\t\\t\\t_         => g[i - 1][j] + g[i][j - 1]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}\\n\\treturn g[^1][^1];\\n}\\n```\\n\\nSame, rewritten with a classic `if-else`:\\n```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(g[i][j] == 1)          g[i][j] = 0;\\n\\t\\t\\telse if(i == 0 && j == 0) g[i][j] = 1;\\n\\t\\t\\telse if(i == 0)           g[i][j] = g[i][j - 1] * 1;\\n\\t\\t\\telse if(j == 0)           g[i][j] = g[i - 1][j] * 1;\\n\\t\\t\\telse                      g[i][j] = g[i - 1][j] + g[i][j - 1];\\n\\t\\t}\\n\\t}\\n    return g[^1][^1];\\n}\\n```\\n\\nWhich version do you find more readable/maintainable?",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tg[i][j] = (g[i][j], i, j) switch\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t(1, _, _) => 0,\\n\\t\\t\\t\\t\\t(_, 0, 0) => 1,\\n\\t\\t\\t\\t\\t(_, 0, _) => g[i][j - 1] * 1,\\n\\t\\t\\t\\t\\t(_, _, 0) => g[i - 1][j] * 1,\\n\\t\\t\\t\\t\\t_         => g[i - 1][j] + g[i][j - 1]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}\\n\\treturn g[^1][^1];\\n}\\n```\n```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(g[i][j] == 1)          g[i][j] = 0;\\n\\t\\t\\telse if(i == 0 && j == 0) g[i][j] = 1;\\n\\t\\t\\telse if(i == 0)           g[i][j] = g[i][j - 1] * 1;\\n\\t\\t\\telse if(j == 0)           g[i][j] = g[i - 1][j] * 1;\\n\\t\\t\\telse                      g[i][j] = g[i - 1][j] + g[i][j - 1];\\n\\t\\t}\\n\\t}\\n    return g[^1][^1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2055463,
                "title": "java-easy-solution-o-m-n-time-and-o-1-space-with-comments-0-ms",
                "content": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int R = obstacleGrid.length;\\n        int C = obstacleGrid[0].length;\\n\\n        // If the starting cell has an obstacle, then simply return as there would be\\n        // no paths to the destination.\\n        if (obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        // Number of ways of reaching the starting cell = 1.\\n        obstacleGrid[0][0] = 1;\\n\\n        // Filling the values for the first column\\n        for (int i = 1; i < R; i++) {\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;\\n        }\\n\\n        // Filling the values for the first row\\n        for (int i = 1; i < C; i++) {\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;\\n        }\\n\\n        // Starting from cell(1,1) fill up the values\\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\\n        // i.e. From above and left.\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                } else {\\n                    obstacleGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        // Return value stored in rightmost bottommost cell. That is the destination.\\n        return obstacleGrid[R - 1][C - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int R = obstacleGrid.length;\\n        int C = obstacleGrid[0].length;\\n\\n        // If the starting cell has an obstacle, then simply return as there would be\\n        // no paths to the destination.\\n        if (obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        // Number of ways of reaching the starting cell = 1.\\n        obstacleGrid[0][0] = 1;\\n\\n        // Filling the values for the first column\\n        for (int i = 1; i < R; i++) {\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;\\n        }\\n\\n        // Filling the values for the first row\\n        for (int i = 1; i < C; i++) {\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;\\n        }\\n\\n        // Starting from cell(1,1) fill up the values\\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\\n        // i.e. From above and left.\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                } else {\\n                    obstacleGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        // Return value stored in rightmost bottommost cell. That is the destination.\\n        return obstacleGrid[R - 1][C - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885227,
                "title": "63-unique-paths-ii-100-faster-very-easy-to-understand",
                "content": "\\n### The idea is same as Unique Paths but with checking obstacles...\\n1. First we have to **make an 2d array** .\\n2. then filling the **1st row boundry blocks with checking obstacles** if found then **whole row is 0** ;because there is noy way to reach at that position.\\n3. simlarly for **1st column boundry side blocks** .\\n4. and last filling all the middle elements same checking **obstacles** if **found put 0**\\n \\nThis is the idea if you helpful then please **!!upvote!!**\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        int arr[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==1)\\n                {\\n                    arr[i][0]=0;\\n                    for(int j=i+1;j<m;j++)\\n                    {\\n                        arr[j][0]=0;\\n                    }\\n                break;\\n                }\\n            else\\n            {\\n                    arr[i][0]=1;\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==1)\\n                {\\n                    arr[0][i]=0;\\n                 for(int j=i+1;j<n;j++)\\n                    {\\n                        arr[0][j]=0;\\n                    }\\n                    break;\\n                }\\n            else\\n            {\\n                    arr[0][i]=1;\\n            }\\n        }\\n         for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    arr[i][j]=0;\\n                }\\n                \\n                else\\n                {\\n                    arr[i][j]=arr[i-1][j]+arr[i][j-1];\\n                }  \\n            }\\n        }\\n        return arr[m-1][n-1];\\n    }\\n};\\n```\\n//------------//---------//----------//-------------//-------------//----------//---------//-------------//----\\n```\\nif ( if you understand )\\n     {\\n          Upvote (this post);\\n     }\\nelse if (just want to know solution)\\n     {\\n    ignore(post);\\n     }\\nelse\\n    {\\n  UPVOTE\\n   }\\n   ```\\n  !! Thanks !!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        int arr[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==1)\\n                {\\n                    arr[i][0]=0;\\n                    for(int j=i+1;j<m;j++)\\n                    {\\n                        arr[j][0]=0;\\n                    }\\n                break;\\n                }\\n            else\\n            {\\n                    arr[i][0]=1;\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==1)\\n                {\\n                    arr[0][i]=0;\\n                 for(int j=i+1;j<n;j++)\\n                    {\\n                        arr[0][j]=0;\\n                    }\\n                    break;\\n                }\\n            else\\n            {\\n                    arr[0][i]=1;\\n            }\\n        }\\n         for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    arr[i][j]=0;\\n                }\\n                \\n                else\\n                {\\n                    arr[i][j]=arr[i-1][j]+arr[i][j-1];\\n                }  \\n            }\\n        }\\n        return arr[m-1][n-1];\\n    }\\n};\\n```\n```\\nif ( if you understand )\\n     {\\n          Upvote (this post);\\n     }\\nelse if (just want to know solution)\\n     {\\n    ignore(post);\\n     }\\nelse\\n    {\\n  UPVOTE\\n   }\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1766264,
                "title": "c-4-solutions-recursive-memoization-tabulation-super-optimised",
                "content": "**1. Recursive**\\n```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    int left = path(row, col - 1, obstacleGrid);\\n    int up = path(row - 1, col, obstacleGrid);\\n    return left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    return path(row - 1, col - 1, obstacleGrid);\\n}\\n```\\n\\n**2. Memoization**\\n```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = path(row, col - 1, obstacleGrid, dp);\\n    int up = path(row - 1, col, obstacleGrid, dp);\\n    return dp[row][col] = left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return path(row - 1, col - 1, obstacleGrid, dp);\\n}\\n```\\n\\n**3. Tabulation**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = 1;\\n            else if(obstacleGrid[i][j] == 1) dp[i][j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = dp[i - 1][j];\\n                if(j > 0) left = dp[i][j - 1];\\n                dp[i][j] = left + up;\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```\\n\\n**4. Tabulation + More Space Optimised**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<int> prevRow(col, 0);\\n    \\n    for(int i = 0; i < row; i++) {\\n        vector<int> temp(col, 0);\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) temp[j] = 1;\\n            else if(obstacleGrid[i][j] == 1) temp[j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = prevRow[j];\\n                if(j > 0) left = temp[j - 1];\\n                temp[j] = left + up;\\n            }\\n        }\\n        prevRow = temp;\\n    }\\n    return prevRow[col - 1];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    int left = path(row, col - 1, obstacleGrid);\\n    int up = path(row - 1, col, obstacleGrid);\\n    return left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    return path(row - 1, col - 1, obstacleGrid);\\n}\\n```\n```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = path(row, col - 1, obstacleGrid, dp);\\n    int up = path(row - 1, col, obstacleGrid, dp);\\n    return dp[row][col] = left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return path(row - 1, col - 1, obstacleGrid, dp);\\n}\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = 1;\\n            else if(obstacleGrid[i][j] == 1) dp[i][j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = dp[i - 1][j];\\n                if(j > 0) left = dp[i][j - 1];\\n                dp[i][j] = left + up;\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<int> prevRow(col, 0);\\n    \\n    for(int i = 0; i < row; i++) {\\n        vector<int> temp(col, 0);\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) temp[j] = 1;\\n            else if(obstacleGrid[i][j] == 1) temp[j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = prevRow[j];\\n                if(j > 0) left = temp[j - 1];\\n                temp[j] = left + up;\\n            }\\n        }\\n        prevRow = temp;\\n    }\\n    return prevRow[col - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444230,
                "title": "c-solution-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        //filling 0th row\\n        for(int i = 0; i < n; i++){\\n            if(obstacleGrid[0][i] == 1) break;\\n            dp[0][i] = 1;\\n        }\\n        \\n        //filling 0th column\\n         for(int i = 0; i < m; i++){\\n            if(obstacleGrid[i][0] == 1) break;\\n            dp[i][0] = 1;\\n        }\\n        \\n        //filling rest of the dp array\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++){\\n                if(obstacleGrid[i][j] == 1) continue;\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = size(obstacleGrid), n = size(obstacleGrid[0]);\\n        dp.resize(m, vector<int>(n));\\n        return helper(obstacleGrid, 0, 0);\\n    }\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= m || j >= n) return 0;\\n        if( grid[i][j]) return dp[i][j] = 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = helper(grid, i, j+1) + helper(grid, i+1, j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        //filling 0th row\\n        for(int i = 0; i < n; i++){\\n            if(obstacleGrid[0][i] == 1) break;\\n            dp[0][i] = 1;\\n        }\\n        \\n        //filling 0th column\\n         for(int i = 0; i < m; i++){\\n            if(obstacleGrid[i][0] == 1) break;\\n            dp[i][0] = 1;\\n        }\\n        \\n        //filling rest of the dp array\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++){\\n                if(obstacleGrid[i][j] == 1) continue;\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = size(obstacleGrid), n = size(obstacleGrid[0]);\\n        dp.resize(m, vector<int>(n));\\n        return helper(obstacleGrid, 0, 0);\\n    }\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= m || j >= n) return 0;\\n        if( grid[i][j]) return dp[i][j] = 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = helper(grid, i, j+1) + helper(grid, i+1, j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374932,
                "title": "simple-c-solution-using-two-different-approaches",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n//1st Approach\\n//This will give TLE\\n```\\n//DFS+Backtracking\\n    void dfs(int i,int j,int m,int n,int &cnt,vector<vector<int>> &vis,vector<vector<int>> obstacleGrid)\\n    {\\n        if(i>=m||j>=n)\\n            return ;\\n        if(obstacleGrid[i][j]==1||vis[i][j]==1)\\n            return;\\n        if(i==m-1&&j==n-1)\\n            cnt++;\\n        vis[i][j]=1;\\n        dfs(i+1,j,m,n,cnt,vis,obstacleGrid);\\n        dfs(i,j+1,m,n,cnt,vis,obstacleGrid);\\n        vis[i][j]=0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int cnt=0;\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)\\n            return 0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        dfs(0,0,m,n,cnt,vis,obstacleGrid);\\n        return cnt;\\n        }\\n\\t\\t\\n\\t\\t//Recursive+Memoization\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp,vector<vector<int>> &obstacleGrid)\\n    {\\n        if(i>=m||j>=n||obstacleGrid[i][j])\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(i+1,j,m,n,dp,obstacleGrid)+solve(i,j+1,m,n,dp,obstacleGrid);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n     vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp,obstacleGrid);\\n        }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//DFS+Backtracking\\n    void dfs(int i,int j,int m,int n,int &cnt,vector<vector<int>> &vis,vector<vector<int>> obstacleGrid)\\n    {\\n        if(i>=m||j>=n)\\n            return ;\\n        if(obstacleGrid[i][j]==1||vis[i][j]==1)\\n            return;\\n        if(i==m-1&&j==n-1)\\n            cnt++;\\n        vis[i][j]=1;\\n        dfs(i+1,j,m,n,cnt,vis,obstacleGrid);\\n        dfs(i,j+1,m,n,cnt,vis,obstacleGrid);\\n        vis[i][j]=0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int cnt=0;\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)\\n            return 0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        dfs(0,0,m,n,cnt,vis,obstacleGrid);\\n        return cnt;\\n        }\\n\\t\\t\\n\\t\\t//Recursive+Memoization\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp,vector<vector<int>> &obstacleGrid)\\n    {\\n        if(i>=m||j>=n||obstacleGrid[i][j])\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(i+1,j,m,n,dp,obstacleGrid)+solve(i,j+1,m,n,dp,obstacleGrid);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n     vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp,obstacleGrid);\\n        }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1180246,
                "title": "unique-paths-ii-short-easy-w-explanation-commented-code",
                "content": "We start at the top-left of the **`obstacleGrid`** and for each cell in the grid, we can either move right or down. We can\\'t land at an obstacle. We need to return the number of unique paths to reach the bottom-right of grid.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [Rejected]***\\n\\nLet\\'s build our solution starting from the brute force approach. Let\\'s directly apply what\\'s given in the problem statement.  At each cell, we have two choices -\\n\\n&emsp;&emsp;\\u2726 *Go Right*\\n&emsp;&emsp;\\u2726 *Go Down*\\n\\nSo, we can recursively build up our solution as -.\\n\\n1. At each cell, explore the two choices available to us - go right & go down (**Recursive function**).\\n\\n2. If we reach the bottom-right cell of the grid, we have found a unique path (**Base Condition - I**). \\n\\n3. If at any time, we reach a cell with value 1, it is an **obstacle cell** and we can\\'t move any further. So, we just stop exploring further paths from this cell (**Base Condition - II**).  \\n\\n\\nWe will accumulate all such unique paths.\\n\\n**C++**\\n```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Recursive version) [Accepted]***\\n\\nWe can observe that there are a lot of cells that are revisited in the above appraoch and the whole path is recursed till the bottom-right cell is reached for each cell again and again. We don\\'t need to recalculate this everytime if we just store the previously calculated result for a given cell.\\n\\nWe can do this by maintaining a 2d DP array. Here *`dp[i][j]`* will denote the number of unique paths to reach the bottom-right corner of the grid starting from the cell - *`obstacleGrid[i][j]`*.\\n\\n**C++**\\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Iterative version) [Accepted]***\\n\\nWe can also solve it iteratively. We have 1 way in which we can start from *`grid[0][0]`* and for rest of the cells, we could have reached here from the top cell or the left cell. So, we can maintain *`dp[i][j]`* and iteratively accumulate unique paths for current cell by adding *`dp[i - 1][j]`* (number of ways we reached top cell) and *`dp[i][j - 1]`* (number of ways we reached left cell).\\n\\nHere, I am using padded row and column in *`dp`* to simplify the code. In this solution, *`dp[i][j]`*, will denote the number of unique paths to reach the cell *`grid[i-1][j-1]`* (since padded row and column used in dp at start) from the start. \\n\\nThus, we can iterate over the whole grid and at last return **`dp[m][n]`** which will be the number of unique paths to reach bottom-right of grid from the start.\\n\\nHere, *`dp[0][1]`* (or *`dp[1][0]`*) needs to be set to 1 at the start, so that *`dp[1][1]`* will become 1 in our loop (denoting we have one way to reach the starting cell `grid[0][0]`).\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Space Optimized) [Accepted]***\\n\\nWe can see that in the above solution, we are only ever accessing the current and previous rows of the dp array. So, we don\\'t need to maintain the whole *`M*N`* DP array and the space usage can be optimized by maintaining just 2 rows.\\n\\nA common way of doing this with most dp problems is to declare a two rows dp matrix and just alternate between the rows at each iteration. We can alternate between the rows by doing a parity check while indexing a row of dp. Thus, we can use `dp[0]` at even indices and `dp[1]` and odd indices of iteration.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution V - (In-Place) [Accepted]***\\n\\nWe can also choose to modify the given input grid itself (if input modification is allowed). This solution is similar to *`Solution - III`*, with just the change that we are using *`grid`* itself instead of auxillary space for **`dp`**.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i,j in zip(range(1, n), range(1, m)):\\n\\t\\tgrid[0][i] = not grid[0][i] & grid[0][i - 1]\\n\\t\\tgrid[j][0] = not grid[j][0] & grid[j - 1][0]        \\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i,j in zip(range(1, n), range(1, m)):\\n\\t\\tgrid[0][i] = not grid[0][i] & grid[0][i - 1]\\n\\t\\tgrid[j][0] = not grid[j][0] & grid[j - 1][0]        \\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043867,
                "title": "java-0ms-beats-100-recursion-top-down-dp",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\nMemory Usage: 38.2 MB, less than 55.04% of Java online submissions for Unique Paths II.\\n\\n```\\nclass Solution {\\n        \\n    private int util(int[][] b, int x, int y, int[][] dp)\\n    {\\n        //base case check - if x or y is invalid or if there is obstacle\\n        if( x < 0 || y < 0 || b[x][y] == 1)\\n            return 0;\\n        \\n        // if we reached the cell (0,0) - return 1 as there is a path\\n        if(x == 0  && y == 0 )\\n            return 1;\\n        \\n\\t// check your cache to avoid repeated check\\n        if(dp[x][y] != Integer.MAX_VALUE)\\n            return dp[x][y];\\n\\n\\t// else go to the top or left cell and store back the result        \\n        dp[x][y] = util(b, x-1, y, dp) + util(b, x, y-1, dp);\\n        \\n        return dp[x][y];\\n        \\n    }\\n    \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       //base case\\n        if(obstacleGrid.length == 0)\\n            return 0;\\n        \\n        if(obstacleGrid.length == 1 && obstacleGrid[0].length ==1)\\n            return obstacleGrid[0][0] == 0 ? 1 : 0;\\n        \\n        int[][] dp  = new int[obstacleGrid.length][obstacleGrid[0].length];\\n        \\n\\t// initialize DP array\\n        for(int i=0; i < dp.length; i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE );\\n        \\n        //start from the last for this question\\n        int m = obstacleGrid.length -1 ;\\n        int n = obstacleGrid[0].length -1;\\n        \\n       // Start from the bottom right most cell and go till (0,0) cell\\n        util(obstacleGrid, m, n, dp);\\n        \\n        return dp[m][n] != Integer.MAX_VALUE ? dp[m][n] : 0; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    private int util(int[][] b, int x, int y, int[][] dp)\\n    {\\n        //base case check - if x or y is invalid or if there is obstacle\\n        if( x < 0 || y < 0 || b[x][y] == 1)\\n            return 0;\\n        \\n        // if we reached the cell (0,0) - return 1 as there is a path\\n        if(x == 0  && y == 0 )\\n            return 1;\\n        \\n\\t// check your cache to avoid repeated check\\n        if(dp[x][y] != Integer.MAX_VALUE)\\n            return dp[x][y];\\n\\n\\t// else go to the top or left cell and store back the result        \\n        dp[x][y] = util(b, x-1, y, dp) + util(b, x, y-1, dp);\\n        \\n        return dp[x][y];\\n        \\n    }\\n    \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       //base case\\n        if(obstacleGrid.length == 0)\\n            return 0;\\n        \\n        if(obstacleGrid.length == 1 && obstacleGrid[0].length ==1)\\n            return obstacleGrid[0][0] == 0 ? 1 : 0;\\n        \\n        int[][] dp  = new int[obstacleGrid.length][obstacleGrid[0].length];\\n        \\n\\t// initialize DP array\\n        for(int i=0; i < dp.length; i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE );\\n        \\n        //start from the last for this question\\n        int m = obstacleGrid.length -1 ;\\n        int n = obstacleGrid[0].length -1;\\n        \\n       // Start from the bottom right most cell and go till (0,0) cell\\n        util(obstacleGrid, m, n, dp);\\n        \\n        return dp[m][n] != Integer.MAX_VALUE ? dp[m][n] : 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763068,
                "title": "python-memo-dp-table-explained",
                "content": "Code is fully commented, if you have any questions feel free.\\n\\n***Memo version (better than 90% submissions)***\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        self.height, self.width = len(obstacleGrid), len(obstacleGrid[0])\\n        self.memo = defaultdict(int)\\n        \\n        def walk(i, j):\\n            # If were on an obstacle\\n            if obstacleGrid[i][j] == 1: return 0\\n            \\n            # If we arrived to the end we know there is a path\\n            if i == self.height - 1 and j == self.width - 1:\\n                return 1\\n            \\n            # Memo\\n            if (i, j) in self.memo:\\n                return self.memo[(i, j)]\\n            \\n            # Travel down\\n            if i < self.height - 1:\\n                self.memo[(i, j)] += walk(i + 1, j)\\n            \\n            # Travel right\\n            if j < self.width - 1:\\n                self.memo[(i, j)] += walk(i, j + 1)\\n            \\n            return self.memo[(i, j)]\\n                \\n        \\n        return walk(0, 0)\\n```\\n\\n\\n***Tabulated version (better than 85%)***\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        height, width = len(obstacleGrid), len(obstacleGrid[0])\\n        if obstacleGrid[height - 1][width - 1] == 1: return 0\\n        \\n        dp = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\\n        dp[height - 1][width - 1] = 1\\n        \\n        for i in range(height)[::-1]:\\n            for j in range(width)[::-1]:\\n                # This if block skips the first iteration only\\n                if i == height - 1 and j == width - 1: continue\\n                if obstacleGrid[i][j] == 1: continue\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n        \\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        self.height, self.width = len(obstacleGrid), len(obstacleGrid[0])\\n        self.memo = defaultdict(int)\\n        \\n        def walk(i, j):\\n            # If were on an obstacle\\n            if obstacleGrid[i][j] == 1: return 0\\n            \\n            # If we arrived to the end we know there is a path\\n            if i == self.height - 1 and j == self.width - 1:\\n                return 1\\n            \\n            # Memo\\n            if (i, j) in self.memo:\\n                return self.memo[(i, j)]\\n            \\n            # Travel down\\n            if i < self.height - 1:\\n                self.memo[(i, j)] += walk(i + 1, j)\\n            \\n            # Travel right\\n            if j < self.width - 1:\\n                self.memo[(i, j)] += walk(i, j + 1)\\n            \\n            return self.memo[(i, j)]\\n                \\n        \\n        return walk(0, 0)\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        height, width = len(obstacleGrid), len(obstacleGrid[0])\\n        if obstacleGrid[height - 1][width - 1] == 1: return 0\\n        \\n        dp = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\\n        dp[height - 1][width - 1] = 1\\n        \\n        for i in range(height)[::-1]:\\n            for j in range(width)[::-1]:\\n                # This if block skips the first iteration only\\n                if i == height - 1 and j == width - 1: continue\\n                if obstacleGrid[i][j] == 1: continue\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649140,
                "title": "simple-java-o-1-space-solution",
                "content": "For cell i,j we just need to sum left cell + top cell.\\nIf any of them is obstacle, then we say it\\'s 0, otherwise take it\\'s value.\\n\\n```\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        if (grid[0][0] == 1 || grid[n - 1][m - 1] == 1) return 0;\\n        grid[0][0] = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                } else {\\n                    int top = i == 0 ? 0 : grid[i - 1][j];\\n                    int left = j == 0 ? 0 : grid[i][j - 1];\\n                    grid[i][j] = top + left;        \\n                }\\n            }\\n        }\\n        return grid[n - 1][m - 1];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        if (grid[0][0] == 1 || grid[n - 1][m - 1] == 1) return 0;\\n        grid[0][0] = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                } else {\\n                    int top = i == 0 ? 0 : grid[i - 1][j];\\n                    int left = j == 0 ? 0 : grid[i][j - 1];\\n                    grid[i][j] = top + left;        \\n                }\\n            }\\n        }\\n        return grid[n - 1][m - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 587294,
                "title": "java-100-faster-simple-solution",
                "content": "#### Success\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\nMemory Usage: 38.5 MB, less than 90.77% of Java online submissions for Unique Paths II.**\\n\\n```\\n\\nclass Solution{\\n    public int uniquePathsWithObstacles(int[][] arr) \\n\\t{\\n        if(arr == null || arr.length == 0) \\n\\t\\t\\treturn 0;\\n        for(int i = 0 ; i < arr.length; i++){\\n            for(int j = 0; j < arr[0].length; j++){\\n                arr[i][j] ^= 1;\\n                if(arr[i][j] == 1){\\n                    if(i == 0 && j != 0)\\n                        arr[i][j] = arr[i][j-1];\\n                    if(i != 0 && j == 0)\\n                        arr[i][j] = arr[i-1][j];\\n                    if(i != 0 && j != 0)\\n                        arr[i][j] = arr[i-1][j] + arr[i][j-1];\\n                }   \\n            }\\n        } \\n        return arr[arr.length - 1][arr[0].length - 1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution{\\n    public int uniquePathsWithObstacles(int[][] arr) \\n\\t{\\n        if(arr == null || arr.length == 0) \\n\\t\\t\\treturn 0;\\n        for(int i = 0 ; i < arr.length; i++){\\n            for(int j = 0; j < arr[0].length; j++){\\n                arr[i][j] ^= 1;\\n                if(arr[i][j] == 1){\\n                    if(i == 0 && j != 0)\\n                        arr[i][j] = arr[i][j-1];\\n                    if(i != 0 && j == 0)\\n                        arr[i][j] = arr[i-1][j];\\n                    if(i != 0 && j != 0)\\n                        arr[i][j] = arr[i-1][j] + arr[i][j-1];\\n                }   \\n            }\\n        } \\n        return arr[arr.length - 1][arr[0].length - 1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279532,
                "title": "my-simple-and-easy-solution-with-dp-using-c",
                "content": "My idea is inspired by the Unique Paths question, and the dynamic Programming thought. Everytime we want to calculate, just think about last time how we get there, and how many ways to get there.\\n\\nI add a `vector<vector<long> > dp(row, vector<long>(col, 0));` to store the numbers of the way to reach the point. For example, `dp[4][3] = 6;` means we have  6 ways to reach the `obstacleGrid[4][3]`.\\n\\nIn this question, robots only can move down or move right. Each time moves one point. When we are in `obstacleGrid[i - 1][j]`, we can **move down** to reach `obstacleGrid[i][j]`; or if we are in `obstacleGrid[i][j - 1]`, we can **move right** to reach `obstacleGrid[i][j]`. \\n\\nThere\\'s two ways to reach `obstacleGrid[i][j]`, move down or move right. If we want to calculate the number of ways to reach `obstacleGrid[i][j]`, we only need to know the number of the ways to reach `obstacleGrid[i - 1][j]` and `obstacleGrid[i][j - 1]`.\\n\\nSo, easy to find the relationship below:\\n`dp[i][j] = dp[i - 1][j] + ap[i][j - 1];`\\n(Assumed all the i and j above is valid.)\\n\\nHere is my code:\\n```\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        // just because obstacleGrid is too long to type\\n        vector<vector<int> >& t = obstacleGrid;\\n        int row = t.size(), col = t[0].size();\\n        vector<vector<long> > dp(row, vector<long>(col, 0));\\n        dp[0][0] = (t[0][0] == 1 ? 0 : 1);\\n        // 1. calculate the first column\\n        for (int i = 1; i < row; ++i) \\n            dp[i][0] = (t[i][0] == 0 && dp[i - 1][0] > 0 ? 1 : 0);\\n        // 2. calculate the first row\\n        for (int i = 1; i < col; i++) \\n            dp[0][i] = (t[0][i] == 0 && dp[0][i - 1] > 0 ? 1 : 0);\\n        // 3. calculate the rest of the Grid\\n        for (int i = 1; i < row; ++i) \\n            for (int j = 1; j < col; ++j) \\n                dp[i][j] = (t[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1]);            \\n        return dp[row - 1][col - 1];\\n    }    \\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555904198.png)\\n\\nIf we have  a 5 * 5 obstacle grid, the order of the calculation is like the picture above.\\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555904508.png)\\n\\nFirst, make sure whether the starting point has a obstacle or not. \\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555905008.png)\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555905057.png)\\n\\nThen, calculate the first row and the first column.\\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555905218.png)\\n\\nAt last, calculate the rest of the obstacle grid.\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        // just because obstacleGrid is too long to type\\n        vector<vector<int> >& t = obstacleGrid;\\n        int row = t.size(), col = t[0].size();\\n        vector<vector<long> > dp(row, vector<long>(col, 0));\\n        dp[0][0] = (t[0][0] == 1 ? 0 : 1);\\n        // 1. calculate the first column\\n        for (int i = 1; i < row; ++i) \\n            dp[i][0] = (t[i][0] == 0 && dp[i - 1][0] > 0 ? 1 : 0);\\n        // 2. calculate the first row\\n        for (int i = 1; i < col; i++) \\n            dp[0][i] = (t[0][i] == 0 && dp[0][i - 1] > 0 ? 1 : 0);\\n        // 3. calculate the rest of the Grid\\n        for (int i = 1; i < row; ++i) \\n            for (int j = 1; j < col; ++j) \\n                dp[i][j] = (t[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1]);            \\n        return dp[row - 1][col - 1];\\n    }    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193557,
                "title": "java-time-o-n-m-space-o-1-explanation",
                "content": "Let\\'s say we have the following field with obstacles:\\n![image](https://assets.leetcode.com/users/olsh/image_1542205389.png)\\n\\nLet\\'s go through every cell and calculate how many paths are there to this cell.\\nFirst cell: we just stept into it. That\\'s all => only one path.\\n![image](https://assets.leetcode.com/users/olsh/image_1542205778.png)\\nGo to neighbor cells. One of them is obstacle. We mark it as 0 because in future, for calculating numbers or routes to other cells, they won\\'t add anything.\\nAnother cell is 1 because we can get there only from the first cell. \\n![image](https://assets.leetcode.com/users/olsh/image_1542207602.png)\\nEvery other cell (i,j) will be sum of cells above (i-1,j) and left (i,j-1). For border cells (with indices (ai,0) and (0, bi)) we assume that one of neighbor cells is 0, so just copy number from other cell:\\n![image](https://assets.leetcode.com/users/olsh/image_1542208046.png)\\n\\nAfter it, we just get the number in the target cell.\\n\\nHere is the code:\\n```\\nclass Solution {\\n           public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n           for (int i=0;i<obstacleGrid.length;i++){\\n               for (int j=0;j<obstacleGrid[i].length;j++){\\n                   if (obstacleGrid[i][j]==1) obstacleGrid[i][j]=0;\\n                   else if (i==0 && j==0) obstacleGrid[i][j]=1;\\n                   else if (i==0) obstacleGrid[i][j]=obstacleGrid[i][j-1];\\n                   else if (j==0) obstacleGrid[i][j]=obstacleGrid[i-1][j];\\n                   else obstacleGrid[i][j]=obstacleGrid[i-1][j]+obstacleGrid[i][j-1];\\n               }\\n           }\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[obstacleGrid.length-1].length-1];\\n    }\\n\\n}\\n\\n```\\n\\nCurrently, I\\'m searching for the ways to optimize it. For example if you meet an abstacle, you don\\'t calculate all the cells \"behind\" it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n           public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n           for (int i=0;i<obstacleGrid.length;i++){\\n               for (int j=0;j<obstacleGrid[i].length;j++){\\n                   if (obstacleGrid[i][j]==1) obstacleGrid[i][j]=0;\\n                   else if (i==0 && j==0) obstacleGrid[i][j]=1;\\n                   else if (i==0) obstacleGrid[i][j]=obstacleGrid[i][j-1];\\n                   else if (j==0) obstacleGrid[i][j]=obstacleGrid[i-1][j];\\n                   else obstacleGrid[i][j]=obstacleGrid[i-1][j]+obstacleGrid[i][j-1];\\n               }\\n           }\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[obstacleGrid.length-1].length-1];\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179781,
                "title": "dp-and-o-1-short-javascript-solution",
                "content": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    for(var i=0;i<obstacleGrid.length;i++){\\n        for(var j=0;j<obstacleGrid[0].length;j++){\\n            if(obstacleGrid[i][j] == 1)\\n                obstacleGrid[i][j] = 0\\n            else if(i==0&&j==0)\\n                obstacleGrid[0][0] = 1;\\n            else\\n                obstacleGrid[i][j] = (i>0? obstacleGrid[i-1][j] : 0) + (j>0 ? obstacleGrid[i][j-1] :0)\\n        }\\n    }\\n    return obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length-1]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    for(var i=0;i<obstacleGrid.length;i++){\\n        for(var j=0;j<obstacleGrid[0].length;j++){\\n            if(obstacleGrid[i][j] == 1)\\n                obstacleGrid[i][j] = 0\\n            else if(i==0&&j==0)\\n                obstacleGrid[0][0] = 1;\\n            else\\n                obstacleGrid[i][j] = (i>0? obstacleGrid[i-1][j] : 0) + (j>0 ? obstacleGrid[i][j-1] :0)\\n        }\\n    }\\n    return obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23247,
                "title": "short-and-sweet-python-solution-in-place-dp-ac-62ms",
                "content": "\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if (not obstacleGrid) or obstacleGrid[0][0]:\\n            return 0\\n        \\n        obstacleGrid[0][0] = 1\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        for i in range(1,m):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1-obstacleGrid[i][0])\\n            \\n        for j in range(1,n):\\n            obstacleGrid[0][j] = obstacleGrid[0][j-1] * (1-obstacleGrid[0][j])\\n            \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                obstacleGrid[i][j] = (1-obstacleGrid[i][j])*(obstacleGrid[i-1][j]+obstacleGrid[i][j-1])\\n        \\n        return obstacleGrid[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if (not obstacleGrid) or obstacleGrid[0][0]:\\n            return 0\\n        \\n        obstacleGrid[0][0] = 1\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        for i in range(1,m):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1-obstacleGrid[i][0])\\n            \\n        for j in range(1,n):\\n            obstacleGrid[0][j] = obstacleGrid[0][j-1] * (1-obstacleGrid[0][j])\\n            \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                obstacleGrid[i][j] = (1-obstacleGrid[i][j])*(obstacleGrid[i-1][j]+obstacleGrid[i][j-1])\\n        \\n        return obstacleGrid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23275,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        dp = [[0 for i in range(cols)] for j in range(rows)]\\n        for i in range(rows-1, -1, -1):\\n            for j in range(cols-1, -1, -1):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i == rows-1 and j == cols-1:\\n                        dp[i][j] = 1\\n                    elif i == rows - 1:\\n                        dp[i][j] = dp[i][j+1]\\n                    elif j == cols -1:\\n                        dp[i][j] = dp[i+1][j]\\n                    else:\\n                        dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        dp = [[0 for i in range(cols)] for j in range(rows)]\\n        for i in range(rows-1, -1, -1):\\n            for j in range(cols-1, -1, -1):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i == rows-1 and j == cols-1:\\n                        dp[i][j] = 1\\n                    elif i == rows - 1:\\n                        dp[i][j] = dp[i][j+1]\\n                    elif j == cols -1:\\n                        dp[i][j] = dp[i+1][j]\\n                    else:\\n                        dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23344,
                "title": "my-easy-understanding-java-solution-with-explanation",
                "content": "Here is my understanding of the code: Array dp stores the number of paths which passing this point. The whole algorithm is to sum up the paths from left grid and up grid. 'if (row[j] == 1) dp[j] = 0; means if there is an obstacle at this point. All the paths passing this point will no longer valid. In other words, the grid right of the obstacle can be reached only by the grid which lies up to it. Hope it helps.\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n    int width = obstacleGrid[0].length;\\n    int[] dp = new int[width];\\n    dp[0] = 1;\\n    for (int[] row : obstacleGrid) {\\n        for (int j = 0; j < width; j++) {\\n            if (row[j] == 1)\\n                dp[j] = 0;\\n            else if (j > 0)\\n                dp[j] += dp[j - 1];\\n        }\\n    }\\n    return dp[width - 1];\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Here is my understanding of the code: Array dp stores the number of paths which passing this point. The whole algorithm is to sum up the paths from left grid and up grid. 'if (row[j] == 1) dp[j] = 0; means if there is an obstacle at this point. All the paths passing this point will no longer valid. In other words, the grid right of the obstacle can be reached only by the grid which lies up to it. Hope it helps.\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n    int width = obstacleGrid[0].length;\\n    int[] dp = new int[width];\\n    dp[0] = 1;\\n    for (int[] row : obstacleGrid) {\\n        for (int j = 0; j < width; j++) {\\n            if (row[j] == 1)\\n                dp[j] = 0;\\n            else if (j > 0)\\n                dp[j] += dp[j - 1];\\n        }\\n    }\\n    return dp[width - 1];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 23377,
                "title": "pyhon-dp-solution",
                "content": "\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        m, n, dp = len(obstacleGrid), len(obstacleGrid[0]), [0, 1]\\n        dp += [0] * (n - 1)\\n        for i in xrange(1, m + 1):\\n            for j in xrange(1, n + 1):\\n                dp[j] = (not obstacleGrid[i-1][j-1]) * (dp[j] + dp[j-1]) \\n        return dp[-1]",
                "solutionTags": [],
                "code": "\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        m, n, dp = len(obstacleGrid), len(obstacleGrid[0]), [0, 1]\\n        dp += [0] * (n - 1)\\n        for i in xrange(1, m + 1):\\n            for j in xrange(1, n + 1):\\n                dp[j] = (not obstacleGrid[i-1][j-1]) * (dp[j] + dp[j-1]) \\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23389,
                "title": "simple-4ms-dp-c-solution",
                "content": "    class Solution {\\n        public:\\n            int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n                int m = grid.size(), n = ( m == 0 ? 0 : grid[0].size());\\n                if( !m || !n || grid[m-1][n-1] == 1 ) return 0;\\n                vector<vector<int>> dp( m, vector<int>(n, 0));\\n                for( int i = 0; i < m; i++ ) if( grid[i][0] != 1 ) dp[i][0] = 1; else break;\\n                for( int i = 0; i < n; i++ ) if( grid[0][i] != 1 ) dp[0][i] = 1; else break;\\n                for( int i = 1; i < m; i++ )\\n                    for( int j = 1; j < n; j++ ) dp[i][j] = (( grid[i-1][j] == 1 ) ? 0 : dp[i-1][j]) + (( grid[i][j-1] == 1 ) ? 0 : dp[i][j-1]);\\n                return dp[m-1][n-1];\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n                int m = grid.size(), n = ( m == 0 ? 0 : grid[0].size());\\n                if( !m || !n || grid[m-1][n-1] == 1 ) return 0;\\n                vector<vector<int>> dp( m, vector<int>(n, 0));\\n                for( int i = 0; i < m; i++ ) if( grid[i][0] != 1 ) dp[i][0] = 1; else break;\\n                for( int i = 0; i < n; i++ ) if( grid[0][i] != 1 ) dp[0][i] = 1; else break;\\n                for( int i = 1; i < m; i++ )\\n                    for( int j = 1; j < n; j++ ) dp[i][j] = (( grid[i-1][j] == 1 ) ? 0 : dp[i-1][j]) + (( grid[i][j-1] == 1 ) ? 0 : dp[i][j-1]);\\n                return dp[m-1][n-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3899886,
                "title": "java-dp-beats-100-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2D array visualization of ways :-\\nInput\\nobstacleGrid =\\n[[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,1,0],[0,0,0,0]]\\nStdout\\n1 1 1 1 \\n1 0 1 2 \\n1 1 2 4 \\n1 2 0 4 \\n1 3 3 7\\nTotal unique ways :- 7 ways\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       \\n        int n=obstacleGrid.length;\\n        int m=obstacleGrid[0].length;\\n   if (n == 0 || m == 0 || obstacleGrid[0][0] == 1)  return 0;\\n\\n        int dp[][] =new int[n][m];\\n        //base case \\n        for(int i=0;i<n;i++){\\n              if(obstacleGrid[i][0]==1)break;\\n              dp[i][0]=1;\\n          }\\n        for(int i=0;i<m;i++){\\n              if(obstacleGrid[0][i]==1)break;\\n              dp[0][i]=1;\\n          }\\n        //bottom up approach\\n       for(int i=1;i<n;i++){\\n           for(int j=1;j<m;j++){\\n               if(obstacleGrid[i][j]==0){\\n               if(dp[i-1][j]!=0 && dp[i][j-1]!=0){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n               }\\n               else if(dp[i-1][j]!=0){\\n                   dp[i][j]=dp[i-1][j];\\n               }\\n               else if(dp[i][j-1]!=0)\\n               dp[i][j]=dp[i][j-1];\\n           }\\n           }\\n       }\\n       return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       \\n        int n=obstacleGrid.length;\\n        int m=obstacleGrid[0].length;\\n   if (n == 0 || m == 0 || obstacleGrid[0][0] == 1)  return 0;\\n\\n        int dp[][] =new int[n][m];\\n        //base case \\n        for(int i=0;i<n;i++){\\n              if(obstacleGrid[i][0]==1)break;\\n              dp[i][0]=1;\\n          }\\n        for(int i=0;i<m;i++){\\n              if(obstacleGrid[0][i]==1)break;\\n              dp[0][i]=1;\\n          }\\n        //bottom up approach\\n       for(int i=1;i<n;i++){\\n           for(int j=1;j<m;j++){\\n               if(obstacleGrid[i][j]==0){\\n               if(dp[i-1][j]!=0 && dp[i][j-1]!=0){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n               }\\n               else if(dp[i-1][j]!=0){\\n                   dp[i][j]=dp[i-1][j];\\n               }\\n               else if(dp[i][j-1]!=0)\\n               dp[i][j]=dp[i][j-1];\\n           }\\n           }\\n       }\\n       return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898742,
                "title": "simple-c-video-solution-recursion-memoization",
                "content": "# Video Solution \\nhttps://youtu.be/t8nABhbPsuQ\\n# Intuition\\nWe will solve this question using recursion and inorder to reduce the time complexity we will use memoization.\\nFor mememoization we will have a 2D DP vector of integers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n**Please upvote if you liked !!!**\\n\\n# Code\\n```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n// this function will return all possible paths corresponding to row and col....\\n    int paths(int row,int col,vector<vector<int>>&obstacleGrid,vector<vector<int>>&dp,int n,int m){\\n        // base cases:\\n        // 1. if robot goes outside grid or on the cell having obstacle\\n        if(row<0||col<0||row>=n||col>=m||obstacleGrid[row][col]==1){\\n            return 0;\\n        }\\n        // 2. If robot is able to reach the bottom right cell...\\n        if(row==n-1&&col==m-1){\\n            return 1; // as we have found a particular combination..\\n        }\\n        // repetative cases:\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        vector<pair<int,int>>dir={{0,1},{1,0}};\\n        int ans=0; // it is all possible paths...\\n        for(auto ele:dir){\\n            int nr=row+ele.first;\\n            int nc=col+ele.second;\\n            ans+=paths(nr,nc,obstacleGrid,dp,n,m);\\n        }\\n        return dp[row][col]=ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size(),m=obstacleGrid[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1)); // this vector is used for memoization...\\n        return paths(0,0,obstacleGrid,dp,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n// this function will return all possible paths corresponding to row and col....\\n    int paths(int row,int col,vector<vector<int>>&obstacleGrid,vector<vector<int>>&dp,int n,int m){\\n        // base cases:\\n        // 1. if robot goes outside grid or on the cell having obstacle\\n        if(row<0||col<0||row>=n||col>=m||obstacleGrid[row][col]==1){\\n            return 0;\\n        }\\n        // 2. If robot is able to reach the bottom right cell...\\n        if(row==n-1&&col==m-1){\\n            return 1; // as we have found a particular combination..\\n        }\\n        // repetative cases:\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        vector<pair<int,int>>dir={{0,1},{1,0}};\\n        int ans=0; // it is all possible paths...\\n        for(auto ele:dir){\\n            int nr=row+ele.first;\\n            int nc=col+ele.second;\\n            ans+=paths(nr,nc,obstacleGrid,dp,n,m);\\n        }\\n        return dp[row][col]=ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size(),m=obstacleGrid[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1)); // this vector is used for memoization...\\n        return paths(0,0,obstacleGrid,dp,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898003,
                "title": "beats-100-user-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY SUPPORT**\\n# SPACE OPTIMIZED SOLUTION\\n# Approach\\nCreate a function uniquePathsWithObstacles that takes a 2D vector obstacleGrid as input.\\n\\nDetermine the number of rows m and columns n in the obstacleGrid.\\n\\nInitialize a 1D vector dp of size n with all values initialized to 0. This vector will be used to store the results of subproblems to avoid redundant calculations.\\n\\nSet dp[0] to 1 as there\\'s only one way to start from the top-left corner.\\n\\nIterate through each row of the obstacleGrid:\\n\\na. For each cell in the current row, check if it\\'s an obstacle. If it is, set dp[j] to 0 since there\\'s no way to reach an obstacle cell.\\n\\nb. Otherwise, update dp[j] with the sum of the previous value dp[j] and the value at dp[j - 1]. This is because you can reach the current cell either from above or from the left.\\n\\nAfter iterating through all rows, the value in dp[n - 1] will represent the total number of unique paths to the bottom-right corner.\\n\\nReturn the value at dp[n - 1].\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<int> dp(n, 0); // Single 1D vector for memoization\\n\\n        dp[0] = 1; // Initial value for the start cell\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[j] = 0; // Reset to 0 if there\\'s an obstacle in the current cell\\n                } else if (j > 0) {\\n                    dp[j] += dp[j - 1]; // Calculate the current cell\\'s value based on left cell\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1]; // The last element contains the result for the destination cell\\n    }\\n};\\n\\n```\\n\\n\\n# MEMOIZATION\\n\\n# Approach\\nCreate a function uniquePathsWithObstacles that takes a 2D vector obstacleGrid as input.\\n\\nDetermine the number of rows m and columns n in the obstacleGrid.\\n\\nInitialize a 2D vector dp of size m x n with all values initialized to -1. This dp vector will be used to store the results of subproblems to avoid redundant calculations.\\n\\nCall the path function to calculate the unique paths while considering obstacles, and return the result.\\n\\nCreate a function path that takes the following parameters: obstacleGrid, current row index i, current column index j, total number of rows m, total number of columns n, and the memoization array dp.\\n\\nIn the path function, implement the following base cases:\\n\\nIf i is greater than or equal to m or j is greater than or equal to n, return 0 since the current cell is out of bounds.\\nIf the current cell contains an obstacle (i.e., obstacleGrid[i][j] is 1), return 0.\\nIf the current cell is the destination cell (i.e., i is m - 1 and j is n - 1), return 1 since there\\'s only one way to reach the destination if there are no obstacles in the way.\\n\\nCheck if the result for the current cell (i, j) is already calculated in the dp array. If it\\'s not -1, return the stored value.\\n\\nRecursively calculate the number of paths moving down and moving right from the current cell. These values are obtained by calling the path function with incremented i for moving down and incremented j for moving right.\\n\\nCalculate the total number of unique paths from the current cell as the sum of the paths moving down and moving right: dp[i][j] = down + right.\\n\\nReturn the calculated value for the current cell.\\n\\nFinally, call the uniquePathsWithObstacles function with the input obstacleGrid to get the total number of unique paths that the robot can take to reach the bottom-right corner.\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(M*N)\\n# CODE\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return path(obstacleGrid, 0, 0, m, n, dp);\\n    }\\n\\n    int path(vector<vector<int>>& obstacleGrid, int i, int j, int m, int n, vector<vector<int>>& dp) {\\n        if (i >= m || j >= n || obstacleGrid[i][j] == 1)\\n            return 0;\\n\\n        if (i == m - 1 && j == n - 1)\\n            return 1;\\n\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int down = path(obstacleGrid, i + 1, j, m, n, dp);\\n        int right = path(obstacleGrid, i, j + 1, m, n, dp);\\n\\n        dp[i][j] = down + right;\\n        return dp[i][j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<int> dp(n, 0); // Single 1D vector for memoization\\n\\n        dp[0] = 1; // Initial value for the start cell\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[j] = 0; // Reset to 0 if there\\'s an obstacle in the current cell\\n                } else if (j > 0) {\\n                    dp[j] += dp[j - 1]; // Calculate the current cell\\'s value based on left cell\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1]; // The last element contains the result for the destination cell\\n    }\\n};\\n\\n```\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return path(obstacleGrid, 0, 0, m, n, dp);\\n    }\\n\\n    int path(vector<vector<int>>& obstacleGrid, int i, int j, int m, int n, vector<vector<int>>& dp) {\\n        if (i >= m || j >= n || obstacleGrid[i][j] == 1)\\n            return 0;\\n\\n        if (i == m - 1 && j == n - 1)\\n            return 1;\\n\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int down = path(obstacleGrid, i + 1, j, m, n, dp);\\n        int right = path(obstacleGrid, i, j + 1, m, n, dp);\\n\\n        dp[i][j] = down + right;\\n        return dp[i][j];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3897134,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m=len(obstacleGrid)\\n        n=len(obstacleGrid[0])\\n        dp=[[0 for _ in range(n)] for _ in range(m)]\\n        for col in range(n):\\n            if obstacleGrid[0][col]==1:\\n                break\\n            dp[0][col]=1\\n        for row in range(m):\\n            if obstacleGrid[row][0]==1:\\n                break\\n\\n            dp[row][0]=1\\n\\n        for row in range(1,m):\\n            for col in range(1,n):\\n                if obstacleGrid[row][col]==1:\\n                    continue\\n\\n                dp[row][col]=dp[row-1][col]+dp[row][col-1]\\n\\n        return dp[-1][-1]                            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m=len(obstacleGrid)\\n        n=len(obstacleGrid[0])\\n        dp=[[0 for _ in range(n)] for _ in range(m)]\\n        for col in range(n):\\n            if obstacleGrid[0][col]==1:\\n                break\\n            dp[0][col]=1\\n        for row in range(m):\\n            if obstacleGrid[row][0]==1:\\n                break\\n\\n            dp[row][0]=1\\n\\n        for row in range(1,m):\\n            for col in range(1,n):\\n                if obstacleGrid[row][col]==1:\\n                    continue\\n\\n                dp[row][col]=dp[row-1][col]+dp[row][col-1]\\n\\n        return dp[-1][-1]                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839926,
                "title": "simple-brute-force-memoization-tabulation-easy-to-understand-beat-100",
                "content": "# Intuition\\nThe code aims to find the number of unique paths in a grid from the top-left corner to the bottom-right corner, considering certain obstacles that block the path. The grid is represented by a 2D matrix, where each cell can either be empty (0) or contain an obstacle (1). The problem can be solved using dynamic programming to efficiently compute the number of unique paths.\\nSure, let\\'s split the Approach section into three parts: Brute Force, Memoization, and Tabulation, along with their respective complexities.\\n\\n# Brute Force Approach\\nThe brute force approach is implemented using the `solve` function, which is a recursive function exploring all possible paths from the top-left to the bottom-right corner. The function backtracks and explores the right and down directions to reach the destination while avoiding obstacles.\\n\\n## Complexity\\n- Time complexity: The time complexity for the brute force approach is exponential, i.e., O(2^n), where n is the number of cells in the grid. This is because each cell has two choices (right or down), and the function explores all possible paths.\\n- Space complexity: The space complexity for the brute force approach is O(n) due to the recursive call stack.\\n\\n# Code\\n```\\n    int solve(int i, int j, vector<vector<int>>&oG){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solve(i,j+1,oG);\\n        down = solve(i+1,j,oG);\\n        ans = right + down;\\n        return ans;\\n    }\\n```\\n\\n# Memoization Approach\\nThe memoization approach is implemented using the `solveMEM` function, which is a recursive function with memoization. It avoids redundant computations by storing the results of previously computed subproblems in a 2D memoization table (`dp`).\\n\\n## Complexity\\n- Time complexity: The memoized approach significantly improves the time complexity by avoiding redundant computations. The time complexity becomes linear, i.e., O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n- Space complexity: The memoization approach uses an additional 2D memoization table (`dp`) of size O(m * n) to store results, making the space complexity O(m * n).\\n\\n# Code\\n```\\n    int solveMEM(int i, int j, vector<vector<int>>&oG,vector<vector<int>>&dp){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solveMEM(i,j+1,oG,dp);\\n        down = solveMEM(i+1,j,oG,dp);\\n        ans = right + down;\\n        return dp[i][j]=ans;\\n    }\\n```\\n\\n# Tabulation Approach\\nThe tabulation approach is implemented using the `solveTAB` function, which solves the problem using dynamic programming with tabulation. It fills a 2D table (`dp`) to store the number of unique paths for each cell in the grid, starting from the destination cell and iterating from bottom to top and from right to left.\\n\\n## Complexity\\n- Time complexity: The tabulation approach also has a linear time complexity of O(m * n), where m is the number of rows and n is the number of columns in the grid. The function fills the table in a bottom-up manner, avoiding redundant computations.\\n- Space complexity: The tabulation approach uses a 2D table (`dp`) of size O(m * n), making the space complexity O(m * n).\\n\\nBy using memoization or tabulation, the solution\\'s time complexity is significantly reduced compared to the brute force approach, making it more efficient for larger grid sizes.\\n\\n# Code\\n```\\n    int solveTAB(vector<vector<int>>&oG){\\n        vector<vector<int>>dp(oG.size()+1,vector<int>(oG[0].size(),0));\\n        if(oG[oG.size()-1][oG[0].size()-1]==1) return 0;\\n        dp[oG.size()-1][oG[0].size()-1]=1;\\n        for(int i=oG.size()-2;i>=0;i--){\\n            if(oG[i][oG[0].size()-1]!=1){\\n                dp[i][oG[0].size()-1]=1;\\n            }\\n            else break;\\n        }\\n        for(int j=oG[0].size()-2;j>=0;j--){\\n            if(oG[oG.size()-1][j]!=1){\\n                dp[oG.size()-1][j]=1;\\n            }\\n            else break;\\n        }\\n\\n        for(int i=oG.size()-2;i>=0;i--){\\n            for(int j=oG[0].size()-2;j>=0;j--){\\n                long long ans=0;\\n                long long right=0,down=0;\\n                right = dp[i][j+1];\\n                down = dp[i+1][j];\\n                ans = right + down;\\n                if(oG[i][j]!=1)\\n                    dp[i][j]=ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/08e806e8-0ee1-4252-88ba-4a3b65e30ac3_1690743444.0506742.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\n    int solve(int i, int j, vector<vector<int>>&oG){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solve(i,j+1,oG);\\n        down = solve(i+1,j,oG);\\n        ans = right + down;\\n        return ans;\\n    }\\n```\n```\\n    int solveMEM(int i, int j, vector<vector<int>>&oG,vector<vector<int>>&dp){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solveMEM(i,j+1,oG,dp);\\n        down = solveMEM(i+1,j,oG,dp);\\n        ans = right + down;\\n        return dp[i][j]=ans;\\n    }\\n```\n```\\n    int solveTAB(vector<vector<int>>&oG){\\n        vector<vector<int>>dp(oG.size()+1,vector<int>(oG[0].size(),0));\\n        if(oG[oG.size()-1][oG[0].size()-1]==1) return 0;\\n        dp[oG.size()-1][oG[0].size()-1]=1;\\n        for(int i=oG.size()-2;i>=0;i--){\\n            if(oG[i][oG[0].size()-1]!=1){\\n                dp[i][oG[0].size()-1]=1;\\n            }\\n            else break;\\n        }\\n        for(int j=oG[0].size()-2;j>=0;j--){\\n            if(oG[oG.size()-1][j]!=1){\\n                dp[oG.size()-1][j]=1;\\n            }\\n            else break;\\n        }\\n\\n        for(int i=oG.size()-2;i>=0;i--){\\n            for(int j=oG[0].size()-2;j>=0;j--){\\n                long long ans=0;\\n                long long right=0,down=0;\\n                right = dp[i][j+1];\\n                down = dp[i+1][j];\\n                ans = right + down;\\n                if(oG[i][j]!=1)\\n                    dp[i][j]=ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3375664,
                "title": "c-solution-using-memoziation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int ans(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& obstacleGrid){\\n        if(i>=0 && j>=0 && obstacleGrid[i][j]==1) return 0;\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=ans(i-1, j, dp, obstacleGrid);\\n        int left=ans(i, j-1, dp, obstacleGrid);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return ans(m-1, n-1, dp, obstacleGrid);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int ans(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& obstacleGrid){\\n        if(i>=0 && j>=0 && obstacleGrid[i][j]==1) return 0;\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=ans(i-1, j, dp, obstacleGrid);\\n        int left=ans(i, j-1, dp, obstacleGrid);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return ans(m-1, n-1, dp, obstacleGrid);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321276,
                "title": "63-unique-paths-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    int total_ways(vector<vector<int>>& obstacleGrid, int m,int n, int row, int col,vector<vector<int>>& dp){\\n           \\n        if(row >= m || col >= n)\\n            return 0;\\n        \\n        if(obstacleGrid[row][col] == 1)\\n            return 0;\\n        \\n        if(row == m-1 && col == n-1)\\n            return 1;\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int right = total_ways(obstacleGrid,m,n,row,col+1,dp);\\n        int down = total_ways(obstacleGrid,m,n,row+1,col,dp);\\n        \\n         dp[row][col] = right + down;\\n        return dp[row][col];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n           int  m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        return total_ways(obstacleGrid,m,n,0,0,dp);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int total_ways(vector<vector<int>>& obstacleGrid, int m,int n, int row, int col,vector<vector<int>>& dp){\\n           \\n        if(row >= m || col >= n)\\n            return 0;\\n        \\n        if(obstacleGrid[row][col] == 1)\\n            return 0;\\n        \\n        if(row == m-1 && col == n-1)\\n            return 1;\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int right = total_ways(obstacleGrid,m,n,row,col+1,dp);\\n        int down = total_ways(obstacleGrid,m,n,row+1,col,dp);\\n        \\n         dp[row][col] = right + down;\\n        return dp[row][col];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n           int  m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        return total_ways(obstacleGrid,m,n,0,0,dp);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209363,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180658,
                "title": "beats-90-79-63-unique-paths-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a 2D dp list with the size of m+1 x n+1, with all elements initialized as 0.\\n2. Set dp[0][1] to 1 as it is the starting point for the robot.\\n3. Loop through the grid, if the current element is not an obstacle (obstacleGrid[i-1][j-1] == 0), calculate the number of possible paths to reach the current cell by adding the number of paths from the cell above and the cell on the left (dp[i][j] = dp[i-1][j] + dp[i][j-1]).\\n4. Return the number of paths to reach the bottom-right corner (dp[m][n]).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp[0][1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if obstacleGrid[i - 1][j - 1] == 0:\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp[0][1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if obstacleGrid[i - 1][j - 1] == 0:\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050140,
                "title": "c-easy-solution-top-down-approach-beats-85",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& obs,vector<vector<int>>&dp){\\n        if(i>=0 && j>=0 && obs[i][j]==1)\\n            return 0;\\n        if(i==0 && j==0 ) return 1;\\n        if(i<0 || j<0) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=f(i-1,j,obs,dp);\\n        int left=f(i,j-1,obs,dp);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int n=obs.size();\\n        int m=obs[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return f(n-1,m-1,obs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& obs,vector<vector<int>>&dp){\\n        if(i>=0 && j>=0 && obs[i][j]==1)\\n            return 0;\\n        if(i==0 && j==0 ) return 1;\\n        if(i<0 || j<0) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=f(i-1,j,obs,dp);\\n        int left=f(i,j-1,obs,dp);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int n=obs.size();\\n        int m=obs[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return f(n-1,m-1,obs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995680,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(v[0][0]==1)\\n        return 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(v[i][0]==1)\\n            {\\n                for(int j=i;j<m;j++)\\n                v[j][0]=0;\\n                break;\\n            }\\n            v[i][0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[0][i]==1)\\n            {\\n                for(int j=i;j<n;j++)\\n                v[0][j]=0;\\n                break;\\n            }\\n            v[0][i]=1;\\n        }\\n        // for(int i=0;i<m;i++)\\n        // for(int j=0;j<n;j++)\\n        // cout<<v[i][j]<<\" \";\\n        // cout<<\"\\\\n\";\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                v[i][j]=v[i-1][j]+v[i][j-1];\\n                else\\n                v[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        cout<<v[i][j]<<\" \";\\n        return v[m-1][n-1];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(v[0][0]==1)\\n        return 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(v[i][0]==1)\\n            {\\n                for(int j=i;j<m;j++)\\n                v[j][0]=0;\\n                break;\\n            }\\n            v[i][0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[0][i]==1)\\n            {\\n                for(int j=i;j<n;j++)\\n                v[0][j]=0;\\n                break;\\n            }\\n            v[0][i]=1;\\n        }\\n        // for(int i=0;i<m;i++)\\n        // for(int j=0;j<n;j++)\\n        // cout<<v[i][j]<<\" \";\\n        // cout<<\"\\\\n\";\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                v[i][j]=v[i-1][j]+v[i][j-1];\\n                else\\n                v[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        cout<<v[i][j]<<\" \";\\n        return v[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2979281,
                "title": "tabulation-based-soln-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to unique paths II \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsame as unique paths just one change if mat[i][j]=1 count of ways=0 for that point \\ncorner case: if starting element is obstacle return 0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\n  \\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] dp=new int[n][m];\\n       \\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                   if(grid[i][j]==1){\\n                     dp[i][j]=0;\\n                     continue;\\n                 }\\n                 if(i==0 && j==0) {\\n                     dp[i][j]=1;\\n                     continue;\\n                 }\\n               \\n                 int up=0;\\n                 int left=0;\\n                 if(i>0) up=dp[i-1][j];\\n                 if(j>0) left=dp[i][j-1];\\n                 dp[i][j]=up+left;\\n             }\\n         }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] dp=new int[n][m];\\n       \\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                   if(grid[i][j]==1){\\n                     dp[i][j]=0;\\n                     continue;\\n                 }\\n                 if(i==0 && j==0) {\\n                     dp[i][j]=1;\\n                     continue;\\n                 }\\n               \\n                 int up=0;\\n                 int left=0;\\n                 if(i>0) up=dp[i-1][j];\\n                 if(j>0) left=dp[i][j-1];\\n                 dp[i][j]=up+left;\\n             }\\n         }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975056,
                "title": "java-dynamic-programming-easy",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            if (obstacleGrid[i][0] == 1) {\\n                dp[i][0] = 0;\\n                break;\\n            }\\n            dp[i][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (obstacleGrid[0][i] == 1) {\\n                dp[0][i] = 0;\\n                break;\\n            }\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n// TC: O(n + n) + O(m * n) ~ O(m * n)\\n// SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            if (obstacleGrid[i][0] == 1) {\\n                dp[i][0] = 0;\\n                break;\\n            }\\n            dp[i][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (obstacleGrid[0][i] == 1) {\\n                dp[0][i] = 0;\\n                break;\\n            }\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n// TC: O(n + n) + O(m * n) ~ O(m * n)\\n// SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968122,
                "title": "concise-dp-solution-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &obstacleGrid, vector<vector<int>> &dp) {\\n        if(!i && !j) return 1;\\n        if(i < 0 || j < 0 || obstacleGrid[i][j]) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, obstacleGrid, dp);\\n        int l = dfs(i, j - 1, obstacleGrid, dp);\\n\\n        return dp[i][j] = u + l;\\n    }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]) return 0;\\n\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return dfs(m - 1, n - 1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &obstacleGrid, vector<vector<int>> &dp) {\\n        if(!i && !j) return 1;\\n        if(i < 0 || j < 0 || obstacleGrid[i][j]) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, obstacleGrid, dp);\\n        int l = dfs(i, j - 1, obstacleGrid, dp);\\n\\n        return dp[i][j] = u + l;\\n    }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]) return 0;\\n\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return dfs(m - 1, n - 1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535872,
                "title": "5-line-java-solution-using-recursion-and-hashmap",
                "content": "please vote up if find solution simple to code ! \\nfor explanation please reply , i will be more than happy to explain ... \\n\\n\\n\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles (int[][] obstacleGrid) {\\n        return depth(obstacleGrid, 0, 0, new HashMap<>());\\n    }\\n\\n    public int depth (int[][] grid, int i, int j, HashMap< String, Integer > memo) {\\n        if ( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1 ) return 0;\\n        if ( memo.containsKey(\"\" + j + i) ) return memo.get(\"\" + j + i);\\n        if ( j == grid[0].length - 1 && i == grid.length - 1 ) return 1; \\n        memo.put(\"\" + j + i, depth(grid, i, j + 1, memo) + depth(grid, i + 1, j, memo));\\n        return memo.get(\"\" + j + i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles (int[][] obstacleGrid) {\\n        return depth(obstacleGrid, 0, 0, new HashMap<>());\\n    }\\n\\n    public int depth (int[][] grid, int i, int j, HashMap< String, Integer > memo) {\\n        if ( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1 ) return 0;\\n        if ( memo.containsKey(\"\" + j + i) ) return memo.get(\"\" + j + i);\\n        if ( j == grid[0].length - 1 && i == grid.length - 1 ) return 1; \\n        memo.put(\"\" + j + i, depth(grid, i, j + 1, memo) + depth(grid, i + 1, j, memo));\\n        return memo.get(\"\" + j + i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064647,
                "title": "c-dp-solution",
                "content": "using logic from my previous solution of  [Unique Paths 1](https://leetcode.com/problems/unique-paths/) \\n[https://leetcode.com/problems/unique-paths/discuss/2064527/c-dp-simple-solution](https://leetcode.com/problems/unique-paths/discuss/2064527/c-dp-simple-solution)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n, vector<vector<int>> &arr) {\\n        \\n        if(arr[0][0]==1)\\n            return 0;\\n        \\n        int dp[101][101];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[0][i]==1){\\n                dp[0][i]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[0][i]=1;\\n            else dp[0][i]=0;\\n\\n        }\\n        \\n        c=0;\\n        for(int j=0;j<m;j++)\\n            if(arr[j][0]==1){\\n                dp[j][0]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[j][0]=1;\\n            else dp[j][0]=0;\\n        \\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                \\n                if(arr[i][j]==1)\\n                    dp[i][j]=0;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                \\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n        \\n    }\\n\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        return uniquePaths(obstacleGrid.size(), obstacleGrid[0].size(), obstacleGrid);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n, vector<vector<int>> &arr) {\\n        \\n        if(arr[0][0]==1)\\n            return 0;\\n        \\n        int dp[101][101];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[0][i]==1){\\n                dp[0][i]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[0][i]=1;\\n            else dp[0][i]=0;\\n\\n        }\\n        \\n        c=0;\\n        for(int j=0;j<m;j++)\\n            if(arr[j][0]==1){\\n                dp[j][0]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[j][0]=1;\\n            else dp[j][0]=0;\\n        \\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                \\n                if(arr[i][j]==1)\\n                    dp[i][j]=0;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                \\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n        \\n    }\\n\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        return uniquePaths(obstacleGrid.size(), obstacleGrid[0].size(), obstacleGrid);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056832,
                "title": "dynamic-programming-detailed-explanation-bottom-up",
                "content": "Hello Leetcoders, Hope you are doing well.\\n\\nLet\\'s solve this problem together.\\n\\n**Problem statement :** \\nWe have a matrix and a robot. Initially robot is located at top-left corner (0,0) of the matrix and robot want\\'s to go to destination bottom-right corner(m-1,n-1) index. Robot can only go right and bottom directions.\\n\\nFind total no. of ways robot can go from source to destination index.\\n\\nFollow-up : Their are some obstacles in the matrix which robot want\\'s to avoid during his journey.\\n\\n**Approach - backtracking :** \\n\\nData we have\\n* Source and destination defined.\\n* Next step is defined -> right or bottom\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        \\n        rb(grid, visited, m, n, 0, 0);\\n        \\n        return count;\\n    }\\n    \\n    private void rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return;\\n        \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            count++;\\n            return;\\n        }\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        rb(grid, visited, m, n, i, j+1); // go right\\n        rb(grid, visited, m, n, i+1, j); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n    }\\n}\\n```\\n\\nThis approach will show you TLE\\n![image](https://assets.leetcode.com/users/images/2c10b5f3-d4fa-4c0a-bb6f-6c7983a61a42_1653043386.22838.png)\\n\\n*Having TLE Means we have so many overlapping subproblem (which is obvious)*\\n\\n**Approach : Recursive + Memoization + Bottom-Up**\\n\\nStore the value for each position toi avoid overlapping-subproblem\\n\\n```\\n\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int dp[][] = new int[m][n]; // store values\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        dp[m-1][n-1] = 1; // memorize the calculated values\\n        \\n        rb(grid, visited, m, n, 0, 0, dp); // recursive call\\n        \\n        return dp[0][0];\\n    }\\n    \\n    private int rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j, int[][] dp) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return 0;\\n        \\n            \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            // count++;\\n            return dp[i][j];\\n        }\\n        \\n        // if current position is already processed\\n        if(dp[i][j] != 0) return dp[i][j];\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        int right = rb(grid, visited, m, n, i, j+1, dp); // go right\\n        int bottom = rb(grid, visited, m, n, i+1, j, dp); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n        \\n        dp[i][j] = right + bottom;\\n        return dp[i][j];\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/533d44ab-ca94-467a-86d6-c9e2237ca8fd_1653044000.3008218.png)\\n\\n\\nNow Interviewer will say can you optimize it more (currently we are using 2 arrays and stack space for recursive call)\\n\\n**Approach : DP + Iterative**\\n\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] arr) {\\n\\t\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        \\n        if(arr[0][0] == 1 || arr[m-1][n-1] == 1) return 0; // if there are an obstacle at source or destination position\\n        \\n        int dp[][] = new int[m][n]; // Store calculated values \\n        dp[0][0] = 1; // no. of ways we can start from starting positon \\n        \\n\\t\\t// update dp array border positons - first cell in every row\\n        for(int i=1; i<m; i++) {\\n            if(arr[i][0] == 0) dp[i][0] = dp[i-1][0];\\n            else dp[i][0] = 0;\\n        }\\n        \\n\\t\\t// update dp array border positons - first cell in every coloum\\n        for(int i=1; i<n; i++) {\\n            if(arr[0][i] == 0) dp[0][i] = dp[0][i-1];\\n            else dp[0][i] = 0;\\n        }\\n        \\n\\t\\t// Iterative processing \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                if(arr[i][j] == 1) dp[i][j] = 0; // if current cell have an obstacle\\n                else {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]; // no obstacle - total ways from top & left\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1]; // destination\\n    }\\n}\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8b1f2b0a-4aa8-4e4a-b116-28ac4c5242e4_1653044440.076339.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        \\n        rb(grid, visited, m, n, 0, 0);\\n        \\n        return count;\\n    }\\n    \\n    private void rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return;\\n        \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            count++;\\n            return;\\n        }\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        rb(grid, visited, m, n, i, j+1); // go right\\n        rb(grid, visited, m, n, i+1, j); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int dp[][] = new int[m][n]; // store values\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        dp[m-1][n-1] = 1; // memorize the calculated values\\n        \\n        rb(grid, visited, m, n, 0, 0, dp); // recursive call\\n        \\n        return dp[0][0];\\n    }\\n    \\n    private int rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j, int[][] dp) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return 0;\\n        \\n            \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            // count++;\\n            return dp[i][j];\\n        }\\n        \\n        // if current position is already processed\\n        if(dp[i][j] != 0) return dp[i][j];\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        int right = rb(grid, visited, m, n, i, j+1, dp); // go right\\n        int bottom = rb(grid, visited, m, n, i+1, j, dp); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n        \\n        dp[i][j] = right + bottom;\\n        return dp[i][j];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] arr) {\\n\\t\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        \\n        if(arr[0][0] == 1 || arr[m-1][n-1] == 1) return 0; // if there are an obstacle at source or destination position\\n        \\n        int dp[][] = new int[m][n]; // Store calculated values \\n        dp[0][0] = 1; // no. of ways we can start from starting positon \\n        \\n\\t\\t// update dp array border positons - first cell in every row\\n        for(int i=1; i<m; i++) {\\n            if(arr[i][0] == 0) dp[i][0] = dp[i-1][0];\\n            else dp[i][0] = 0;\\n        }\\n        \\n\\t\\t// update dp array border positons - first cell in every coloum\\n        for(int i=1; i<n; i++) {\\n            if(arr[0][i] == 0) dp[0][i] = dp[0][i-1];\\n            else dp[0][i] = 0;\\n        }\\n        \\n\\t\\t// Iterative processing \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                if(arr[i][j] == 1) dp[i][j] = 0; // if current cell have an obstacle\\n                else {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]; // no obstacle - total ways from top & left\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1]; // destination\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056661,
                "title": "c-memoization-simple-clean-and-concise-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int way = 0;\\n    int dfsTraversal(vector<vector<int>>& matrix,int i, int j,int row, int col, vector<vector<int>>&vec){\\n        \\n        if(i >= row or j >= col)\\n            return 0;\\n        if(matrix[i][j] == 1)\\n            return 0;\\n        if(i == row-1 and j == col-1){\\n            way++;  // finding the total way\\n            return 1;\\n        }\\n        if(vec[i][j] != 0){\\n            way += vec[i][j]; //adding the current state value to the way \\n            return vec[i][j];\\n        }\\n        else{\\n            return vec[i][j] = dfsTraversal(matrix, i+1, j, row, col, vec) + dfsTraversal(matrix, i, j+1, row, col, vec); // check down and right path\\n        }\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = obstacleGrid.size(), col = obstacleGrid[0].size();\\n        vector<vector<int>>vec(row, vector<int>(col,0));\\n        \\n        //best case -> when bottom-right corner is an obstacle\\n        if(obstacleGrid[row-1][col-1] == 1)\\n            return 0;\\n        \\n        dfsTraversal(obstacleGrid, 0, 0, row, col, vec);\\n        \\n        return way;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int way = 0;\\n    int dfsTraversal(vector<vector<int>>& matrix,int i, int j,int row, int col, vector<vector<int>>&vec){\\n        \\n        if(i >= row or j >= col)\\n            return 0;\\n        if(matrix[i][j] == 1)\\n            return 0;\\n        if(i == row-1 and j == col-1){\\n            way++;  // finding the total way\\n            return 1;\\n        }\\n        if(vec[i][j] != 0){\\n            way += vec[i][j]; //adding the current state value to the way \\n            return vec[i][j];\\n        }\\n        else{\\n            return vec[i][j] = dfsTraversal(matrix, i+1, j, row, col, vec) + dfsTraversal(matrix, i, j+1, row, col, vec); // check down and right path\\n        }\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = obstacleGrid.size(), col = obstacleGrid[0].size();\\n        vector<vector<int>>vec(row, vector<int>(col,0));\\n        \\n        //best case -> when bottom-right corner is an obstacle\\n        if(obstacleGrid[row-1][col-1] == 1)\\n            return 0;\\n        \\n        dfsTraversal(obstacleGrid, 0, 0, row, col, vec);\\n        \\n        return way;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2056511,
                "title": "c-unique-path-sol",
                "content": "class Solution {\\npublic:\\n    long long dp[101][101]={0};\\n    \\n    int dfs(int i,int j,vector<vector<int>>&grid)\\n    {\\n       if(i==0 && j==0) return 1;\\n        if(i<0||j<0||grid[i][j]==1) return 0;\\n        if(dp[i][j]!=0)\\n            return dp[i][j];\\n        int val=0;\\n         val+=dfs(i,j-1,grid);\\n         val+= dfs(i-1,j,grid);\\n        return dp[i][j]+=val;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==1|| grid[n-1][m-1]==1) return 0;\\n        if(n==1 && m==1) return 1;\\n        dfs(n-1,m-1,grid);\\n        return dp[n-1][m-1];\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long dp[101][101]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2056143,
                "title": "java-easy-unique-paths-ii-dp-solution-using-arraylist-and-matrices",
                "content": "**Solution:**\\n\\n\\tclass Solution {\\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint a=obstacleGrid.length;\\n\\t\\tint b=obstacleGrid[0].length;\\n\\t\\tint[][] c=new int[a][b];\\n\\t\\tif(obstacleGrid[a-1][b-1]==1 || obstacleGrid[0][0]==1){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t//Calling helper function\\n\\t\\thelper(obstacleGrid,0,0,c,a,b);\\n\\t\\tif(c[0][0]==-1){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t//Returning count from matrix c and row 0,,column 0\\n\\t\\treturn c[0][0];\\n\\t}\\n\\tpublic List<Integer> helper(int[][] obstacleGrid,int i,int j,int[][] c,int a,int b){\\n\\t\\tList<Integer> a2;\\n\\t\\tList<Integer> a3;\\n\\t\\tint d;\\n\\t\\t//Checking have we reach end position\\n\\t\\tif(i==a-1 && j==b-1){\\n\\t\\t\\tc[i][j]=1;\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(1);\\n\\t\\t\\ta2.add(1);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//Checking if we are going out of bound or checking if no solution\\n\\t\\tif(i>=a || j>=b || c[i][j]==-1){\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//If obstacle found backtracking marking that position as -1 in matrix c\\n\\t\\tif(obstacleGrid[i][j]==1){\\n\\t\\t\\tc[i][j]=-1;\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//If count already found return count\\n\\t\\tif(c[i][j]!=-1 && c[i][j]!=0){\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(1);\\n\\t\\t\\ta2.add(c[i][j]);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//Calling helper going to bottom\\n\\t\\ta2=helper(obstacleGrid,i+1,j,c,a,b);\\n\\t\\t//Calling helper going to right\\n\\t\\ta3=helper(obstacleGrid,i,j+1,c,a,b);\\n\\t\\t//Checking if atleast onefunction call leads to solution or not\\n\\t\\tif(a2.get(0)==1 || a3.get(0)==1){\\n\\t\\t\\tList<Integer> a4=new ArrayList<Integer>();\\n\\t\\t\\ta4.add(1);\\n\\t\\t\\t//Doing addition of both the function call count and storing it in matrix \\n\\t\\t\\td=a2.get(1)+a3.get(1);\\n\\t\\t\\ta4.add(d);\\n\\t\\t\\tc[i][j]=d;\\n\\t\\t\\treturn a4;\\n\\t\\t}\\n\\t\\t//If  no solution marking that position in matrix c as -1\\n\\t\\tc[i][j]=-1;\\n\\t\\ta2=new ArrayList<Integer>();\\n\\t\\ta2.add(0);\\n\\t\\ta2.add(0);\\n\\t\\treturn a2;\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint a=obstacleGrid.length;\\n\\t\\tint b=obstacleGrid[0].length;\\n\\t\\tint[][] c=new int[a][b];\\n\\t\\tif(obstacleGrid[a-1][b-1]==1 || obstacleGrid[0][0]==1){\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2055945,
                "title": "4ms-o-n-m-solution-using-memoization-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid , int x , int y)\\n    {\\n        if(x<0 || y<0)\\n        {\\n            return 0;\\n        }\\n        if(obstacleGrid[x][y] == 1)\\n            return 0;\\n        if(x == 0 && y==0)\\n            return 1;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        int ans = 0;\\n        ans+=solve(obstacleGrid , x - 1 , y);\\n        ans+=solve(obstacleGrid , x , y-1);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        if(obstacleGrid[n-1][m-1] == 1 || obstacleGrid[0][0] == 1)\\n            return 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid , n-1 , m-1);\\n    }\\n};\\n```\\n```\\nTime Complexity ---->  O(N*M)\\nSpace Complexity ----> O(N*M)\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid , int x , int y)\\n    {\\n        if(x<0 || y<0)\\n        {\\n            return 0;\\n        }\\n        if(obstacleGrid[x][y] == 1)\\n            return 0;\\n        if(x == 0 && y==0)\\n            return 1;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        int ans = 0;\\n        ans+=solve(obstacleGrid , x - 1 , y);\\n        ans+=solve(obstacleGrid , x , y-1);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        if(obstacleGrid[n-1][m-1] == 1 || obstacleGrid[0][0] == 1)\\n            return 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid , n-1 , m-1);\\n    }\\n};\\n```\n```\\nTime Complexity ---->  O(N*M)\\nSpace Complexity ----> O(N*M)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722265,
                "title": "c-no-extra-space-used-space-efficient-dp",
                "content": "```\\n// Use dynamic Programming, if the grid at i,j position contains obstacle, turn it to 0\\n// And for the rest grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\\n\\n// You don\\'t even have to make new 2D vector, use the same obstacleGrid vector\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0] == 1)\\n            return 0;\\n        \\n        int i = 0, j = 1;\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        while(i < m && obstacleGrid[i][0] != 1) {\\n            obstacleGrid[i][0] = 1;\\n            i++;\\n        }\\n        while(i < m) {\\n            obstacleGrid[i][0] = 0;\\n            i++;\\n        }\\n        \\n        while(j < n && obstacleGrid[0][j] != 1) {\\n            obstacleGrid[0][j] = 1;\\n            j++;\\n        }\\n        while(j < n) {\\n            obstacleGrid[0][j] = 0;\\n            j++;\\n        }\\n        \\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = 0;\\n                else\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n        }\\n    \\n        return obstacleGrid[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// Use dynamic Programming, if the grid at i,j position contains obstacle, turn it to 0\\n// And for the rest grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\\n\\n// You don\\'t even have to make new 2D vector, use the same obstacleGrid vector\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0] == 1)\\n            return 0;\\n        \\n        int i = 0, j = 1;\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        while(i < m && obstacleGrid[i][0] != 1) {\\n            obstacleGrid[i][0] = 1;\\n            i++;\\n        }\\n        while(i < m) {\\n            obstacleGrid[i][0] = 0;\\n            i++;\\n        }\\n        \\n        while(j < n && obstacleGrid[0][j] != 1) {\\n            obstacleGrid[0][j] = 1;\\n            j++;\\n        }\\n        while(j < n) {\\n            obstacleGrid[0][j] = 0;\\n            j++;\\n        }\\n        \\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = 0;\\n                else\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n        }\\n    \\n        return obstacleGrid[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719600,
                "title": "best-c-code-using-hashmap-memo-world-best-solution-200-fast",
                "content": "class Solution {\\npublic:\\n         int need ( int  m,int n, int row, int col,unordered_map<string ,int>&mp,vector<vector<int>>& obstacleGrid)\\n     {\\n        \\n          if(row>=m || col >=n)\\n          {\\n               return 0 ; \\n          }\\n                if(obstacleGrid[row][col]==1)\\n             \\n             {\\n                   return 0 ; \\n              }\\n           \\n          if(row==m-1 && col ==n-1)\\n          {\\n               return 1 ; \\n          }\\n             \\n      \\n      string currentKey = to_string(row) + \"_\" + to_string(col);\\n            \\n        if(mp.find(currentKey)!=mp.end()){\\n           return mp[currentKey];\\n        }\\n         \\n          int need1 = need(m,n,row+1,col,mp,obstacleGrid);\\n          int need2 = need(m,n, row,col+1,mp,obstacleGrid);\\n                      mp[currentKey]=need1+need2;\\n            return mp[currentKey];\\n         \\n         \\n     }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n         int m = obstacleGrid.size();\\n         int n= obstacleGrid[0].size();\\n        unordered_map<string ,int>mp;\\n          return need (m,n,0,0,mp,obstacleGrid)  ; \\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n         int need ( int  m,int n, int row, int col,unordered_map<string ,int>&mp,vector<vector<int>>& obstacleGrid)\\n     {\\n        \\n          if(row>=m || col >=n)\\n          {\\n               return 0 ; \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1578150,
                "title": "easy-to-understand-in-c-amazing-approach",
                "content": "class Solution \\n{\\npublic:\\n\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a >= m || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        } \\n        if() {\\n            dp[a][b] = path(obstacleGrid, m, n, a+1, b, dp) + path(obstacleGrid, m, n, a, b+1, dp);\\n        }\\n        return dp[a][b];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return path(obstacleGrid, m, n, 0, 0, dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a >= m || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1535030,
                "title": "python-sc-o-1-concise-dp-with-explanation",
                "content": "### Introduction\\n\\nStarting from the top left corner of the grid, find the number of unique ways one can traverse either down or right to reach the bottom right corner while avoiding any obstacles.\\n\\n---\\n\\n### Intuition\\n\\nAt each coordinate ```(x, y)``` in the grid, we have the following rule:\\n\\n- If ```obstacleGrid[x][y] == 1```, there cannot be any paths to that coordinate since there is an obstacle there. Hence, we immediately know that **the number of paths for that coordinate is 0**.\\n- Otherwise, since we can only move right or down, a path that travels through ```(x, y)``` must come either from ```(x-1, y)``` (if it exists) or ```(x, y-1)``` (if it exists). Hence, the number of paths that travel through ```(x, y)``` must be **the sum of the number of paths that travel through ```(x-1, y)``` and ```(x, y-1)```**.\\n\\nThis recursive calculation of the number of paths is the reason why DP is useful for this problem. Moreover, we can afford to utilise the given ```obstacleGrid``` array and use O(1) auxiliary space. This is because **once we have determined the number of paths to ```(x, y)```, we will use that calculated value instead of the original value in future calculations**.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        for i, j in product(range(len(obstacleGrid)), range(len(obstacleGrid[0]))):  # you can split this into two for loops if you want\\n            \"\"\"\\n            If obstacleGrid[i][j] is an obstacle, its number of paths is immediately 0.\\n            Otherwise, the number of paths is:\\n              - The number of paths to (x-1, y), if it exists;\\n              - Plus the number of paths to (x, y-1), if it exists;\\n              - Handling the starting point by setting it to 1\\n            \"\"\"\\n            obstacleGrid[i][j] = 0 if obstacleGrid[i][j] else \\\\\\n                                 (obstacleGrid[i-1][j] if i > 0 else 0) + \\\\\\n                                 (obstacleGrid[i][j-1] if j > 0 else 0) + \\\\\\n                                 (i == 0 and j == 0)                       \\n        return obstacleGrid[-1][-1]\\n```\\n\\n**TC: O(mn)**, where `m` is the length of the grid and `n` is the breadth of the grid, since each element in the grid is accessed once.\\n**SC: O(1)**, since we modify the given array in-place.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```(x, y)```\n```obstacleGrid[x][y] == 1```\n```(x, y)```\n```(x-1, y)```\n```(x, y-1)```\n```(x, y)```\n```(x-1, y)```\n```(x, y-1)```\n```obstacleGrid```\n```(x, y)```\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        for i, j in product(range(len(obstacleGrid)), range(len(obstacleGrid[0]))):  # you can split this into two for loops if you want\\n            \"\"\"\\n            If obstacleGrid[i][j] is an obstacle, its number of paths is immediately 0.\\n            Otherwise, the number of paths is:\\n              - The number of paths to (x-1, y), if it exists;\\n              - Plus the number of paths to (x, y-1), if it exists;\\n              - Handling the starting point by setting it to 1\\n            \"\"\"\\n            obstacleGrid[i][j] = 0 if obstacleGrid[i][j] else \\\\\\n                                 (obstacleGrid[i-1][j] if i > 0 else 0) + \\\\\\n                                 (obstacleGrid[i][j-1] if j > 0 else 0) + \\\\\\n                                 (i == 0 and j == 0)                       \\n        return obstacleGrid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331225,
                "title": "c-recursive-bottom-up-dp",
                "content": "**Recursive Solution**\\nthis solution will give you TLE\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int ans = 0;\\n        solve(0,0,a,ans);\\n        return ans;\\n    }\\n    \\n    void solve(int i,int j,vector<vector<int>>&a,int &ans)\\n    {\\n        if(i>=a.size()||j>=a[0].size()||a[i][j]==1)\\n        {\\n            return;\\n        }\\n        if(i==a.size()-1&&j==a[0].size()-1)\\n        {\\n            ans++;\\n        }\\n        solve(i+1,j,a,ans);\\n        solve(i,j+1,a,ans);\\n    }\\n};\\n```\\n\\n**Bottom-Up DP**\\n4ms running time on leetcode server\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++)\\n            if(a[i][0]==1)\\n                break;\\n            else\\n                dp[i][0] = 1;\\n        \\n        for(int j=0;j<m;j++)\\n            if(a[0][j]==1)\\n                break;\\n            else\\n                dp[0][j] = 1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                if(a[i][j]!=1)\\n                {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```\\n\\n*If find helpful please upvote it* **:)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int ans = 0;\\n        solve(0,0,a,ans);\\n        return ans;\\n    }\\n    \\n    void solve(int i,int j,vector<vector<int>>&a,int &ans)\\n    {\\n        if(i>=a.size()||j>=a[0].size()||a[i][j]==1)\\n        {\\n            return;\\n        }\\n        if(i==a.size()-1&&j==a[0].size()-1)\\n        {\\n            ans++;\\n        }\\n        solve(i+1,j,a,ans);\\n        solve(i,j+1,a,ans);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++)\\n            if(a[i][0]==1)\\n                break;\\n            else\\n                dp[i][0] = 1;\\n        \\n        for(int j=0;j<m;j++)\\n            if(a[0][j]==1)\\n                break;\\n            else\\n                dp[0][j] = 1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                if(a[i][j]!=1)\\n                {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318178,
                "title": "c-tle-ac-using-dp-memoization",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        } \\n        else {\\n            dp[a][b] = path(obstacleGrid, m, n, a+1, b, dp) + path(obstacleGrid, m, n, a, b+1, dp);\\n        }\\n        return dp[a][b];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(obstacleGrid, m, n, a+1, b) + path(obstacleGrid, m, n, a, b+1);\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        } \\n        else {\\n            dp[a][b] = path(obstacleGrid, m, n, a+1, b, dp) + path(obstacleGrid, m, n, a, b+1, dp);\\n        }\\n        return dp[a][b];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(obstacleGrid, m, n, a+1, b) + path(obstacleGrid, m, n, a, b+1);\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232747,
                "title": "dp-o-1-space-js-solution",
                "content": "```\\n/*\\nDP\\n\\nSolution:\\n1. If there is an obstacle at the starting point (0,0) or the target point (m-1,n-1), there is zero path because we\\ncan\\'t either start or reach the target. \\n2. Else,...Let\\'s suppose we have a m x n table, where table[row][col] is the number of possible paths from (row,col) to the\\nbottom-right. table[row][col] = (grid[row][col] === 0) ? table[row][col+1] + table[row+1][col] : 1.\\nIf current entry has an obstacle, there is no path from this entry. Else, the number of paths is that from the right + that from the bottom.\\n3. We certainly know that grid[m-1][n-1] has a path of 1. Hence, this is our base case and therefore we will iterate through grid backwards and record numer of paths to the given table accordingly. We don\\'t need to initalise a new table.\\nWhy? Since we traverse backwards, we don\\'t need the value of traversed entry once it is used. Hence, we will replace its\\nentry with the number of possible paths so that upcoming entries can use it for computation. \\nAt the end of iteration, the answer is obstacleGrid[0][0].\\n\\nImportant note: for entries in the last row or the last column, row+1 or col+1 will be out of bounds. We will consider entries out of bounds zero because it is not possible to reach the bottom-right once we go past its row or column.\\n*/\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (obstacleGrid.length === 0 || obstacleGrid[0].length === 0) {\\n        return 0;\\n    }\\n    let height = obstacleGrid.length, width = obstacleGrid[0].length;\\n    if (obstacleGrid[0][0] === 1 || obstacleGrid[height-1][width-1] === 1) {\\n        return 0;\\n    }\\n    for (let row = height-1; row >= 0; row--) {\\n        for (let col = width-1; col >= 0; col--) {\\n            if (row === height-1 && col === width-1) {\\n                obstacleGrid[row][col] = 1;\\n                continue;\\n            }\\n            let right = col < width-1 ? obstacleGrid[row][col+1] : 0;\\n            let bottom = row < height-1 ? obstacleGrid[row+1][col] : 0;\\n            obstacleGrid[row][col] = (obstacleGrid[row][col] === 0) ? right + bottom : 0;\\n        }\\n    }\\n    return obstacleGrid[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nDP\\n\\nSolution:\\n1. If there is an obstacle at the starting point (0,0) or the target point (m-1,n-1), there is zero path because we\\ncan\\'t either start or reach the target. \\n2. Else,...Let\\'s suppose we have a m x n table, where table[row][col] is the number of possible paths from (row,col) to the\\nbottom-right. table[row][col] = (grid[row][col] === 0) ? table[row][col+1] + table[row+1][col] : 1.\\nIf current entry has an obstacle, there is no path from this entry. Else, the number of paths is that from the right + that from the bottom.\\n3. We certainly know that grid[m-1][n-1] has a path of 1. Hence, this is our base case and therefore we will iterate through grid backwards and record numer of paths to the given table accordingly. We don\\'t need to initalise a new table.\\nWhy? Since we traverse backwards, we don\\'t need the value of traversed entry once it is used. Hence, we will replace its\\nentry with the number of possible paths so that upcoming entries can use it for computation. \\nAt the end of iteration, the answer is obstacleGrid[0][0].\\n\\nImportant note: for entries in the last row or the last column, row+1 or col+1 will be out of bounds. We will consider entries out of bounds zero because it is not possible to reach the bottom-right once we go past its row or column.\\n*/\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (obstacleGrid.length === 0 || obstacleGrid[0].length === 0) {\\n        return 0;\\n    }\\n    let height = obstacleGrid.length, width = obstacleGrid[0].length;\\n    if (obstacleGrid[0][0] === 1 || obstacleGrid[height-1][width-1] === 1) {\\n        return 0;\\n    }\\n    for (let row = height-1; row >= 0; row--) {\\n        for (let col = width-1; col >= 0; col--) {\\n            if (row === height-1 && col === width-1) {\\n                obstacleGrid[row][col] = 1;\\n                continue;\\n            }\\n            let right = col < width-1 ? obstacleGrid[row][col+1] : 0;\\n            let bottom = row < height-1 ? obstacleGrid[row+1][col] : 0;\\n            obstacleGrid[row][col] = (obstacleGrid[row][col] === 0) ? right + bottom : 0;\\n        }\\n    }\\n    return obstacleGrid[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225230,
                "title": "short-python3-memoization-solution",
                "content": "Clearly in this quesion we can go either one step to the right or one step down so we create two separate recursive calls, where one handles right side movements [paths(i,j+1)]  and the other handles bottom movements [paths(i+1,j)]. This process is repeated until it:\\n1) Exceeds size of the matrix rows or columns\\n2) It encounters an obstacle which is in this case a 1\\n\\nwhen the above two conditions are met we return a : \"0\"\\n\\nOtherwise if we manage to reach the destination i.e (i==row-1 and j==col-1) we return a : \"1\"\\n\\nThe above returned values are summed up in a variable c which hold the total no of ways we can reach the destination without meeting an obstacle.\\n\\nFinally, the solution is memoized by storing the results obtained upto a point say (i,j) in a dictionary.\\n\\nclass Solution:\\n    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        row=len(grid)\\n        col=len(grid[0])\\n        dp={}\\n        \\n        def paths(i,j):\\n            \\n            if(i>=row or j>=col):\\n                return 0\\n            \\n            if(grid[i][j]==1):\\n                return 0\\n            if(i==row-1 and j==col-1):\\n                return 1\\n            \\n            if((i,j) in dp):\\n                return dp[(i,j)]\\n            \\n            c=0\\n            \\n            c+=paths(i,j+1)+paths(i+1,j)\\n            \\n            dp[(i,j)]=c\\n            \\n            return c\\n        \\n        res=paths(0,0)\\n        \\n        return(res)",
                "solutionTags": [],
                "code": "class Solution:\\n    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        row=len(grid)\\n        col=len(grid[0])\\n        dp={}",
                "codeTag": "Java"
            },
            {
                "id": 1151303,
                "title": "c-7-line-dp-explained-o-n-space-not-changing-obstaclegrid",
                "content": "First, we can use an (m+1) \\\\* (n+1) memo grid initialized with zero to solve the problem. This uses O(mn) space.\\n\\n(m+1) \\\\* (n+1) creates an extra row and column as shown below (circled in green). Using DP, we build from i=1,j=1 and stop at i=m,j=n (circled in red). If there is no obstacle, `grid[i][j] = grid[i-1][j] + grid[i][j-1`.\\n\\nNote that we must assign `grid[0][1]` to `1` so that `grid[1][1]` (the robot starting point) is computed as `1` (assuming `obstacleGrid[0][0]` is `0`).\\n\\n![image](https://assets.leetcode.com/users/images/cb4c390a-9487-45d9-b1ac-c5667962f351_1618046825.5591438.jpeg)\\n\\n```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<vector<int>> grid(m+1, vector<int>(n+1,0));\\n\\tgrid[0][1] = 1;\\n\\tfor (int i=1; i<m+1;++i)\\n\\t\\tfor (int j=1; j<n+1;++j)\\n\\t\\t\\tif (obstacleGrid[i-1][j-1] != 1)\\n\\t\\t\\t\\tgrid[i][j] = grid[i-1][j] + grid[i][j-1];\\n\\treturn grid[m][n];\\n}\\n```\\n\\nSimilar to problem 62, we can reduce the (m+1) \\\\* (n+1) memo grid to an **n+1** memo vector. This uses O(n) space. Again, we must assign `vec[1]` to `1` .\\n\\n```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<int> vec(n+1,0);\\n\\tvec[1]=1;\\n\\tfor (int i=0;i<m;++i)\\n\\t\\tfor (int j=1;j<n+1;++j)\\n\\t\\t\\tvec[j] = obstacleGrid[i][j-1] == 1 ? 0 : vec[j]+vec[j-1];\\n\\treturn vec[n];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<vector<int>> grid(m+1, vector<int>(n+1,0));\\n\\tgrid[0][1] = 1;\\n\\tfor (int i=1; i<m+1;++i)\\n\\t\\tfor (int j=1; j<n+1;++j)\\n\\t\\t\\tif (obstacleGrid[i-1][j-1] != 1)\\n\\t\\t\\t\\tgrid[i][j] = grid[i-1][j] + grid[i][j-1];\\n\\treturn grid[m][n];\\n}\\n```\n```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<int> vec(n+1,0);\\n\\tvec[1]=1;\\n\\tfor (int i=0;i<m;++i)\\n\\t\\tfor (int j=1;j<n+1;++j)\\n\\t\\t\\tvec[j] = obstacleGrid[i][j-1] == 1 ? 0 : vec[j]+vec[j-1];\\n\\treturn vec[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627199,
                "title": "java-solution-beats-100-with-dfs-memoization",
                "content": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\t\\t// check if there is no block at ent point\\n        if (obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length - 1] == 1) {\\n            return 0;\\n        }\\n\\t\\t// mem[i][j] is the count of paths from (i, j) to end point\\n        int[][] mem = new int[obstacleGrid.length][obstacleGrid[0].length];   \\n        for (int[] row : mem) {\\n            Arrays.fill(row, -1);            \\n        }\\n        return dfs(obstacleGrid, 0, 0, mem);\\n    }\\n    \\n    private int dfs(int[][] a, int i, int j, int[][] mem) {\\n        if (i == a.length - 1 && j == a[0].length - 1) {\\n            return 1;\\n        }\\n        if (i >= a.length || j >= a[0].length || a[i][j] == 1) {\\n            return 0;\\n        }\\n        \\n        int count = mem[i][j];\\n        if (mem[i][j] == -1) {\\n            count = dfs(a, i + 1, j, mem) + dfs(a, i, j + 1, mem);\\n            mem[i][j] = count;            \\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\nTime: O(m * n) since we will visit some point at most twice(once from the point above it and once from the point on its left)\\n\\nSpace: O(m * n) since we need a 2d array mem, the recursion depth is at most m + n which is less than m * n when m >= 2, n >= 2",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\t\\t// check if there is no block at ent point\\n        if (obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length - 1] == 1) {\\n            return 0;\\n        }\\n\\t\\t// mem[i][j] is the count of paths from (i, j) to end point\\n        int[][] mem = new int[obstacleGrid.length][obstacleGrid[0].length];   \\n        for (int[] row : mem) {\\n            Arrays.fill(row, -1);            \\n        }\\n        return dfs(obstacleGrid, 0, 0, mem);\\n    }\\n    \\n    private int dfs(int[][] a, int i, int j, int[][] mem) {\\n        if (i == a.length - 1 && j == a[0].length - 1) {\\n            return 1;\\n        }\\n        if (i >= a.length || j >= a[0].length || a[i][j] == 1) {\\n            return 0;\\n        }\\n        \\n        int count = mem[i][j];\\n        if (mem[i][j] == -1) {\\n            count = dfs(a, i + 1, j, mem) + dfs(a, i, j + 1, mem);\\n            mem[i][j] = count;            \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562340,
                "title": "python-dfs-memoization",
                "content": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid:\\n            return 0\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1]:\\n            return 0\\n        \\n        mem = dict()\\n        return self.findPaths(0, 0, obstacleGrid, mem)\\n    \\n    \\n    \\n    def findPaths(self, i, j, grid, mem):\\n        if (i,j) in mem:\\n            return mem[(i,j)]\\n        \\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return 1\\n        \\n        c = 0\\n        for x, y in [(i+1,j), (i, j+1)]:\\n            if x < len(grid) and y < len(grid[0]) and not grid[x][y]:\\n                c += self.findPaths(x, y, grid, mem)\\n        \\n        mem[(i,j)] = c\\n        return c\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid:\\n            return 0\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1]:\\n            return 0\\n        \\n        mem = dict()\\n        return self.findPaths(0, 0, obstacleGrid, mem)\\n    \\n    \\n    \\n    def findPaths(self, i, j, grid, mem):\\n        if (i,j) in mem:\\n            return mem[(i,j)]\\n        \\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return 1\\n        \\n        c = 0\\n        for x, y in [(i+1,j), (i, j+1)]:\\n            if x < len(grid) and y < len(grid[0]) and not grid[x][y]:\\n                c += self.findPaths(x, y, grid, mem)\\n        \\n        mem[(i,j)] = c\\n        return c\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 488683,
                "title": "javascript-dynamic-programming",
                "content": "```js\\nfunction uniquePathsWithObstacles(obstacleGrid) {\\n  if (obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] === 1) {\\n    return 0;\\n  }\\n  let dp = new Array(obstacleGrid.length)\\n    .fill()\\n    .map(row => new Array(obstacleGrid[0].length).fill(0));\\n  dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;\\n  for (let i = 0; i < obstacleGrid.length; i++) {\\n    for (let j = 0; j < obstacleGrid[0].length; j++) {\\n      let up = i - 1 >= 0 && obstacleGrid[i - 1][j] !== 1 ? dp[i - 1][j] : 0;\\n      let left = j - 1 >= 0 && obstacleGrid[i][j - 1] !== 1 ? dp[i][j - 1] : 0;\\n      dp[i][j] += +up + left;\\n    }\\n  }\\n  return dp[dp.length - 1][dp[0].length - 1];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```js\\nfunction uniquePathsWithObstacles(obstacleGrid) {\\n  if (obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] === 1) {\\n    return 0;\\n  }\\n  let dp = new Array(obstacleGrid.length)\\n    .fill()\\n    .map(row => new Array(obstacleGrid[0].length).fill(0));\\n  dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;\\n  for (let i = 0; i < obstacleGrid.length; i++) {\\n    for (let j = 0; j < obstacleGrid[0].length; j++) {\\n      let up = i - 1 >= 0 && obstacleGrid[i - 1][j] !== 1 ? dp[i - 1][j] : 0;\\n      let left = j - 1 >= 0 && obstacleGrid[i][j - 1] !== 1 ? dp[i][j - 1] : 0;\\n      dp[i][j] += +up + left;\\n    }\\n  }\\n  return dp[dp.length - 1][dp[0].length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391947,
                "title": "integer-overflow",
                "content": "Not sure how to avoid integer overflow as I have even tried solution provided by leetcode\\n\\nLeetcode solution is in Java and in C++ when I run below code it genrated run time failure\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void print(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    cout << \"x \";\\n                    continue;\\n                }\\n                cout << obstacleGrid[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        cout << \"========================\" << endl;\\n    }\\n        \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        cout << \"x = \" << x << \", y = \" << y << endl;\\n        \\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 1) return 0;\\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 0) return 1;        \\n                \\n        if (obstacleGrid[x - 1][y - 1] == 1 ||\\n            obstacleGrid[0][0] == 1) return 0;\\n        \\n        print(obstacleGrid);\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                    continue;\\n                }\\n                \\n                if (i == 0) {\\n                    if (j == 0) {\\n                        obstacleGrid[i][j] = 1;\\n                    } else if (obstacleGrid[i][j] == 1) {\\n                        obstacleGrid[i][j] = 0;\\n                    } else {\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1];\\n                    }\\n                    continue;\\n                }\\n                \\n                if (j == 0) {\\n                    if (obstacleGrid[i][j] == 0) {\\n                        obstacleGrid[i][j] = obstacleGrid[i-1][j];    \\n                    } else if (obstacleGrid[i][j] == 1){\\n                        obstacleGrid[i][j] = 0;\\n                    }\\n                    continue;\\n                }                \\n                    \\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n            print(obstacleGrid);\\n        }\\n        \\n        \\n        return obstacleGrid[x - 1][y - 1];\\n        \\n        \\n    }\\n};\\n\\n\\n0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \\n0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 \\n1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 \\n0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 \\n0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 \\n1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 \\n0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 \\n0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \\n1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 1 \\n0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 \\n0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 \\n0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 \\n1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 1 \\n0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 1 \\n1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 \\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 \\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void print(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    cout << \"x \";\\n                    continue;\\n                }\\n                cout << obstacleGrid[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        cout << \"========================\" << endl;\\n    }\\n        \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        cout << \"x = \" << x << \", y = \" << y << endl;\\n        \\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 1) return 0;\\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 0) return 1;        \\n                \\n        if (obstacleGrid[x - 1][y - 1] == 1 ||\\n            obstacleGrid[0][0] == 1) return 0;\\n        \\n        print(obstacleGrid);\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                    continue;\\n                }\\n                \\n                if (i == 0) {\\n                    if (j == 0) {\\n                        obstacleGrid[i][j] = 1;\\n                    } else if (obstacleGrid[i][j] == 1) {\\n                        obstacleGrid[i][j] = 0;\\n                    } else {\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1];\\n                    }\\n                    continue;\\n                }\\n                \\n                if (j == 0) {\\n                    if (obstacleGrid[i][j] == 0) {\\n                        obstacleGrid[i][j] = obstacleGrid[i-1][j];    \\n                    } else if (obstacleGrid[i][j] == 1){\\n                        obstacleGrid[i][j] = 0;\\n                    }\\n                    continue;\\n                }                \\n                    \\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n            print(obstacleGrid);\\n        }\\n        \\n        \\n        return obstacleGrid[x - 1][y - 1];\\n        \\n        \\n    }\\n};\\n\\n\\n0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \\n0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 \\n1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 \\n0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 \\n0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 \\n1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 \\n0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 \\n0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \\n1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 1 \\n0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 \\n0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 \\n0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 \\n1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 1 \\n0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 1 \\n1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 \\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 \\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 391913,
                "title": "python-two-approaches-dfs-and-dp-with-comments-and-explanation",
                "content": "# Approach 1 - DFS - TLE (27/34) TEST CASES #\\n**Idea:**\\nSince the movement in the grid is restricted only to moving right and down, the grid can be thought of - represented as- a DAG in which each node has at max two childs (or each cell has two neighbouring cells to visit). With this analysis in mind, this problem reduces to something very similar to **Print all paths of binary tree** \\n\\nWe can use an implicit stack to run a basic DFS algorithm on the DAG\\'s root (root = top-left cell in the grid aka matrix[0][0]. A counter is mainatined to keep track of the paths every time we reach the target cell (or the leaf node, if you prefer the BT analogy). We know we have reached the target (leaf node) if the x,y coordinates are equal to m,n. \\n\\n- Note:\\n\\t-  In a basic DFS on a graph, most implementations require a visited set to make sure we\\'re not going around in circles as we traverse the graph. However, this is not necessary in this problem because our graph is:\\n\\t\\t 1) Directed \\n \\t\\t\\t  - because movement is restricted to **(right, down in the grid)** which is **synonmoys to ( traversing once to the left child and then to the right child in a BT)**\\n\\t\\t2) Acyclic:\\n\\t\\t\\t- same reason (links are one-way)\\n\\t\\t3) Binary \\n\\t\\t\\t- Because only two direction out of possible 4 are allowed\\n\\t\\t\\t\\n\\t- In summary, our graph is not a graph, it\\'s a binary tree. And we know that traversal will always moving down the tree. so we don\\'t have to worry about encountring the same node (or cell) again.*\\n\\n\\n**Time Complexity :**\\n- O(num) where num is the number of nodes in the matrix \\n\\t- *in reality O(num*2) --> because for each node, there are 2 neighbours that we need to iterate over but howevevr, asymptotically boils down to O(num)\\n\\n- Or O(N*M) where N and M are the dimesnions of the matrix\\n\\n**Space Complexity:**\\n- O(num) where num is the number of nodes in the matrix because we had to use a stack\\n- Or O(N*M) where N and M are the dimensions of the grid\\n\\n\\n**Code**\\n\\n```\\n        m = obstacleGrid\\n        if not m or len(m) == 0 or m==[[]] or m[0][0] == 1:\\n            return 0\\n        res = []\\n        count = 0\\n        stack = [((0,0), m[0][0], [(0,0)])]\\n        dirs = [(1,0), (0,1)] # only move down the tree\\n        while stack:\\n            print(stack)\\n            coor, node, path = stack.pop()\\n            x, y = coor\\n            \\n            if x == len(m)-1 and y == len(m[0])-1: # leaf - bottom right\\n                count += 1\\n                res.append(path)\\n            \\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                # check if within bounds:\\n                if newX >= 0 and newX <= len(m)-1 and newY >= 0 and newY <= len(m[0])-1:\\n                    # check if no obstacle:\\n                    if m[newX][newY] != 1:\\n                        # append to stack\\n                        stack.append(((newX, newY), m[newX][newY], path+[(newX, newY)]))\\n        # print(res)\\n        return count\\n\\n```\\n\\n# Approach 2 - Dynamic Programming #\\n\\n**Leetcode Solution**\\n\\n**Time complexity**\\n- O(num) where is the num of nodes in the matrix (num of cells)\\n\\t- Each node/cell is visited only once\\n-  Or O(N*M) where N and M are the grid\\'s dimensions\\n              \\n**Space compleixty**\\n- O(1) in=place modification\\n\\n**Code**\\n```\\n\\t\\tm = obstacleGrid\\n        if not m or m == [[]] or len(m)==0 or m[0][0] == 1:\\n            return 0\\n        \\n        # start:\\n        m[0][0] = 1\\n        \\n        # top row:\\n        for i in range(1, len(m[0])):\\n            if m[0][i] == 1: # obstacle\\n                m[0][i] = 0\\n            else:\\n                m[0][i] = m[0][i-1] # previous cell (cell to the left)\\n                \\n        # left most col:\\n        for i in range(1, len(m)):\\n            if m[i][0] == 1: # obstacle\\n                m[i][0] = 0\\n            else:\\n                m[i][0] = m[i-1][0] # previous cell (cell to the top)\\n                \\n        # rest of the grid:\\n        for i in range(1, len(m)):\\n            for j in range(1, len(m[0])):\\n                if m[i][j] == 1:\\n                    m[i][j] = 0\\n                else:\\n                    m[i][j] = m[i-1][j] + m[i][j-1]\\n                    \\n        return m[len(m)-1][len(m[0])-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n        m = obstacleGrid\\n        if not m or len(m) == 0 or m==[[]] or m[0][0] == 1:\\n            return 0\\n        res = []\\n        count = 0\\n        stack = [((0,0), m[0][0], [(0,0)])]\\n        dirs = [(1,0), (0,1)] # only move down the tree\\n        while stack:\\n            print(stack)\\n            coor, node, path = stack.pop()\\n            x, y = coor\\n            \\n            if x == len(m)-1 and y == len(m[0])-1: # leaf - bottom right\\n                count += 1\\n                res.append(path)\\n            \\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                # check if within bounds:\\n                if newX >= 0 and newX <= len(m)-1 and newY >= 0 and newY <= len(m[0])-1:\\n                    # check if no obstacle:\\n                    if m[newX][newY] != 1:\\n                        # append to stack\\n                        stack.append(((newX, newY), m[newX][newY], path+[(newX, newY)]))\\n        # print(res)\\n        return count\\n\\n```\n```\\n\\t\\tm = obstacleGrid\\n        if not m or m == [[]] or len(m)==0 or m[0][0] == 1:\\n            return 0\\n        \\n        # start:\\n        m[0][0] = 1\\n        \\n        # top row:\\n        for i in range(1, len(m[0])):\\n            if m[0][i] == 1: # obstacle\\n                m[0][i] = 0\\n            else:\\n                m[0][i] = m[0][i-1] # previous cell (cell to the left)\\n                \\n        # left most col:\\n        for i in range(1, len(m)):\\n            if m[i][0] == 1: # obstacle\\n                m[i][0] = 0\\n            else:\\n                m[i][0] = m[i-1][0] # previous cell (cell to the top)\\n                \\n        # rest of the grid:\\n        for i in range(1, len(m)):\\n            for j in range(1, len(m[0])):\\n                if m[i][j] == 1:\\n                    m[i][j] = 0\\n                else:\\n                    m[i][j] = m[i-1][j] + m[i][j-1]\\n                    \\n        return m[len(m)-1][len(m[0])-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 370976,
                "title": "c-solution-beats-100-percent-time-and-memory",
                "content": "class Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1)return 0;\\n        \\n        vector<unsigned int> dp(n);\\n \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(obstacleGrid[i][j]) dp[j] = 0;\\n                else if(i == 0 && j == 0) dp[j] = 1;\\n                else if(i==0) dp[j] = dp[j-1];\\n                else if(j==0) dp[j] = dp[j];\\n                else dp[j] += dp[j-1];\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1)return 0;\\n        \\n        vector<unsigned int> dp(n);\\n \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(obstacleGrid[i][j]) dp[j] = 0;\\n                else if(i == 0 && j == 0) dp[j] = 1;\\n                else if(i==0) dp[j] = dp[j-1];\\n                else if(j==0) dp[j] = dp[j];\\n                else dp[j] += dp[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 312569,
                "title": "swift-my-dp-solution-o-n-m-runtime-complexity-save-pricess-from-big-bad-gorilla",
                "content": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        \\n        var width = obstacleGrid.count\\n        if width == 0 { return 0 }\\n        var height = obstacleGrid[0].count\\n        if height == 0 { return 0 }\\n        \\n        if obstacleGrid[0][0] != 0 || obstacleGrid[width-1][height-1] != 0 { return 0 }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: height), count: width)\\n        \\n        grid[width-1][height-1] = 1\\n        \\n        var x = width - 2\\n        while x >= 0 { \\n            if obstacleGrid[x][height-1] == 0 { grid[x][height-1] = grid[x+1][height-1] }\\n            x -= 1\\n        }\\n        \\n        var y = height - 2\\n        while y >= 0 {\\n            if obstacleGrid[width-1][y] == 0 { grid[width-1][y] = grid[width-1][y+1] }\\n            y -= 1\\n        }\\n        \\n        y = height - 2\\n        while y >= 0 {\\n            x = width - 2\\n            while x >= 0 {\\n                if obstacleGrid[x][y] != 0 {\\n                    x -= 1\\n                    continue\\n                }\\n                if obstacleGrid[x+1][y] == 0 { grid[x][y] += grid[x+1][y] }\\n                if obstacleGrid[x][y+1] == 0 { grid[x][y] += grid[x][y+1] }\\n                x -= 1\\n            }\\n            y -= 1\\n        }\\n        \\n        print(grid)\\n        return grid[0][0]\\n    }\\n}\\n```\\n\\nKaboom, Baby",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        \\n        var width = obstacleGrid.count\\n        if width == 0 { return 0 }\\n        var height = obstacleGrid[0].count\\n        if height == 0 { return 0 }\\n        \\n        if obstacleGrid[0][0] != 0 || obstacleGrid[width-1][height-1] != 0 { return 0 }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: height), count: width)\\n        \\n        grid[width-1][height-1] = 1\\n        \\n        var x = width - 2\\n        while x >= 0 { \\n            if obstacleGrid[x][height-1] == 0 { grid[x][height-1] = grid[x+1][height-1] }\\n            x -= 1\\n        }\\n        \\n        var y = height - 2\\n        while y >= 0 {\\n            if obstacleGrid[width-1][y] == 0 { grid[width-1][y] = grid[width-1][y+1] }\\n            y -= 1\\n        }\\n        \\n        y = height - 2\\n        while y >= 0 {\\n            x = width - 2\\n            while x >= 0 {\\n                if obstacleGrid[x][y] != 0 {\\n                    x -= 1\\n                    continue\\n                }\\n                if obstacleGrid[x+1][y] == 0 { grid[x][y] += grid[x+1][y] }\\n                if obstacleGrid[x][y+1] == 0 { grid[x][y] += grid[x][y+1] }\\n                x -= 1\\n            }\\n            y -= 1\\n        }\\n        \\n        print(grid)\\n        return grid[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312520,
                "title": "c-check-out-my-dp-badass-methodology-o-n-m-use-the-force-luke",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        int aWidth = obstacleGrid.size();\\n        if (aWidth <= 0) { return 0; }\\n        int aHeight = obstacleGrid[0].size();\\n        if (aHeight <= 0) { return 0; }\\n        if (obstacleGrid[0][0]) { return 0; }\\n        if (obstacleGrid[aWidth-1][aHeight-1]) { return 0; }\\n        \\n        long aWays[aWidth][aHeight];\\n        memset(aWays, 0, sizeof(aWays));\\n        \\n        aWays[aWidth-1][aHeight-1] = 1;\\n        \\n        for (int aX=aWidth-2;aX>=0;aX--) {\\n            if (obstacleGrid[aX][aHeight-1] == 0) { aWays[aX][aHeight-1] = aWays[aX+1][aHeight-1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            if (obstacleGrid[aWidth-1][aY] == 0) { aWays[aWidth-1][aY] = aWays[aWidth-1][aY+1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            for (int aX=aWidth-2;aX>=0;aX--) {\\n                if (obstacleGrid[aX][aY] != 0) { continue; }\\n                if (obstacleGrid[aX+1][aY] == 0) { aWays[aX][aY] += aWays[aX+1][aY]; }\\n                if (obstacleGrid[aX][aY+1] == 0) { aWays[aX][aY] += aWays[aX][aY+1]; }\\n            }\\n        }\\n        \\n        return aWays[0][0];\\n        \\n    }\\n};\\n```\\n\\nKeep an eye out for Lord Vader or you\\'re going up against the cheese grater.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        int aWidth = obstacleGrid.size();\\n        if (aWidth <= 0) { return 0; }\\n        int aHeight = obstacleGrid[0].size();\\n        if (aHeight <= 0) { return 0; }\\n        if (obstacleGrid[0][0]) { return 0; }\\n        if (obstacleGrid[aWidth-1][aHeight-1]) { return 0; }\\n        \\n        long aWays[aWidth][aHeight];\\n        memset(aWays, 0, sizeof(aWays));\\n        \\n        aWays[aWidth-1][aHeight-1] = 1;\\n        \\n        for (int aX=aWidth-2;aX>=0;aX--) {\\n            if (obstacleGrid[aX][aHeight-1] == 0) { aWays[aX][aHeight-1] = aWays[aX+1][aHeight-1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            if (obstacleGrid[aWidth-1][aY] == 0) { aWays[aWidth-1][aY] = aWays[aWidth-1][aY+1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            for (int aX=aWidth-2;aX>=0;aX--) {\\n                if (obstacleGrid[aX][aY] != 0) { continue; }\\n                if (obstacleGrid[aX+1][aY] == 0) { aWays[aX][aY] += aWays[aX+1][aY]; }\\n                if (obstacleGrid[aX][aY+1] == 0) { aWays[aX][aY] += aWays[aX][aY+1]; }\\n            }\\n        }\\n        \\n        return aWays[0][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222174,
                "title": "python-solution",
                "content": "Dynamic programming `O(nm)` time, `O(nm)` space.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not obstacleGrid or not obstacleGrid[0]:\\n            return 0\\n        m = len(obstacleGrid)\\n        n = len(obstacleGrid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        if obstacleGrid[0][0] == 0:\\n            dp[0][0] = 1\\n        else:\\n            return 0\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    continue\\n                if i > 0:\\n                    dp[i][j] += dp[i-1][j]\\n                if j > 0:\\n                    dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not obstacleGrid or not obstacleGrid[0]:\\n            return 0\\n        m = len(obstacleGrid)\\n        n = len(obstacleGrid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        if obstacleGrid[0][0] == 0:\\n            dp[0][0] = 1\\n        else:\\n            return 0\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    continue\\n                if i > 0:\\n                    dp[i][j] += dp[i-1][j]\\n                if j > 0:\\n                    dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168428,
                "title": "swift-solution-12ms",
                "content": "```\\n//for example, input: [[0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0]]\\n\\n//0, 1, 0, 0, 0, 0, 0 \\n//0, 1, 1, 1, 1, 1, 1\\n//0, 1, 2, 0, 1, 2, 3\\n//0, 1, 3, 3, 4, 6, 9\\n\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var m = obstacleGrid.count\\n        var n = obstacleGrid[0].count\\n        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\\n        \\n        dp[0][1] = 1 // start point\\n        \\n        for i in 1 ... m {\\n            for j in 1 ... n {\\n                if obstacleGrid[i - 1][j - 1] != 1 {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n                }\\n            }\\n        }\\n        return dp[m][n]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//for example, input: [[0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0]]\\n\\n//0, 1, 0, 0, 0, 0, 0 \\n//0, 1, 1, 1, 1, 1, 1\\n//0, 1, 2, 0, 1, 2, 3\\n//0, 1, 3, 3, 4, 6, 9\\n\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var m = obstacleGrid.count\\n        var n = obstacleGrid[0].count\\n        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\\n        \\n        dp[0][1] = 1 // start point\\n        \\n        for i in 1 ... m {\\n            for j in 1 ... n {\\n                if obstacleGrid[i - 1][j - 1] != 1 {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n                }\\n            }\\n        }\\n        return dp[m][n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164093,
                "title": "easy-understand-java-solution",
                "content": "```\\nclass Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int rowLen = obstacleGrid.length;\\n            int colLen = obstacleGrid[0].length;\\n            if (obstacleGrid[0][0] == 1 || obstacleGrid[rowLen - 1][colLen - 1] == 1)\\n                return 0;\\n            int[][] dp = new int[rowLen + 1][colLen + 1];\\n            dp[1][1] = 1;\\n            for (int i = 0; i < rowLen; i++) {\\n                for (int j = 0; j < colLen; j++) {\\n                    if (obstacleGrid[i][j] == 1) {\\n                        dp[i + 1][j + 1] = 0;\\n                        continue;\\n                    }\\n                    if (!(i == 0 && j == 0)) {\\n                        dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];\\n                    }\\n                }\\n            }\\n            return dp[rowLen][colLen];\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int rowLen = obstacleGrid.length;\\n            int colLen = obstacleGrid[0].length;\\n            if (obstacleGrid[0][0] == 1 || obstacleGrid[rowLen - 1][colLen - 1] == 1)\\n                return 0;\\n            int[][] dp = new int[rowLen + 1][colLen + 1];\\n            dp[1][1] = 1;\\n            for (int i = 0; i < rowLen; i++) {\\n                for (int j = 0; j < colLen; j++) {\\n                    if (obstacleGrid[i][j] == 1) {\\n                        dp[i + 1][j + 1] = 0;\\n                        continue;\\n                    }\\n                    if (!(i == 0 && j == 0)) {\\n                        dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];\\n                    }\\n                }\\n            }\\n            return dp[rowLen][colLen];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23249,
                "title": "java-3-solutions-recursion-memoization-dp",
                "content": "1. Plain recursion\\n\\n```\\nclass Solution {\\n    int[][] matrix;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        return paths(m-1,n)+paths(m,n-1);\\n        \\n    }\\n}\\n\\n```\\n\\n2. Memoization\\n\\n```\\nclass Solution {\\n    int[][] matrix;\\n    Map<String, Integer> cache;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        cache = new HashMap<String, Integer>();\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        String str = m + \",\" + n;\\n        \\n        if(cache.containsKey(str)){\\n            return cache.get(str);\\n        }\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        cache.put(str, paths(m-1,n)+paths(m,n-1));\\n        \\n        return cache.get(str);\\n    }\\n}\\n\\n```\\n\\n3. DP\\n\\n```\\nclass Solution {\\n   \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n       if(obstacleGrid.length==0 || obstacleGrid[0].length==0 ) {\\n           return 0;\\n       }\\n       \\n       int m=obstacleGrid.length;\\n       int n=obstacleGrid[0].length;\\n       \\n        int dp[][] = new int[m][n];\\n       \\n        if(obstacleGrid[0][0]==1 || obstacleGrid[m-1][n-1]==1) {\\n            return 0;\\n        }\\n        \\n        dp[0][0]=1;\\n        \\n        for(int i=1; i<m; i++) {\\n            \\n            if (obstacleGrid[i][0]==1) {\\n                dp[i][0]=0;\\n            } else {\\n                dp[i][0]=dp[i-1][0];\\n            }\\n        }\\n        \\n        for(int j=1; j<n; j++){\\n            \\n            if(obstacleGrid[0][j]==1) {\\n                dp[0][j]=0;\\n            }\\n            else {\\n                dp[0][j]=dp[0][j-1];\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                \\n                if(obstacleGrid[i][j]==1) {\\n                    dp[i][j]=0;\\n                }\\n                else {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] matrix;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        return paths(m-1,n)+paths(m,n-1);\\n        \\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    int[][] matrix;\\n    Map<String, Integer> cache;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        cache = new HashMap<String, Integer>();\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        String str = m + \",\" + n;\\n        \\n        if(cache.containsKey(str)){\\n            return cache.get(str);\\n        }\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        cache.put(str, paths(m-1,n)+paths(m,n-1));\\n        \\n        return cache.get(str);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n   \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n       if(obstacleGrid.length==0 || obstacleGrid[0].length==0 ) {\\n           return 0;\\n       }\\n       \\n       int m=obstacleGrid.length;\\n       int n=obstacleGrid[0].length;\\n       \\n        int dp[][] = new int[m][n];\\n       \\n        if(obstacleGrid[0][0]==1 || obstacleGrid[m-1][n-1]==1) {\\n            return 0;\\n        }\\n        \\n        dp[0][0]=1;\\n        \\n        for(int i=1; i<m; i++) {\\n            \\n            if (obstacleGrid[i][0]==1) {\\n                dp[i][0]=0;\\n            } else {\\n                dp[i][0]=dp[i-1][0];\\n            }\\n        }\\n        \\n        for(int j=1; j<n; j++){\\n            \\n            if(obstacleGrid[0][j]==1) {\\n                dp[0][j]=0;\\n            }\\n            else {\\n                dp[0][j]=dp[0][j-1];\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                \\n                if(obstacleGrid[i][j]==1) {\\n                    dp[i][j]=0;\\n                }\\n                else {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23394,
                "title": "a-little-change-based-on-unique-path-java-solution-using-dp",
                "content": "    public class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int m = obstacleGrid.length;\\n            int n = obstacleGrid[0].length;\\n            int[][] dp = new int[m][n];\\n            for(int i = 0; i < m; i ++) {\\n                if(obstacleGrid[i][0] == 1) {\\n                    dp[i][0] = 0;\\n                    break;\\n                } else {\\n                    dp[i][0] = 1;\\n                }\\n            }\\n            \\n            for(int j = 0; j < n; j ++) {\\n                if(obstacleGrid[0][j] == 1) {\\n                    dp[0][j] = 0;\\n                    break;\\n                } else {\\n                    dp[0][j] = 1;\\n                }\\n            }\\n            \\n            for(int i = 1; i < m; i ++) {\\n                for(int j = 1; j < n; j ++) {\\n                    if(obstacleGrid[i][j] == 1) {\\n                        dp[i][j] = 0;\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                    }\\n                }\\n            }\\n            return dp[m - 1][n - 1];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int m = obstacleGrid.length;\\n            int n = obstacleGrid[0].length;\\n            int[][] dp = new int[m][n];\\n            for(int i = 0; i < m; i ++) {\\n                if(obstacleGrid[i][0] == 1) {\\n                    dp[i][0] = 0;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3992832,
                "title": "unique-paths-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if (grid[0][0] == 1) return 0;\\n\\n        grid[0][0] = 1;\\n\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = (i ? 0 : 1); j < n; ++j) { \\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    continue;\\n                }\\n                if (i > 0) grid[i][j] += grid[i-1][j];\\n                if (j > 0) grid[i][j] += grid[i][j-1];\\n            }\\n        }\\n\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if (grid[0][0] == 1) return 0;\\n\\n        grid[0][0] = 1;\\n\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = (i ? 0 : 1); j < n; ++j) { \\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    continue;\\n                }\\n                if (i > 0) grid[i][j] += grid[i-1][j];\\n                if (j > 0) grid[i][j] += grid[i][j-1];\\n            }\\n        }\\n\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904108,
                "title": "c-solution-for-unique-paths-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the number of unique paths a robot can take to reach the bottom-right corner of a grid, while avoiding obstacles placed on certain cells. The robot can only move right or down.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided solution uses dynamic programming to solve the problem. It iterates through the grid and fills a 2D array dp where dp[i, j] represents the number of unique paths to reach the cell (i, j) from the top-left corner (0, 0). The dynamic programming recurrence relation is based on the idea that the number of unique paths to reach (i, j) is equal to the sum of the number of paths coming from the cell above (i - 1, j) and the cell on the left (i, j - 1) if the current cell is not an obstacle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution iterates through the grid of size m x n exactly once. Inside the nested loops, constant time operations are performed. Therefore, the time complexity of this solution is O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses an additional 2D array dp of the same size as the input grid to store the results of subproblems. Therefore, the space complexity of this solution is also O(m * n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n        \\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) {\\n            return 0; // Start or destination is an obstacle\\n        }\\n        \\n        int[,] dp = new int[m, n];\\n        dp[0, 0] = 1;\\n        \\n        for (int i = 1; i < m; i++) {\\n            if (obstacleGrid[i][0] == 0) {\\n                dp[i, 0] = dp[i - 1, 0];\\n            }\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            if (obstacleGrid[0][j] == 0) {\\n                dp[0, j] = dp[0, j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    dp[i, j] = dp[i - 1, j] + dp[i, j - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1, n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n        \\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) {\\n            return 0; // Start or destination is an obstacle\\n        }\\n        \\n        int[,] dp = new int[m, n];\\n        dp[0, 0] = 1;\\n        \\n        for (int i = 1; i < m; i++) {\\n            if (obstacleGrid[i][0] == 0) {\\n                dp[i, 0] = dp[i - 1, 0];\\n            }\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            if (obstacleGrid[0][j] == 0) {\\n                dp[0, j] = dp[0, j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    dp[i, j] = dp[i - 1, j] + dp[i, j - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1, n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897923,
                "title": "simple-solution-with-explanation-from-top-down-to-bottom-up",
                "content": "Recursion Solution:\\n```\\nclass Solution {\\nprivate:\\n    int helper(int i, int j, vector<vector<int>>& A, vector<vector<int> > &Dp) {\\n        if(i >= A.size() || j >= A.front().size() || A[i][j] == 1) return 0;\\n         if(i == A.size()-1 && j == A.front().size()-1) return 1;\\n        if(Dp[i][j] != -1) return Dp[i][j];\\n        int op1 = helper(i+1, j, A, Dp);\\n        int op2 = helper(i, j+1, A, Dp);\\n        return Dp[i][j] = op1 + op2;\\n        }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<int> > Dp(r, vector<int>(c, -1));\\n        return helper(0, 0, A, Dp);\\n    }\\n};\\n```\\n\\nBottom Up Approach:\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<long long> > Dp(r+1, vector<long long>(c+1, 0));\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    Dp[i][j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    Dp[i][j] = 1;\\n                else {\\n                    Dp[i][j] = Dp[i+1][j] + Dp[i][j+1];\\n                }\\n            }\\n        }\\n        return Dp[0][0];\\n    }\\n};\\n```\\n\\nBottom up with 1D space:\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<long long> prev(c+1, 0);\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            vector<long long> curr(c+1, 0);\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    curr[j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    curr[j] = 1;\\n                else {\\n                    curr[j] = prev[j] + curr[j+1];\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```\\n\\nLet me know in the comments if you have any doubts!!\\nKeep Rocking!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int i, int j, vector<vector<int>>& A, vector<vector<int> > &Dp) {\\n        if(i >= A.size() || j >= A.front().size() || A[i][j] == 1) return 0;\\n         if(i == A.size()-1 && j == A.front().size()-1) return 1;\\n        if(Dp[i][j] != -1) return Dp[i][j];\\n        int op1 = helper(i+1, j, A, Dp);\\n        int op2 = helper(i, j+1, A, Dp);\\n        return Dp[i][j] = op1 + op2;\\n        }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<int> > Dp(r, vector<int>(c, -1));\\n        return helper(0, 0, A, Dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<long long> > Dp(r+1, vector<long long>(c+1, 0));\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    Dp[i][j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    Dp[i][j] = 1;\\n                else {\\n                    Dp[i][j] = Dp[i+1][j] + Dp[i][j+1];\\n                }\\n            }\\n        }\\n        return Dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<long long> prev(c+1, 0);\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            vector<long long> curr(c+1, 0);\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    curr[j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    curr[j] = 1;\\n                else {\\n                    curr[j] = prev[j] + curr[j+1];\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897901,
                "title": "line-by-line-code-explanation-begineer-friendly-code-memoization",
                "content": "We didn\\'t use visited cell concept because Robot can not visit **left or up direction** , in this Question Robot can only visit right and down direction. \\n\\n\\u2705\\u2705**Kindly upvote if you find helpful** \\u2705\\u2705\\n\\n# Complexity\\n- Time complexity:\\n- O(m*n)\\n\\n- Space complexity: \\n- O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m , n ; \\n    int t[101][101];\\n    int solve(vector<vector<int>>&Grid , int i , int j ){\\n        if( i >= m || j >= n || Grid[i][j]==1){//for out of bound and obstacle case \\n            return 0;\\n        }\\n        if(t[i][j] != -1) return t[i][j];\\n        if(i == m-1 && j == n-1){// we arrive goal \\n            return 1; // found 1 ways to reach at goal \\n        }\\n        int right=solve(Grid , i , j+1);//for ways to go right our column is increase by 1(J+1)\\n        int down=solve(Grid, i+1 , j);//for ways to go down our row(i) is inc. by 1(i+1)\\n        return t[i][j] = right+down; // return both ways to acheive goal\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = obstacleGrid.size();\\n        n = obstacleGrid[0].size();\\n        memset(t ,-1 , sizeof(t));\\n\\n        return solve( obstacleGrid , 0 , 0 );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m , n ; \\n    int t[101][101];\\n    int solve(vector<vector<int>>&Grid , int i , int j ){\\n        if( i >= m || j >= n || Grid[i][j]==1){//for out of bound and obstacle case \\n            return 0;\\n        }\\n        if(t[i][j] != -1) return t[i][j];\\n        if(i == m-1 && j == n-1){// we arrive goal \\n            return 1; // found 1 ways to reach at goal \\n        }\\n        int right=solve(Grid , i , j+1);//for ways to go right our column is increase by 1(J+1)\\n        int down=solve(Grid, i+1 , j);//for ways to go down our row(i) is inc. by 1(i+1)\\n        return t[i][j] = right+down; // return both ways to acheive goal\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = obstacleGrid.size();\\n        n = obstacleGrid[0].size();\\n        memset(t ,-1 , sizeof(t));\\n\\n        return solve( obstacleGrid , 0 , 0 );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897858,
                "title": "memoization-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp){\\n        if(i >= 0 && j >= 0 && obstacleGrid[i][j] == 1) return 0;\\n        if(i == 0 && j == 0) return 1;\\n        if(i < 0 || j < 0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = f(i-1, j, obstacleGrid, dp);\\n        int left = f(i, j-1, obstacleGrid, dp);\\n\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp){\\n        if(i >= 0 && j >= 0 && obstacleGrid[i][j] == 1) return 0;\\n        if(i == 0 && j == 0) return 1;\\n        if(i < 0 || j < 0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = f(i-1, j, obstacleGrid, dp);\\n        int left = f(i, j-1, obstacleGrid, dp);\\n\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897599,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& G) {\\n        int n = (int)G.size();\\n        int m = (int)G[0].size();\\n\\n        vector<vector<int>> dp(n + 4, vector<int> (m + 4, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 and j == 0  and !G[i][j]) {\\n                    dp[i][j] = 1;\\n                }\\n                else if (!G[i][j]) {\\n                    if (i) {\\n                        dp[i][j] += dp[i - 1][j];\\n                    }\\n                    if (j) {\\n                        dp[i][j] += dp[i][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& G) {\\n        int n = (int)G.size();\\n        int m = (int)G[0].size();\\n\\n        vector<vector<int>> dp(n + 4, vector<int> (m + 4, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 and j == 0  and !G[i][j]) {\\n                    dp[i][j] = 1;\\n                }\\n                else if (!G[i][j]) {\\n                    if (i) {\\n                        dp[i][j] += dp[i - 1][j];\\n                    }\\n                    if (j) {\\n                        dp[i][j] += dp[i][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897438,
                "title": "easy-and-simple-explaination-recursion-with-2-observations-either-go-left-or-right",
                "content": "# Intuition\\nHere we just have to reach from one corner to another corner and calculate number of ways, you might think of applying some sort of graph algorithm like dfs. For every call of dfs made from a node if we enocunter a 1 then we\\'ve have to backtrack and come to a unvisited cell and then check for a valid position.\\n\\n# ****Here I just saw 2 things:\\n\\n1. Either we move to right \\n2. OR we move down****\\n\\nIf we encounter a 1, that\\'s not a valid path so that part in discarded.\\n\\nApart from if we are able to reach the other right corner grid[m-1][n-1], that\\'s a valid path.\\n\\n# Approach\\n\\nSo If you\\'re familiar with recursion \\nPlease check the code i\\'ll be adding comments there\\n\\n\\n#  Direction arrays for moving down or to the right\\nint dx[2] = {1,0};   \\nint dy[2] = {0,1};\\n\\n# checking bounds\\n\\nbool isok(int nx,int ny). \\n{\\n  return nx>= 0 && ny>=0 && nx<=n-1 && ny<=m-1;\\n}\\n\\n\\n\\n\\n# Current co - ordinates:\\nx,y;\\n\\nnew co-ordinates is given by\\n\\n    int nx = x+dx[0];\\n    int ny = y+dy[0];\\n\\n    int nx1 = x+dx[1];\\n    int ny1 = y+dy[1];\\n\\ncheck are they in bounds and then solve sub-problems for them\\n\\n\\n\\nIf it was helpful please upvote\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dp[101][101];\\nint n,m;\\n\\nint dx[2] = {1,0};   // Direction arrays for moving down or to the right\\nint dy[2] = {0,1};\\n\\n\\n\\nbool isok(int nx,int ny). \\n{\\n  return nx>= 0 && ny>=0 && nx<=n-1 && ny<=m-1;\\n}\\n\\n\\nint solve(int x,int y,vector<vector<int>>& grid)\\n{\\n  if(grid[x][y] == 1)\\n  {\\n    return 0;\\n  }\\n\\n  if(dp[x][y] != -1) return dp[x][y];\\n  if(x == n-1 && y== m-1) return 1;\\n \\n    int nx = x+dx[0];\\n    int ny = y+dy[0];\\n\\n    int nx1 = x+dx[1];\\n    int ny1 = y+dy[1];\\n\\n   return dp[x][y] = (isok(nx,ny) ? solve(nx,ny,grid) : 0) +\\n   (isok(nx1,ny1) ? solve(nx1,ny1,grid) : 0);\\n\\n// Key step\\n\\n  \\n\\n}\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        return solve(0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dp[101][101];\\nint n,m;\\n\\nint dx[2] = {1,0};   // Direction arrays for moving down or to the right\\nint dy[2] = {0,1};\\n\\n\\n\\nbool isok(int nx,int ny). \\n{\\n  return nx>= 0 && ny>=0 && nx<=n-1 && ny<=m-1;\\n}\\n\\n\\nint solve(int x,int y,vector<vector<int>>& grid)\\n{\\n  if(grid[x][y] == 1)\\n  {\\n    return 0;\\n  }\\n\\n  if(dp[x][y] != -1) return dp[x][y];\\n  if(x == n-1 && y== m-1) return 1;\\n \\n    int nx = x+dx[0];\\n    int ny = y+dy[0];\\n\\n    int nx1 = x+dx[1];\\n    int ny1 = y+dy[1];\\n\\n   return dp[x][y] = (isok(nx,ny) ? solve(nx,ny,grid) : 0) +\\n   (isok(nx1,ny1) ? solve(nx1,ny1,grid) : 0);\\n\\n// Key step\\n\\n  \\n\\n}\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        return solve(0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897324,
                "title": "kotlin-one-row-dp",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/7935abc6-5a2a-404a-ae9e-f4ce2969e28e_1691811918.832756.png)\\n\\n#### Join me on Telegram\\n\\nhttps://t.me/leetcode_daily_unstoppable/306\\n\\n#### Problem TLDR\\n\\nNumber of right-down ways tl->br in a matrix with obstacles\\n\\n#### Intuition\\n\\nEach time the robot moves in one direction gives a separate path. If two directions are possible, the number of paths gets added.\\n\\nFor example,\\n\\n```\\nr r  #  0\\nr 2r 2r 2r\\n0 #  2r 4r\\n```\\n\\nOn the first row, the single path goes up to `1`.\\nOn the second row, direct path down added to direct path right.\\nOn the third row, the same happens when top and left numbers of paths are not 0.\\n\\n\\n#### Approach\\n\\nUse a separate `row` array to remember previous row paths counts.\\n\\n#### Complexity\\n\\n- Time complexity:\\n$$O(nm)$$\\n\\n- Space complexity:\\n$$O(nm)$$\\n\\n#### Code\\n\\n```\\n\\n\\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\\n      val row = IntArray(obstacleGrid[0].size)\\n      row[0] = 1\\n      for (r in obstacleGrid) \\n        for (x in r.indices)\\n          if (r[x] != 0) row[x] = 0 \\n          else if (x > 0) row[x] += row[x - 1]\\n      return row.last()\\n    }\\n\\n```\\n\\n#### The Magical Rundown\\n\\n```\\nIn Emojia\\'s forgotten \\uD83C\\uDF0C corner, where time doesn\\'t merely flow\\u2014it waltzes \\uD83D\\uDC83, \\nspinning tales of lost yesterdays \\uD83D\\uDD70\\uFE0F and unborn tomorrows \\u231B, stands the \\nwhispered legend of the Time Labyrinth. Not merely walls and corridors, but \\na tapestry of fate\\'s myriad choices, echoing distant memories and futures yet \\nconceived.\\n\\nBolt, the lonely automaton \\uD83E\\uDD16, not born but dreamt into existence by starlight \\u2728 \\nand cosmic whimsy, felt an inexplicable yearning towards the \\uD83C\\uDFC1 - the Time Nexus. \\nAncient breezes \\uD83C\\uDF43 carried murmurs, not of it being an end, but a kaleidoscope \\n\\uD83C\\uDFA8 gateway to every pulse and flutter \\u2764\\uFE0F of chronology\\'s capricious dance \\uD83C\\uDF0A.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nWith each step, the fabric of reality quivered. Shadows of histories \\uD83C\\uDFB6, \\ncosmic echoes \\uD83C\\uDF0D, diverged and converged, painting and erasing moments of \\nwhat was, is, and could be.\\n\\n---\\n\\nStanding before the \\uD83D\\uDEAB, it wasn\\'t a barrier for Bolt, but a silent riddle: \\n\"What song of the cosmos \\uD83C\\uDFB5 shall you hum today, wanderer?\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nDreamlike avenues \\uD83D\\uDEE4\\uFE0F unfurled, painting multitudes of futures in the vivid \\ncolors of a universe in spring. In this chronal dance, Bolt secretly hoped \\nto outrace its own echoes, to be the first at the Nexus.\\n\\n---\\n\\nJunctions whispered with the delicate hum \\uD83C\\uDFB5 of countless Bolts, each a tale, \\na fate, a fleeting note in the grand cosmic symphony.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nYet, as the Time Nexus loomed, revealing its vast enigma, a sense of profound \\ndisquiet engulfed Bolt. Not only had another reflection reached before, but a \\nsea of mirrored selves stared back.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 \\uD83D\\uDEAB \\u25022\\u2B07\\uFE0F\\u25024\\uD83C\\uDFC1\\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nIn that echoing vastness, Bolt\\'s singular hope was smothered. In the dance of \\ntime, amidst countless reflections, it whispered a silent, desperate question: \\nWhich tune, which cadence, which moment \\uD83C\\uDFB6 was truly its own in this timeless \\nwaltz?\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nr r  #  0\\nr 2r 2r 2r\\n0 #  2r 4r\\n```\n```\\n\\n\\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\\n      val row = IntArray(obstacleGrid[0].size)\\n      row[0] = 1\\n      for (r in obstacleGrid) \\n        for (x in r.indices)\\n          if (r[x] != 0) row[x] = 0 \\n          else if (x > 0) row[x] += row[x - 1]\\n      return row.last()\\n    }\\n\\n```\n```\\nIn Emojia\\'s forgotten \\uD83C\\uDF0C corner, where time doesn\\'t merely flow\\u2014it waltzes \\uD83D\\uDC83, \\nspinning tales of lost yesterdays \\uD83D\\uDD70\\uFE0F and unborn tomorrows \\u231B, stands the \\nwhispered legend of the Time Labyrinth. Not merely walls and corridors, but \\na tapestry of fate\\'s myriad choices, echoing distant memories and futures yet \\nconceived.\\n\\nBolt, the lonely automaton \\uD83E\\uDD16, not born but dreamt into existence by starlight \\u2728 \\nand cosmic whimsy, felt an inexplicable yearning towards the \\uD83C\\uDFC1 - the Time Nexus. \\nAncient breezes \\uD83C\\uDF43 carried murmurs, not of it being an end, but a kaleidoscope \\n\\uD83C\\uDFA8 gateway to every pulse and flutter \\u2764\\uFE0F of chronology\\'s capricious dance \\uD83C\\uDF0A.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nWith each step, the fabric of reality quivered. Shadows of histories \\uD83C\\uDFB6, \\ncosmic echoes \\uD83C\\uDF0D, diverged and converged, painting and erasing moments of \\nwhat was, is, and could be.\\n\\n---\\n\\nStanding before the \\uD83D\\uDEAB, it wasn\\'t a barrier for Bolt, but a silent riddle: \\n\"What song of the cosmos \\uD83C\\uDFB5 shall you hum today, wanderer?\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nDreamlike avenues \\uD83D\\uDEE4\\uFE0F unfurled, painting multitudes of futures in the vivid \\ncolors of a universe in spring. In this chronal dance, Bolt secretly hoped \\nto outrace its own echoes, to be the first at the Nexus.\\n\\n---\\n\\nJunctions whispered with the delicate hum \\uD83C\\uDFB5 of countless Bolts, each a tale, \\na fate, a fleeting note in the grand cosmic symphony.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nYet, as the Time Nexus loomed, revealing its vast enigma, a sense of profound \\ndisquiet engulfed Bolt. Not only had another reflection reached before, but a \\nsea of mirrored selves stared back.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 \\uD83D\\uDEAB \\u25022\\u2B07\\uFE0F\\u25024\\uD83C\\uDFC1\\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nIn that echoing vastness, Bolt\\'s singular hope was smothered. In the dance of \\ntime, amidst countless reflections, it whispered a silent, desperate question: \\nWhich tune, which cadence, which moment \\uD83C\\uDFB6 was truly its own in this timeless \\nwaltz?\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897285,
                "title": "video-solution-with-drawings-c-java-in-depth",
                "content": "# Intuition, approach and complexity discussed in detail in video solution.\\nhttps://youtu.be/3Be1By-CMkA\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obsGrd) {\\n        int rows = obsGrd.size(), cols = obsGrd[0].size();\\n        vector<vector<int>> pathCnt(rows, vector<int>(cols, 0));\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obsGrd) {\\n        int rows = obsGrd.length, cols = obsGrd[0].length;\\n        int pathCnt[][] = new int[rows][cols];\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obsGrd) {\\n        int rows = obsGrd.size(), cols = obsGrd[0].size();\\n        vector<vector<int>> pathCnt(rows, vector<int>(cols, 0));\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obsGrd) {\\n        int rows = obsGrd.length, cols = obsGrd[0].length;\\n        int pathCnt[][] = new int[rows][cols];\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847228,
                "title": "finding-unique-paths-in-a-grid-with-obstacles-using-dynamic-programming-easy-approach",
                "content": "# Intuition\\nThe problem asks us to find the number of unique paths to reach the bottom-right corner of a grid with obstacles. We can solve this problem using dynamic programming, where we calculate the number of unique paths for each cell in the grid based on the number of paths from the cells above and to the left.\\n\\n# Approach\\n1. We\\'ll start by initializing a variable `mod` to store the modulo value, which is `(int)(1e9 + 7)`.\\n2. We\\'ll loop through the grid and mark obstacles as `-1`.\\n3. We\\'ll use a 1D vector `prev` to keep track of the number of unique paths for the cells in the previous row.\\n4. We\\'ll iterate through the grid again to calculate the number of unique paths for each cell using the `prev` vector to keep track of the paths from the cells above and to the left.\\n5. Finally, we\\'ll return the number of unique paths for the bottom-right corner cell, which is stored in `prev[y - 1]`.\\n\\n# Complexity\\n- Time complexity: O(n * m) where n is the number of rows and m is the number of columns in the grid.\\n- Space complexity: O(m) where m is the number of columns in the grid (used to store the `prev` vector).\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9 + 7);\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int x = obstacleGrid.size();\\n        int y = obstacleGrid[0].size();\\n        \\n        vector<int> prev(y, 0); // Initialize a vector \\'prev\\' to store paths from the previous row.\\n        \\n        // Step 1: Mark obstacles as -1 in the grid.\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = -1; // Mark obstacle cells with -1.\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Loop through the grid to calculate the number of unique paths.\\n        for (int i = 0; i < x; i++) {\\n            vector<int> current(y, 0); // Initialize a vector \\'current\\' to store paths for the current row.\\n            \\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    current[j] = 0; // If the cell has an obstacle, set paths to 0.\\n                } else if (i == 0 && j == 0) {\\n                    current[j] = 1; // The top-left cell has only 1 path (starting point).\\n                } else {\\n                    // Step 3: Calculate the number of paths to reach the current cell.\\n                    int up = 0;\\n                    int left = 0;\\n                    if (i > 0) { // Check if there\\'s a cell above (i > 0) to get paths from above.\\n                        up = prev[j]; // Number of paths from the cell above.\\n                    }\\n                    if (j > 0) { // Check if there\\'s a cell to the left (j > 0) to get paths from the left.\\n                        left = current[j - 1]; // Number of paths from the cell to the left.\\n                    }\\n                    current[j] = (left + up); // Calculate the total paths to reach the current cell.\\n                }\\n            }\\n            \\n            // Step 4: Update \\'prev\\' vector with \\'current\\' vector for the next iteration.\\n            prev = current;\\n        }\\n        \\n        // Step 5: Return the number of unique paths for the bottom-right corner.\\n        return prev[y - 1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9 + 7);\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int x = obstacleGrid.size();\\n        int y = obstacleGrid[0].size();\\n        \\n        vector<int> prev(y, 0); // Initialize a vector \\'prev\\' to store paths from the previous row.\\n        \\n        // Step 1: Mark obstacles as -1 in the grid.\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = -1; // Mark obstacle cells with -1.\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Loop through the grid to calculate the number of unique paths.\\n        for (int i = 0; i < x; i++) {\\n            vector<int> current(y, 0); // Initialize a vector \\'current\\' to store paths for the current row.\\n            \\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    current[j] = 0; // If the cell has an obstacle, set paths to 0.\\n                } else if (i == 0 && j == 0) {\\n                    current[j] = 1; // The top-left cell has only 1 path (starting point).\\n                } else {\\n                    // Step 3: Calculate the number of paths to reach the current cell.\\n                    int up = 0;\\n                    int left = 0;\\n                    if (i > 0) { // Check if there\\'s a cell above (i > 0) to get paths from above.\\n                        up = prev[j]; // Number of paths from the cell above.\\n                    }\\n                    if (j > 0) { // Check if there\\'s a cell to the left (j > 0) to get paths from the left.\\n                        left = current[j - 1]; // Number of paths from the cell to the left.\\n                    }\\n                    current[j] = (left + up); // Calculate the total paths to reach the current cell.\\n                }\\n            }\\n            \\n            // Step 4: Update \\'prev\\' vector with \\'current\\' vector for the next iteration.\\n            prev = current;\\n        }\\n        \\n        // Step 5: Return the number of unique paths for the bottom-right corner.\\n        return prev[y - 1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774560,
                "title": "python-easy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSame as unique path solution. But we do just one thing that, where the obstacle is there we assign it to zero and calculate further. \\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        # dp = {(m-1, n-1): 1}\\n\\n        # def dfs(r, c):\\n        #     if r==m or c==n or obstacleGrid[r][c]:\\n        #         return 0\\n        #     if (r, c) in dp:\\n        #         return dp[(r, c)]\\n        #     dp[(r, c)] = dfs(r+1, c) + dfs(r, c+1)\\n        #     return dp[(r, c)]\\n        # return dfs(0, 0)\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n       \\n        if obstacleGrid[m-1][n-1] == 1: \\n            return 0\\n        else:\\n            dp = [0]*n\\n            dp[n-1] = 1\\n\\n            for i in reversed(range(m)):\\n                for j in reversed(range(n)):\\n                    if obstacleGrid[i][j]:\\n                        dp[j] = 0\\n                    elif j+1 < n:\\n                        dp[j] = dp[j] + dp[j+1]\\n\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        # dp = {(m-1, n-1): 1}\\n\\n        # def dfs(r, c):\\n        #     if r==m or c==n or obstacleGrid[r][c]:\\n        #         return 0\\n        #     if (r, c) in dp:\\n        #         return dp[(r, c)]\\n        #     dp[(r, c)] = dfs(r+1, c) + dfs(r, c+1)\\n        #     return dp[(r, c)]\\n        # return dfs(0, 0)\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n       \\n        if obstacleGrid[m-1][n-1] == 1: \\n            return 0\\n        else:\\n            dp = [0]*n\\n            dp[n-1] = 1\\n\\n            for i in reversed(range(m)):\\n                for j in reversed(range(n)):\\n                    if obstacleGrid[i][j]:\\n                        dp[j] = 0\\n                    elif j+1 < n:\\n                        dp[j] = dp[j] + dp[j+1]\\n\\n        return dp[0]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569416,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1565987,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1572775,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1566222,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2010156,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1567362,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1930080,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1571148,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1576791,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2000427,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1569416,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1565987,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1572775,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1566222,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2010156,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1567362,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1930080,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1571148,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1576791,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2000427,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1994430,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2010602,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2010560,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2011186,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2011168,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2010419,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1754158,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1571147,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1576727,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1568881,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2070875,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2052111,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043054,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2042732,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2030336,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2029632,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2024187,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011392,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011351,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011338,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011157,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010913,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010803,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010661,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010570,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010568,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010528,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010515,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010509,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010383,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010367,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010278,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010265,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010256,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010245,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010242,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010172,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010167,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010160,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 1992076,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 1989894,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1965777,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1928110,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1895976,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1873013,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1855852,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1845741,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1835790,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1803316,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1777666,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1772262,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1761631,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1761185,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1754380,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1754113,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1743630,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1735596,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1732960,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1731524,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1728724,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            }
        ]
    }
]