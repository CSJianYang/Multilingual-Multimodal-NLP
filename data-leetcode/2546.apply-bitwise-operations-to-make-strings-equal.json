[
    {
        "title": "Apply Bitwise Operations to Make Strings Equal",
        "question_content": "You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:\n\n\tChoose two different indices i and j where 0 <= i, j < n.\n\tSimultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).\n\nFor example, if s = \"0110\", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = \"1110\".\nReturn true if you can make the string s equal to target, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: s = \"1010\", target = \"0110\"\nOutput: true\nExplanation: We can do the following operations:\n- Choose i = 2 and j = 0. We have now s = \"0010\".\n- Choose i = 2 and j = 1. We have now s = \"0110\".\nSince we can make s equal to target, we return true.\n\nExample 2:\n\nInput: s = \"11\", target = \"00\"\nOutput: false\nExplanation: It is not possible to make s equal to target with any number of operations.\n\n&nbsp;\nConstraints:\n\n\tn == s.length == target.length\n\t2 <= n <= 105\n\ts and target consist of only the digits 0 and 1.",
        "solutions": [
            {
                "id": 3083831,
                "title": "java-c-python-1-line-check-1",
                "content": "# **Intuition**\\nEnumerate the values for `s[i]` and `s[j]`\\n`(0, 0)` -> `(0, 0)`\\n`(1, 0)` -> `(1, 1)`\\n`(0, 1)` -> `(1, 1)`\\n`(1, 1)` -> `(1, 0)`\\n<br>\\n\\n# **Explanation**\\n**To summrize the rule**\\n1. Two 0s stay 0s.\\n2. If we have 1, we can make any 0 to 1.\\n3. If we have at least two 1s, we can make any 1 to 0.\\n\\n**Continue to sunmmrize**\\n1. All 0 string can not change.\\n2. Any other strings can transform from each other.\\n\\n**So we only need to check**\\nif `s` has 1.\\nif `target` has 1.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n# Solution 1: Check if strings have 1\\n**Java**\\n```java\\n    public boolean makeStringsEqual(String s, String t) {\\n        return s.contains(\"1\") == t.contains(\"1\");\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool makeStringsEqual(string s, string t) {\\n        return (s.find(\\'1\\') != string::npos) == (t.find(\\'1\\') != string::npos);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def makeStringsEqual(self, s, t):\\n        return (\\'1\\' in s) == (\\'1\\' in t)\\n```\\n<br>\\n\\n# Solution 2: Shorter\\n**Python**\\n```py\\n    def makeStringsEqual(self, s, t):\\n        return max(s) == max(t)\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean makeStringsEqual(String s, String t) {\\n        return s.contains(\"1\") == t.contains(\"1\");\\n    }\\n```\n```cpp\\n    bool makeStringsEqual(string s, string t) {\\n        return (s.find(\\'1\\') != string::npos) == (t.find(\\'1\\') != string::npos);\\n    }\\n```\n```py\\n    def makeStringsEqual(self, s, t):\\n        return (\\'1\\' in s) == (\\'1\\' in t)\\n```\n```py\\n    def makeStringsEqual(self, s, t):\\n        return max(s) == max(t)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3084076,
                "title": "java-easy-bit-manipulation-with-explanation",
                "content": "**The basic intuition is to make 0 to 1 we need 1 and to make 1 to 0 we need 1 so I counted the number of 0 that are needed to convert to one and then I checked if the number of 1 in the string is greater than zero then I was assured that the 0 can be converted to 1. To convert 1 to 0 I also need 1 so I checked if I have extra number of 1 other than the number of 1 that are going to be converted to 0 then I returned true otherwise false.**\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target))\\n            return true;\\n        int tozero=0;\\n        int toone=0;\\n        int cntzero=0;\\n        int cntone=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\')\\n                cntzero++;\\n            else\\n                cntone++;\\n            if(s.charAt(i)!=target.charAt(i)){\\n                if(s.charAt(i)==\\'0\\')\\n                    toone++;\\n                else\\n                    tozero++;\\n            }\\n        }\\n        if(toone>0 && cntone>0)\\n            return true;\\n        else if(tozero>0 && cntone>tozero)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target))\\n            return true;\\n        int tozero=0;\\n        int toone=0;\\n        int cntzero=0;\\n        int cntone=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\')\\n                cntzero++;\\n            else\\n                cntone++;\\n            if(s.charAt(i)!=target.charAt(i)){\\n                if(s.charAt(i)==\\'0\\')\\n                    toone++;\\n                else\\n                    tozero++;\\n            }\\n        }\\n        if(toone>0 && cntone>0)\\n            return true;\\n        else if(tozero>0 && cntone>tozero)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083886,
                "title": "one-liner",
                "content": "We can change `1` to `0` and `0` to `1` if there is at least one `1` in the string:\\n- we cannot make a string to be all zeros (one `1` will remain).\\n- we cannot modify all-zeros string.\\n\\nTherefore, we can make `s` into any `t`, providing both `s` and `t` contain at least one `1`.\\n> An edge case is when both `s` and `t` are all-zeros.\\n\\n**C++**\\n```cpp\\nbool makeStringsEqual(string s, string t) {\\n    return (count(begin(s), end(s), \\'1\\') > 0) == (count(begin(t), end(t), \\'1\\') > 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool makeStringsEqual(string s, string t) {\\n    return (count(begin(s), end(s), \\'1\\') > 0) == (count(begin(t), end(t), \\'1\\') > 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084017,
                "title": "very-simple-and-easy-to-understand-solution",
                "content": "\\n\\n```\\n/*\\nCheck if there is atleast one 1 in both the strings or not, if atleast one 1 in both the string then its true other wise flase.\\nCorner case: even both of the string have no 1 and all zeor in both cases then also it will be true.\\n*/\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int t = 0, a = 0;\\n        for(auto c: s) a+=(c - \\'0\\');\\n        for(auto c: target) t+=(c - \\'0\\');\\n        if(a > 0 && t > 0 || a == 0 && t == 0) return true;\\n        return false;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nCheck if there is atleast one 1 in both the strings or not, if atleast one 1 in both the string then its true other wise flase.\\nCorner case: even both of the string have no 1 and all zeor in both cases then also it will be true.\\n*/\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int t = 0, a = 0;\\n        for(auto c: s) a+=(c - \\'0\\');\\n        for(auto c: target) t+=(c - \\'0\\');\\n        if(a > 0 && t > 0 || a == 0 && t == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083931,
                "title": "java-python-3-analysis-results-short-codes",
                "content": "**If a string contains no `1`, then there is no way to change it any longer;  If a string contains at least a `1`, there is no way to change it to an all-zero string,  under the rules of the problem.**\\n\\nOtherwise, we can always  change `s` to `target`.\\n\\n```java\\n    public boolean makeStringsEqual(String s, String target) {\\n        if (!s.contains(\"1\") || !target.contains(\"1\")) {\\n            return s.equals(target);\\n        }\\n        return true;\\n    }\\n```\\n\\n```python\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if (\\'1\\' not in s) or (\\'1\\' not in target):\\n            return s == target\\n        return True\\n```\\n\\nIn case you are interested one liners:\\n\\n```java\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.equals(target) || s.contains(\"1\") && target.contains(\"1\");\\n    }\\n```\\n```python\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return s == target or (\\'1\\' in s) and (\\'1\\' in target)\\n```\\nor \\n```java\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n```\\n```python\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return max(s) == max(target)\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public boolean makeStringsEqual(String s, String target) {\\n        if (!s.contains(\"1\") || !target.contains(\"1\")) {\\n            return s.equals(target);\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if (\\'1\\' not in s) or (\\'1\\' not in target):\\n            return s == target\\n        return True\\n```\n```java\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.equals(target) || s.contains(\"1\") && target.contains(\"1\");\\n    }\\n```\n```python\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return s == target or (\\'1\\' in s) and (\\'1\\' in target)\\n```\n```java\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n```\n```python\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return max(s) == max(target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3083899,
                "title": "one-liner-and-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return s==target or (int(target)>0 and int(s)>0)\\n        \\n        \\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return s==target or (int(target)>0 and int(s)>0)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083885,
                "title": "c-simple-intuitive-approach",
                "content": "**If any of the string has all 0\\'s we can\\'t convert it to another.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target) return true;\\n        \\n        int cnt0=0, cnt1=0, cnt2=0, cnt3=0;\\n        for(auto &it: s){\\n            if(it==\\'0\\') cnt0++;\\n            else cnt1++;\\n        }\\n        for(auto &it: target){\\n            if(it==\\'0\\') cnt2++;\\n            else cnt3++;\\n        }\\n        \\n        \\n        if((cnt0 && !cnt1) || (cnt2 && !cnt3)) return false;\\n        return true;\\n    }\\n};\\n```\\n**Do upvote if it helps:)**\\n\\nCheck out my youtube channel for related content\\nhttps://www.youtube.com/@ignition548/featured",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target) return true;\\n        \\n        int cnt0=0, cnt1=0, cnt2=0, cnt3=0;\\n        for(auto &it: s){\\n            if(it==\\'0\\') cnt0++;\\n            else cnt1++;\\n        }\\n        for(auto &it: target){\\n            if(it==\\'0\\') cnt2++;\\n            else cnt3++;\\n        }\\n        \\n        \\n        if((cnt0 && !cnt1) || (cnt2 && !cnt3)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085007,
                "title": "c-this-code-simple-clean-t-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/777f47f8-20a3-43ae-b36c-3c49cb1c1495_1674373433.4487357.png)\\n\\n**T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool makeStringsEqual(string s, string t) {\\n\\t\\t\\t\\tint ssum=0,tsum=0;\\n\\t\\t\\t\\tint n=s.size(),m=t.size();\\n\\n\\t\\t\\t\\tif(m!=n) return false;\\n\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(s[i]==\\'1\\') ssum++;\\n\\t\\t\\t\\t\\tif(t[i]==\\'1\\') tsum++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(ssum==0 && tsum>0) return false;\\n\\t\\t\\t\\telse if(tsum==0 && ssum>0) return false;\\n\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool makeStringsEqual(string s, string t) {\\n\\t\\t\\t\\tint ssum=0,tsum=0;\\n\\t\\t\\t\\tint n=s.size(),m=t.size();\\n\\n\\t\\t\\t\\tif(m!=n) return false;\\n\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(s[i]==\\'1\\') ssum++;\\n\\t\\t\\t\\t\\tif(t[i]==\\'1\\') tsum++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3084661,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int a=0, b=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'1\\')\\n            a++;\\n        }\\n        for(char c:t)\\n        {\\n            if(c==\\'1\\')\\n            b++;\\n        }\\n        if(a==0 && b==0)\\n        return true;\\n        if(a==0 && b!=0)\\n        return false;\\n        if(b==0)\\n        return false;\\n        return true;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int a=0, b=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'1\\')\\n            a++;\\n        }\\n        for(char c:t)\\n        {\\n            if(c==\\'1\\')\\n            b++;\\n        }\\n        if(a==0 && b==0)\\n        return true;\\n        if(a==0 && b!=0)\\n        return false;\\n        if(b==0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084018,
                "title": "video-explanation-with-intuitive-proofs",
                "content": "## Explanation\\n\\nhttps://www.youtube.com/watch?v=1Aw0gN21W6w\\n\\n[Click here if the preview doesn\\'t works](https://www.youtube.com/watch?v=1Aw0gN21W6w)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) return true; // 00000 000000\\n        \\n        bool t_has_one = false;\\n        for (auto i : target)\\n            if (i == \\'1\\') t_has_one = true;\\n                \\n        bool s_has_one = false;\\n        for (auto i : s) \\n            if (i == \\'1\\') s_has_one = true;\\n        \\n        return s_has_one && t_has_one;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) return true; // 00000 000000\\n        \\n        bool t_has_one = false;\\n        for (auto i : target)\\n            if (i == \\'1\\') t_has_one = true;\\n                \\n        bool s_has_one = false;\\n        for (auto i : s) \\n            if (i == \\'1\\') s_has_one = true;\\n        \\n        return s_has_one && t_has_one;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550923,
                "title": "c-simple-count-of-1-s",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s1, string s2) {\\n        if(s1==s2){\\n            return true;\\n        }\\n        if(s1.length()==1){\\n            if(s2==\"1\")return false;\\n        }\\n        int x = 0, y = 0;\\n        for(auto &i: s1)x += (i==\\'1\\');\\n        for(auto &i: s2)y += (i==\\'1\\');\\n        int n = s1.length();\\n        if((x && !y)||(!x && y)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s1, string s2) {\\n        if(s1==s2){\\n            return true;\\n        }\\n        if(s1.length()==1){\\n            if(s2==\"1\")return false;\\n        }\\n        int x = 0, y = 0;\\n        for(auto &i: s1)x += (i==\\'1\\');\\n        for(auto &i: s2)y += (i==\\'1\\');\\n        int n = s1.length();\\n        if((x && !y)||(!x && y)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092025,
                "title": "python-3-2-lines-w-explanation-t-m-45-ms-15-mb",
                "content": "From the table below, one can see that:\\n- If`s` has a `1`, then any other digit in`s`can be flipped, but there will remain at least one`1` in`s`, no matter how many oprations are performed.\\n- If`s` has no `1`s, then no other digit in`s`can be flipped.\\n\\n\\n![table.jpg](https://assets.leetcode.com/users/images/8da2e415-bc06-4f9e-b1a8-e2435dc8b58e_1674418336.9983306.jpeg)\\n\\n\\nThese two conditions imply the two stuations in which we will return`True`:\\n- The two strings as given are equal;  or\\n- Each string has at least one `1`.\\n\\nAll other situations return `False`.\\n\\n\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n\\n        if s == target: return True\\n        \\n        return int(s,2)*int(target,2)\\n\\n```\\n[https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/submissions/883262113/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n\\n        if s == target: return True\\n        \\n        return int(s,2)*int(target,2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083844,
                "title": "count-one",
                "content": "**If you have 1, then you can make any bit to 1.\\nIf you have at least two 1, then you can make any bit to 0.**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    bool makeStringsEqual(string s, string target) {\\n        \\n        if (s == target)    return true;\\n        int oneIns = count(begin(s), end(s), \\'1\\'), oneInt = count(begin(target), end(target), \\'1\\');\\n        \\n        return (oneIns >= 1) and (oneInt >= 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool makeStringsEqual(string s, string target) {\\n        \\n        if (s == target)    return true;\\n        int oneIns = count(begin(s), end(s), \\'1\\'), oneInt = count(begin(target), end(target), \\'1\\');\\n        \\n        return (oneIns >= 1) and (oneInt >= 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362791,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)\\n        {\\n            return true;\\n        }\\n        int n = target.size();\\n        int count=0, count0=0, count1=0;\\n        int count0T=0, count1T=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                count0++;\\n            }\\n            else\\n            {\\n                count1++;\\n            }\\n            if(target[i]==\\'0\\')\\n            {\\n                count0T++;\\n            }\\n            else\\n            {\\n                count1T++;\\n            }\\n            count++;\\n        }\\n        if(count==count0)\\n        {\\n            return false;\\n        }\\n        if(count0T==count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)\\n        {\\n            return true;\\n        }\\n        int n = target.size();\\n        int count=0, count0=0, count1=0;\\n        int count0T=0, count1T=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                count0++;\\n            }\\n            else\\n            {\\n                count1++;\\n            }\\n            if(target[i]==\\'0\\')\\n            {\\n                count0T++;\\n            }\\n            else\\n            {\\n                count1T++;\\n            }\\n            count++;\\n        }\\n        if(count==count0)\\n        {\\n            return false;\\n        }\\n        if(count0T==count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083968,
                "title": "python-1-liner-solution-super-easy-to-understand-altho-its-an-easy-question",
                "content": "# what should i even say, all testcases have been passed using this simple code!\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return max(s) == max(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return max(s) == max(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083822,
                "title": "c-easy-o-n-with-explanation",
                "content": "```C++\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n = s.length();\\n        int s_cnt0 = 0, t_cnt0 = 0;\\n        for(auto&c :s) if(c==\\'0\\')s_cnt0++;\\n        for(auto&c :target) if(c==\\'0\\')t_cnt0++;\\n        if(s_cnt0 == n && t_cnt0!=n) return false;\\n        if(s_cnt0 != n && t_cnt0==n) return false;\\n        return true;\\n    }\\n};\\n```\\nOr you can write the code like the following by string `find` function. \\n```C++\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return (s.find(\"1\") == string::npos) == (t.find(\"1\") == string::npos);\\n    }\\n};\\n```\\n\\n\\n# Observation\\nLet\\'s list the truth table to show the relationship of  two bits.\\n```\\nO:OR, X:XOR\\n           O X   X O  \\n    0 0 -> 0 0   0 0\\n    0 1 -> 1 1   1 1\\n    1 0 -> 1 1   1 1\\n    1 1 -> 1 0   0 1\\n```\\n# Conclusion from observation.\\n    11 can decide some bit to 0\\n    10 | 01 just can make 11.\\n    00 is still 00. \\n    If you have 1, then you can make any bit to 1.\\n    If you have 1, then you can make any bit to 0.\\n    The case contain 1 can make any case contain 1 but not all zero.\\n    If you have no \\'1\\', then you just only can keep as no \\'1\\'.\\n\\n    Have 1 and no 1 will become different group. \\n    Have 1 can change to any element that have 1\\n    \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n = s.length();\\n        int s_cnt0 = 0, t_cnt0 = 0;\\n        for(auto&c :s) if(c==\\'0\\')s_cnt0++;\\n        for(auto&c :target) if(c==\\'0\\')t_cnt0++;\\n        if(s_cnt0 == n && t_cnt0!=n) return false;\\n        if(s_cnt0 != n && t_cnt0==n) return false;\\n        return true;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return (s.find(\"1\") == string::npos) == (t.find(\"1\") == string::npos);\\n    }\\n};\\n```\n```\\nO:OR, X:XOR\\n           O X   X O  \\n    0 0 -> 0 0   0 0\\n    0 1 -> 1 1   1 1\\n    1 0 -> 1 1   1 1\\n    1 1 -> 1 0   0 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083803,
                "title": "0s-then-1s-no-bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int n = s.size();\\n        unordered_map<char, int> m;\\n        for(char c : s) m[c]++;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] != t[i] && s[i] == \\'0\\') {\\n                m[\\'0\\']--;\\n                if(!m[\\'0\\']) m.erase(\\'0\\');\\n                if(m.find(\\'1\\') == m.end()) return false;\\n                m[\\'1\\']++;\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(s[i] != t[i] && s[i] == \\'1\\') {\\n                m[\\'1\\']--;\\n                if(!m[\\'1\\']) m.erase(\\'1\\');\\n                if(m.find(\\'1\\') == m.end()) return false;\\n                m[\\'0\\']++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int n = s.size();\\n        unordered_map<char, int> m;\\n        for(char c : s) m[c]++;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] != t[i] && s[i] == \\'0\\') {\\n                m[\\'0\\']--;\\n                if(!m[\\'0\\']) m.erase(\\'0\\');\\n                if(m.find(\\'1\\') == m.end()) return false;\\n                m[\\'1\\']++;\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(s[i] != t[i] && s[i] == \\'1\\') {\\n                m[\\'1\\']--;\\n                if(!m[\\'1\\']) m.erase(\\'1\\');\\n                if(m.find(\\'1\\') == m.end()) return false;\\n                m[\\'0\\']++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299486,
                "title": "count-of-one-s-one-liner-time-o-n-space-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int i,n = s.length(),a=0,b=0;\\n        for(i = 0; i < n; i++){\\n            a += (s[i]==\\'1\\');\\n            b += (target[i]==\\'1\\');\\n        }\\n        if((a==0&&b)||(b==0&&a))return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int i,n = s.length(),a=0,b=0;\\n        for(i = 0; i < n; i++){\\n            a += (s[i]==\\'1\\');\\n            b += (target[i]==\\'1\\');\\n        }\\n        if((a==0&&b)||(b==0&&a))return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086969,
                "title": "c-easy-to-undestand-simple-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) {\\n        return true;\\n    }\\n    int n = s.length();\\n    if (s == string(n, \\'0\\') || target == string(n, \\'0\\')) {\\n    return false;\\n    }\\n    return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) {\\n        return true;\\n    }\\n    int n = s.length();\\n    if (s == string(n, \\'0\\') || target == string(n, \\'0\\')) {\\n    return false;\\n    }\\n    return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084563,
                "title": "o-1-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        //We check if the two strings are already equal \\n        if(s==target)\\n        {\\n            return true;\\n        }\\n        int n = target.size();\\n        int count=0, count0=0, count1=0;\\n        int count0T=0, count1T=0;\\n        //We try to find out if all the characters are 0\\'s in either the given stri9ng s or the target string as in any case it is not possible for any string to givea target string contaning all 0\\'s  either than itself coz only (0 XOR 0 =0 )and (0 OR 0) = 0\\n        //Also if the given string contains all 0\\'s then they can\\'t create any other string that itself coz (0 XOR 0) = 0 and (0 OR 0)=0\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                count0++;\\n            }\\n            else\\n            {\\n                count1++;\\n            }\\n            if(target[i]==\\'0\\')\\n            {\\n                count0T++;\\n            }\\n            else\\n            {\\n                count1T++;\\n            }\\n            count++;\\n        }\\n        if(count==count0)\\n        {\\n            return false;\\n        }\\n        if(count0T==count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\nPlease Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        //We check if the two strings are already equal \\n        if(s==target)\\n        {\\n            return true;\\n        }\\n        int n = target.size();\\n        int count=0, count0=0, count1=0;\\n        int count0T=0, count1T=0;\\n        //We try to find out if all the characters are 0\\'s in either the given stri9ng s or the target string as in any case it is not possible for any string to givea target string contaning all 0\\'s  either than itself coz only (0 XOR 0 =0 )and (0 OR 0) = 0\\n        //Also if the given string contains all 0\\'s then they can\\'t create any other string that itself coz (0 XOR 0) = 0 and (0 OR 0)=0\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                count0++;\\n            }\\n            else\\n            {\\n                count1++;\\n            }\\n            if(target[i]==\\'0\\')\\n            {\\n                count0T++;\\n            }\\n            else\\n            {\\n                count1T++;\\n            }\\n            count++;\\n        }\\n        if(count==count0)\\n        {\\n            return false;\\n        }\\n        if(count0T==count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\nPlease Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084514,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf both the strings have atleast one 1 then it is possible to convert string s into string target. But in case of both having only zeroes is also possible.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size();\\n        bool f=0,g=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                f=1;\\n            if(target[i]==\\'1\\')\\n                g=1;\\n        }\\n        if(f && g)\\n            return 1;\\n        if(!f && !g)\\n            return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size();\\n        bool f=0,g=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                f=1;\\n            if(target[i]==\\'1\\')\\n                g=1;\\n        }\\n        if(f && g)\\n            return 1;\\n        if(!f && !g)\\n            return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084148,
                "title": "2-line-xor-concept-c-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        // base case\\n        if(s == target) return true;\\n        string z = string(s.size(), \\'0\\'); // z is a string of length s and all the characters are 0\\n        return s != z && target != z;\\n        // because if all the characters are 0, then according to xor concept\\n        // we can only achieve 1 if we have (0 and 1) or (1 and 0). But not using (0 and 0) so-\\n        // if any of the string are filled with all zeroes, then it\\'s not possible otherwise it\\'s possible to change.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        // base case\\n        if(s == target) return true;\\n        string z = string(s.size(), \\'0\\'); // z is a string of length s and all the characters are 0\\n        return s != z && target != z;\\n        // because if all the characters are 0, then according to xor concept\\n        // we can only achieve 1 if we have (0 and 1) or (1 and 0). But not using (0 and 0) so-\\n        // if any of the string are filled with all zeroes, then it\\'s not possible otherwise it\\'s possible to change.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343180,
                "title": "the-logic-behind-the-solution",
                "content": "# Intuition\\nTo check what bits should we choose to convert a 0 to 1 or 1 to 0 lets construct the truth table\\nBit1 Bit2 OR XOR\\n0    0   -> 0   0\\n0    1   -> 1   1\\n1    0   -> 1   1\\n1    1   -> 1   0\\nHere we can see that 0 0 can be reached from 0 0 only. So neither of the strings(source or target) should be completely zero. Because in order to convert the last 1 to zero we dont have any 1 left. \\n\\n# Approach\\nCheck if both the strings are equal already then return true.\\nElse if any of the strings is completely 0. eg 0000 or 000000. return false else true;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n//     bit1 bit2  OR XOR\\n//     0    0 ->   0   0\\n//     0    1 ->   1   1\\n//     1    0 ->   1   1\\n//     1    1 ->   1   0\\n//     0 0 can only be reached from two zeroes. So neither of the strings should be all zeroes or both should be all zeroes.\\n\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target) return true;\\n        bool sIsZero= true;\\n        bool tIsZero= true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\') sIsZero=false;\\n            if(target[i]==\\'1\\') tIsZero=false;\\n        }\\n        if(sIsZero || tIsZero) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n//     bit1 bit2  OR XOR\\n//     0    0 ->   0   0\\n//     0    1 ->   1   1\\n//     1    0 ->   1   1\\n//     1    1 ->   1   0\\n//     0 0 can only be reached from two zeroes. So neither of the strings should be all zeroes or both should be all zeroes.\\n\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target) return true;\\n        bool sIsZero= true;\\n        bool tIsZero= true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\') sIsZero=false;\\n            if(target[i]==\\'1\\') tIsZero=false;\\n        }\\n        if(sIsZero || tIsZero) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277946,
                "title": "intuitive-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s == target) return true;\\n        int count1=0,count2=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s[i]==\\'0\\') count1++; \\n        if(count1==s.length()) return false;\\n         for(int i=0;i<target.length();i++)\\n        if(target[i]==\\'0\\') count2++; \\n        if(count2==target.length()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s == target) return true;\\n        int count1=0,count2=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s[i]==\\'0\\') count1++; \\n        if(count1==s.length()) return false;\\n         for(int i=0;i<target.length();i++)\\n        if(target[i]==\\'0\\') count2++; \\n        if(count2==target.length()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096552,
                "title": "not-hard-at-all",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, t: String) -> bool {\\n        let n = s.len();\\n        \\n        let data_s = s.chars().fold((0, 0), |a, b| if b == \\'0\\' {(a.0 + 1, a.1)} else {(a.0, a.1 + 1)});\\n        let data_t = t.chars().fold((0, 0), |a, b| if b == \\'0\\' {(a.0 + 1, a.1)} else {(a.0, a.1 + 1)});\\n        \\n        /*\\n        If 0\\'s in s == n?\\n            if t has a single one = false\\n        if 0\\'s in t == n but 0\\'s in s != n\\n        */\\n        \\n        if data_s.0 == n {\\n            data_t.0 == n \\n        } else if data_t.0 == n { \\n            false\\n        } else {\\n            true\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, t: String) -> bool {\\n        let n = s.len();\\n        \\n        let data_s = s.chars().fold((0, 0), |a, b| if b == \\'0\\' {(a.0 + 1, a.1)} else {(a.0, a.1 + 1)});\\n        let data_t = t.chars().fold((0, 0), |a, b| if b == \\'0\\' {(a.0 + 1, a.1)} else {(a.0, a.1 + 1)});\\n        \\n        /*\\n        If 0\\'s in s == n?\\n            if t has a single one = false\\n        if 0\\'s in t == n but 0\\'s in s != n\\n        */\\n        \\n        if data_s.0 == n {\\n            data_t.0 == n \\n        } else if data_t.0 == n { \\n            false\\n        } else {\\n            true\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3093965,
                "title": "java-easy-sol-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\")==target.contains(\"1\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\")==target.contains(\"1\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093137,
                "title": "easy-to-understand-detail-explanation",
                "content": "The first thing which came in my mind is that when given string contain all zeroes 00000 and target is like 10101 and vice versa. In this case we can\\'t make string equal. And second if both given string and target string both are same like s=\"00000\" and target = \"00000\" then we return true. and after that all case will be true.\\n\\n1.Count the number of 1 in both string.\\n2.if countS == 0 or countT = 0 then in this case we check s == target then we return true and if not then it will be false.\\n3.In the end we will return True.\\n\\nTC: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int countS = 0, countT = 0;\\n        countS = count(s.begin(),s.end(),\\'1\\');\\n        countT = count(target.begin(),target.end(),\\'1\\');\\n        if(countS == 0 || countT == 0) return s == target;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int countS = 0, countT = 0;\\n        countS = count(s.begin(),s.end(),\\'1\\');\\n        countT = count(target.begin(),target.end(),\\'1\\');\\n        if(countS == 0 || countT == 0) return s == target;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089346,
                "title": "1-line-solution-direct-return-coding-is-fun",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        string st(s.length(),\\'0\\');\\n        return !(s==st ^ st==target) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        string st(s.length(),\\'0\\');\\n        return !(s==st ^ st==target) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088661,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int c0s=count(s.begin(), s.end(), \\'0\\'), c1s=count(s.begin(), s.end(), \\'1\\'), c0t=count(target.begin(), target.end(), \\'0\\'), c1t=count(target.begin(), target.end(), \\'1\\');\\n        if((c1s && c1t==0) || (c1s==0 && c1t)){return false;}\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int c0s=count(s.begin(), s.end(), \\'0\\'), c1s=count(s.begin(), s.end(), \\'1\\'), c0t=count(target.begin(), target.end(), \\'0\\'), c1t=count(target.begin(), target.end(), \\'1\\');\\n        if((c1s && c1t==0) || (c1s==0 && c1t)){return false;}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086631,
                "title": "easy-peasy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int scn=0, tcn=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'1\\') scn++;\\n            if(t[i]==\\'1\\') tcn++;\\n        }\\n        if(scn==0 && tcn==0) return true;\\n        return !(scn==0 || tcn==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int scn=0, tcn=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'1\\') scn++;\\n            if(t[i]==\\'1\\') tcn++;\\n        }\\n        if(scn==0 && tcn==0) return true;\\n        return !(scn==0 || tcn==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086163,
                "title": "python3-golang-rust-count-one",
                "content": "We have to check if one of the strings contains 1 and the other does not, and vice versa. If both have it, then we can bring our string s equal to the target.\\n\\n**Python3**:\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return \\'1\\' in s and \\'1\\' in target or \\'1\\' not in target and \\'1\\' not in s\\n```\\n\\n**Golang**:\\n```\\nfunc makeStringsEqual(s string, target string) bool {\\n    s_check, target_check := strings.Contains(s, \"1\"), strings.Contains(target, \"1\")\\n    \\n    if (s_check == true && target_check == false) || (s_check == false && target_check == true) {\\n        return false\\n    } else {\\n        return true\\n    }\\n}\\n```\\n\\n**Rust**:\\n```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, target: String) -> bool {\\n        return (!s.contains(\"1\") && !target.contains(\"1\")) || (s.contains(\"1\") && target.contains(\"1\"))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return \\'1\\' in s and \\'1\\' in target or \\'1\\' not in target and \\'1\\' not in s\\n```\n```\\nfunc makeStringsEqual(s string, target string) bool {\\n    s_check, target_check := strings.Contains(s, \"1\"), strings.Contains(target, \"1\")\\n    \\n    if (s_check == true && target_check == false) || (s_check == false && target_check == true) {\\n        return false\\n    } else {\\n        return true\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, target: String) -> bool {\\n        return (!s.contains(\"1\") && !target.contains(\"1\")) || (s.contains(\"1\") && target.contains(\"1\"))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085893,
                "title": "java-2-solutions",
                "content": "# Please Upvote :D\\n---\\n- If the strings are already equal, we don\\'t need to perform any operation.\\n- If we have atleast one `1` in both `s` and `target`, we can make them equal.\\n``` java []\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if (s.equals(target)) {     // if already equal\\n            return true;\\n        }\\n        // if both have 1s, return true, otherwise false\\n        return hasOnes(s) && hasOnes(target); \\n    }\\n    \\n    // method to check if the string has 1s\\n    private boolean hasOnes(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n#### Using the same idea, we can make the solution much shorter:\\n\\n- When both `s` and `target` have 1s, `true == true` returns `true`.\\n- If only either of them has 1s, then `false == true` or `true == false` returns `false`.\\n- If none of them has 1s, `false == false` returns `true`.\\n``` java []\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if (s.equals(target)) {     // if already equal\\n            return true;\\n        }\\n        // if both have 1s, return true, otherwise false\\n        return hasOnes(s) && hasOnes(target); \\n    }\\n    \\n    // method to check if the string has 1s\\n    private boolean hasOnes(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085651,
                "title": "java-easy-to-understand-bitwise-operations",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        int n=s.length();\\n        \\n        int a=0, b=0;\\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                a++;\\n            }\\n            if(t.charAt(i)==\\'1\\'){\\n                b++;\\n            }\\n            \\n        }\\n      if(a>0 && b==0){\\n          return false;\\n      }\\n        if(a==0 && b>0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        int n=s.length();\\n        \\n        int a=0, b=0;\\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                a++;\\n            }\\n            if(t.charAt(i)==\\'1\\'){\\n                b++;\\n            }\\n            \\n        }\\n      if(a>0 && b==0){\\n          return false;\\n      }\\n        if(a==0 && b>0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085002,
                "title": "best-approach-short-and-easy-beats-88",
                "content": "\\n# Approach\\n1. If \\'1\\' is present in a string then \\'0\\' XOR with \\'1\\' is 1 .\\n2.  Check only \\'1\\' is present in string or not.\\n3. if 1 is present then update value of x1=1,x2=1.\\n4. And if both value is 1 then take  x1 &&  x2. \\n\\n# Complexity\\n- Time complexity:  O(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)return true;\\n        int x1=0,x2=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\')x1=1;\\n            if(target[i]==\\'1\\')x2=1;\\n        }\\n        return  x1 && x2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)return true;\\n        int x1=0,x2=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\')x1=1;\\n            if(target[i]==\\'1\\')x2=1;\\n        }\\n        return  x1 && x2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084907,
                "title": "count-no-of-zero-s-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int x = 0, y = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            x += (s[i]==\\'0\\');\\n            y += (t[i]==\\'0\\');\\n        }\\n        if(x==s.length()&&y==t.length()){\\n            return true;\\n        }else if((y == t.length()&&s.length())||(x==s.length()&&y!=t.length())){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int x = 0, y = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            x += (s[i]==\\'0\\');\\n            y += (t[i]==\\'0\\');\\n        }\\n        if(x==s.length()&&y==t.length()){\\n            return true;\\n        }else if((y == t.length()&&s.length())||(x==s.length()&&y!=t.length())){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084881,
                "title": "c-one-liner-beats-100",
                "content": "![dfa3bbb407676ac62e58d6fccf8f7743.jpg (1).png](https://assets.leetcode.com/users/images/65ae5daa-1729-4e8f-8520-9d623dc50852_1674371945.377967.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool MakeStringsEqual(string s, string target) \\n    {\\n        return s.Contains(\"1\") == target.Contains(\"1\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool MakeStringsEqual(string s, string target) \\n    {\\n        return s.Contains(\"1\") == target.Contains(\"1\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084851,
                "title": "2-lines-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if \\'1\\' in s and \\'1\\' not in target or (\\'1\\' in target and \\'1\\' not in s):\\n            return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if \\'1\\' in s and \\'1\\' not in target or (\\'1\\' in target and \\'1\\' not in s):\\n            return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084763,
                "title": "didn-t-realise-that-1-has-so-much-power-easy-approach-explained",
                "content": "# Approach\\uD83E\\uDDE0\\n<!-- Describe your approach to solving the problem. -->\\n- Case 1 :\\'1\\' in s and \\'0\\' in target\\n\\n1.If we have \\'1\\' in s and \\'0\\' in target we can take help from another \\'1\\' in s to place \\'0\\' .\\n```\\ni.e (1^1=0) & (1|1=1) .\\n```\\n\\n2.If there is no \\'1\\' available we can create an additional \\'1\\' by using \\'0\\' as below\\n```\\ni.e (1^0=1) & (1|0=1) .\\n```\\nand then using that \\'1\\' as in first point .\\nHere if the target is string containing all \\'0\\' then we cannot make s and target equal as there would always be one \\'1\\' in s .\\n\\n\\n- Case 2 :\\'0\\' in s and \\'1\\' in target\\n\\n1.If we have \\'0\\' in s and \\'1\\' in target we can take help from a \\'1\\' in s to place \\'1\\'  .\\n```\\ni.e (0^1=1) & (0|1=1) .\\n```\\n2.If there is no \\'1\\' available we cannot make s and target equal .\\nbecause : (0^0=0) && (0|0=0) .(s is string containing all \\'0\\' in this situation)\\n\\n\\n#### \\uD83C\\uDF1FSo only thing we need to check is either number of \\'1\\' in both s and target is 0 \\n\\'OR\\' \\n#### both s and target should have atleast one \\'1\\'.\\n\\n----\\n\\n# Complexity\\u231B\\n## - Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n## - Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n----\\n# Code \\n## *C++ :*\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size();\\n        bool chk1=0,chk2=0;\\n        for(int i=0 ; i<n; i++){\\n            if(s[i]&1){\\n                chk1=true;\\n                break;\\n            }\\n        }\\n        for(int i=0 ; i<n; i++){\\n            if(target[i]&1){\\n                chk2=true;\\n                break;\\n            }\\n        }\\n        return (chk1==chk2);\\n    }\\n};\\n```\\n\\n# Code \\n## *Python3 :*\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        c1=False\\n        c2=False\\n        for i in s :\\n            if(i==\\'1\\') :\\n                c1=True\\n                break\\n        for i in target :\\n            if(i==\\'1\\') :\\n                c2=True\\n                break\\n        return c1==c2\\n```\\n# Code \\n## *Javascript :*\\n```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n    let n=s.length;\\n    let c1=false,c2=false;\\n    for(let i=0 ; i<n;  i++){\\n        if(s[i]&1){\\n            c1=true;\\n            break;\\n        }\\n    }\\n    for(let i=0 ; i<n;  i++){\\n        if(target[i]&1){\\n            c2=true;\\n            break;\\n        }\\n    }\\n    return c1==c2;\\n};\\n```\\n### DO UPOTE if it helped you .\\n![image.png](https://assets.leetcode.com/users/images/b7a3d428-0ed6-4a35-a666-b173e881d8dc_1674370889.0894904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\ni.e (1^1=0) & (1|1=1) .\\n```\n```\\ni.e (1^0=1) & (1|0=1) .\\n```\n```\\ni.e (0^1=1) & (0|1=1) .\\n```\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size();\\n        bool chk1=0,chk2=0;\\n        for(int i=0 ; i<n; i++){\\n            if(s[i]&1){\\n                chk1=true;\\n                break;\\n            }\\n        }\\n        for(int i=0 ; i<n; i++){\\n            if(target[i]&1){\\n                chk2=true;\\n                break;\\n            }\\n        }\\n        return (chk1==chk2);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        c1=False\\n        c2=False\\n        for i in s :\\n            if(i==\\'1\\') :\\n                c1=True\\n                break\\n        for i in target :\\n            if(i==\\'1\\') :\\n                c2=True\\n                break\\n        return c1==c2\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n    let n=s.length;\\n    let c1=false,c2=false;\\n    for(let i=0 ; i<n;  i++){\\n        if(s[i]&1){\\n            c1=true;\\n            break;\\n        }\\n    }\\n    for(let i=0 ; i<n;  i++){\\n        if(target[i]&1){\\n            c2=true;\\n            break;\\n        }\\n    }\\n    return c1==c2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084298,
                "title": "java-count-approach-easiest-ac",
                "content": "if both strings are equal return true\\nelse\\ncheck for atleast 1 string having 1.\\nif it satisfy the condition return true else false.\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target))return true;\\n        int t = 0, a = 0;\\n       \\n        for(int i=0;i<s.length();i++){\\n            a+=s.charAt(i)-\\'0\\';\\n            t+=target.charAt(i)-\\'0\\';\\n        }\\n        if(a > 0 && t > 0 || a == 0 && t == 0) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target))return true;\\n        int t = 0, a = 0;\\n       \\n        for(int i=0;i<s.length();i++){\\n            a+=s.charAt(i)-\\'0\\';\\n            t+=target.charAt(i)-\\'0\\';\\n        }\\n        if(a > 0 && t > 0 || a == 0 && t == 0) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084277,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target)) return true;\\n        int s1 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') s1++;\\n            if(target.charAt(i) == \\'1\\') t1++;\\n        }\\n        return s1 > 0 && t1 > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target)) return true;\\n        int s1 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') s1++;\\n            if(target.charAt(i) == \\'1\\') t1++;\\n        }\\n        return s1 > 0 && t1 > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084247,
                "title": "c-2-solutions-one-liner-solution-brute-force-with-explanation",
                "content": "# Method 1: Brute Force\\nHere, we check\\n```\\nFalse Conditions\\n1) If number of 1s(string s)>=1 and number of 1s(string t)==0.\\n2) If number of 1s(string s)==0 and number of 1s(string t)>=1.\\n3) If number of 1s & 0s(string s)>=1 and \\n   number of 1s and 0s(string t)==0\\n\\nElse True\\n```\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n            if(s==t) return true;   //If equal\\n            int o= 0,z= 0;          //For one and zero\\n            for(char ch : s){\\n                if(ch == \\'0\\') z++;  //Zero\\n                else o++;           //One\\n            }\\n            if((o>=1 and t.find(\\'1\\') == -1) or (o==0 and t.find(\\'1\\') != -1)) return false;\\n            if((!o and !z) and (t.find(\\'0\\') == -1 and t.find(\\'1\\') == -1)) return false;\\n            return true;\\n        }\\n};\\n```\\n# Method 2: Optimized\\nIf there is atleast one `1`, then we can make any bit to `1 or 0`.\\n```\\n bool makeStringsEqual(string s, string t) {\\n        if(s==t) return true;\\n        return (count(begin(s),end(s),\\'1\\')>=1 and count(begin(t),end(t),\\'1\\')>=1) ;\\n    }\\n\\n```\\nPlease upvote \\uD83E\\uDD20\\uD83C\\uDF83",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nFalse Conditions\\n1) If number of 1s(string s)>=1 and number of 1s(string t)==0.\\n2) If number of 1s(string s)==0 and number of 1s(string t)>=1.\\n3) If number of 1s & 0s(string s)>=1 and \\n   number of 1s and 0s(string t)==0\\n\\nElse True\\n```\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n            if(s==t) return true;   //If equal\\n            int o= 0,z= 0;          //For one and zero\\n            for(char ch : s){\\n                if(ch == \\'0\\') z++;  //Zero\\n                else o++;           //One\\n            }\\n            if((o>=1 and t.find(\\'1\\') == -1) or (o==0 and t.find(\\'1\\') != -1)) return false;\\n            if((!o and !z) and (t.find(\\'0\\') == -1 and t.find(\\'1\\') == -1)) return false;\\n            return true;\\n        }\\n};\\n```\n```\\n bool makeStringsEqual(string s, string t) {\\n        if(s==t) return true;\\n        return (count(begin(s),end(s),\\'1\\')>=1 and count(begin(t),end(t),\\'1\\')>=1) ;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084233,
                "title": "c-most-easy-to-understand-solution",
                "content": "**Solved it by Considering Different TestCases**\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int cnts=0,cntt=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'1\\')\\n                cnts++;\\n        }\\n        for(char c:target)\\n        {\\n            if(c==\\'1\\')\\n                cntt++;\\n        }\\n        if(cnts==0 and cntt==0)\\n            return true;\\n        else if(cnts>0 and cntt>0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int cnts=0,cntt=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'1\\')\\n                cnts++;\\n        }\\n        for(char c:target)\\n        {\\n            if(c==\\'1\\')\\n                cntt++;\\n        }\\n        if(cnts==0 and cntt==0)\\n            return true;\\n        else if(cnts>0 and cntt>0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084095,
                "title": "c-easy-peasy-solution-3-lines-code",
                "content": "\\n\\n# pls upvote if my solution helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) return true; \\n        string zero = string(s.size(), \\'0\\'); \\n        return s != zero && target != zero; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) return true; \\n        string zero = string(s.size(), \\'0\\'); \\n        return s != zero && target != zero; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083985,
                "title": "my-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        int n = s.length();\\n        int sc0=0, sc1=0; // count of zeroes and ones in string s\\n        int zto = 0, otz = 0; //zto --> count of zeroes that need to be converted to ones, otz --> ones that need to be converted to zero\\n        \\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i) == \\'0\\') sc0++;\\n            else sc1++;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                if(s.charAt(i) == \\'1\\') otz++;\\n                else zto++;\\n            }\\n        }\\n        int cnt=0;\\n\\t\\t\\n\\t\\t// we first convert zeroes to ones because to convert ones to zeroes, we need more ones. hence it is safe to first convert the required number of zeroes to ones\\n        while(cnt < zto){\\n            if(sc1 > 0){\\n                sc1++;\\n                sc0--;\\n                cnt++;\\n            }\\n            else return false;\\n        }\\n        \\n        cnt=0;\\n        while(cnt<otz){\\n            if(sc1 > 1){\\n                sc1--;\\n                sc0++;\\n                cnt++;\\n            }\\n            else return false;\\n        }\\n    \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        int n = s.length();\\n        int sc0=0, sc1=0; // count of zeroes and ones in string s\\n        int zto = 0, otz = 0; //zto --> count of zeroes that need to be converted to ones, otz --> ones that need to be converted to zero\\n        \\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i) == \\'0\\') sc0++;\\n            else sc1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3083887,
                "title": "java-solution-check-if-only-0-or-1-in-strings",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        if(s.equals(t)) return true;\\n        //s has only \"0\"\\n        boolean s0 = s.indexOf(\"1\") == -1;\\n        //s has only \"1\"\\n        boolean s1 = s.indexOf(\"0\") == -1;\\n        //t has only \"0\"\\n        boolean t0 = t.indexOf(\"1\") == -1;\\n        //t has only \"1\"\\n        boolean t1 = t.indexOf(\"0\") == -1;\\n        return !(s0 || t0 || s1 && t0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        if(s.equals(t)) return true;\\n        //s has only \"0\"\\n        boolean s0 = s.indexOf(\"1\") == -1;\\n        //s has only \"1\"\\n        boolean s1 = s.indexOf(\"0\") == -1;\\n        //t has only \"0\"\\n        boolean t0 = t.indexOf(\"1\") == -1;\\n        //t has only \"1\"\\n        boolean t1 = t.indexOf(\"0\") == -1;\\n        return !(s0 || t0 || s1 && t0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083825,
                "title": "c-set-for-o-and-1-index",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        set<int> so,sz;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') so.insert(i);\\n            else sz.insert(i);\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i] != target[i]){\\n                if(s[i]==\\'0\\'){\\n                    if(so.size()>0){\\n                        s[i] = \\'1\\';\\n                        so.insert(i);\\n                        sz.erase(i);\\n                    }else{\\n                        return false;\\n                    }\\n                }else{\\n                    if(so.size()>=2){\\n                        s[i] = \\'0\\';\\n                        so.erase(i);\\n                    }else {\\n                        if(sz.size()){\\n                            int x = *(sz.rbegin());\\n                            if(x>i){\\n                                s[x] = \\'1\\';\\n                                s[i] = \\'0\\';\\n                                sz.erase(x);\\n                                so.insert(x);\\n                                so.erase(i);    \\n                            }else{\\n                                return false;\\n                            }\\n                        }else{\\n                            return false;\\n                        }\\n                        \\n                    }\\n                }\\n            }else if(s[i]==\\'0\\'){\\n                sz.erase(i);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        set<int> so,sz;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') so.insert(i);\\n            else sz.insert(i);\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i] != target[i]){\\n                if(s[i]==\\'0\\'){\\n                    if(so.size()>0){\\n                        s[i] = \\'1\\';\\n                        so.insert(i);\\n                        sz.erase(i);\\n                    }else{\\n                        return false;\\n                    }\\n                }else{\\n                    if(so.size()>=2){\\n                        s[i] = \\'0\\';\\n                        so.erase(i);\\n                    }else {\\n                        if(sz.size()){\\n                            int x = *(sz.rbegin());\\n                            if(x>i){\\n                                s[x] = \\'1\\';\\n                                s[i] = \\'0\\';\\n                                sz.erase(x);\\n                                so.insert(x);\\n                                so.erase(i);    \\n                            }else{\\n                                return false;\\n                            }\\n                        }else{\\n                            return false;\\n                        }\\n                        \\n                    }\\n                }\\n            }else if(s[i]==\\'0\\'){\\n                sz.erase(i);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083823,
                "title": "greedy-one-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        return  count(s.begin(),s.end(),\\'1\\') and count(target.begin(),target.end(),\\'1\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        return  count(s.begin(),s.end(),\\'1\\') and count(target.begin(),target.end(),\\'1\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083778,
                "title": "c-count-simple-solution-o-n",
                "content": "\\nif source == target return true;\\nwe need atleast single 1 in target (can\\'t have all 0 in target)\\nwe need atleast single 1 in source to convert 0 to 1 or 1 to 0\\n- converting 0 to 1 is easy if we have even single 1 but converting 1 to 0 require atleast the same number of 1s in source \\n```\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) return true;\\n        \\n        int sourceOneCount = 0, targetOneCount = 0, sourceToTargetOneCount = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'1\\') sourceOneCount++; \\n            if (target[i] == \\'0\\' && s[i] == \\'1\\') sourceToTargetOneCount++;\\n            if (target[i] == \\'1\\') targetOneCount++;\\n        }\\n        \\n        if (sourceToTargetOneCount <= sourceOneCount && targetOneCount > 0 && sourceOneCount > 0) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) return true;\\n        \\n        int sourceOneCount = 0, targetOneCount = 0, sourceToTargetOneCount = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'1\\') sourceOneCount++; \\n            if (target[i] == \\'0\\' && s[i] == \\'1\\') sourceToTargetOneCount++;\\n            if (target[i] == \\'1\\') targetOneCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3083776,
                "title": "it-requires-one-1-to-perform-each-operation",
                "content": "## STEPS: \\n### Step 1: understand the table \\n```\\n|  i  |  j  |  OR  |  XOR  |\\n|  0  |  0  |  0   |   0   | CASE 1\\n|  1  |  1  |  1   |   0   | CASE 2\\n|  1  |  0  |  1   |   1   | CASE 3\\n|  0  |  1  |  1   |   1   | CASE 4\\n```\\n```\\nCASE 1: \\n- this is a trivial case because none of the i or j is flipped\\nCASE 2: [1 to 0]\\n- this is the case where j is flipped from 1 to 0 \\nCASE 3: [0 to 1]\\n- this is the case where j is flipped from 0 to 1 \\nCASE 4: [0 to 1]\\n- this is the case where i is flipped from 0 to 1 \\n```\\n\\n### Step 2: Gather the insights from above cases\\n```\\n- if we want to convert 1 to 0 there is just one way by making the i as j \\n- if we want to convert 0 to 1, there are 2 ways, either by making 0 as i or j\\n```\\n**[\\uD83E\\uDD29This is the main insight\\uD83E\\uDD29] In all the 3 cases, CASE 1, CASE 2, CASE 3, we will require one 1 to make the operation.**\\n\\n\\n### Step 3: \"One 1 to make each operation\"\\n```\\n- since we require \"1\" to make each operation, we can first convert those zeros which are ones in the target\\n- So that we get more ones in the \"s\" string\\n- now the total ones will be: ones initially + zeros that are flipped to ones\\n- totalOnes = ones initially + zeroToOne\\n- [fake ones \\uD83D\\uDE44] out of which certain 1s are the ones which are to be converted from 1 to 0 \\n- [real ones \\uD83E\\uDD70] are the ones which are not fake\\n  so realOne = totalOnes - oneToZero\\n\\n```\\n\\n# Code\\n```\\nbool makeStringsEqual(string s, string t) {\\n        int n = s.length();\\n        int ones = 0, zeroToOne = 0, oneToZero = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\') ones++;\\n            if(s[i] == \\'0\\' && t[i] == \\'1\\') zeroToOne++;\\n            if(s[i] == \\'1\\' && t[i] == \\'0\\') oneToZero++;\\n        }\\n        int totalOnes, realOnes;\\n        if(zeroToOne == 0 && oneToZero == 0) return true;\\n        if(ones <= 0) return false;\\n\\n        totalOnes = ones + zeroToOne;\\n        realOnes = totalOnes - oneToZero;\\n        if(realOnes > 0) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n|  i  |  j  |  OR  |  XOR  |\\n|  0  |  0  |  0   |   0   | CASE 1\\n|  1  |  1  |  1   |   0   | CASE 2\\n|  1  |  0  |  1   |   1   | CASE 3\\n|  0  |  1  |  1   |   1   | CASE 4\\n```\n```\\nCASE 1: \\n- this is a trivial case because none of the i or j is flipped\\nCASE 2: [1 to 0]\\n- this is the case where j is flipped from 1 to 0 \\nCASE 3: [0 to 1]\\n- this is the case where j is flipped from 0 to 1 \\nCASE 4: [0 to 1]\\n- this is the case where i is flipped from 0 to 1 \\n```\n```\\n- if we want to convert 1 to 0 there is just one way by making the i as j \\n- if we want to convert 0 to 1, there are 2 ways, either by making 0 as i or j\\n```\n```\\n- since we require \"1\" to make each operation, we can first convert those zeros which are ones in the target\\n- So that we get more ones in the \"s\" string\\n- now the total ones will be: ones initially + zeros that are flipped to ones\\n- totalOnes = ones initially + zeroToOne\\n- [fake ones \\uD83D\\uDE44] out of which certain 1s are the ones which are to be converted from 1 to 0 \\n- [real ones \\uD83E\\uDD70] are the ones which are not fake\\n  so realOne = totalOnes - oneToZero\\n\\n```\n```\\nbool makeStringsEqual(string s, string t) {\\n        int n = s.length();\\n        int ones = 0, zeroToOne = 0, oneToZero = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\') ones++;\\n            if(s[i] == \\'0\\' && t[i] == \\'1\\') zeroToOne++;\\n            if(s[i] == \\'1\\' && t[i] == \\'0\\') oneToZero++;\\n        }\\n        int totalOnes, realOnes;\\n        if(zeroToOne == 0 && oneToZero == 0) return true;\\n        if(ones <= 0) return false;\\n\\n        totalOnes = ones + zeroToOne;\\n        realOnes = totalOnes - oneToZero;\\n        if(realOnes > 0) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083763,
                "title": "easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n(0, 0) => 0 OR 0 = 0, 0 XOR 0 = 0\\n(0, 1) => 0 OR 1 = 1, 0 XOR 1 = 1\\n(1, 1) => 1 OR 1 = 1, 1 XOR 1 = 0\\n\\nWith OR and XOR operations we can convert:\\n0, 0 => 0, 0\\n0, 1 => 1, 1\\n1, 1 => 0, 1\\n\\nIf you observe the pattern, we can convert any (0, 1) to (1, 1) and vice versa. **\\'1\\' plays important role.**\\nFrom this we can deduce following:\\n1. If we have at least one \\'1\\'\\n    - We are stuck with \\'1\\' at the end. We can\\'t convert it all to \\'0\\'.\\n    - We can convert it all to \\'1\\' or combination of \\'0\\' and \\'1\\'.\\n    - So, target string should at least have one \\'1\\'.\\n2. If we have zero \\'1\\', means all are \\'0\\'\\n    - \\'0\\' can only be converted to \\'0\\', can\\'t convert it to \\'1\\'.\\n    - So, target string should also have zero \\'1\\'.\\n \\n**Conclusion: Either both strings should have at least \\'1\\' or no \\'1\\'.**\\n\\n# Approach\\nCheck if both strings have at least \\'1\\' or no \\'1\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the string.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool MakeStringsEqual(string s, string target) {\\n        bool s_one = false, target_one = false;\\n        for (var i = 0; i < s.Length && (!s_one || !target_one); i++) {            \\n            if (s[i] == \\'1\\')    s_one = true;\\n            if (target[i] == \\'1\\')   target_one = true;\\n        }\\n        \\n        return !(s_one ^ target_one);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool MakeStringsEqual(string s, string target) {\\n        bool s_one = false, target_one = false;\\n        for (var i = 0; i < s.Length && (!s_one || !target_one); i++) {            \\n            if (s[i] == \\'1\\')    s_one = true;\\n            if (target[i] == \\'1\\')   target_one = true;\\n        }\\n        \\n        return !(s_one ^ target_one);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083760,
                "title": "javascript-4-observations",
                "content": "**Solution: 4 Observations**\\n\\nOutcomes of the 4 different situations:\\n1.   `11 -> 10`\\n1.   `10 -> 11`\\n1.   `01 -> 11`\\n1.   `00 -> 00`\\n\\nObservations:\\n1. If `s` only has `\"0\"`s and target has a `\"1\"`, it is impossible because we can never get a `\"1\"` from `\"0\"`s.\\n2. No matter how many `\"1\"`s we try to remove, there will always be one left because `11 -> 10`. Therefore if `s` has `\"1\"`s and target has only `\"0\"`s, it is impossible.\\n3. As long as we have at least one `\"1\"`, we can produce as many or at little `\"1\"`s as we like (must be more than `0`).\\n   * Getting more `\"1\"`s: `01 -> 11`, `10 -> 11`.\\n   * Getting less `\"1\"`s: `11 -> 10`, and `11 -> 01` if we flip the order of `(i, j)`.\\n4. Notice there is a cycle (`11 -> 10`, `10 -> 11`). Because the order of `(i, j)` doesn\\'t matter, this cycle applies for the opposite direction also. This means we can swap the order of `10 -> 01`, `01 -> 10` however we want. Swapping means we can order in any way possible.\\n\\nTo summarize the last two observations, as long as we have at least one `\"1\"` in s, we can produce as many `\"1\"`s as we need and order `s` in any way.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n```\\nvar makeStringsEqual = function(s, target) {\\n  if (!s.includes(\"1\") && target.includes(\"1\")) return false; \\n  if (s.includes(\"1\") && !target.includes(\"1\")) return false; \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeStringsEqual = function(s, target) {\\n  if (!s.includes(\"1\") && target.includes(\"1\")) return false; \\n  if (s.includes(\"1\") && !target.includes(\"1\")) return false; \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963366,
                "title": "python-medium",
                "content": "```\\nclass Solution(object):\\n    def makeStringsEqual(self, s, target):\\n        \\n        \\n        c = Counter(s)\\n        t = Counter(target)\\n        \\n        if s == target:\\n            return True\\n         \\n        if c[\"1\"] >= 1 and t[\"0\"] != len(target):\\n            return True\\n        \\n        \\n        \\n        return False\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeStringsEqual(self, s, target):\\n        \\n        \\n        c = Counter(s)\\n        t = Counter(target)\\n        \\n        if s == target:\\n            return True\\n         \\n        if c[\"1\"] >= 1 and t[\"0\"] != len(target):\\n            return True\\n        \\n        \\n        \\n        return False\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942032,
                "title": "golang-o-n-solution",
                "content": "# Code\\n```go\\nfunc makeStringsEqual(s string, target string) bool {\\n\\t// 1, 1 -> 1, 0\\n\\t// 0, 1 -> 1, 1\\n\\t// 0, 0 -> 0, 0\\n\\tif s == target {\\n\\t\\treturn true\\n\\t}\\n\\ts0, s1, t0, t1 := 0, 0, 0, 0\\n\\tfor i := range s {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\ts0++\\n\\t\\t} else {\\n\\t\\t\\ts1++\\n\\t\\t}\\n\\t\\tif target[i] == \\'0\\' {\\n\\t\\t\\tt0++\\n\\t\\t} else {\\n\\t\\t\\tt1++\\n\\t\\t}\\n\\t}\\n\\tif s1 == 0 || t1 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc makeStringsEqual(s string, target string) bool {\\n\\t// 1, 1 -> 1, 0\\n\\t// 0, 1 -> 1, 1\\n\\t// 0, 0 -> 0, 0\\n\\tif s == target {\\n\\t\\treturn true\\n\\t}\\n\\ts0, s1, t0, t1 := 0, 0, 0, 0\\n\\tfor i := range s {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\ts0++\\n\\t\\t} else {\\n\\t\\t\\ts1++\\n\\t\\t}\\n\\t\\tif target[i] == \\'0\\' {\\n\\t\\t\\tt0++\\n\\t\\t} else {\\n\\t\\t\\tt1++\\n\\t\\t}\\n\\t}\\n\\tif s1 == 0 || t1 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917863,
                "title": "java-o-n",
                "content": "# Intuition\\ncount number of zero and one and check possible outcome combination\\n\\n# Approach\\n01->11\\n11->01 \\n\\n00->10 this is not possible \\n\\nso just create a check for this thing in the solution \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n\\n        int n = s.length();\\n\\n        int one=0;\\n        int zero=0;\\n\\n        int oneTar=0;\\n        int zeroTar=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }else{\\n                one++;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(target.charAt(i)==\\'0\\'){\\n                zeroTar++;\\n            }else{\\n                oneTar++;\\n            }\\n        }\\n\\n        int oneRange = one;\\n        if (one>0){\\n            oneRange +=zero;\\n        }\\n        int zeroRange = zero;\\n        if (one>0){\\n            zeroRange +=one-1;\\n        }\\n\\n        if (oneTar>oneRange){\\n            return false;\\n        }\\n\\n        if (zeroTar>zeroRange){\\n            return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n\\n        int n = s.length();\\n\\n        int one=0;\\n        int zero=0;\\n\\n        int oneTar=0;\\n        int zeroTar=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }else{\\n                one++;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(target.charAt(i)==\\'0\\'){\\n                zeroTar++;\\n            }else{\\n                oneTar++;\\n            }\\n        }\\n\\n        int oneRange = one;\\n        if (one>0){\\n            oneRange +=zero;\\n        }\\n        int zeroRange = zero;\\n        if (one>0){\\n            zeroRange +=one-1;\\n        }\\n\\n        if (oneTar>oneRange){\\n            return false;\\n        }\\n\\n        if (zeroTar>zeroRange){\\n            return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883158,
                "title": "easy-bit-manipulation-general-observation-4-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        // xor - different 1 || same - 0\\n        // or - 0|0 = 0 || rest = 1 \\n        bool s1 = false, s2 = false;\\n        for(auto i:s) if(i == \\'1\\') s1 = true;\\n        for(auto i:target) if(i == \\'1\\') s2 = true;\\n        if(!s1 && !s2) return true;\\n        return s1&&s2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        // xor - different 1 || same - 0\\n        // or - 0|0 = 0 || rest = 1 \\n        bool s1 = false, s2 = false;\\n        for(auto i:s) if(i == \\'1\\') s1 = true;\\n        for(auto i:target) if(i == \\'1\\') s2 = true;\\n        if(!s1 && !s2) return true;\\n        return s1&&s2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876475,
                "title": "simple-and-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif even one 1 is present in each target and s then its possible to convert to one another.\\nBecause we can generate as many 1 as the length by the operation: \\n=>op(1,0)=(1,1)\\nand we can convert any 1 to 0 by this operation:\\n=>op(1,1)= (1,0)\\nBut there is an exception, for any operation to work we need atleast one 1 as you can see, so we will need atleast one 1-bit in each s and target to convert to another.\\n# Approach\\n- check if already equal then return true\\n- check if both of them have atleast one 1-bit or not. If yes return true else return false\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) \\n    {\\n        if(s==target)return true;\\n\\n        bool is_one_present_1=0,is_one_present_2=0;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==\\'1\\'){\\n                is_one_present_1=true;\\n                break;\\n            }\\n\\n        for(int i=0;i<s.size();i++)\\n            if(target[i]==\\'1\\'){\\n                is_one_present_2=true;\\n                break;\\n            }\\n            \\n        return is_one_present_1&is_one_present_2;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) \\n    {\\n        if(s==target)return true;\\n\\n        bool is_one_present_1=0,is_one_present_2=0;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==\\'1\\'){\\n                is_one_present_1=true;\\n                break;\\n            }\\n\\n        for(int i=0;i<s.size();i++)\\n            if(target[i]==\\'1\\'){\\n                is_one_present_2=true;\\n                break;\\n            }\\n            \\n        return is_one_present_1&is_one_present_2;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846210,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int cnt1=0;\\n        int cnt2=0;\\n        int n=s.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==\\'0\\') cnt1++;\\n            if (target[i]==\\'0\\') cnt2++;\\n        }\\n        if (cnt1==n || cnt2==n) return cnt1==cnt2;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int cnt1=0;\\n        int cnt2=0;\\n        int n=s.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==\\'0\\') cnt1++;\\n            if (target[i]==\\'0\\') cnt2++;\\n        }\\n        if (cnt1==n || cnt2==n) return cnt1==cnt2;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845394,
                "title": "0-n-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int n = s.length();\\n        if(s==t)\\n        return true;\\n        int pz = 0;\\n        int dz = 0;\\n        int po = 0;\\n        int dio = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\' && t[i]==\\'1\\')\\n            dz++;\\n            else if(s[i]==\\'1\\' && t[i]==\\'0\\')\\n            dio++;\\n            else if(s[i]==\\'0\\' && t[i]==\\'0\\')\\n            pz++;\\n            else\\n            po++;\\n\\n        }\\n\\n        if(po>=1)\\n        return true;\\n\\n        if(dio>=1)\\n        {\\n            po+=dz;\\n            dz = 0;\\n        }\\n\\n        if(po>=1)\\n        return true;\\n\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int n = s.length();\\n        if(s==t)\\n        return true;\\n        int pz = 0;\\n        int dz = 0;\\n        int po = 0;\\n        int dio = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\' && t[i]==\\'1\\')\\n            dz++;\\n            else if(s[i]==\\'1\\' && t[i]==\\'0\\')\\n            dio++;\\n            else if(s[i]==\\'0\\' && t[i]==\\'0\\')\\n            pz++;\\n            else\\n            po++;\\n\\n        }\\n\\n        if(po>=1)\\n        return true;\\n\\n        if(dio>=1)\\n        {\\n            po+=dz;\\n            dz = 0;\\n        }\\n\\n        if(po>=1)\\n        return true;\\n\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672445,
                "title": "easy-solution-100-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nonly to check if both string has 1 or not.\\nif have return true, else false;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return (s.find(\\'1\\')!=string::npos)==(t.find(\\'1\\')!=string::npos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return (s.find(\\'1\\')!=string::npos)==(t.find(\\'1\\')!=string::npos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589674,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        int slen = s.length();\\n        \\n        Boolean ans1 = false;\\n        Boolean ans2 = false;\\n        for(int i = 0;i<slen;i++){\\n            if(s.charAt(i) == \\'1\\' ){\\n                ans1 = true;\\n            }\\n            if(target.charAt(i) == \\'1\\'){\\n                ans2 = true;\\n            }\\n\\n        }\\n        return ans1 == ans2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        int slen = s.length();\\n        \\n        Boolean ans1 = false;\\n        Boolean ans2 = false;\\n        for(int i = 0;i<slen;i++){\\n            if(s.charAt(i) == \\'1\\' ){\\n                ans1 = true;\\n            }\\n            if(target.charAt(i) == \\'1\\'){\\n                ans2 = true;\\n            }\\n\\n        }\\n        return ans1 == ans2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564884,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this\\n   \\n problem. -->\\n with 1 and 0 you cant only go to 0 and 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif target is only zero , the only way to succeed is if S is also zero.\\n. other case : you can go any number unless you are zeros.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nbool isEqual(char *s1, char* s2){\\n    while(*s1 != \\'\\\\0\\'){\\n        if(*s1 != *s2){\\n            return false;\\n        }\\n        s1++;\\n        s2++;\\n    }\\n    return true;\\n}\\nbool pos(char *s1){\\n    while(*s1 != \\'\\\\0\\'){\\n        if(*s1 == \\'1\\'){\\n            return true;\\n        }\\n        s1++;\\n    }\\n    return false;\\n}\\n\\nbool makeStringsEqual(char * s, char * target){\\n    return isEqual(s,target) || (pos(s) && pos(target));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isEqual(char *s1, char* s2){\\n    while(*s1 != \\'\\\\0\\'){\\n        if(*s1 != *s2){\\n            return false;\\n        }\\n        s1++;\\n        s2++;\\n    }\\n    return true;\\n}\\nbool pos(char *s1){\\n    while(*s1 != \\'\\\\0\\'){\\n        if(*s1 == \\'1\\'){\\n            return true;\\n        }\\n        s1++;\\n    }\\n    return false;\\n}\\n\\nbool makeStringsEqual(char * s, char * target){\\n    return isEqual(s,target) || (pos(s) && pos(target));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488754,
                "title": "apply-bitwise-operations-to-make-strings-equal",
                "content": "--------------- Easy C++ Solution --------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size();\\n        bool chk1=0,chk2=0;\\n        for(int i=0 ; i<n; i++){\\n            if(s[i]&1){\\n                chk1=true;\\n                break;\\n            }\\n        }\\n        for(int i=0 ; i<n; i++){\\n            if(target[i]&1){\\n                chk2=true;\\n                break;\\n            }\\n        }\\n        return (chk1==chk2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size();\\n        bool chk1=0,chk2=0;\\n        for(int i=0 ; i<n; i++){\\n            if(s[i]&1){\\n                chk1=true;\\n                break;\\n            }\\n        }\\n        for(int i=0 ; i<n; i++){\\n            if(target[i]&1){\\n                chk2=true;\\n                break;\\n            }\\n        }\\n        return (chk1==chk2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340734,
                "title": "three-line-python-solution-for-this-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt was looking tricky question, but after few minutes spending on pen and paper it was easily done.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply check if number of 1\\'s either in string \"s\" or in \"target\" is \\nzero then return False. Otherwise return True.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if s==target: return True\\n        if s.count(\"1\")==0 or target.count(\"1\")==0: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if s==target: return True\\n        if s.count(\"1\")==0 or target.count(\"1\")==0: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308319,
                "title": "math-four-situations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def hasChar(self, s, t):\\n        for c in s:\\n            if c == t:\\n                return True\\n        return False\\n\\n    def hasOne(self, s):\\n        return self.hasChar(s, \\'1\\')\\n\\n    def hasZero(self, s):\\n        return self.hasChar(s, \\'0\\')\\n\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        # 0 1 => 1 1\\n        # 0 0 => 0 0\\n        # 1 0 => 1 1\\n        # 1 1 => 1 0\\n\\n        s_one = self.hasOne(s)\\n        s_zero = self.hasZero(s)\\n        t_one = self.hasOne(target)\\n        t_zero = self.hasZero(target)\\n\\n        if not s_zero and not t_one:\\n            return False\\n            \\n        if s_one and not t_one:\\n            return False\\n\\n        if not s_one and t_one:\\n            return False\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def hasChar(self, s, t):\\n        for c in s:\\n            if c == t:\\n                return True\\n        return False\\n\\n    def hasOne(self, s):\\n        return self.hasChar(s, \\'1\\')\\n\\n    def hasZero(self, s):\\n        return self.hasChar(s, \\'0\\')\\n\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        # 0 1 => 1 1\\n        # 0 0 => 0 0\\n        # 1 0 => 1 1\\n        # 1 1 => 1 0\\n\\n        s_one = self.hasOne(s)\\n        s_zero = self.hasZero(s)\\n        t_one = self.hasOne(target)\\n        t_zero = self.hasZero(target)\\n\\n        if not s_zero and not t_one:\\n            return False\\n            \\n        if s_one and not t_one:\\n            return False\\n\\n        if not s_one and t_one:\\n            return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274342,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, target: String) -> bool {\\n        s.contains(\\'1\\') && target.contains(\\'1\\') || s == target\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, target: String) -> bool {\\n        s.contains(\\'1\\') && target.contains(\\'1\\') || s == target\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3195199,
                "title": "swift-one-liner-s-max-t-max",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func makeStringsEqual(_ s: String, _ t: String) -> Bool {\\n        s.max() == t.max()\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, twice as fast (accepted answer)**\\n```\\nclass Solution {\\n    func makeStringsEqual(_ s: String, _ t: String) -> Bool {\\n        s == t || (s.firstIndex(of: \"1\") != nil && t.firstIndex(of: \"1\") != nil)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func makeStringsEqual(_ s: String, _ t: String) -> Bool {\\n        s.max() == t.max()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func makeStringsEqual(_ s: String, _ t: String) -> Bool {\\n        s == t || (s.firstIndex(of: \"1\") != nil && t.firstIndex(of: \"1\") != nil)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176566,
                "title": "simple-o-n-approach",
                "content": "\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int c00=0,c10=0,c01=0,c11=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                if(t[i]==\\'1\\')\\n                    c11++;\\n                else\\n                    c10++;\\n            }\\n            else{\\n                if(t[i]==\\'1\\')\\n                    c01++;\\n                else\\n                    c00++;\\n            }\\n        }\\n        \\n        if(c01 and !(c11 or c10))\\n            return 0;\\n    \\n        if(c01)\\n            c11++;\\n        \\n        if(c10 and !c11)\\n            return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int c00=0,c10=0,c01=0,c11=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                if(t[i]==\\'1\\')\\n                    c11++;\\n                else\\n                    c10++;\\n            }\\n            else{\\n                if(t[i]==\\'1\\')\\n                    c01++;\\n                else\\n                    c00++;\\n            }\\n        }\\n        \\n        if(c01 and !(c11 or c10))\\n            return 0;\\n    \\n        if(c01)\\n            c11++;\\n        \\n        if(c10 and !c11)\\n            return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176409,
                "title": "simple-concise-and-readable-solution",
                "content": "\\n```\\n// to change any digit, we need 1.\\n\\n// even if there is a single 1, \\n//  1. we can convert any or all zero to 1\\n//  2. we can convert any or all 1 to 0.\\n\\n// So we can change our s to target if there is atleast single 1 in s.\\n\\n// * But, \\n// if target have any 1, and in s, there is no 1, then we cannot make string equal, \\n// as we need atleast a single 1\\n\\n// In both the cases, if s contains any number of 1\\'s, atleast a single 1, will remain at end in s.\\n\\n// But problem is, we cannot eliminate all 1\\'s from s. Atleast a single 1, will remain anyhow in it.\\n// * So if target have all zeros, ans s have a 1, we cannot make strings equal. \\n\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        int sCount1 = 0, tCount1 = 0;\\n        \\n        if(s.equals(target)) return true; // if all zeros or all ones, or all positions same.\\n        \\n        // coming uptil here means, difference in count or positions of 1.\\n        \\n        for(char c: s.toCharArray()) {\\n            if(c == \\'1\\') sCount1++;  // count of 1\\'s in string s.  1 is needful to change into target\\n        }\\n        for(char c: target.toCharArray()) {\\n            if(c == \\'1\\') tCount1++;  // count of 1\\'s in string target.  Atleast a single 1 should be in target. \\n        }\\n        \\n        return sCount1 == 0 || tCount1 == 0 ? false : true; // 1 is not in either s or target.\\n    }\\n}\\n\\n// Below is refined solution. Solution above is something, which helps coming to this one.\\n/*\\nclass Solution {\\n    return s.contains(\"1\") == target.contains(\"1\");\\n\\n    // true when - both conatins only zero or both contains atleast sing;e 1.\\n    // false when - one of them not not contains zero at all.\\n}\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// to change any digit, we need 1.\\n\\n// even if there is a single 1, \\n//  1. we can convert any or all zero to 1\\n//  2. we can convert any or all 1 to 0.\\n\\n// So we can change our s to target if there is atleast single 1 in s.\\n\\n// * But, \\n// if target have any 1, and in s, there is no 1, then we cannot make string equal, \\n// as we need atleast a single 1\\n\\n// In both the cases, if s contains any number of 1\\'s, atleast a single 1, will remain at end in s.\\n\\n// But problem is, we cannot eliminate all 1\\'s from s. Atleast a single 1, will remain anyhow in it.\\n// * So if target have all zeros, ans s have a 1, we cannot make strings equal. \\n\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        int sCount1 = 0, tCount1 = 0;\\n        \\n        if(s.equals(target)) return true; // if all zeros or all ones, or all positions same.\\n        \\n        // coming uptil here means, difference in count or positions of 1.\\n        \\n        for(char c: s.toCharArray()) {\\n            if(c == \\'1\\') sCount1++;  // count of 1\\'s in string s.  1 is needful to change into target\\n        }\\n        for(char c: target.toCharArray()) {\\n            if(c == \\'1\\') tCount1++;  // count of 1\\'s in string target.  Atleast a single 1 should be in target. \\n        }\\n        \\n        return sCount1 == 0 || tCount1 == 0 ? false : true; // 1 is not in either s or target.\\n    }\\n}\\n\\n// Below is refined solution. Solution above is something, which helps coming to this one.\\n/*\\nclass Solution {\\n    return s.contains(\"1\") == target.contains(\"1\");\\n\\n    // true when - both conatins only zero or both contains atleast sing;e 1.\\n    // false when - one of them not not contains zero at all.\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170011,
                "title": "1-liner",
                "content": "```\\nbool makeStringsEqual(string s, string t) \\n{\\n\\treturn !(any_of(begin(s), end(s), bind1st(equal_to<int>(),\\'1\\'))^any_of(begin(t), end(t), bind1st(equal_to<int>(),\\'1\\')));\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool makeStringsEqual(string s, string t) \\n{\\n\\treturn !(any_of(begin(s), end(s), bind1st(equal_to<int>(),\\'1\\'))^any_of(begin(t), end(t), bind1st(equal_to<int>(),\\'1\\')));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167508,
                "title": "very-simple-approach-0ms",
                "content": "# Intuition\\njust pen and paper and dry run o some testcases\\n\\n# Approach\\nthink where ans is impossible\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n      //corner case\\n      if(s==target)return true;\\n        int ct0ins=0,ct0int=0;\\n        for(auto x:s)\\n        if(x==\\'0\\')ct0ins++;\\n       for(auto x:target)\\n        if(x==\\'0\\')ct0int++;\\n       \\n        if(ct0ins==s.length() or ct0int==target.length())return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n      //corner case\\n      if(s==target)return true;\\n        int ct0ins=0,ct0int=0;\\n        for(auto x:s)\\n        if(x==\\'0\\')ct0ins++;\\n       for(auto x:target)\\n        if(x==\\'0\\')ct0int++;\\n       \\n        if(ct0ins==s.length() or ct0int==target.length())return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159839,
                "title": "cpp-simple-solution-cakewalk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.length();\\n      \\n        int Ct=0,Cs=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            Cs +=(s[i]==\\'1\\');\\n            Ct +=(target[i]==\\'1\\');\\n        }\\n        \\n        if(Cs==Ct)\\n        {\\n            return true;\\n        }\\n        if(Ct==0 or Cs==0)return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.length();\\n      \\n        int Ct=0,Cs=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            Cs +=(s[i]==\\'1\\');\\n            Ct +=(target[i]==\\'1\\');\\n        }\\n        \\n        if(Cs==Ct)\\n        {\\n            return true;\\n        }\\n        if(Ct==0 or Cs==0)return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154852,
                "title": "easiest-solution-c-easy-to-understand-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target) return true;\\n        int cnt = 0;\\n        for(auto i:s) if(i==\\'0\\') cnt++;\\n        if(cnt==s.length()) return false;\\n        int cnt1 = 0;\\n        for(auto i:target) if(i==\\'0\\') cnt1++;\\n        if(cnt1==s.length()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target) return true;\\n        int cnt = 0;\\n        for(auto i:s) if(i==\\'0\\') cnt++;\\n        if(cnt==s.length()) return false;\\n        int cnt1 = 0;\\n        for(auto i:target) if(i==\\'0\\') cnt1++;\\n        if(cnt1==s.length()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154756,
                "title": "c-o-n-time-and-o-1-space-detailed-explanation",
                "content": "# Intuition\\n- Since we can choose **2** elements, there can be **4** possibilities.\\n\\n# Approach\\n- The idea is quite simple but a little tricky to catch\\n- Since each element can be either **0** or **1**, there are 4 possibilities:\\n    - **0 0**\\n    - **0 1**\\n    - **1 0**\\n    - **1 1**\\n- Let\\'s see them one by one and try finding a pattern\\n    - **0 0** : we can\\'t do anything about it\\n        - 0 **XOR** 0: 0\\n        - 0 **OR** 0: 0\\n    > conclusion: We need atleast one **1** to update the values\\n   \\n    - **1 0**: we can do everything with it!\\n        - 1 **XOR** 0: 1\\n        - 1 **OR** 0: 1\\n        - According the the problem, any number of operations is allowed. So, above obtained 1\\'s can be reused\\n        - 1 **XOR** 1: 0\\n        - 1 **OR** 1: 1\\n    > conclusion: 1 0: can be converted to any pair we want to (except 00)\\n    > these pairs are: **0 1**, **1 1**, and even back to **1 0**\\n\\n    - **0 1**: same as **1 0**, right?\\n    - **1 1**: we already saw this in **1 0**, that **1 1** can be used to get **1 0**, **0 1** and back to **1 1**\\n\\n> Final Conclusions:\\n> * We need atleast one **1**, then we are golden! We can use that pair to get to any other pair(except 0 0)\\n> * If the `s` has at least one **1**, you can\\'t get rid of that **1**\\n> * if the `s` only has **0s** no updation is possible\\n\\n- So, finally, we come to a conclusion that if `s` and `target` have at least one **1** `return true`, also if both of them have **NO** **1s** `return true` `else return false`\\n# Complexity\\n- Time complexity:\\n    - O(N)\\n\\n- Space complexity:\\n    - O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        return (s.find(\\'1\\') != std::string::npos) && (target.find(\\'1\\') != std::string::npos) || (s == target);\\n    }\\n};\\n```\\n\\n### Consider Upvoting, if it helped =)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        return (s.find(\\'1\\') != std::string::npos) && (target.find(\\'1\\') != std::string::npos) || (s == target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139465,
                "title": "different-approach-c-bitwise-operations",
                "content": "# Approach\\n\\nThe basic steps followed in this approach are:\\n1. Take bitwise OR of s and target and store it in `OR` string.\\n2. Take bitwise XOR of s and target and store it in `XOR` string.\\n3. Now, take bitwise XOR of `OR` and `XOR` strings and store it in some string `ans`.\\n4. Lastly, check\\n    - if any of the strings s or target is equal to `ans` string, then return false.\\n    - else,  true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target){\\n            return true;\\n        }\\n        string OR = \"\", XOR = \"\", ans = \"\";\\n        for (int i = 0; i < s.length(); i++){\\n            OR += to_string((s[i]-\\'0\\')|(target[i]-\\'0\\'));\\n            XOR += to_string((s[i]-\\'0\\')^(target[i]-\\'0\\'));\\n        }\\n        for (int i = 0; i < s.length(); i++){\\n            ans += to_string((s[i]-\\'0\\')^(target[i]-\\'0\\'));\\n        }\\n        \\n        return !(ans == s || ans == target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target){\\n            return true;\\n        }\\n        string OR = \"\", XOR = \"\", ans = \"\";\\n        for (int i = 0; i < s.length(); i++){\\n            OR += to_string((s[i]-\\'0\\')|(target[i]-\\'0\\'));\\n            XOR += to_string((s[i]-\\'0\\')^(target[i]-\\'0\\'));\\n        }\\n        for (int i = 0; i < s.length(); i++){\\n            ans += to_string((s[i]-\\'0\\')^(target[i]-\\'0\\'));\\n        }\\n        \\n        return !(ans == s || ans == target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135257,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       bool makeStringsEqual(string s, string t) {\\n        return (s.find(\\'1\\') != string::npos) == (t.find(\\'1\\') != string::npos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       bool makeStringsEqual(string s, string t) {\\n        return (s.find(\\'1\\') != string::npos) == (t.find(\\'1\\') != string::npos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131258,
                "title": "very-fast-and-easy-o-n-time-o-1-memory-cpp-solution-explained",
                "content": "# Intuition\\nIf you have at least one `\\'1\\'` you can never achieve a state where there are no one, but you can set any position you want to `\\'1\\'` and you can make any `\\'1\\'` into a `\\'0\\'`.\\n\\n# Approach\\nThe solution is now simple, count all the ones in both strings, if all of the are zeros initially then they are already equal. If the both contain at least one `\\'1\\'` then you can always make them equal.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        auto ones = accumulate(s.begin(), s.end(), (int)0) - s.size() * int(\\'0\\');\\n        auto t_ones = accumulate(target.begin(), target.end(), (int)0) - target.size() * int(\\'0\\');\\n        return ones and t_ones or !(ones) and !(t_ones);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        auto ones = accumulate(s.begin(), s.end(), (int)0) - s.size() * int(\\'0\\');\\n        auto t_ones = accumulate(target.begin(), target.end(), (int)0) - target.size() * int(\\'0\\');\\n        return ones and t_ones or !(ones) and !(t_ones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130331,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_s + n_target)\\n * Space Complexity: O(1)\\n * where `n_s` is the length of the string `s`\\n *       `n_target` is the length of the string `target`\\n */\\nclass Solution {\\n public:\\n  bool makeStringsEqual(const string &s, const string &target) {\\n    constexpr char one = \\'1\\';\\n    return (s.find(one) == string::npos) == (target.find(one) == string::npos);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_s + n_target)\\n * Space Complexity: O(1)\\n * where `n_s` is the length of the string `s`\\n *       `n_target` is the length of the string `target`\\n */\\nclass Solution {\\n public:\\n  bool makeStringsEqual(const string &s, const string &target) {\\n    constexpr char one = \\'1\\';\\n    return (s.find(one) == string::npos) == (target.find(one) == string::npos);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129597,
                "title": "0ms-one-line",
                "content": "\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return !(s.indexOf(\\'1\\')==-1^target.indexOf(\\'1\\')==-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return !(s.indexOf(\\'1\\')==-1^target.indexOf(\\'1\\')==-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128957,
                "title": "javascript-if-they-are-equal-or-if-both-have-at-least-one-1-return-true",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf they are equal or if both have at least one 1, you can make one out of the other under problem conditions, therefore return true\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCode up above\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n       let sCount = 0\\n       let tCount = 0\\n       if(s===target) return true\\n\\n       for(let i = 0; i < s.length; i++) {\\n           const currS = s[i]\\n           const currT = target[i]\\n\\n           sCount += Number(currS)\\n           tCount += Number(currT)\\n       }\\n\\n       if(sCount > 0 && tCount > 0) return true\\n       return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n       let sCount = 0\\n       let tCount = 0\\n       if(s===target) return true\\n\\n       for(let i = 0; i < s.length; i++) {\\n           const currS = s[i]\\n           const currT = target[i]\\n\\n           sCount += Number(currS)\\n           tCount += Number(currT)\\n       }\\n\\n       if(sCount > 0 && tCount > 0) return true\\n       return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128423,
                "title": "two-python-solutions",
                "content": "\\n# Code V1\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n\\n        if(s==target):\\n            return True\\n        n=len(s)\\n        if(s==\\'0\\'*n or target==\\'0\\'*n):\\n            return False\\n        return  True\\n\\n\\n```\\n# Code V2 \\n\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\\'1\\' in s) == (\\'1\\' in target)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n\\n        if(s==target):\\n            return True\\n        n=len(s)\\n        if(s==\\'0\\'*n or target==\\'0\\'*n):\\n            return False\\n        return  True\\n\\n\\n```\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\\'1\\' in s) == (\\'1\\' in target)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111333,
                "title": "python-video-walkthrough-one-line-solution-time-o-n-space-o-1",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/aW_nMoH--lQ)\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return max(s) == max(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return max(s) == max(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111090,
                "title": "c-explanation-steps-by-steps",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public bool MakeStringsEqual(string s, string target) \\n    {\\n         /*      or        xor \\n            * 0    0    0      0    0    0\\n            * 0    1    1      0    1    1\\n            * 1    0    1      1    0    1\\n            * 1    1    1      1    1    0\\n            * \\n            * s[i] s[j] s[i]  s[i] s[j] s[j] \\n            * \\n            *   s[i] change case: \\n            *   when s[i] = 0 and s[j] = 1; \\n            *   01 -> 11;\\n            *   \\n            *   s[j] change case: \\n            *   when s[i] = 1;\\n            *   10 -> 11, 11-> 10\\n            *  \\n            *  then: if a string contains only 0, it can not change. \\n            *  And if a string contains 1, it can change to all the binary strings except only 0 string\\n            *  \\n            *  \\n            *  conclusion:\\n            *  if s contains 1 and target contains 1\\n            *  return true\\n            *  \\n            *  if s not contains 1 and target not contains 1\\n            *  return true\\n            *  \\n            *  if s contains 1 and target not contains 1\\n            *  return false\\n            *  \\n            *  if s not contains 1 and target contains 1\\n            *  return false\\n        */\\n\\n        var set_s = new HashSet<char>();\\n        var set_t = new HashSet<char>();\\n\\n        foreach (var ch in s) \\n        {\\n            if (!set_s.Contains(ch)) \\n            {\\n                set_s.Add(ch);\\n            }\\n        }\\n\\n        foreach (var ch in target)\\n        {\\n            if (!set_t.Contains(ch))\\n            {\\n                set_t.Add(ch);\\n            }\\n        }\\n\\n        return !(set_s.Contains(\\'1\\') ^ set_t.Contains(\\'1\\'));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool MakeStringsEqual(string s, string target) \\n    {\\n         /*      or        xor \\n            * 0    0    0      0    0    0\\n            * 0    1    1      0    1    1\\n            * 1    0    1      1    0    1\\n            * 1    1    1      1    1    0\\n            * \\n            * s[i] s[j] s[i]  s[i] s[j] s[j] \\n            * \\n            *   s[i] change case: \\n            *   when s[i] = 0 and s[j] = 1; \\n            *   01 -> 11;\\n            *   \\n            *   s[j] change case: \\n            *   when s[i] = 1;\\n            *   10 -> 11, 11-> 10\\n            *  \\n            *  then: if a string contains only 0, it can not change. \\n            *  And if a string contains 1, it can change to all the binary strings except only 0 string\\n            *  \\n            *  \\n            *  conclusion:\\n            *  if s contains 1 and target contains 1\\n            *  return true\\n            *  \\n            *  if s not contains 1 and target not contains 1\\n            *  return true\\n            *  \\n            *  if s contains 1 and target not contains 1\\n            *  return false\\n            *  \\n            *  if s not contains 1 and target contains 1\\n            *  return false\\n        */\\n\\n        var set_s = new HashSet<char>();\\n        var set_t = new HashSet<char>();\\n\\n        foreach (var ch in s) \\n        {\\n            if (!set_s.Contains(ch)) \\n            {\\n                set_s.Add(ch);\\n            }\\n        }\\n\\n        foreach (var ch in target)\\n        {\\n            if (!set_t.Contains(ch))\\n            {\\n                set_t.Add(ch);\\n            }\\n        }\\n\\n        return !(set_s.Contains(\\'1\\') ^ set_t.Contains(\\'1\\'));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111081,
                "title": "c-counting-1s-100-time-8ms-95-space-12-9mb",
                "content": "This problems seems rather tricks and might temp you to try and solve it actually modifying `s` until you reach the target configuration of `t`, but we can definitely do better.\\n\\nIf we build for starters some bitwise table to see what are our four scenarios, we will see this:\\n\\n```cpp\\ni   j   |   ^\\n1   1   1   0\\n1   0   1   1\\n0   1   1   1\\n0   0   0   0\\n```\\n\\nGiven that we can pick `i` and `j` where we want them, the cases actually boil down to three:\\n\\n```cpp\\ni and j are different:\\n    0, 1 => 1, 1\\n    1, 0 => 1, 1\\ni and j are both 1:\\n    1, 1 => 1, 0\\ni and j are both 0:\\n    0, 0 => 0, 0\\n```\\n\\nHence we can see that the `0, 0` situation is our \"stalemate\" (ie: we cannot change that), but otherwise we can always move from one state to the other (ie: `1, 1` => `0, 1` and `0, 1` => `1, 1`).\\n\\nAs a consequence of that, we can deduct that if `t` has `0` `1`s, then also `s` has to be none of them and the other way around; conversely, if we either `s` or `t` have at least `1`, given that each string is always guaranteed to be at least `2` characters or more, then we know that we can freely change status, increasing or reducing the amount of `1`s as needed.\\n\\nBasically, we can `return` `true` is either both `s` and `t` have no `1`s or if both of them have at least one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return any_of(begin(s), end(s), [](char c){\\n            return c == \\'1\\';\\n        }) == any_of(begin(t), end(t), [](char c){\\n            return c == \\'1\\';\\n        });\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/6835eaf0-286a-4863-92e0-c01d148b2205_1674941071.369945.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\ni   j   |   ^\\n1   1   1   0\\n1   0   1   1\\n0   1   1   1\\n0   0   0   0\\n```\n```cpp\\ni and j are different:\\n    0, 1 => 1, 1\\n    1, 0 => 1, 1\\ni and j are both 1:\\n    1, 1 => 1, 0\\ni and j are both 0:\\n    0, 0 => 0, 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return any_of(begin(s), end(s), [](char c){\\n            return c == \\'1\\';\\n        }) == any_of(begin(t), end(t), [](char c){\\n            return c == \\'1\\';\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109836,
                "title": "java-one-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n\\n        int one = 0;\\n        int one1 = 0;\\n\\n        for(int i=0; i<target.length(); i++){\\n\\n            if(s.charAt(i) == \\'1\\'){ one++; }\\n            if(target.charAt(i) == \\'1\\'){ one1++; }\\n\\n        }\\n\\n        if((one1 == 0 && one > 0) || (one == 0 && one1 > 0)){ return false; }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n\\n        int one = 0;\\n        int one1 = 0;\\n\\n        for(int i=0; i<target.length(); i++){\\n\\n            if(s.charAt(i) == \\'1\\'){ one++; }\\n            if(target.charAt(i) == \\'1\\'){ one1++; }\\n\\n        }\\n\\n        if((one1 == 0 && one > 0) || (one == 0 && one1 > 0)){ return false; }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109594,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int countS = 0, countT = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            countS += s[i] - \\'0\\';\\n            countT += target[i] - \\'0\\';\\n        }\\n        return !((countS == 0 && countT != 0) || (countS != 0 && countT == 0));\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int countS = 0, countT = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            countS += s[i] - \\'0\\';\\n            countT += target[i] - \\'0\\';\\n        }\\n        return (countS > 0) == (countT > 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int countS = 0, countT = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            countS += s[i] - \\'0\\';\\n            countT += target[i] - \\'0\\';\\n        }\\n        return !((countS == 0 && countT != 0) || (countS != 0 && countT == 0));\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int countS = 0, countT = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            countS += s[i] - \\'0\\';\\n            countT += target[i] - \\'0\\';\\n        }\\n        return (countS > 0) == (countT > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107879,
                "title": "java-bit-manipulation-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target))\\n            return true;\\n        int tozero=0;\\n        int toone=0;\\n        int cntzero=0;\\n        int cntone=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\')\\n                cntzero++;\\n            else\\n                cntone++;\\n            if(s.charAt(i)!=target.charAt(i)){\\n                if(s.charAt(i)==\\'0\\')\\n                    toone++;\\n                else\\n                    tozero++;\\n            }\\n        }\\n        if(toone>0 && cntone>0)\\n            return true;\\n        else if(tozero>0 && cntone>tozero)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target))\\n            return true;\\n        int tozero=0;\\n        int toone=0;\\n        int cntzero=0;\\n        int cntone=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\')\\n                cntzero++;\\n            else\\n                cntone++;\\n            if(s.charAt(i)!=target.charAt(i)){\\n                if(s.charAt(i)==\\'0\\')\\n                    toone++;\\n                else\\n                    tozero++;\\n            }\\n        }\\n        if(toone>0 && cntone>0)\\n            return true;\\n        else if(tozero>0 && cntone>tozero)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104920,
                "title": "rust-one-liner",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, target: String) -> bool {\\n        s.bytes().any(|b| b == b\\'1\\') == target.bytes().any(|b| b == b\\'1\\')\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "String",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, target: String) -> bool {\\n        s.bytes().any(|b| b == b\\'1\\') == target.bytes().any(|b| b == b\\'1\\')\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104366,
                "title": "simple-solution-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe intuition behind this problem is that if any of the given string does not contain \\'1\\' i.e the whole string consists of only 0\\'s then we cannot change that string. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe logic is quite simple, if the entire string is of 0\\'s then taking any two index and performing XOR operation will give me 0 and taking any other two index and performing OR operatoion will still give me 0.\\n\\nsince.. \\n0 | 0 = 0\\n\\n0 ^ 0 = 0\\n\\nso we check if the string consists of only zeroe\\'s or not \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        \\n        int one1 = 0, one2 = 0;\\n        \\n        one1 = count(s.begin(), s.end(), \\'1\\');\\n        one2 = count(target.begin(), target.end(), \\'1\\');\\n    \\n//here we have counted the number of 1\\'s in both the strings.\\n// we are checking if any of the string contains only 0\\'s or not\\n\\n        if(one1 == 0 or one2 == 0){\\n            return s==target;\\n        } \\n\\n//there is an edge case which needs to be handled \\n//that it might happen that both the string consists of only 0\\'s\\n//in that case we return true else we return false;\\n\\n//if the string is not totally zero then we can make any combination\\n//Hence return true\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        \\n        int one1 = 0, one2 = 0;\\n        \\n        one1 = count(s.begin(), s.end(), \\'1\\');\\n        one2 = count(target.begin(), target.end(), \\'1\\');\\n    \\n//here we have counted the number of 1\\'s in both the strings.\\n// we are checking if any of the string contains only 0\\'s or not\\n\\n        if(one1 == 0 or one2 == 0){\\n            return s==target;\\n        } \\n\\n//there is an edge case which needs to be handled \\n//that it might happen that both the string consists of only 0\\'s\\n//in that case we return true else we return false;\\n\\n//if the string is not totally zero then we can make any combination\\n//Hence return true\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100996,
                "title": "c-simple-solution-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // For conversion of zero to one or from one to zero, we will always require one for this operation as second operant, in both XOR and OR operations.\\n    // If we have to convert s[i] to 1 (currently 0) then we have to select s[j] as 1 then we can do OR operation and s[i] = s[i] | s[j] = 0 | 1 = 1.  \\n    // If we have to convert s[i] to 0 (currently 1) then we have to select s[j] as 1 then we can do XOR operation and s[i] = s[i] ^ s[j] = 1 ^ 1 = 0.\\n    bool makeStringsEqual(string s, string target) {\\n        \\n        // If both string are equal then return ture.\\n        if(s == target) {\\n            return true;\\n        }\\n        \\n        // Calculate the number of ones in string s and number of zeroes in target string.\\n        int calOne = 0, calZero = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'1\\') {\\n                calOne++;\\n            }\\n            if(target[i] == \\'0\\') {\\n                calZero++;\\n            }\\n        }\\n        \\n        // If target string cointain all zero then the answer would be always false.\\n        // Beacuse we will now be able to remove all ones for string s. And will always have atleast one left.\\n        if(calZero == target.size()) {\\n            return false;\\n        }\\n        \\n        // If number of ones is zero in string s, then also the answer would be false always.\\n        // Beacuse then we cannot convert any zero to one.\\n        if(calOne == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // For conversion of zero to one or from one to zero, we will always require one for this operation as second operant, in both XOR and OR operations.\\n    // If we have to convert s[i] to 1 (currently 0) then we have to select s[j] as 1 then we can do OR operation and s[i] = s[i] | s[j] = 0 | 1 = 1.  \\n    // If we have to convert s[i] to 0 (currently 1) then we have to select s[j] as 1 then we can do XOR operation and s[i] = s[i] ^ s[j] = 1 ^ 1 = 0.\\n    bool makeStringsEqual(string s, string target) {\\n        \\n        // If both string are equal then return ture.\\n        if(s == target) {\\n            return true;\\n        }\\n        \\n        // Calculate the number of ones in string s and number of zeroes in target string.\\n        int calOne = 0, calZero = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'1\\') {\\n                calOne++;\\n            }\\n            if(target[i] == \\'0\\') {\\n                calZero++;\\n            }\\n        }\\n        \\n        // If target string cointain all zero then the answer would be always false.\\n        // Beacuse we will now be able to remove all ones for string s. And will always have atleast one left.\\n        if(calZero == target.size()) {\\n            return false;\\n        }\\n        \\n        // If number of ones is zero in string s, then also the answer would be false always.\\n        // Beacuse then we cannot convert any zero to one.\\n        if(calOne == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100620,
                "title": "java-beats-0ms-100-one-line-short-and-fast-easy-to-understand-best-solutioni",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100338,
                "title": "simple-constructive-algorithm-easy-specially-for-begineer-s",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)\\n            return true;\\n        bool isOnePresent=false;\\n        for(auto x: s){\\n            if(x==\\'1\\'){\\n                isOnePresent=true;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\' and target[i]==\\'1\\' and isOnePresent)\\n                s[i]=\\'1\\';\\n            if(s[i]==\\'1\\' and target[i]==\\'1\\')\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n\\n\\n/////////\\n// 1.........\\n\\n// target\\n// 0\\n    \\n// => Only posible is to do xor with s[j]=1; where target[i]=0 or target[j]=0\\n    \\n    \\n// 1     1\\n    \\n// 0     1\\n    \\n    \\n    \\n// 1     1\\n    \\n// 1     0\\n    \\n    \\n\\n// 0   1\\n    \\n// 1   1\\n    \\n    \\n// 1  0\\n\\n// 1  1 \\n    \\n\\n// 1  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)\\n            return true;\\n        bool isOnePresent=false;\\n        for(auto x: s){\\n            if(x==\\'1\\'){\\n                isOnePresent=true;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\' and target[i]==\\'1\\' and isOnePresent)\\n                s[i]=\\'1\\';\\n            if(s[i]==\\'1\\' and target[i]==\\'1\\')\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n\\n\\n/////////\\n// 1.........\\n\\n// target\\n// 0\\n    \\n// => Only posible is to do xor with s[j]=1; where target[i]=0 or target[j]=0\\n    \\n    \\n// 1     1\\n    \\n// 0     1\\n    \\n    \\n    \\n// 1     1\\n    \\n// 1     0\\n    \\n    \\n\\n// 0   1\\n    \\n// 1   1\\n    \\n    \\n// 1  0\\n\\n// 1  1 \\n    \\n\\n// 1  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100064,
                "title": "c-using-bitwise-operations",
                "content": "```\\n/*our string \\'s\\' and \\'target\\' if they are not equal then \\nthey must contain at least one \\'1\\' as due to presence of atleast\\n one \\'1\\', the other \\'1\\' can be easily increased or \\ndecreased using bitwise or, xor and and operations. */\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        bool f1=false,f2=false;\\n        if(s==target){\\n            return true;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                f1=true;\\n            }\\n            if(target[i]==\\'1\\'){\\n                f2=true;\\n            }\\n        }\\n        if(f1 && f2){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*our string \\'s\\' and \\'target\\' if they are not equal then \\nthey must contain at least one \\'1\\' as due to presence of atleast\\n one \\'1\\', the other \\'1\\' can be easily increased or \\ndecreased using bitwise or, xor and and operations. */\\n\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        bool f1=false,f2=false;\\n        if(s==target){\\n            return true;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                f1=true;\\n            }\\n            if(target[i]==\\'1\\'){\\n                f2=true;\\n            }\\n        }\\n        if(f1 && f2){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098052,
                "title": "c-two-approaches-methods-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply s must have at least one \\'1\\' which can be used to convert character into \\'0\\' or \\'1\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust checking firstly, both the string must have same length.\\nIf length is not same return false.\\nSecondly, we are checking either of two string are completly filled with zero or not. If either of string is containing only zeros then we will return false.\\nElse we can convert s into target using XOR or OR.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Length of string).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\nAs we are not using any extra space other than a string varibale, which is a constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int m=s.size(),n=target.size();\\n        if(m!=n)return false;\\n\\n        // METHOD 1\\n        // int s1=0,s2=0;  // s1 --> sum1 and s2 --> sum2\\n\\n        // for(int i=0;i<m;i++){\\n        //     if(s[i]==\\'1\\')s1++;\\n        //     if(target[i]==\\'1\\')s2++;\\n        // }\\n\\n        // return (s1 and s2 or !s1 and !s2);\\n\\n        // METHOD 2, ALTERNATE\\n        string mask(m,\\'0\\');\\n        return !(s==mask^target==mask);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int m=s.size(),n=target.size();\\n        if(m!=n)return false;\\n\\n        // METHOD 1\\n        // int s1=0,s2=0;  // s1 --> sum1 and s2 --> sum2\\n\\n        // for(int i=0;i<m;i++){\\n        //     if(s[i]==\\'1\\')s1++;\\n        //     if(target[i]==\\'1\\')s2++;\\n        // }\\n\\n        // return (s1 and s2 or !s1 and !s2);\\n\\n        // METHOD 2, ALTERNATE\\n        string mask(m,\\'0\\');\\n        return !(s==mask^target==mask);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095640,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n     if(s == target) return true;\\n     bool f1 = false;\\n     bool f2 = false;\\n     for(int i = 0;i<s.size();i++)\\n     {\\n         if(s[i] == \\'1\\') f1  = true;\\n         if(target[i] == \\'1\\') f2 = true;\\n     }\\n     if(f1 & f2) return true;\\n     return false;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n     if(s == target) return true;\\n     bool f1 = false;\\n     bool f2 = false;\\n     for(int i = 0;i<s.size();i++)\\n     {\\n         if(s[i] == \\'1\\') f1  = true;\\n         if(target[i] == \\'1\\') f2 = true;\\n     }\\n     if(f1 & f2) return true;\\n     return false;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095615,
                "title": "detailed-java-solution-simple-and-easy-to-understand",
                "content": "# Intuition\\nConsider all the possible cases:\\n```\\ns[i] -> value of s[i]\\ns[j] -> value of s[j]\\ns[i]\\' -> new value of s[i] after (s[i] | s[j])\\ns[j]\\' -> new value of s[j] after (s[i] ^ s[j])\\n\\ns[i]    s[j]    s[i]\\'   s[j]\\'\\n0       0       0       0\\n0       1       1       1\\n1       0       1       1\\n1       1       1       0\\n```\\n\\nThings we can conclude from the data:\\n1. If both 0, then they stay 0.\\n2. If one of them is 1 and other is 0, then both indexes change to 1.\\n3. If both are 1, we get one 0 and one 1.\\n\\n# Approach\\nIf we visual the above data as:\\n```\\n(s[i], s[j]) --> (s[i]\\', s[j]\\')\\n```\\n```\\n(0,0) --> (0,0)\\n\\n(0,1) --> (1,1)\\n\\n(1,0) --> (1,1)\\n\\n(1,1) --> (1,0)\\n```\\n\\nand start mapping, then,\\n```\\n(0,0) <--> (0,0)\\n\\n(0,1) --> (1,1) <--> (1,0)\\n```\\n\\nWe can further conclude that:\\n1. String with only 0s can transform to string with only 0s.\\n2. Rest all transformations are possible.\\n\\nConsider 2 variables,\\ns1 represents whether s contains 1\\nt1 represents whether target contains 1\\n\\nMapping a truth table:\\n```\\ns1  t1  Result\\n0   0   1\\n0   1   0\\n1   0   0\\n1   1   1\\n```\\n\\nResult can be obtained with XNOR of s1 and t1:\\n```\\nResult = !(s1 ^ t1)\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean makeStringsEqual(String s, String target) {\\n    boolean s1 = s.contains(\"1\");\\n\\n    boolean t1 = target.contains(\"1\");\\n\\n    return !(s1 ^ t1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ns[i] -> value of s[i]\\ns[j] -> value of s[j]\\ns[i]\\' -> new value of s[i] after (s[i] | s[j])\\ns[j]\\' -> new value of s[j] after (s[i] ^ s[j])\\n\\ns[i]    s[j]    s[i]\\'   s[j]\\'\\n0       0       0       0\\n0       1       1       1\\n1       0       1       1\\n1       1       1       0\\n```\n```\\n(s[i], s[j]) --> (s[i]\\', s[j]\\')\\n```\n```\\n(0,0) --> (0,0)\\n\\n(0,1) --> (1,1)\\n\\n(1,0) --> (1,1)\\n\\n(1,1) --> (1,0)\\n```\n```\\n(0,0) <--> (0,0)\\n\\n(0,1) --> (1,1) <--> (1,0)\\n```\n```\\ns1  t1  Result\\n0   0   1\\n0   1   0\\n1   0   0\\n1   1   1\\n```\n```\\nResult = !(s1 ^ t1)\\n```\n```\\nclass Solution {\\n  public boolean makeStringsEqual(String s, String target) {\\n    boolean s1 = s.contains(\"1\");\\n\\n    boolean t1 = target.contains(\"1\");\\n\\n    return !(s1 ^ t1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095517,
                "title": "python-simple-solution-with-explanation-beats-95",
                "content": "# Explantion\\n\\nWrite down all the possible transformation that\\'s possible for i, j index\\n\\nInput (i,j)  -> Output (i,j)\\n\\n0,0  -> 0,0\\n1,0  -> 1,1\\n0,1  -> 1,1\\n1,1  -> 1,0\\n\\nOne observation here is 0,0 -> 0,0 is useless transformation as it does nothing.\\n\\nAnother thing to notice here is we can convert 1,0 -> 1,1 and 1,1 -> 1,0 (forget about the order of i,j)\\n\\nAll this boils down to the if else case written down below i.e. \\n\\n* 1st condition (target == s):\\nif the set of target and set of s both have \"0\" and \"1\" element it\\'s possible to make the transformation\\n\\nthis condition also covers the case if target and s has just 1\\'s or 0\\'s\\n\\n* 2nd condition (len(target) == len(s)):\\nBecause the 1st condition is not met and both the set have same length it means that they are not equal and either of them has just 1\\'s and the other set has just 0\\'s \\n\\nThis transformation is not possible because of the useless transformation (better if you write down some examples and verify for yourself using above mapping of transformations)\\n\\n* 3rd condition (s == [\\'0\\'] or target == [\\'0\\']):\\nWe are now left with following cases\\ntarget set || s set\\n1) 10 || 1\\n2) 10 || 0\\n3) 1 || 10\\n4) 0 || 10\\n\\nHere case 2 and 4 are not possible transformation therefore this 3rd condition handles them\\n\\n\\nLet me know if anything doesn\\'t make sense! Happy to clarify any doubts concerning the explanation \\uD83D\\uDE42\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        target = list(set(target))\\n        s = list(set(s))\\n\\n        if target == s: # 1st condition\\n            return True\\n        elif len(target) == len(s): # 2nd condition\\n            return False\\n        elif s == [\\'0\\'] or target == [\\'0\\']: # 3rd condition\\n            return False\\n        else:\\n            return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        target = list(set(target))\\n        s = list(set(s))\\n\\n        if target == s: # 1st condition\\n            return True\\n        elif len(target) == len(s): # 2nd condition\\n            return False\\n        elif s == [\\'0\\'] or target == [\\'0\\']: # 3rd condition\\n            return False\\n        else:\\n            return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095024,
                "title": "c-very-short-and-easy-code-explained",
                "content": "If any of the string contains all zero and other string is having atleast one( \\'1\\') then we  can not convert given string into target.\\notherwise in all cases we can convert!\\n\\nJust dry run 3 to 4 test cases you will get the idea;\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int cnt1=0,cnt2=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            cnt1+=(s[i]-\\'0\\');\\n            cnt2+=(target[i]-\\'0\\');\\n        }\\n        if(cnt2==0 and cnt1)return false;\\n        if(cnt1 ==0 and cnt2)return false;\\n        return true;\\n    }\\n};\\n``\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int cnt1=0,cnt2=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            cnt1+=(s[i]-\\'0\\');\\n            cnt2+=(target[i]-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3094067,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if (s.count(\"1\")==target.count(\"1\") and s.count(\"0\")==target.count(\"0\")):\\n            return True\\n        if(s.count(\"0\")==len(s) or target.count(\"0\")==len(target)):\\n            return False\\n        if((s.count(\"1\")==len(s)) and target.count(\"1\")==len(target)):\\n            return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if (s.count(\"1\")==target.count(\"1\") and s.count(\"0\")==target.count(\"0\")):\\n            return True\\n        if(s.count(\"0\")==len(s) or target.count(\"0\")==len(target)):\\n            return False\\n        if((s.count(\"1\")==len(s)) and target.count(\"1\")==len(target)):\\n            return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093782,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n          int count1=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                count1++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n             if(s[i]==\\'0\\' && target[i]==\\'1\\'){\\n                if(count1>0){\\n                    count1++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){    \\n            if(s[i]==\\'1\\' && target[i]==\\'0\\'){\\n                if(count1>1){\\n                    count1--;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n          int count1=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                count1++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n             if(s[i]==\\'0\\' && target[i]==\\'1\\'){\\n                if(count1>0){\\n                    count1++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){    \\n            if(s[i]==\\'1\\' && target[i]==\\'0\\'){\\n                if(count1>1){\\n                    count1--;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093705,
                "title": "rust-one-line-solution",
                "content": "```rust\\nimpl Solution {\\n\\tpub fn make_strings_equal(s: String, target: String) -> bool {\\n\\t\\t!(s.find(\"1\").is_some() ^ target.find(\"1\").is_some())\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n\\tpub fn make_strings_equal(s: String, target: String) -> bool {\\n\\t\\t!(s.find(\"1\").is_some() ^ target.find(\"1\").is_some())\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092893,
                "title": "python-solution-3-lines-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n```\\nij\\n01 -> 11\\n00 -> 00\\n10 -> 11\\n11 -> 10\\n1010 -> 0110\\n```\\n## Observation\\n- You can move `1` to different position\\n- You can remove an `1` if there is more than two `1`s\\n- You can\\'t convert to a string with `0` only if the original string contains `1`\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:        \\n        s_ones = Counter(s)[\\'1\\']\\n        t_ones = Counter(target)[\\'1\\']\\n        return s_ones == t_ones or s_ones > 0 and t_ones > 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nij\\n01 -> 11\\n00 -> 00\\n10 -> 11\\n11 -> 10\\n1010 -> 0110\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:        \\n        s_ones = Counter(s)[\\'1\\']\\n        t_ones = Counter(target)[\\'1\\']\\n        return s_ones == t_ones or s_ones > 0 and t_ones > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092818,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s.compare(target) == 0) {\\n            return true;\\n        }\\n        // step1 \\n        int count1 = 0;\\n        int count_ones = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\') {\\n                count_ones++;\\n            }\\n\\n            if(s[i] == \\'0\\' && target[i] == \\'1\\') {\\n                count1++;\\n            }\\n        }\\n\\n        if(count1!=0 && count_ones == 0) {\\n            return false;\\n        }\\n\\n        count_ones += count1;\\n        int count2 = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\' && target[i] == \\'0\\') {\\n                count2++;\\n            }\\n        }\\n\\n        return count_ones > count2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s.compare(target) == 0) {\\n            return true;\\n        }\\n        // step1 \\n        int count1 = 0;\\n        int count_ones = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\') {\\n                count_ones++;\\n            }\\n\\n            if(s[i] == \\'0\\' && target[i] == \\'1\\') {\\n                count1++;\\n            }\\n        }\\n\\n        if(count1!=0 && count_ones == 0) {\\n            return false;\\n        }\\n\\n        count_ones += count1;\\n        int count2 = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\' && target[i] == \\'0\\') {\\n                count2++;\\n            }\\n        }\\n\\n        return count_ones > count2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092480,
                "title": "python-find-the-pattern",
                "content": "# Intuition\\nfor bitwise question, do not simulate it , we need to find to logic\\n\\n(0, 0) -> (0, 0)\\n(1, 0) -> (1, 1)\\n(0, 1) -> (1, 1)\\n(1, 1) -> (1, 0)\\n\\nie.\\n=> for all zeros, we cannot make one, and it must be zero\\n=> for all ones, we cannot make all zeros\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        t0 = list(target).count(\"0\")\\n        t1 = list(target).count(\"1\")\\n        s0 = list(s).count(\"0\")\\n        s1 = list(s).count(\"1\")\\n        # target all zero, s must be allzero\\n        if t1==0 and s1>0:\\n            return False\\n        # target all one, s need have one one\\n        if t0==0 and s1==0:\\n            return False\\n        # if source all zero, target must be zero\\n        if s1==0 and t1>0:\\n            return False\\n        \\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        t0 = list(target).count(\"0\")\\n        t1 = list(target).count(\"1\")\\n        s0 = list(s).count(\"0\")\\n        s1 = list(s).count(\"1\")\\n        # target all zero, s must be allzero\\n        if t1==0 and s1>0:\\n            return False\\n        # target all one, s need have one one\\n        if t0==0 and s1==0:\\n            return False\\n        # if source all zero, target must be zero\\n        if s1==0 and t1>0:\\n            return False\\n        \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091159,
                "title": "1-liner-javascript-regex",
                "content": "\\n# Code:\\n```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function (s, target) {\\n    return (/1/).test(target) && (/1/).test(s) || s === target;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function (s, target) {\\n    return (/1/).test(target) && (/1/).test(s) || s === target;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3091044,
                "title": "c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int one_s = 0 ;\\n        int one_tar = 0 ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'1\\'){\\n                one_s++;\\n            }\\n            if(target[i] == \\'1\\'){\\n                one_tar++;\\n            }\\n        }\\n        if(one_s > 0 and one_tar > 0 || one_s == 0 and one_tar == 0){\\n            return true ;\\n        }\\n        \\n        return false ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int one_s = 0 ;\\n        int one_tar = 0 ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'1\\'){\\n                one_s++;\\n            }\\n            if(target[i] == \\'1\\'){\\n                one_tar++;\\n            }\\n        }\\n        if(one_s > 0 and one_tar > 0 || one_s == 0 and one_tar == 0){\\n            return true ;\\n        }\\n        \\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090334,
                "title": "a-few-solutions",
                "content": "Use inversion, ie. return `false` when it is impossible to transform `s` to `t`:\\n\\n* Case 1: **all** characters of `s` are `0` and **any** character of `t` is `1`\\n* Case 2: **any** character of `s` is `1` and **all** characters of `t` are `0`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var makeStringsEqual = { s: String, t: String -> \\n        !(s.toCharArray().all{ it == \\'0\\' } && t.toCharArray().any{ it == \\'1\\' })\\n     && !(s.toCharArray().any{ it == \\'1\\' } && t.toCharArray().all{ it == \\'0\\' })\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet makeStringsEqual = (s, t) =>\\n    !(s.split(\\'\\').every(c => c == \\'0\\') && t.split(\\'\\').some(c => c == \\'1\\'))\\n && !(s.split(\\'\\').some(c => c == \\'1\\') && t.split(\\'\\').every(c => c == \\'0\\'));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    makeStringsEqual = lambda self, s, t: not (all(c == \\'0\\' for c in s) and any(c == \\'1\\' for c in t)) and not (any(c == \\'1\\' for c in s) and all(c == \\'0\\' for c in t))\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, t: String) -> bool {\\n        !(s.chars().all(|c| c == \\'0\\') && t.chars().any(|c| c == \\'1\\'))\\n     && !(s.chars().any(|c| c == \\'1\\') && t.chars().all(|c| c == \\'0\\'))\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return !(all_of(s.begin(), s.end(), [](auto c) { return c == \\'0\\'; }) && any_of(t.begin(), t.end(), [](auto c) { return c == \\'1\\'; }))\\n            && !(any_of(s.begin(), s.end(), [](auto c) { return c == \\'1\\'; }) && all_of(t.begin(), t.end(), [](auto c) { return c == \\'0\\'; }));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var makeStringsEqual = { s: String, t: String -> \\n        !(s.toCharArray().all{ it == \\'0\\' } && t.toCharArray().any{ it == \\'1\\' })\\n     && !(s.toCharArray().any{ it == \\'1\\' } && t.toCharArray().all{ it == \\'0\\' })\\n    }\\n}\\n```\n```\\nlet makeStringsEqual = (s, t) =>\\n    !(s.split(\\'\\').every(c => c == \\'0\\') && t.split(\\'\\').some(c => c == \\'1\\'))\\n && !(s.split(\\'\\').some(c => c == \\'1\\') && t.split(\\'\\').every(c => c == \\'0\\'));\\n```\n```\\nclass Solution:\\n    makeStringsEqual = lambda self, s, t: not (all(c == \\'0\\' for c in s) and any(c == \\'1\\' for c in t)) and not (any(c == \\'1\\' for c in s) and all(c == \\'0\\' for c in t))\\n```\n```\\nimpl Solution {\\n    pub fn make_strings_equal(s: String, t: String) -> bool {\\n        !(s.chars().all(|c| c == \\'0\\') && t.chars().any(|c| c == \\'1\\'))\\n     && !(s.chars().any(|c| c == \\'1\\') && t.chars().all(|c| c == \\'0\\'))\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        return !(all_of(s.begin(), s.end(), [](auto c) { return c == \\'0\\'; }) && any_of(t.begin(), t.end(), [](auto c) { return c == \\'1\\'; }))\\n            && !(any_of(s.begin(), s.end(), [](auto c) { return c == \\'1\\'; }) && all_of(t.begin(), t.end(), [](auto c) { return c == \\'0\\'; }));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090314,
                "title": "very-simple-and-easy-to-understand-accepted-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Case-1:** If both strings are same then return true.\\n    \\n**Case-2:** If exactly one of the strings is having all 0\\u2019s, then it is impossible to make the string s equal to target, then in this case return false.\\n\\n**Case-3:** In all other cases we can make the string s equal to target.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        if(s==t)        //If already both strings are same then return true.\\n        {\\n            return true;\\n        }\\n        else if(s.find(\"1\")==string::npos or t.find(\"1\")==string::npos)  // If exactly one of the strings is having all 0\\u2019s, then it is impossible to make the string s equal to target.\\n        {\\n            return false;\\n        }\\n        return true;  //In all other cases we can make the string s equal to target.\\n    }\\n};\\n\\n\\n\\n```\\n**Do upvote if it helps :)**\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        if(s==t)        //If already both strings are same then return true.\\n        {\\n            return true;\\n        }\\n        else if(s.find(\"1\")==string::npos or t.find(\"1\")==string::npos)  // If exactly one of the strings is having all 0\\u2019s, then it is impossible to make the string s equal to target.\\n        {\\n            return false;\\n        }\\n        return true;  //In all other cases we can make the string s equal to target.\\n    }\\n};\\n\\n\\n\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090308,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool makeStringsEqual(string s, string target) \\n    {\\n        int z1=0, z2=0;\\n        int n=s.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'0\\') z1++;\\n            if(target[x]==\\'0\\') z2++;\\n        }\\n        if(z1==n && z2==n) return true;\\n        if(z1==n || z2==n) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool makeStringsEqual(string s, string target) \\n    {\\n        int z1=0, z2=0;\\n        int n=s.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'0\\') z1++;\\n            if(target[x]==\\'0\\') z2++;\\n        }\\n        if(z1==n && z2==n) return true;\\n        if(z1==n || z2==n) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090235,
                "title": "java-2-solutions",
                "content": "```\\n    //2.\\n    //Runtime: 1 ms 100%; Memory: 54.5MB 16%\\n    //Time: O(N); Space: O(1)\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n\\n    //1.count 1\\n    //Runtime: 5ms 83%; Memory: 54.2MB 17%\\n    //Time: O(N); Space: O(1)\\n    public boolean makeStringsEqual_1(String s, String target) {\\n        boolean f1 = false, f2 = false;\\n        for (int i = 0; i < s.length() && (!f1); i++)\\n            f1 = s.charAt(i) - \\'0\\' == 1;\\n\\n        for (int i = 0; i < s.length() && (!f2); i++)\\n            f2 = target.charAt(i) - \\'0\\' == 1;\\n        return f1 == f2;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //2.\\n    //Runtime: 1 ms 100%; Memory: 54.5MB 16%\\n    //Time: O(N); Space: O(1)\\n    public boolean makeStringsEqual(String s, String target) {\\n        return s.contains(\"1\") == target.contains(\"1\");\\n    }\\n\\n    //1.count 1\\n    //Runtime: 5ms 83%; Memory: 54.2MB 17%\\n    //Time: O(N); Space: O(1)\\n    public boolean makeStringsEqual_1(String s, String target) {\\n        boolean f1 = false, f2 = false;\\n        for (int i = 0; i < s.length() && (!f1); i++)\\n            f1 = s.charAt(i) - \\'0\\' == 1;\\n\\n        for (int i = 0; i < s.length() && (!f2); i++)\\n            f2 = target.charAt(i) - \\'0\\' == 1;\\n        return f1 == f2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090064,
                "title": "apply-bitwise-operations-to-make-strings-equal-c-simple-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int st=count(begin(s),end(s),\\'1\\');\\n        int tt=count(begin(t),end(t),\\'1\\');\\n      if(st>0 && tt>0)return true;\\n        else if(st==0 && tt==0)return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int st=count(begin(s),end(s),\\'1\\');\\n        int tt=count(begin(t),end(t),\\'1\\');\\n      if(st>0 && tt>0)return true;\\n        else if(st==0 && tt==0)return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089800,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s == target)\\n        {\\n            return true;\\n        }\\n        int cnts0 = 0;\\n        int cntt0 = 0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                cnts0++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[i] == \\'0\\')\\n            {\\n                cntt0++;\\n            }\\n        }\\n        if(cnts0 == n || cntt0 == n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s == target)\\n        {\\n            return true;\\n        }\\n        int cnts0 = 0;\\n        int cntt0 = 0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                cnts0++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[i] == \\'0\\')\\n            {\\n                cntt0++;\\n            }\\n        }\\n        if(cnts0 == n || cntt0 == n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089714,
                "title": "easy-to-understand-100-fast-c-solution",
                "content": "public class Solution {\\n    public bool MakeStringsEqual(string s, string t) {\\n        int one_s=0,one_t=0;\\n        int flag=0;\\n        for(int i=0;i<s.Length;i++)\\n        {\\n            if(t[i]==\\'1\\')\\n                one_t++;\\n            if(s[i]==\\'1\\')\\n                one_s++;\\n            if(s[i]!=t[i])\\n                flag=1;\\n        }\\n        \\n        if(flag==0)\\n        return true;\\n        else\\n        {\\n            if(one_s==0||one_t==0)\\n                return false;\\n            else\\n                return true;\\n        }\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool MakeStringsEqual(string s, string t) {\\n        int one_s=0,one_t=0;\\n        int flag=0;\\n        for(int i=0;i<s.Length;i++)\\n        {\\n            if(t[i]==\\'1\\')\\n                one_t++;\\n            if(s[i]==\\'1\\')\\n                one_s++;\\n            if(s[i]!=t[i])\\n                flag=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3089225,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if s == target:\\n            return True\\n        ss = [int(i) for i in s]\\n        targets = [int(i) for i in target]\\n        if list(set(ss)) == [0]:\\n            return False\\n        change = []\\n        ones = ss.count(1)\\n        taro = targets.count(1)\\n        if taro == 0 and ones != 0:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if s == target:\\n            return True\\n        ss = [int(i) for i in s]\\n        targets = [int(i) for i in target]\\n        if list(set(ss)) == [0]:\\n            return False\\n        change = []\\n        ones = ss.count(1)\\n        taro = targets.count(1)\\n        if taro == 0 and ones != 0:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088889,
                "title": "go-o-n-explain-and-some-examples",
                "content": "# Code\\n```\\nfunc makeStringsEqual(s string, target string) bool {\\n    /*\\n    Four situations of s[i], s[j]:\\n    1 or 1 = 1    1 xor 1 = 0    (1,1) -> (1,0) / (0,1)\\n    1 or 0 = 1    1 xor 0 = 1    (1,0) -> (1,1)\\n    0 or 1 = 1    0 xor 1 = 1    (0,1) -> (1,1)\\n    0 or 0 = 0    0 xor 0 = 0    (0,0) -> (0,0)\\n    \\n    So we can convert all of `11` to `01`, and `10` to `01`\\n    11 -> 01\\n    00\\n    111 -> 011 -> 001\\n    000\\n    1111 -> 0101 -> 0001\\n    0000\\n    1111111 -> 0101011 -> 0001001 -> 0000001\\n    0000001\\n    101110100 -> 001010100 -> 000010100 -> 000000100\\n    110011000 -> 010001000 -> 000001000\\n\\n    We only need to care about the count of `1`\\n    */\\n    s1 := 0\\n    for _, c := range(s) {\\n        if c == \\'1\\' { s1 += 1 }\\n    }\\n    t1 := 0\\n    for _, c := range(target) {\\n        if c == \\'1\\' { t1 += 1}\\n    }\\n    if (s1 == 0 && t1 != 0) || (s1 != 0 && t1 == 0) { return false }\\n    return true\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeStringsEqual(s string, target string) bool {\\n    /*\\n    Four situations of s[i], s[j]:\\n    1 or 1 = 1    1 xor 1 = 0    (1,1) -> (1,0) / (0,1)\\n    1 or 0 = 1    1 xor 0 = 1    (1,0) -> (1,1)\\n    0 or 1 = 1    0 xor 1 = 1    (0,1) -> (1,1)\\n    0 or 0 = 0    0 xor 0 = 0    (0,0) -> (0,0)\\n    \\n    So we can convert all of `11` to `01`, and `10` to `01`\\n    11 -> 01\\n    00\\n    111 -> 011 -> 001\\n    000\\n    1111 -> 0101 -> 0001\\n    0000\\n    1111111 -> 0101011 -> 0001001 -> 0000001\\n    0000001\\n    101110100 -> 001010100 -> 000010100 -> 000000100\\n    110011000 -> 010001000 -> 000001000\\n\\n    We only need to care about the count of `1`\\n    */\\n    s1 := 0\\n    for _, c := range(s) {\\n        if c == \\'1\\' { s1 += 1 }\\n    }\\n    t1 := 0\\n    for _, c := range(target) {\\n        if c == \\'1\\' { t1 += 1}\\n    }\\n    if (s1 == 0 && t1 != 0) || (s1 != 0 && t1 == 0) { return false }\\n    return true\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088616,
                "title": "easy-to-understand-c-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nXOR gives 0 if both the input is same otherwise gives 1\\n\\nOR gives 0 if both the input is 0 otherwise gives 1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the number of ones in both the strings.\\n\\nif both strings contains >=1 ones then s can be converted into target.\\nwe can select the indexes which are different and second index which is one.\\n\\nif number of ones in both strings is 0 then they are already same\\n\\nelse the given string cannot be converted into target because we need at least 1 ones in s to alternate its bits.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int s_one=0, tar_one=0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'1\\') s_one++;\\n            if(target[i]==\\'1\\') tar_one++;\\n        }\\n        \\n        if(s_one>=1&&tar_one>=1) return true;\\n        else if(s_one==0 && tar_one==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int s_one=0, tar_one=0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'1\\') s_one++;\\n            if(target[i]==\\'1\\') tar_one++;\\n        }\\n        \\n        if(s_one>=1&&tar_one>=1) return true;\\n        else if(s_one==0 && tar_one==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088330,
                "title": "easy-python-solution",
                "content": "\\tdef makeStringsEqual(self, s: str, target: str) -> bool:\\n        n=len(s)\\n        if(s==target):\\n            return True\\n        if(s.count(\"0\")==n or target.count(\"0\")==n):\\n            return False\\n        return True",
                "solutionTags": [],
                "code": "\\tdef makeStringsEqual(self, s: str, target: str) -> bool:\\n        n=len(s)\\n        if(s==target):\\n            return True\\n        if(s.count(\"0\")==n or target.count(\"0\")==n):\\n            return False\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 3088026,
                "title": "c-rule-based-o-n",
                "content": "# Problem\\n\\n[Account Login - LeetCode](https://leetcode.com/contest/weekly-contest-329/problems/apply-bitwise-operations-to-make-strings-equal/)\\n\\n# Analysis\\n\\nThe problem looks scared at the first glance. Bit manipulation is always not very intuitive by reading. So let\\u2019s write down all possible transformations to see if we can find a rule. Since the problem doesn\\u2019t have requirement on i compared to j. So any number can be `s[i]` and any number else can be `s[j]`. \\n\\nIf we have `s[i]` and `s[j]`\\n\\n1. 1,0 \\u21921|0, 1^0 \\u2192 1,1 \\n2. 0,1 \\u21920|1, 0^1 \\u2192 1,1\\n3. 1,1 \\u21921|1, 1^1 \\u2192 1,0\\n4. 0,0 \\u21920|0, 0^0 \\u2192 0,0\\n\\nSo we can observe that, is there is `s[k] = 1`, any values else can be freely flipped but the `s[k]` =1 cannot be eliminated. If `s` is all 0, no value can be changed.\\n\\nSo if `s` is all 0, return `true` iff`target` is all 0. if `s` has a `1`, return `true` iff `target` has at lease an `1`\\n\\n# Solution\\n\\nTime: O(N)\\n\\nSpace: O(1)\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n\\t\\t// 1 0: 1 | 0 = 1, 1 ^ 0 = 1\\n\\t\\t// 0 0: 0 | 0 = 0, 0 ^ 0 = 0\\n\\t\\t// 0 1: 0 | 1 = 1, 0 ^ 1 = 1\\n\\t\\t// 1 1: 1 | 1 = 1, 1 ^ 1 = 0\\n\\t\\t// random 1 0 -> 1 1, 0 1 -> 1 1, 1 1 -> 1 0, 0 0 -> 0 0\\n\\t\\t// i,j is randomly chosen\\n\\t\\t// so if we have a \\'1\\' in s, we can make 0 to 1 and 1 to 0\\n\\t\\t// 1. if s is all \\'0\\' we can change nothing\\n\\t\\t// 2. if target is all \\'0\\' we can not achieve \\n\\t\\tbool haveOne = false;\\n\\t\\tfor(char c : target)\\n\\t\\t\\thaveOne |= c == \\'1\\';\\n\\t\\tif(!haveOne) return s == target;\\n\\t\\thaveOne = false;\\n\\t\\tfor(char c : s)\\n\\t\\t\\thaveOne |= c == \\'1\\';\\n\\t\\treturn haveOne;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n\\t\\t// 1 0: 1 | 0 = 1, 1 ^ 0 = 1\\n\\t\\t// 0 0: 0 | 0 = 0, 0 ^ 0 = 0\\n\\t\\t// 0 1: 0 | 1 = 1, 0 ^ 1 = 1\\n\\t\\t// 1 1: 1 | 1 = 1, 1 ^ 1 = 0\\n\\t\\t// random 1 0 -> 1 1, 0 1 -> 1 1, 1 1 -> 1 0, 0 0 -> 0 0\\n\\t\\t// i,j is randomly chosen\\n\\t\\t// so if we have a \\'1\\' in s, we can make 0 to 1 and 1 to 0\\n\\t\\t// 1. if s is all \\'0\\' we can change nothing\\n\\t\\t// 2. if target is all \\'0\\' we can not achieve \\n\\t\\tbool haveOne = false;\\n\\t\\tfor(char c : target)\\n\\t\\t\\thaveOne |= c == \\'1\\';\\n\\t\\tif(!haveOne) return s == target;\\n\\t\\thaveOne = false;\\n\\t\\tfor(char c : s)\\n\\t\\t\\thaveOne |= c == \\'1\\';\\n\\t\\treturn haveOne;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087998,
                "title": "python3-easy-solution",
                "content": "According to the problem we can always change s to target unless the string contains 1 because then there is no way to change it any longer as there is no way to change it to an all-zero string.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if (\\'1\\' not in s) or (\\'1\\' not in target):\\n           return s == target\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        if (\\'1\\' not in s) or (\\'1\\' not in target):\\n           return s == target\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087762,
                "title": "java-easy-solution",
                "content": "# Java || Best Solution || Easy \\uD83D\\uDE0A\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        \\n        int Numbers = s.length();\\n        int First_no=0, Second_no=0;\\n        \\n        for(int i=0; i<Numbers; i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                First_no++;\\n            }\\n            if(target.charAt(i)==\\'1\\'){\\n                Second_no++;\\n            }\\n          \\n        }\\n      if(First_no>0 && Second_no==0){\\n          return false;\\n      }\\n        if(First_no==0 && Second_no>0){\\n            return false;\\n        }\\n        return true; \\n    }\\n}\\n```\\nPlease Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        \\n        int Numbers = s.length();\\n        int First_no=0, Second_no=0;\\n        \\n        for(int i=0; i<Numbers; i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                First_no++;\\n            }\\n            if(target.charAt(i)==\\'1\\'){\\n                Second_no++;\\n            }\\n          \\n        }\\n      if(First_no>0 && Second_no==0){\\n          return false;\\n      }\\n        if(First_no==0 && Second_no>0){\\n            return false;\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087715,
                "title": "one-liner-with-detailed-explanation-beginner-friendly",
                "content": "# Intuition\\nSuppose we pick any two digits. \\nIf they are \"10\", they can be transformed into \"11\" and \"01\". \\nIf they are \"01\", they can be transformed into \"11\" and \"10\". \\nIf they are \"11\", they can be transformed into \"01\" and \"10\"\\nIf they are \"00\", nothing can be done.\\n\\nTo conclude, \"10\", \"11\", \"01\" are basically equivalent.\\n \\nSo we observe that if a string `s` has a \"1\", it can be transformed to any string `target`, as long as `target` also has a \"1\". In other words, if they both contain \"1\", they are equivalent under unlimited transformations.\\n\\nIf none of them has \"1\", it means they are both all \"0\", and since by assumption their lengths are the same, they are just the same.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\"1\" in s) == (\"1\" in target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\"1\" in s) == (\"1\" in target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087598,
                "title": "easy-best-solution-in-c-with-comments",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\n//if both the strings will contain atleast one \\'1\\' then ans will always be true and also when both of them will contain no \\'1\\'(i.e number of \\'1\\'s is both strings is zero)\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size(),tar_1=0,s_1=0;\\n        for(auto it:target)\\n            if(it==\\'1\\'){\\n                tar_1++;\\n                break;\\n            }\\n        for(auto it:s)\\n            if(it==\\'1\\'){\\n                s_1++;\\n                break;\\n            }\\n        if((tar_1 == 1 && s_1 == 1) || (tar_1==0 && s_1==0))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//if both the strings will contain atleast one \\'1\\' then ans will always be true and also when both of them will contain no \\'1\\'(i.e number of \\'1\\'s is both strings is zero)\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.size(),tar_1=0,s_1=0;\\n        for(auto it:target)\\n            if(it==\\'1\\'){\\n                tar_1++;\\n                break;\\n            }\\n        for(auto it:s)\\n            if(it==\\'1\\'){\\n                s_1++;\\n                break;\\n            }\\n        if((tar_1 == 1 && s_1 == 1) || (tar_1==0 && s_1==0))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087591,
                "title": "python-3-one-liner",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\\'1\\' in s) == (\\'1\\' in target)     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\\'1\\' in s) == (\\'1\\' in target)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087476,
                "title": "ruby",
                "content": "```ruby\\ndef make_strings_equal(s, t) =\\n    s.include?(?1) == t.include?(?1)\\n```\\n```ruby\\ndef make_strings_equal(s, t) = !s[?1] == !t[?1]\\n```\\nExplanation: https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3083831/java-c-python-1-line-check-1/",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef make_strings_equal(s, t) =\\n    s.include?(?1) == t.include?(?1)\\n```\n```ruby\\ndef make_strings_equal(s, t) = !s[?1] == !t[?1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3087069,
                "title": "golang-7-ms-6-3-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc makeStringsEqual(s string, target string) bool {\\n\\tvar haveOnesS, haveOnesTarget bool\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\thaveOnesS = true\\n\\t\\t}\\n\\t\\tif target[i] == \\'1\\' {\\n\\t\\t\\thaveOnesTarget = true\\n\\t\\t}\\n\\t}\\n\\treturn haveOnesS == haveOnesTarget\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeStringsEqual(s string, target string) bool {\\n\\tvar haveOnesS, haveOnesTarget bool\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\thaveOnesS = true\\n\\t\\t}\\n\\t\\tif target[i] == \\'1\\' {\\n\\t\\t\\thaveOnesTarget = true\\n\\t\\t}\\n\\t}\\n\\treturn haveOnesS == haveOnesTarget\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086950,
                "title": "java-one-of-the-easiest-solution-with-explanation-but-what-wired-question-it-is",
                "content": "**Approach**\\n\\nThe question is quite easy to understand, but when it comes to solving it with the given constraints, its quite trick.\\n\\nTherefore we need to look at the question from different angle. and figure out.\\n\\nSince the String, contains binary it means that there can be combinations possible\\n\\n```\\n\\tinitial | final Result\\n\\ti   j   | i  j\\n\\t0 0  |0 0\\n\\t0 1 | 1  1\\n\\t1 0 | 1  1\\n\\t1  1 | 1 0\\n```\\n\\nNow with this table we can observe that even if there existing only one \"1\" on both the String at any place.\\nit would gives us result\\n\\n**Solution**\\n\\n```\\npublic static boolean makeStringsEqual(String s, String target) {\\n        if (s.equals(target)) return true;\\n        if (s.contains(\"1\") && target.contains(\"1\")) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\tinitial | final Result\\n\\ti   j   | i  j\\n\\t0 0  |0 0\\n\\t0 1 | 1  1\\n\\t1 0 | 1  1\\n\\t1  1 | 1 0\\n```\n```\\npublic static boolean makeStringsEqual(String s, String target) {\\n        if (s.equals(target)) return true;\\n        if (s.contains(\"1\") && target.contains(\"1\")) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086698,
                "title": "code-is-simple-and-short-explaination-is-done-superb-simple",
                "content": "# idea\\nThe code is so simple, but logic is kind of very tricky\\nS = 0010\\nT = 1010\\nANS : TRUE we can convert S to T, How?\\njust take i=2 and j=0. so XOR val is 1 that is replaced at 0th idx, and OR val is 1, so that is kept at 2th idx to keep 1 as 1.\\n\\n- Here they told i j. But no cond like i<j or any\\n- Thereby we can put xor and or ans as we like\\n- Now all we need to do is take 2 bits, apply xor and or, put those 2 results in the S\\n- How to choose next question?\\n- We need to observe:\\n- 0 0 : XOR=0 OR=0\\n- 0 1, 1 0 : XOR = 1 OR=1\\n- 1 1 : XOR = 0 OR = 1\\n- So observe observe, with 0 0 u can do nothing\\n- But to SET a bit we can use 01 10 pairs so that res has 0 -> 1\\n- TO UNSET a bit we can use 11 so that res has 1->0\\n- Eg:\\n- 1010 => 0010 pick **1**0**1**0\\n- 1010 => 1000 pick 1**01**0\\n- Now you may say to do any we need a helper bit that is 1\\n- But in a spl case IF helper bit itself we need to make it as 0. Then we need some bit that is 1.\\n- So to assure that we need 1 bit that is 1 in TARGET. So that we assure that it\\'s first converted with helper bit and later the helper bit is changed with it.\\n- So thats what we did, search for 1 in both and return the ans\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s == target) return true; // to tackle edge case: s\"000\" t\"000\"\\n        bool b1,b2;\\n        b1 = b2 = false;\\n        int N = s.size();\\n        for(int i=0; i<N; i++){\\n            if(s[i] == \\'1\\') b1 = true;\\n            if(target[i] == \\'1\\') b2=true;\\n        }\\n        if(b1 && b2) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s == target) return true; // to tackle edge case: s\"000\" t\"000\"\\n        bool b1,b2;\\n        b1 = b2 = false;\\n        int N = s.size();\\n        for(int i=0; i<N; i++){\\n            if(s[i] == \\'1\\') b1 = true;\\n            if(target[i] == \\'1\\') b2=true;\\n        }\\n        if(b1 && b2) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086659,
                "title": "easy-to-understand-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf one out of the two strings have all 0\\'s in it then it is not possible to make them equal.\\n\\nIf both the strings have all zeros in them, then they are equal.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int sz = 0;\\n        int tz = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\'){\\n                sz++;\\n            }\\n            if(target[i] == \\'1\\'){\\n                tz++;\\n            }\\n        }\\n        if((sz == 0 && tz != 0)|| (sz != 0 && tz == 0)){\\n            return false;\\n        }   \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int sz = 0;\\n        int tz = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\'){\\n                sz++;\\n            }\\n            if(target[i] == \\'1\\'){\\n                tz++;\\n            }\\n        }\\n        if((sz == 0 && tz != 0)|| (sz != 0 && tz == 0)){\\n            return false;\\n        }   \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086616,
                "title": "go-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a 0 needs to be converted to 1, we need to OR it with a 1. If a 1 needs to be converted to 0, we need to XOR it with a 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if there is atleast one :\\n- 1 that needs to be converted to 0\\n- 0 that needs to be converted to 1\\n- 1 that remains 1 in the target\\n\\nAfter this, if we consider a index i with 0 and index j with 1, i = i or j, will be i = 1 and j = i xor j, will be i = 1 as well. Hence to convert all 0s that need to be converted to 1s, we need atleast one index which has 1. After this, for all 1s that need to be converted to 0s, we need atleast a single 1. Now if i = 1 and j = 1, i = i xor j will be i = 0 and j = i or j will be j = 1. The 0s that were converted to 1s can also be used here. If we only have 1s that need to be converted to 0s and not 0s that need to be converted to 1s, we just check if we have atleast a single 1 that remains the same in target.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nfunc makeStringsEqual(s string, target string) bool {\\n    xors := false // check if there is >= 1 1s that need to be converted to 0s\\n    ors := false // check if there is >= 1 0s that need to be converted to 1s\\n    ones := false // check if there is >= 1 1s that remain the same\\n    \\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] != target[i] {\\n            if s[i] == 49 {\\n                xors = true\\n            } else {\\n                ors = true\\n            }\\n        } else if s[i] == 49 {\\n            ones = true// these ones\\n        }\\n    }\\n    \\n    if ors {\\n        if xors || ones { // all req 0s can be converted to 1s\\n            if xors { // if we need to convert 1s to 0s\\n                if ones || ors { // all required 1s can be converted to 0s, newly converted 0s to 1s can also be used for this\\n                    return true;\\n                } else { // all required 1s can\\'t be converted to 0s\\n                    return false;\\n                }\\n            }\\n            return true; // no 1s are required to be turned to 0s so return true\\n        } else {\\n            return false; // all req 0s cant be converted to 1s\\n        }\\n    }\\n    \\n    if xors { // if we only have 1s that need to turned to 0s\\n        if ones { //we need atleast one 1 that doesn\\'t need to be turned to 0 so it can be used with other ones that need to be convrted to 0. Those 1s can be xor(ed) with this one and the one can be or(ed)\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    return true;  \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeStringsEqual(s string, target string) bool {\\n    xors := false // check if there is >= 1 1s that need to be converted to 0s\\n    ors := false // check if there is >= 1 0s that need to be converted to 1s\\n    ones := false // check if there is >= 1 1s that remain the same\\n    \\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] != target[i] {\\n            if s[i] == 49 {\\n                xors = true\\n            } else {\\n                ors = true\\n            }\\n        } else if s[i] == 49 {\\n            ones = true// these ones\\n        }\\n    }\\n    \\n    if ors {\\n        if xors || ones { // all req 0s can be converted to 1s\\n            if xors { // if we need to convert 1s to 0s\\n                if ones || ors { // all required 1s can be converted to 0s, newly converted 0s to 1s can also be used for this\\n                    return true;\\n                } else { // all required 1s can\\'t be converted to 0s\\n                    return false;\\n                }\\n            }\\n            return true; // no 1s are required to be turned to 0s so return true\\n        } else {\\n            return false; // all req 0s cant be converted to 1s\\n        }\\n    }\\n    \\n    if xors { // if we only have 1s that need to turned to 0s\\n        if ones { //we need atleast one 1 that doesn\\'t need to be turned to 0 so it can be used with other ones that need to be convrted to 0. Those 1s can be xor(ed) with this one and the one can be or(ed)\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    return true;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086276,
                "title": "c-simple-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we put a table of all possible arguments and corresponding outcomes:\\n\\n```\\n0, 0 => 0, 0\\n0, 1 => 1, 1\\n1, 0 => 1, 1\\n1, 1 => 1, 0\\n        0, 1 (if we swap i and j)\\n```  \\n\\nSo having at least on `1` within `s` we can make any combination except all zeroes; we can\\'t do anything with all zeroes `s`. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple test for all zero case\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(1)`\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool MakeStringsEqual(string s, string target) {\\n        if (s.Length != target.Length) \\n            return false;\\n\\n        if (s.All(c => c == \\'0\\') || target.All(c => c == \\'0\\'))\\n            return s == target;\\n\\n        return true;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n0, 0 => 0, 0\\n0, 1 => 1, 1\\n1, 0 => 1, 1\\n1, 1 => 1, 0\\n        0, 1 (if we swap i and j)\\n```\n```\\npublic class Solution {\\n    public bool MakeStringsEqual(string s, string target) {\\n        if (s.Length != target.Length) \\n            return false;\\n\\n        if (s.All(c => c == \\'0\\') || target.All(c => c == \\'0\\'))\\n            return s == target;\\n\\n        return true;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086128,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n    return s.includes(\"1\") === target.includes(\"1\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n    return s.includes(\"1\") === target.includes(\"1\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086119,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n    return s.split(\\'\\').find((_)=> _ == \"1\") === target.split(\\'\\').find((_)=> _ == \"1\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar makeStringsEqual = function(s, target) {\\n    return s.split(\\'\\').find((_)=> _ == \"1\") === target.split(\\'\\').find((_)=> _ == \"1\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086071,
                "title": "c-explanation-with-easy-approach-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore all the count of 1 and 0 of both strings .\\nif any string has zero greater than or equal to sum of one and zero that means it cant be make equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nremember the base case that if they are already equal.then return true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int ct1=0,ct0=0;\\n            if(s==t)                       // if equal return true\\n                    return true;\\n            for(int i=0;i<s.size();++i)\\n            {\\n                    if(s[i]==\\'1\\')\\n                            ct1++;\\n                    else\\n                            ct0++;\\n            }\\n        int cnt1=0,cnt0=0;\\n            for(int i=0;i<t.size();++i)\\n            {\\n                    if(t[i]==\\'1\\')\\n                            cnt1++;\\n                    else\\n                            cnt0++;\\n            }\\n            if(cnt0>=ct1+ct0 || ct0>=cnt1+cnt0)   \\n                    return false;\\n            else\\n                    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int ct1=0,ct0=0;\\n            if(s==t)                       // if equal return true\\n                    return true;\\n            for(int i=0;i<s.size();++i)\\n            {\\n                    if(s[i]==\\'1\\')\\n                            ct1++;\\n                    else\\n                            ct0++;\\n            }\\n        int cnt1=0,cnt0=0;\\n            for(int i=0;i<t.size();++i)\\n            {\\n                    if(t[i]==\\'1\\')\\n                            cnt1++;\\n                    else\\n                            cnt0++;\\n            }\\n            if(cnt0>=ct1+ct0 || ct0>=cnt1+cnt0)   \\n                    return false;\\n            else\\n                    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086001,
                "title": "easy-video-solution-observation-based-o-n-c-beginner-friendly",
                "content": "# Intuition and Approach\\nhttps://youtu.be/jM2c-6_0ajo\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        bool flag1=false,flag2=false;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\') flag1=true;\\n            if(target[i]==\\'1\\') flag2=true;\\n        }\\n        return (s==target|(flag1&flag2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        bool flag1=false,flag2=false;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\') flag1=true;\\n            if(target[i]==\\'1\\') flag2=true;\\n        }\\n        return (s==target|(flag1&flag2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085973,
                "title": "accepted-easy-to-understand-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int n = s.length();\\n        int c0 = 0, c1 = 0;\\n        for(auto x: s) {\\n            if(x==\\'0\\') c0++;\\n            else c1++;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            if(s[i] == t[i]) continue;\\n            else {\\n                if(t[i] == \\'0\\') \\n                {\\n                    // i.e => s[i] == 1\\n                    if(c1 >= 2) {\\n                        s[i] = \\'0\\';\\n                        c1--;\\n                    }\\n                }\\n                else {\\n                    // i.e => s[i] == 0\\n                    if(c1>=1) {\\n                        s[i]=\\'1\\';\\n                        c1++;\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--) \\n        {\\n            if(s[i] == t[i]) continue;\\n            else {\\n                if(t[i] == \\'0\\') \\n                {\\n                    // i.e => s[i] == 1\\n                    if(c1 >= 2) {\\n                        s[i] = \\'0\\';\\n                        c1--;\\n                    }\\n                }\\n                else {\\n                    // i.e => s[i] == 0\\n                    if(c1>=1) {\\n                        s[i]=\\'1\\';\\n                        c1++;\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return (s==t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int n = s.length();\\n        int c0 = 0, c1 = 0;\\n        for(auto x: s) {\\n            if(x==\\'0\\') c0++;\\n            else c1++;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            if(s[i] == t[i]) continue;\\n            else {\\n                if(t[i] == \\'0\\') \\n                {\\n                    // i.e => s[i] == 1\\n                    if(c1 >= 2) {\\n                        s[i] = \\'0\\';\\n                        c1--;\\n                    }\\n                }\\n                else {\\n                    // i.e => s[i] == 0\\n                    if(c1>=1) {\\n                        s[i]=\\'1\\';\\n                        c1++;\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--) \\n        {\\n            if(s[i] == t[i]) continue;\\n            else {\\n                if(t[i] == \\'0\\') \\n                {\\n                    // i.e => s[i] == 1\\n                    if(c1 >= 2) {\\n                        s[i] = \\'0\\';\\n                        c1--;\\n                    }\\n                }\\n                else {\\n                    // i.e => s[i] == 0\\n                    if(c1>=1) {\\n                        s[i]=\\'1\\';\\n                        c1++;\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return (s==t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085916,
                "title": "very-simple-and-easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n       int c1=0;\\n        for(auto it : s)\\n        {\\n            if(it==\\'1\\')\\n            {\\n                c1++;\\n            }\\n        }\\n        int t1=0;\\n        for(auto it : target)\\n        {\\n            if(it==\\'1\\')\\n            {\\n                t1++;\\n            }\\n        }\\n        \\n        if((c1!=0 && t1!=0) || (c1==0 &&t1==0)) // when both string is \"0000\" like this ....\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n       int c1=0;\\n        for(auto it : s)\\n        {\\n            if(it==\\'1\\')\\n            {\\n                c1++;\\n            }\\n        }\\n        int t1=0;\\n        for(auto it : target)\\n        {\\n            if(it==\\'1\\')\\n            {\\n                t1++;\\n            }\\n        }\\n        \\n        if((c1!=0 && t1!=0) || (c1==0 &&t1==0)) // when both string is \"0000\" like this ....\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085825,
                "title": "optimised-approach-easy-o-n-time-complexity",
                "content": "# Intuition: Visualise a pattern that when we choose two indices and they encountered to be either \\'10\\' elements when combined,then after applying the operations any number of times, we get 10,11,10,11,10....similar kind of pattern similarly even after exchanging their indices i.e. making i to j or vice versa, we are gonna see the similar kind of pattern such as : 10,11,01,11...so on. This gives us an understanding that we can make the string same if there is presence of ones in both the strings. If we found any of the string with count of ones as zero, then it is impossible and so return false in that case otherwise return true.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Store the count of ones for both the strings.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) \\n    {\\n        int count_ones=0,count_onet=0,count_zeros=0,count_zerot=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                count_ones++;\\n            else\\n                count_zeros++;\\n        }\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(target[i]==\\'1\\')\\n                count_onet++;\\n            else\\n                count_zerot++;\\n        }\\n        if(count_ones==0 && count_onet>0)\\n            return false;\\n        else if(count_ones>0 && count_onet==0)\\n            return false;\\n        else \\n            return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) \\n    {\\n        int count_ones=0,count_onet=0,count_zeros=0,count_zerot=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                count_ones++;\\n            else\\n                count_zeros++;\\n        }\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(target[i]==\\'1\\')\\n                count_onet++;\\n            else\\n                count_zerot++;\\n        }\\n        if(count_ones==0 && count_onet>0)\\n            return false;\\n        else if(count_ones>0 && count_onet==0)\\n            return false;\\n        else \\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085824,
                "title": "efficient-soln-c",
                "content": "# Intuition\\nshortest method\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n       if(s==target)\\n       {\\n           return true;\\n       }\\n        int x=0;int y=0;\\n        if(s!=target)\\n        {\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                   x=1; \\n                }\\n                \\n            }\\n            for(int i=0;i<target.length();i++)\\n            {\\n                if(target[i]==\\'1\\')\\n                {\\n                    y=1;\\n                }\\n            }\\n            \\n        }\\n        return x&y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n       if(s==target)\\n       {\\n           return true;\\n       }\\n        int x=0;int y=0;\\n        if(s!=target)\\n        {\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                   x=1; \\n                }\\n                \\n            }\\n            for(int i=0;i<target.length();i++)\\n            {\\n                if(target[i]==\\'1\\')\\n                {\\n                    y=1;\\n                }\\n            }\\n            \\n        }\\n        return x&y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085790,
                "title": "c-stupid-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s, string target){\\n        int ones=0, zeroes=0;\\n        for(char c:s){\\n            if(c==\\'1\\') ones++;\\n            else zeroes++;\\n        }\\n        int i=0;\\n        while(i<s.length()){\\n            if(s[i]!=target[i]){\\n                if(target[i]==\\'0\\'){\\n                    if(ones-1<=0) return false;\\n                    else{\\n                        s[i]=\\'0\\';\\n                        zeroes++;\\n                        ones--;\\n                    }\\n                }else{\\n                    if(ones<=0) return false;\\n                    else{\\n                        s[i]=\\'1\\';\\n                        ones++;\\n                    }\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        return true;\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        string temp = s;\\n        reverse(temp.begin(),temp.end());\\n        return check(s,target) || check(temp,target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s, string target){\\n        int ones=0, zeroes=0;\\n        for(char c:s){\\n            if(c==\\'1\\') ones++;\\n            else zeroes++;\\n        }\\n        int i=0;\\n        while(i<s.length()){\\n            if(s[i]!=target[i]){\\n                if(target[i]==\\'0\\'){\\n                    if(ones-1<=0) return false;\\n                    else{\\n                        s[i]=\\'0\\';\\n                        zeroes++;\\n                        ones--;\\n                    }\\n                }else{\\n                    if(ones<=0) return false;\\n                    else{\\n                        s[i]=\\'1\\';\\n                        ones++;\\n                    }\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        return true;\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        string temp = s;\\n        reverse(temp.begin(),temp.end());\\n        return check(s,target) || check(temp,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085782,
                "title": "four-counters-explanation",
                "content": "# Intuition\\n\\nLet\\'s take a look at transformations for different `s[i]` and `s[j]`:\\n\\n![image.png](https://assets.leetcode.com/users/images/1306f500-a3c1-4714-bbda-f30bfae58dfe_1674385764.0040498.png)\\n\\n\\n`s[i]*` and `s[j]*` are the values after transformation. What can we see:\\n1. The 1st row we can ignore, it does nothing: `0, 0 -> 0, 0`\\n2. The 2nd and the 3rd rows show we can convert a pair (`0 and 1`) to `1, 1`\\n3. The 4th-row show we can convert `1, 1` to `0, 1`/`1, 0`.\\n\\nBased on that we can say that any pair `1, 0` can be transformed to `0, 1` by 2 operations: `1, 0` -> `1, 1` -> `0, 1`.\\n*The second conclusion* is we cannot transform `0` to `1` if `s` doesn\\'t have `1` at all. For example `0000` cannot be transformed to `0001`, but `1000` can be transformed to `0001`.\\n\\n---\\n\\n\\n# Approach\\n\\n1. Count all `0` and `1` (`zero_c` and `one_c`) which need to be transformed and all `0` and `1` which doesn\\'t (`zero_a` and `one_a`)\\n2. If `0` and `1` counts to replace are equals, we can transform `s`.\\n3. If `0` count is bigger we need to check if `s` has any `1` (see *The second conclusion* above): `one_c` or `one_a` > 0\\n4. If `1` count is bigger and needs to check if we will be able to transform all `1` to `0`. We can do it if `s` has `1`.\\n    a. `s` has `1` which **should not** be transformed (we can use the 4th formula to transform all `1` to `0`) and we are fine\\n    b. `s` has a `0` which **should** be transformed (so, it will become `1`) and we are fine too using the 4th formula\\n\\n---\\n\\n\\n\\n**Upvote if you get it please.**\\n*Ask any question if doesn\\'t.*\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        zero_c, one_c, zero_a, one_a = 0, 0, 0, 0\\n        for i in range(len(s)):\\n            if s[i] == target[i]:\\n                if s[i] == \\'0\\':\\n                    zero_a += 1\\n                else:\\n                    one_a += 1\\n                continue\\n            if s[i] == \\'0\\':\\n                zero_c += 1\\n            else:\\n                one_c += 1\\n        if zero_c == one_c:\\n            return True\\n        if zero_c > one_c:\\n            if one_c > 0 or one_a > 0:\\n                return True\\n            return False\\n        else:\\n            if one_a > 0 or zero_c > 0:\\n                return True\\n            return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        zero_c, one_c, zero_a, one_a = 0, 0, 0, 0\\n        for i in range(len(s)):\\n            if s[i] == target[i]:\\n                if s[i] == \\'0\\':\\n                    zero_a += 1\\n                else:\\n                    one_a += 1\\n                continue\\n            if s[i] == \\'0\\':\\n                zero_c += 1\\n            else:\\n                one_c += 1\\n        if zero_c == one_c:\\n            return True\\n        if zero_c > one_c:\\n            if one_c > 0 or one_a > 0:\\n                return True\\n            return False\\n        else:\\n            if one_a > 0 or zero_c > 0:\\n                return True\\n            return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085675,
                "title": "python-solution-o-1-check-one-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\\'1\\' in target and \\'1\\' in s) or s == target\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (\\'1\\' in target and \\'1\\' in s) or s == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085653,
                "title": "c-simple-intuition-logical",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.length();\\n        int cnt=0;\\n        int cnt2=0;\\n        for(int i=0;i<n;i++){\\n               if(s[i]==\\'0\\' ){\\n                     cnt++;\\n               }\\n        }\\n         for(int i=0;i<n;i++){\\n               if(target[i]==\\'0\\' ){\\n                     cnt2++;\\n               }\\n        }\\n\\n        if(cnt==cnt2){\\n            return true;\\n        }\\n        if(cnt==n || cnt2==n){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        int n=s.length();\\n        int cnt=0;\\n        int cnt2=0;\\n        for(int i=0;i<n;i++){\\n               if(s[i]==\\'0\\' ){\\n                     cnt++;\\n               }\\n        }\\n         for(int i=0;i<n;i++){\\n               if(target[i]==\\'0\\' ){\\n                     cnt2++;\\n               }\\n        }\\n\\n        if(cnt==cnt2){\\n            return true;\\n        }\\n        if(cnt==n || cnt2==n){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085628,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) \\n            return true;\\n        auto ind1 = s.find(\\'1\\');\\n        auto ind2 = target.find(\\'1\\');\\n        if (ind1 != string::npos && ind2 != string::npos) \\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if (s == target) \\n            return true;\\n        auto ind1 = s.find(\\'1\\');\\n        auto ind2 = target.find(\\'1\\');\\n        if (ind1 != string::npos && ind2 != string::npos) \\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085549,
                "title": "python-simple-solution-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (s.count(\\'1\\') > 0 and target.count(\\'1\\') > 0) or (s.count(\\'1\\') == 0 and target.count(\\'1\\') == 0)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return (s.count(\\'1\\') > 0 and target.count(\\'1\\') > 0) or (s.count(\\'1\\') == 0 and target.count(\\'1\\') == 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085491,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)\\n        return true;\\n        int n=s.length();\\n        int flag=0;\\n        for(auto it:s)\\n        {\\n            if(it==\\'1\\')\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n        return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[i]==\\'1\\')\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target)\\n        return true;\\n        int n=s.length();\\n        int flag=0;\\n        for(auto it:s)\\n        {\\n            if(it==\\'1\\')\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n        return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[i]==\\'1\\')\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085469,
                "title": "c-simple-soution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        bool f=true;\\n        int zero=0,o=0;\\n        for(int i=0; i<s.size(); i++) if(s[i]==\\'0\\') zero++;\\n        for(int i=0; i<t.size(); i++) if(t[i]==\\'0\\')  o++;\\n        \\n        if(zero==s.size() || o==t.size()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        bool f=true;\\n        int zero=0,o=0;\\n        for(int i=0; i<s.size(); i++) if(s[i]==\\'0\\') zero++;\\n        for(int i=0; i<t.size(); i++) if(t[i]==\\'0\\')  o++;\\n        \\n        if(zero==s.size() || o==t.size()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085298,
                "title": "c-easy-to-understrand-solution-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Basic Properties of Bitwise OR and Bitwise XOR\\n->The result of OR is 1 if any of the two bits is 1. \\n->The result of XOR is 1 if the two bits are different.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, get count of 1 and 0 in both string s, target.\\nAnd simpli apply above rules\\nif target string have only zero or string s have only zero then always false other wise true\\n\\nFor more clearity go with code.\\n\\n# Complexity\\n- Time complexity:O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target){\\n            return true;\\n        }\\n        int cnts0=0,cnts1=0,cntt0=0,cntt1=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\'){\\n                cnts1++;\\n            }\\n            else{\\n                cnts0++;\\n            }\\n            if(target[i]==\\'1\\'){\\n                cntt1++;\\n            }\\n            else{\\n                cntt0++;\\n            }\\n        }\\n        if(target.size()==cntt0){\\n            return false;\\n        }\\n        if(s.size()==cnts0 && cntt1>=1){\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        if(s==target){\\n            return true;\\n        }\\n        int cnts0=0,cnts1=0,cntt0=0,cntt1=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\'){\\n                cnts1++;\\n            }\\n            else{\\n                cnts0++;\\n            }\\n            if(target[i]==\\'1\\'){\\n                cntt1++;\\n            }\\n            else{\\n                cntt0++;\\n            }\\n        }\\n        if(target.size()==cntt0){\\n            return false;\\n        }\\n        if(s.size()==cnts0 && cntt1>=1){\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085274,
                "title": "c-bitwise-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic of OR and XOR\\nif string differs and there is no 1 in either of string it is impossible to make string same because\\n        (OR  ,  XOR)\\n1  1    (1  ,   0 )\\n1  0    (1  ,   1)\\n0  1    (1   ,  1)\\n0  0    (0  ,   0)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSelecting any pair of (i , j) cannot make difference if all character in s is 0 and we cannot make all zero if there is any 1 in s and target contains all 0\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        bool flag1=false,flag2=false,flag3=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=target[i]){\\n                flag1=true;\\n            }\\n            if(s[i]==\\'1\\')\\n                flag2=true;\\n            if(target[i]==\\'1\\')\\n                flag3=true;\\n        }\\n        return (!flag1 or(flag1 && flag2 && flag3));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string target) {\\n        bool flag1=false,flag2=false,flag3=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=target[i]){\\n                flag1=true;\\n            }\\n            if(s[i]==\\'1\\')\\n                flag2=true;\\n            if(target[i]==\\'1\\')\\n                flag3=true;\\n        }\\n        return (!flag1 or(flag1 && flag2 && flag3));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085114,
                "title": "solution-using-observation",
                "content": "# POINT TO BE NOTED\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFor this question , my advice to u is take a pen and paper and see all the possibile combinations of i and j and see all the possible results we can get from these combinations before reading the below solution.\\n\\n# Observations\\n\\nAfter seeing all the possible combiations and their outputs you will observe that (1,1) , (0,1) , (1,0) are INTERCONVERTABLE!\\nand\\n(0,0) -> (0,0)\\n\\nThis means that we can not change a (0,0) pair.\\nThis should not be a problem till the time we have a 1 in our solution.\\nBecause with even a single 1 we can transform our string i whatever way possible.\\n\\nThere are only 2 cases where we will be stuck\\n1. when our first string has all zeros.\\n2. when our second string has all zeros.\\n\\nFor these cases, if string 1 and string 2 are same then return true else return false.\\n\\nDO UPVOTE IF YOU LIKE MY SOLUTION\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int length = s.length();\\n        \\n        bool areSame = true;\\n        unordered_map<int,int> m1;\\n        unordered_map<int,int> m2;\\n        \\n        for(int i = 0 ; i < length ; i++){\\n            if(s[i] != t[i])\\n                areSame = false;\\n            m1[s[i] - \\'0\\']++;\\n            m2[t[i] - \\'0\\']++;\\n        }\\n        \\n        if(m1[1] == 0 or m2[1] == 0){\\n            if(areSame == true)\\n                return true;\\n            return false;\\n        }\\n \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string t) {\\n        int length = s.length();\\n        \\n        bool areSame = true;\\n        unordered_map<int,int> m1;\\n        unordered_map<int,int> m2;\\n        \\n        for(int i = 0 ; i < length ; i++){\\n            if(s[i] != t[i])\\n                areSame = false;\\n            m1[s[i] - \\'0\\']++;\\n            m2[t[i] - \\'0\\']++;\\n        }\\n        \\n        if(m1[1] == 0 or m2[1] == 0){\\n            if(areSame == true)\\n                return true;\\n            return false;\\n        }\\n \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085101,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string tar) {\\n        map<int,int> m;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                m[i]=1;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=tar[i])\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                    m.erase(i);\\n                    if(m.size()==0)\\n                    {\\n                        m[i]=1;\\n                        cnt++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(m.size()>0)\\n                    {\\n                        m[i]=1;\\n                        if(cnt>0)\\n                        cnt--;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        if(cnt!=0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeStringsEqual(string s, string tar) {\\n        map<int,int> m;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                m[i]=1;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=tar[i])\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                    m.erase(i);\\n                    if(m.size()==0)\\n                    {\\n                        m[i]=1;\\n                        cnt++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(m.size()>0)\\n                    {\\n                        m[i]=1;\\n                        if(cnt>0)\\n                        cnt--;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        if(cnt!=0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085082,
                "title": "java-one-liner-0ms",
                "content": "\\n<!-- Describe your first thoughts on how t t\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return !(s.indexOf(\\'1\\')>=0 ^ target.indexOf(\\'1\\')>=0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        return !(s.indexOf(\\'1\\')>=0 ^ target.indexOf(\\'1\\')>=0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1768747,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1768931,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1768790,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1770013,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1771675,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1771255,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1770574,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1769527,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1769296,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1769282,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1768747,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1768931,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1768790,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1770013,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1771675,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1771255,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1770574,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1769527,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1769296,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            },
            {
                "id": 1769282,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "It was tough :( , Add new tag observation on it."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "[@ajaxWin](/ajaxWin) I tried to do my best, check it https://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "Igor0",
                        "content": "It is easy to understand that there are only 2 possibilities:\\n- all the chars are \\'0\\'\\n- not all the chars are \\'0\\'"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "More than 10 wrong submissions man."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "do it with only guessing. \\n00 -> 00\\n01 -> 11\\n10 -> 11\\n11 -> 10\\n\\nso you should know what to do now"
                    },
                    {
                        "username": "shivansh961",
                        "content": "It was a weird questions."
                    },
                    {
                        "username": "rashi_05",
                        "content": "```\nWe will only able to reach the target if both the target or \nthe string s contains at least single 1.  \nbecause 1 XOR 1 = 0 && 1 OR 1 = 1\nand 1 XOR 0 = 1  && 1 OR 0 = 1\nbut 0 XOR 0 = 0 and 0 OR 0 = 0 (NO USE)\nSo they must have at least single one to reach the target.\n```\n\nAlthough I wasn't able to solve it during the contest but understood the approach :|"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "Yes, just a corner case added to your solution would have worked perfectly."
                    },
                    {
                        "username": "neet_n_niftee",
                        "content": "Not a fun problem to see during contest at all. "
                    },
                    {
                        "username": "GrandCoder",
                        "content": "think about how to transfer any string to 11111111 (all 1)\n\n-> with (01) and (10), you can do that\n\nThen change the position you want to be 0(11 -> 10)\n\nyou will find out what case can't be achieve"
                    },
                    {
                        "username": "space_invader",
                        "content": "Try to notice what happens when you perform an operation from the condition and the 1st example:\\n\\n````\\nInput: s = \"1010\", target = \"0110\"\\n- Choose i = 2 and j = 0. We have now s = \"0010\".\\n- Choose i = 2 and j = 1. We have now s = \"0110\".\\n````\\n\\ntip: think about the limitation regardless of bitwise operations at all. what  is a conidiation you cannot mutate your `s` after.\\np.s. this problem is not about a bitwise operations at all\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve on the first try during 329?**"
                    },
                    {
                        "username": "xuchen321",
                        "content": "bfs get timeout but not sure what is the solution for this\\n\\nLast Executed Input\\n\"00110000111001111011110001111111011000101100010100000101100110111010100001110001111100101000\"\\n\"10000010100000101001001110011001011001110111100001110110010000110011100100111010010010100110\"\\n `class Solution {\\npublic:\\n    char xor_char(char left, char right) {\\n        if(left != right) {\\n            return \\'1\\';\\n        }\\n        return \\'0\\';\\n    }\\n    \\n    char or_char(char left, char right) {\\n        if(left == \\'0\\' && right == \\'0\\') {\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n    bool makeStringsEqual(string s, string target) {\\n        unordered_set<string> visited;\\n        queue<string> str_queue;\\n        int len = s.size();\\n        if(s == target) {\\n            return true;\\n        }\\n        str_queue.push(s);\\n        visited.insert(s);\\n        while(str_queue.empty() == false) {\\n            string front_str = str_queue.front();\\n            str_queue.pop();\\n          //  cout<<\"front str:\"<<front_str<<endl;\\n            int str_size = front_str.size();\\n            for(int left = 0; left < str_size; left++) {\\n                for(int right = left + 1; right < str_size; right++) {\\n                    char prev_left = front_str[left];\\n                    char prev_right = front_str[right];\\n                    char xor_res = xor_char(front_str[left], front_str[right]);\\n                    char or_res = or_char(front_str[left], front_str[right]);\\n                    front_str[left] = or_res;\\n                    front_str[right] = xor_res;\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n                    \\n                    if(visited.find(front_str) == visited.end()) {\\n                   //     cout<<\"new str\"<<front_str<<endl;\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n                    \\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n\\n                    front_str[left] = xor_res;\\n                    front_str[right] = or_res;\\n\\n                    if(front_str == target) {\\n                        return true;\\n                    }\\n\\n                    if(visited.find(front_str) == visited.end()) {\\n                        str_queue.push(front_str);\\n                        visited.insert(front_str);\\n                    }\\n\\n                    front_str[left] = prev_left;\\n                    front_str[right] = prev_right;\\n                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I tried to do my best and explained my ideas\\nhttps://leetcode.com/problems/apply-bitwise-operations-to-make-strings-equal/solutions/3085782/four-counters-explanation/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Solving these type of questions necessarily requires pen and paper, otherwise we may miss any corner case."
                    }
                ]
            }
        ]
    }
]