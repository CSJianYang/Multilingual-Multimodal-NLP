[
    {
        "title": "Check if Point Is Reachable",
        "question_content": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n\t(x, y - x)\n\t(x - y, y)\n\t(2 * x, y)\n\t(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.\n&nbsp;\nExample 1:\n\nInput: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.\n\nExample 2:\n\nInput: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).\n\n&nbsp;\nConstraints:\n\n\t1 <= targetX, targetY&nbsp;<= 109",
        "solutions": [
            {
                "id": 3082073,
                "title": "java-c-python-1-line-gcd-solution",
                "content": "# **Intuition**\\nTry go from `(x, y)` to `(1,1)`\\nConsider the reverse operation of\\n`(x, y - x)`\\n`(x - y, y)`\\n`(2 * x, y)`\\n`(x, 2 * y)`\\n\\nthat is\\n`(x, y + x)`\\n`(x + y, y)`\\n`(x / 2, y)` if `x % 2 == 0`\\n`(x, y / 2)` if `y % 2 == 0`\\n<br>\\n\\n# **Necessary Condition**\\nAssume `x` and `y` have a common divisor `v` bigger than 2,\\nSince\\n`(x + y) % v == 0`\\n`(x / 2) % v == 0` if `x` is even\\n`(y / 2) % v == 0` if `y` is even\\nThe new value always can be divided by `v`\\n\\nNo matter what operation we use, \\nwe can\\'t reach `(1,1)`\\n\\nTo go from `(x,y)` to `(1,1)`,\\nwe have the necessary condition :\\n`gcd(x,y) = 2 ^ k`\\n<br>\\n\\n# **Sufficient Condition**\\nAssume `gcd(x,y) = 2 ^ k`\\nIf `x` is even, we can go `(x / 2, y)`\\nIf `y` is even, we can go `(x, y / 2)`\\nIf both odd and `x < y`, we can go `(x, (x+y)/2)`\\nIf both odd and `x > y`, we can go `((x+y)/2, y)`\\n`(x, y)` can continue go smaller,\\nuntil `(x, y)` both odd and `x == y`,\\nthat is `x == y == 1`\\n\\n\\n# **Conclusion**\\nBased on the **Necessary Condition** and **Sufficient Condition**,\\nwe conclude that\\n\"`(1, 1)` can go forward to `(x, y)`\"\\nequals to\\n\"`(x, y)` can go back to `(1, 1)`\"\\nequals\\n`gcd(x,y)` is pow of `2`.\\n<br>\\n\\n# **Pow of 2**\\nMany ways to check if `x` is pow of `2`.\\n\\n**Option 1**\\nWe can continuely divide `x` by `2` and\\ncheck if stops at `1`.\\n\\n**Option 2**\\nAlso we can check `x` **lowbit** by `x & -x`.\\n<br>\\n\\n# **Complexity**\\nTime `O(logX + logY))`\\nSpace `O(1)`\\n<br>\\n\\n# **Solution 1**\\n**Java**\\nImplement `gcd` or import `java.math.BigInteger`\\n```java\\n    public boolean isReachable(int x, int y) {\\n        int v = BigInteger.valueOf(x).gcd(BigInteger.valueOf(y)).intValue();\\n        while (v % 2 == 0)\\n            v /= 2;\\n        return v == 1;\\n    }\\n```\\n**C++**\\n```cpp\\n    bool isReachable(int x, int y) {\\n        int v = gcd(x, y);\\n        while (v % 2 == 0)\\n            v /= 2;\\n        return v == 1;\\n    }\\n```\\n<br>\\n\\n# **Solution 2: Use lowbit**\\n**Java**\\n```java\\n    public boolean isReachable(int x, int y) {\\n        int v = BigInteger.valueOf(x).gcd(BigInteger.valueOf(y)).intValue();\\n        return v == (v & -v);\\n    }\\n```\\n**C++**\\n```cpp\\n    bool isReachable(int x, int y) {\\n        int v = gcd(x, y);\\n        return v == (v & -v);\\n    }\\n```\\n**Python**\\n```py\\n    def isReachable(self, x: int, y: int) -> bool:\\n        v = gcd(x, y)\\n        return v == (v & -v)\\n```\\n<br>\\n\\n# **Solution 3: Use bit count**\\n**Java**\\n```java\\n\\tpublic boolean isReachable(int x, int y) {\\n\\t\\treturn BigInteger.valueOf(x).gcd(BigInteger.valueOf(y)).bitCount() == 1;\\n\\t}\\n```\\n**C++**\\n```cpp\\n    bool isReachable(int x, int y) {\\n        return __builtin_popcount(gcd(x, y)) == 1;\\n    }\\n```\\n**Python**\\n```py\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return gcd(x, y).bit_count() == 1\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean isReachable(int x, int y) {\\n        int v = BigInteger.valueOf(x).gcd(BigInteger.valueOf(y)).intValue();\\n        while (v % 2 == 0)\\n            v /= 2;\\n        return v == 1;\\n    }\\n```\n```cpp\\n    bool isReachable(int x, int y) {\\n        int v = gcd(x, y);\\n        while (v % 2 == 0)\\n            v /= 2;\\n        return v == 1;\\n    }\\n```\n```java\\n    public boolean isReachable(int x, int y) {\\n        int v = BigInteger.valueOf(x).gcd(BigInteger.valueOf(y)).intValue();\\n        return v == (v & -v);\\n    }\\n```\n```cpp\\n    bool isReachable(int x, int y) {\\n        int v = gcd(x, y);\\n        return v == (v & -v);\\n    }\\n```\n```py\\n    def isReachable(self, x: int, y: int) -> bool:\\n        v = gcd(x, y)\\n        return v == (v & -v)\\n```\n```java\\n\\tpublic boolean isReachable(int x, int y) {\\n\\t\\treturn BigInteger.valueOf(x).gcd(BigInteger.valueOf(y)).bitCount() == 1;\\n\\t}\\n```\n```cpp\\n    bool isReachable(int x, int y) {\\n        return __builtin_popcount(gcd(x, y)) == 1;\\n    }\\n```\n```py\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return gcd(x, y).bit_count() == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3082147,
                "title": "c-java-python-gcd",
                "content": "\\n\\n# Intuition\\n* If we move from `(targetX, targetY)` to the points `(targetX, targetY - targetX)` or `(targetX \\u2013 targetY, targetY)`, the GCD of the pair remains the same\\n* If we move from `(targetX, targetY)` to the points `(2 * targetX, targetY)` or `(targetX, 2 * targetY)`, the GCD of the pair remains same or gets doubled.\\n* GCD of (1, 1) is 1. From here it can either remain same or get multiplied by 2 each time. Therefore, from the above observations, point (1, 1) can move to point `(targetX, targetY)` if and only if gcd of `(targetX, targetY)` is a power of 2. \\n\\n# Approach\\n* Find gcd of `targetX` and `targetY`\\n* Check if gcd is a power of 2. If it is, return `True` else return `False`.\\n\\n# Complexity\\n- Time complexity: `O(gcd) = O(log(min(targetX, targetY)))`\\n\\n- Space complexity: `O(gcd)`\\n\\n# Code\\n**Python3**:\\n```\\ndef isReachable(self, targetX: int, targetY: int) -> bool:\\n    g = gcd(targetX, targetY)\\n    return g & (g - 1) == 0 # check g is power of 2\\n```\\n\\n**C++**:\\n```\\nbool isReachable(int targetX, int targetY) {\\n    int g = __gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\n```\\n\\n**Java**:\\n```\\npublic boolean isReachable(int targetX, int targetY) {\\n    int g = gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\nprivate int gcd(int a, int b) {\\n    if (a == 0) return b;\\n    return gcd(b % a, a);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ndef isReachable(self, targetX: int, targetY: int) -> bool:\\n    g = gcd(targetX, targetY)\\n    return g & (g - 1) == 0 # check g is power of 2\\n```\n```\\nbool isReachable(int targetX, int targetY) {\\n    int g = __gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\n```\n```\\npublic boolean isReachable(int targetX, int targetY) {\\n    int g = gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\nprivate int gcd(int a, int b) {\\n    if (a == 0) return b;\\n    return gcd(b % a, a);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3082680,
                "title": "greedy-vs-gcd",
                "content": "I initially solved this problem using DP then Greedy, but then I ran through a few examples and realized the condition when the target can be reached.\\n\\n#### GCD\\nThe condition is that GCD of target coordinates is the power of 2.\\n\\nWe can divide both coordinates by 2 while they are even. The resulting target is reachable if its coordinates are co-primes.\\n\\nYou can also see that the greedy solution below looks like the Euclidean GCD algorithm.\\n\\n**C++**\\n```cpp\\nbool isReachable(int targetX, int targetY) {\\n    return __builtin_popcount(gcd(targetX, targetY)) == 1;\\n}\\n```\\n\\n#### Greedy\\nSimilarly to [991. Broken Calculator](https://leetcode.com/problems/broken-calculator/), we work backwards from `{targetX, targetY}` to `{1, 1}`.\\n\\nI initially used DP, but here we can greedily divide then subtrack.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return (\\n            True if x == 1 and y == 1 else\\n            self.isReachable(x / 2, y) if x % 2 == 0 else\\n            self.isReachable(x, y / 2) if y % 2 == 0 else\\n            self.isReachable(x - y, y) if x > y else\\n            self.isReachable(x, y - x) if y > x else False\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nbool isReachable(int targetX, int targetY) {\\n    return __builtin_popcount(gcd(targetX, targetY)) == 1;\\n}\\n```\n```python\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return (\\n            True if x == 1 and y == 1 else\\n            self.isReachable(x / 2, y) if x % 2 == 0 else\\n            self.isReachable(x, y / 2) if y % 2 == 0 else\\n            self.isReachable(x - y, y) if x > y else\\n            self.isReachable(x, y - x) if y > x else False\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082013,
                "title": "java-python-3-check-if-the-gcd-has-only-factor-2-w-explanation-and-analysis",
                "content": "**Intuition**\\n\\nNotice there is double operations for either `x` or `y`- coordinates and the corresponding result must be even. Therefore, if the target coordinates is odd, we can only have `1` option: `+/-`. \\n\\nHence we can simplify the operation if we return from target to source.\\n\\nAlso the following operation hint Euclidean Algorithm:\\n`(x, y - x)`\\n`(x - y, y)`\\nor\\n`(x, y + x)`\\n`(x + y, y)`\\n\\nBased on the above we can implement the following algorithm.\\n\\n----\\nLet us **reverse the procedure and start from target to source**, if either of the target coordinates is divisible by `2`, remove all factor `2`s from it then check if they are co-prime now; If yes, return `true`, otherwise return `false`.\\n\\nWe also can compute the `GCD` first, then check if it has only factor `2`s, and this makes code shorter.\\n\\n```java\\n    public boolean isReachable(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        while (x % 2 == 0) {\\n            x /= 2;\\n        }\\n        return x == 1;\\n    }\\n```\\n```python\\n    def isReachable(self, x: int, y: int) -> bool:\\n        g = gcd(x, y)\\n        while g % 2 == 0:\\n            g //= 2\\n        return g == 1\\n```\\n\\nOr further simplify the above as follows: \\n```java\\n    public boolean isReachable(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return Integer.bitCount(x) == 1;\\n    }\\n```\\n```python\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return gcd(x, y).bit_count() == 1\\n```\\n\\n**Analysis:**\\n\\nBoth the dividing `2` and `gcd`(Euclidean Algorithm) operations cost time `O(log(max(x, y)))`, therefore\\n\\nTime: `O(log(max(x, y)))`, space: `O(1)`.\\n\\n----\\n\\n**Q & A**\\n*Q1*: You have reversed 2*x by x//2. Then why (x-y) is still holding good? Shouldn\\'t it be x+y?\\n*A1*: Actually, *x + y* or *x - y* will NOT change their `GCD`.  It is because `gcd(x + m * y, y) = gcd(x, n * x + y) = gcd(x, y)`, where `m` and `n` are both integers that can be positive, negative or zero.\\n\\n*Proof:*\\n\\nUse contradiction to prove `gcd(x + m * y, y) = gcd(x, y)` as follow:\\n\\nLet `g = gcd(x, y)`, then `x = a * g, y = b * g` and `a` and `b` co-prime.\\n\\n`x + m * y = a * g + m * b * g = (a + m * b) * g`\\n`y = b * g `\\n\\nif `gcd(a + m * b, b) = g\\' > 1`, then `a + m * b = p * g\\'` and`b = q * g\\'`, therefore `a + m * b = a + m * q * g\\' = p * g\\'`, so `a = (p - m * q) * g\\'`, which indicates that `a` and `b` have a `GCD` of `g\\' > 1` and hece `a` and `b` not co-prime, which contradicts the previous assumption `a` and `b` co-prime.\\n\\nSimilarly we can prove that `gcd(x, n * x + y) = gcd(x, y)`\\n\\n**End of Q & A**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public boolean isReachable(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        while (x % 2 == 0) {\\n            x /= 2;\\n        }\\n        return x == 1;\\n    }\\n```\n```python\\n    def isReachable(self, x: int, y: int) -> bool:\\n        g = gcd(x, y)\\n        while g % 2 == 0:\\n            g //= 2\\n        return g == 1\\n```\n```java\\n    public boolean isReachable(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return Integer.bitCount(x) == 1;\\n    }\\n```\n```python\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return gcd(x, y).bit_count() == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3086808,
                "title": "easy-proof-and-video-how-gcd-javascript-and-c",
                "content": "# Observation\\nWe have 4 options:\\n(x, y-x)\\n(x-y, y)\\n(x, 2*y)\\n(2*x, y)\\n\\nI can rewrite last two options as\\n(x, 2^m * y) [It is like, this operation is performed m times]\\n(2^n * x, y) [It is like, this operation is performed n times]\\n\\nThen, I can also rewrite both of the above options as one option:\\n(2^n * x, 2^m * y)\\n\\nNow we have only 3 options:\\n(x, y-x)\\n(x-y, y)\\n(2^n * x, 2^m * y), where n,m>=0\\n\\nSince we are starting with (1, 1), if we only perform last operation, then we can get numbers like:\\n(1,128), (16,64), (256,4)\\n\\nIn other words: (some power of 2, some power of 2)\\n\\nAnd if we would only have last option that would have been very easy to identify for any traget coordinates.\\n\\nJust check whether both x and y coordinate are powers of 2 or not.\\n\\nNow if we add other two operations:\\n(x, y-x)\\n(x-y, y)\\nSo basically what we are doing is, subtraction with some powers of 2.\\n\\nSo how we can confirm whether we actually did subtractions on some power of two?\\nAns: GCD\\n\\nHow?\\nGCD of two numbers don\\'t change even if we replace one number by their subtraction.\\n\\nIf we apply only the last operation then:\\ngcd(x,y) = some power of two\\n\\nNow if we change (x,y) to (x, y-x)\\nThe gcd(x, y-x) will still be some power of 2\\n\\nWhy?\\nBecause if gcd(x, y) = g\\nThen y-x will also be divisble by g because y and x are divisible by g.\\n(y-x)/g = y/g - x/g \\n\\nThe same can be said for (x-y, y)\\n\\nSo doesn\\'t matter which operation we apply, if we are starting from (1, 1) and reaching any corrdinate (x, y)\\nThe gcd of x and y will always be a power of 2.\\n\\nVideo:\\n<iframe width=\"580\" height=\"300\" src=\"https://www.youtube.com/embed/KiVZRzPfKnQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n# Approach\\nIf gcd(targetX, targetY) = some power of 2\\nthen return true\\nelse return false\\n\\n# Complexity\\n- Time complexity: O( log( min(targetX, targetY)))\\n\\n- Space complexity: O( log( min(targetX, targetY)))\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n\\tbool isReachable(int x, int y) {\\n        int gc = __gcd(x,y);\\n        return (gc&(gc-1))==0;\\n    }\\n};\\n```\\n```javascript []\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nfunction gcd(x, y){\\n    if (y===0)\\n        return x;\\n    return gcd(y, x%y);\\n}\\n\\nvar isReachable = function(targetX, targetY) {\\n    let gc = gcd(targetX,targetY);\\n    return (gc&(gc-1))==0;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\tbool isReachable(int x, int y) {\\n        int gc = __gcd(x,y);\\n        return (gc&(gc-1))==0;\\n    }\\n};\\n```\n```javascript []\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nfunction gcd(x, y){\\n    if (y===0)\\n        return x;\\n    return gcd(y, x%y);\\n}\\n\\nvar isReachable = function(targetX, targetY) {\\n    let gc = gcd(targetX,targetY);\\n    return (gc&(gc-1))==0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082255,
                "title": "python3-only-gcd",
                "content": "- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        a=gcd(x,y)\\n        while a%2==0:\\n            a//=2\\n        return a==1\\n \\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        a=gcd(x,y)\\n        while a%2==0:\\n            a//=2\\n        return a==1\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082216,
                "title": "no-gcd-or-other-math-magic-simple-intuition-with-explanation",
                "content": "# Intuition\\n\\nGo from the target to the start.\\n\\nIf `x` or `y` can reach `1`, then both coordinates can reach `1` (by subtracting `1` from the other coordinate).\\n\\nDecrease `x` and `y` greedily until any coordinate reaches `1`, or the process stucks in the same state.\\n\\n# Approach\\n\\nWhen you go backwards, there are only 2 operations possible:\\n\\n1. Divide a coordinate by 2\\n2. Sum the coordinates and replace one of the coordinates with the sum\\n\\nDriven by the greed, we divide any coordinate by 2 whenever it\\'s even.\\n\\nThen sum the coordinates together and replace the greatest coordinate with the sum (we don\\'t try replacing the smallest one because we are greedy). Since the coordinates were odd, the sum is even, so it can be divided by 2 further, thus the process can continue in a cycle.\\n\\nThe process can\\'t continue when the coordinates are equal. `(a + a) / 2 = a`, i.e. the state doesn\\'t change. It means that the start can\\'t be reached.\\n\\n# Code\\n\\n```python\\nclass Solution:\\n  def isReachable(self, targetX: int, targetY: int) -> bool:\\n    x = self.decrease(targetX)\\n    y = self.decrease(targetY)\\n\\n    while True:\\n      if x == 1 or y == 1:\\n        return True\\n\\n      if x == y:\\n        return False # The coordinates won\\'t change, we are stuck\\n\\n      newCoordinate = self.decrease(x + y)\\n      \\n      # Putting the new coordinate to the place of the biggest current coordinate\\n      if x < y:\\n        y = newCoordinate\\n      else:\\n        x = newCoordinate\\n\\n  def decrease(self, value):\\n    while value % 2 == 0:\\n      value = value >> 1 # This means division by 2\\n    return value\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n  def isReachable(self, targetX: int, targetY: int) -> bool:\\n    x = self.decrease(targetX)\\n    y = self.decrease(targetY)\\n\\n    while True:\\n      if x == 1 or y == 1:\\n        return True\\n\\n      if x == y:\\n        return False # The coordinates won\\'t change, we are stuck\\n\\n      newCoordinate = self.decrease(x + y)\\n      \\n      # Putting the new coordinate to the place of the biggest current coordinate\\n      if x < y:\\n        y = newCoordinate\\n      else:\\n        x = newCoordinate\\n\\n  def decrease(self, value):\\n    while value % 2 == 0:\\n      value = value >> 1 # This means division by 2\\n    return value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082131,
                "title": "python3-math-number-theory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf x or y is a power of two, it means there is an exact solution. This is definitely a special case.\\nIf the GCD of x and y is a power of two, then there is a solution. A very easy solution.\\n\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        bl=True\\n        a=x\\n        while a%2==0:\\n            a//=2\\n        if(a==1):\\n            return True\\n        a=y\\n        while a%2==0:\\n            a//=2\\n        if(a==1):\\n            return True\\n        while x>0 and y>0:\\n            x%=y\\n            if x==1:\\n                return True\\n            x,y=y,x\\n        a=x\\n        while a%2==0:\\n            a//=2\\n        if(a==1):\\n            return True\\n        return False\\n        \\n            \\n        \\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        bl=True\\n        a=x\\n        while a%2==0:\\n            a//=2\\n        if(a==1):\\n            return True\\n        a=y\\n        while a%2==0:\\n            a//=2\\n        if(a==1):\\n            return True\\n        while x>0 and y>0:\\n            x%=y\\n            if x==1:\\n                return True\\n            x,y=y,x\\n        a=x\\n        while a%2==0:\\n            a//=2\\n        if(a==1):\\n            return True\\n        return False\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082809,
                "title": "3-lines-c-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logX+logY)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n       while(targetX%2==0)targetX/=2;\\n       while(targetY%2==0)targetY/=2;\\n       return __gcd(targetX,targetY)==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n       while(targetX%2==0)targetX/=2;\\n       while(targetY%2==0)targetY/=2;\\n       return __gcd(targetX,targetY)==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082427,
                "title": "proof-based-solution-now-with-correct-proof",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is quite straightforward: a pair (a, b) is accessible if and only if the greatest common divisor of a and b, gcd(a, b), is a power of 2.\\nThe difficulty is proving this, which fortunately was not required during the contest. Anyway, here is the proof.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn one direction, note that all four operations preserve this property. The starting pair (1, 1) has it since $gcd(1, 1)=1=2^0$, the first two operations preserve the gcd, and the last two operations can multiply the gcd by 2 (or not). Thus, gcd(a, b) can only be a power of 2.\\n\\nConversely, starting from (1, 1) and multiplying the first term repeatedly by 2 we can obtain any pair of the form $(2^n, 1)$, then subtracting $1$ from $2^n$ repeatedly we can obtain any pair of the form $(n, 1)$.\\n\\nMultiplying the second term by 2 repeatedly we can obtain any pair of the form $(n, 2^m)$, then by subtracting $n$ from $2^m$ repeatedly we can obtain any pair of the form $(n,\\\\ 2^m \\\\mod n)$.\\n\\nSuppose we want to obtain the pair (n, k), where k<n and gcd(n, k)=1. Consider the infinite arithmetic progression (n, n+k, n+2k, ...). By Dirichlet\\'s theorem, this progression contains infinitely many primes. Consider one of them: p=n+jk for some $j \\\\geq 0$.\\n\\nBy a slight generalization of [Artin\\'s conjecture](https://mathworld.wolfram.com/ArtinsConjecture.html) (the generalization may need proof, but Artin\\'s conjecture was proved by Christopher Hooley, [\"On Artin\\'s Conjecture\"](https://eudml.org/doc/150785), in 1967, assuming the [Generalized Riemann Hypothesis](https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis)), there are infinitely many such p for which 2 is a primitive root of unity modulo p, meaning that $2^{p-1} \\\\equiv 1 \\\\mod p$ and $2^{k} \\\\not \\\\equiv 1 \\\\mod p$ for $0<k<p-1$.\\n\\nWe know we can obtain any pair of the form $(p,\\\\ 2^m \\\\mod p)$. Since p is prime, the multiplicative group $\\\\mathbb Z_p^*$ is cyclic. Since 2 is a generator (its order is equal to the order of the group), we can obtain any pair (p, k) where $1 \\\\leq k <p$ using powers of 2 modulo p, including the k we want.\\n\\nBut this is the same as (n+jk, k) and then by repeatedly subtracting k from n+jk we can obtain (n, k), as desired.\\n\\nBy symmetry (doing the same thing in reverse if necessary), we can obtain any pair (n, m) where gcd(m, n)=1. Finally, multiplying m and n by (possibly different) arbitrary powers of 2 we can obtain any pair whose gcd is a power of two.\\n\\nEdited: The initial proof was wrong and I corrected it.\\n\\n# Complexity\\n- Time complexity: Logarithmic: $O(\\\\max(\\\\log a, \\\\log b))$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def gcd(a, b):\\n            while b:\\n                a, b=b, a%b\\n            return a\\n        d=gcd(targetX, targetY)\\n        while d!=1:\\n            if d&1:\\n                return False\\n            d>>=1\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def gcd(a, b):\\n            while b:\\n                a, b=b, a%b\\n            return a\\n        d=gcd(targetX, targetY)\\n        while d!=1:\\n            if d&1:\\n                return False\\n            d>>=1\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084440,
                "title": "one-line-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(max(logX,logY))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n    return __builtin_popcount(__gcd(targetX,targetY))==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n    return __builtin_popcount(__gcd(targetX,targetY))==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082530,
                "title": "c-easy-understanding-not-gcd-according-to-question-intution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if(targetX > 1 && targetY > 1){\\n            while(targetX % 2 == 0)\\n                targetX /= 2;\\n            while(targetY % 2 == 0)\\n                targetY /= 2;  \\n            while(targetX >= 1 && targetY >= 1){\\n                if(targetX < targetY)\\n                    targetY -= targetX;\\n                else if(targetX > targetY)\\n                    targetX -= targetY;\\n                else{\\n                    if(targetX == 1 && targetY == 1)\\n                        return true;\\n                    else\\n                        return false;    \\n                }    \\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if(targetX > 1 && targetY > 1){\\n            while(targetX % 2 == 0)\\n                targetX /= 2;\\n            while(targetY % 2 == 0)\\n                targetY /= 2;  \\n            while(targetX >= 1 && targetY >= 1){\\n                if(targetX < targetY)\\n                    targetY -= targetX;\\n                else if(targetX > targetY)\\n                    targetX -= targetY;\\n                else{\\n                    if(targetX == 1 && targetY == 1)\\n                        return true;\\n                    else\\n                        return false;    \\n                }    \\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082462,
                "title": "java-gcd-explained-with-proof",
                "content": "Statement: If `a` divides `b`, `a` divides `c`, then `a` divides `b - c`.\\nProof: We can write `b = am`, `c = an`, where `m`, `n` are integers. We then have `b - c = a(m - n)`. Since `m`, `n` are integers, it follows that `m - n` is an integer. Therefore, the equation `b - c = a(m - n)` implies that `a` divides `b - c`.\\n\\n* From the above statement, we conclude that the former two operations `(x, y - x)` and `(x - y, y)` **do not change** `gcd(x, y)`. \\n* However, the latter two operations `(2 * x, y)` and `(x, 2 * y)` can **double** `gcd(x, y)`. \\n\\nNote that `gcd(1, 1) = 1` and `gcd(1, 1)` can be only doubled multiple times. Therefore, we need `gcd(targetX, targetY) = 2 ^ k` to reach the point `(targetX, targetY)` from `(1, 1)`.\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        return Integer.bitCount(gcd(targetX, targetY)) == 1;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        return Integer.bitCount(gcd(targetX, targetY)) == 1;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082148,
                "title": "java-3-solutions",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        // if they are already (1, 1), then return true\\n        if (targetX == 1 && targetY == 1) {\\n            return true;\\n        }\\n\\n        // keep reducing them unless they become odd\\n        while (targetX % 2 == 0) {\\n            targetX /= 2;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY /= 2;\\n        }\\n        // now reduce them by subtraction\\n        while (targetX >= 1 && targetY >= 1) {\\n            if (targetX > targetY) {\\n                targetX -= targetY;\\n            } else if (targetX < targetY) {\\n                targetY -= targetX;\\n            } else {\\n                // if they ever become equal it should be (1, 1)\\n                return targetX == 1 && targetY == 1;\\n            }\\n        }\\n        \\n        // iteration is over but they didn\\'t become equal\\n        return false;\\n    }\\n}\\n```\\n---\\n### Bonus 1:\\n``` java []\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        while (targetX % 2 == 0) {\\n            targetX /= 2;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY /= 2;\\n        }\\n        \\n        return gcd(targetX, targetY) == 1;\\n    }\\n    \\n    public int gcd(int a, int b) {\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n}\\n```\\n---\\n### Bonus 2:\\n``` java []\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        return help(targetX, targetY);\\n    }\\n\\n    private boolean help(int x, int y) {\\n        if (x == 1 && y == 1) {\\n            return true;\\n        }\\n        if (x < 1 || y < 1) {\\n            return false;\\n        }\\n        if (x > y) {\\n            return (x % 2 == 0)? \\n            help(x / 2, y) : help(x - y, y);\\n        } else {\\n            return (y % 2 == 0)? \\n            help(x, y / 2) : help(x, y - x);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        // if they are already (1, 1), then return true\\n        if (targetX == 1 && targetY == 1) {\\n            return true;\\n        }\\n\\n        // keep reducing them unless they become odd\\n        while (targetX % 2 == 0) {\\n            targetX /= 2;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY /= 2;\\n        }\\n        // now reduce them by subtraction\\n        while (targetX >= 1 && targetY >= 1) {\\n            if (targetX > targetY) {\\n                targetX -= targetY;\\n            } else if (targetX < targetY) {\\n                targetY -= targetX;\\n            } else {\\n                // if they ever become equal it should be (1, 1)\\n                return targetX == 1 && targetY == 1;\\n            }\\n        }\\n        \\n        // iteration is over but they didn\\'t become equal\\n        return false;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        while (targetX % 2 == 0) {\\n            targetX /= 2;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY /= 2;\\n        }\\n        \\n        return gcd(targetX, targetY) == 1;\\n    }\\n    \\n    public int gcd(int a, int b) {\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        return help(targetX, targetY);\\n    }\\n\\n    private boolean help(int x, int y) {\\n        if (x == 1 && y == 1) {\\n            return true;\\n        }\\n        if (x < 1 || y < 1) {\\n            return false;\\n        }\\n        if (x > y) {\\n            return (x % 2 == 0)? \\n            help(x / 2, y) : help(x - y, y);\\n        } else {\\n            return (y % 2 == 0)? \\n            help(x, y / 2) : help(x, y - x);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609014,
                "title": "1000-beats-most-optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int a, int b) {\\n            while(!(a&1)||!(b&1)){\\n                if(!(a&1))a >>= 1;\\n                if(!(b&1))b >>= 1;\\n            }\\n            if(__gcd(a,b)==1)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int a, int b) {\\n            while(!(a&1)||!(b&1)){\\n                if(!(a&1))a >>= 1;\\n                if(!(b&1))b >>= 1;\\n            }\\n            if(__gcd(a,b)==1)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323858,
                "title": "time-space-100-beats-3-line-c-code",
                "content": "````\\n    bool isReachable(int a, int b) {\\n        int c = __gcd(a,b);\\n        while((c&1)==0) c >>= 1;\\n        return (c==1);\\n    }\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "````\\n    bool isReachable(int a, int b) {\\n        int c = __gcd(a,b);\\n        while((c&1)==0) c >>= 1;\\n        return (c==1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084355,
                "title": "beautiful-observation-about-gcd",
                "content": "# Intuition: When you are asked whether you can reach a final state from a starting state, look for a monovariant or an invariant.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem is asking us whether we can reach a point, starting from another point with certain allowed operations. \\n- We can try all possibilities but a more elegant approach is to look for a property that either remains the same or always changes. \\n\\n# Approach - What happens to the GCD ? \\n<!-- Describe your approach to solving the problem-->\\n- $$g(x, y) = g(x - y, y) = g(x, y - x)$$\\n- $$g(2x, y) = 2g(x, y)$$ or $$g(2x, y) = g(x, y)$$\\n- $$g(x, 2y) = 2g(x, y)$$ or $$g(x, 2y) = g(x, y)$$\\n- The GCD either remains the same or doubles at each step. \\n- This means that the final GCD must either remain $$1$$ or be a power of $$2$$. \\n\\n# Complexity\\n- Time complexity: $$O(\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n[Github Code Link](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Biweekly%20Contest%2096)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int is_power_of_2(int n)\\n    {\\n        return ( (n&(n - 1)) == 0 ) ;\\n    }\\n    \\n    bool isReachable(int targetX, int targetY) {\\n        \\n        return is_power_of_2(__gcd(targetX, targetY));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int is_power_of_2(int n)\\n    {\\n        return ( (n&(n - 1)) == 0 ) ;\\n    }\\n    \\n    bool isReachable(int targetX, int targetY) {\\n        \\n        return is_power_of_2(__gcd(targetX, targetY));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082485,
                "title": "c-6-line-code-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int a=targetX,b=targetY;\\n        while(a!=b){\\n            if(a>b) a=a-b;\\n            else b=b-a;}\\n        int ans=log2(a);\\n        return (pow(2,ans)==a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int a=targetX,b=targetY;\\n        while(a!=b){\\n            if(a>b) a=a-b;\\n            else b=b-a;}\\n        int ans=log2(a);\\n        return (pow(2,ans)==a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082100,
                "title": "go-in-reverse-direction",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        // go in the reverse direction from target to (1,1)\\n        int x = targetX, y = targetY;\\n        \\n        while(true) {\\n            while(x%2 == 0) x/=2;\\n            while(y%2 == 0) y/=2;\\n            if(x>y) swap(x,y);\\n            if(x==1 and y==1) return true;\\n            if(x==y) break;\\n            y += x;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n> Note: This was my solution during contest, there is a much simpler solution using GCD",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        // go in the reverse direction from target to (1,1)\\n        int x = targetX, y = targetY;\\n        \\n        while(true) {\\n            while(x%2 == 0) x/=2;\\n            while(y%2 == 0) y/=2;\\n            if(x>y) swap(x,y);\\n            if(x==1 and y==1) return true;\\n            if(x==y) break;\\n            y += x;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263096,
                "title": "very-easy-java-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        // if they are already (1, 1), then return true\\n        if (targetX == 1 && targetY == 1) {\\n            return true;\\n        }\\n\\n        // keep reducing them unless they become odd\\n        while (targetX % 2 == 0) {\\n            targetX /= 2;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY /= 2;\\n        }\\n        // now reduce them by subtraction\\n        while (targetX >= 1 && targetY >= 1) {\\n            if (targetX > targetY) {\\n                targetX -= targetY;\\n            } else if (targetX < targetY) {\\n                targetY -= targetX;\\n            } else {\\n                // if they ever become equal it should be (1, 1)\\n                return targetX == 1 && targetY == 1;\\n            }\\n        }\\n        \\n        // iteration is over but they didn\\'t become equal\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        // if they are already (1, 1), then return true\\n        if (targetX == 1 && targetY == 1) {\\n            return true;\\n        }\\n\\n        // keep reducing them unless they become odd\\n        while (targetX % 2 == 0) {\\n            targetX /= 2;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY /= 2;\\n        }\\n        // now reduce them by subtraction\\n        while (targetX >= 1 && targetY >= 1) {\\n            if (targetX > targetY) {\\n                targetX -= targetY;\\n            } else if (targetX < targetY) {\\n                targetY -= targetX;\\n            } else {\\n                // if they ever become equal it should be (1, 1)\\n                return targetX == 1 && targetY == 1;\\n            }\\n        }\\n        \\n        // iteration is over but they didn\\'t become equal\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087623,
                "title": "easy-solution-fully-explained-pmi-c-java-python3",
                "content": "# Analysis\\n**Claim**: We can only reach (m,n) if gcd(m,n) = 2^k for some k >= 0.\\n\\n**Proof**: Lets prove it by mathematical induction.\\n\\n* Firstly, we can reach (1, 1) as we start from it and gcd(1 , 1) = 1 = 2^0\\n* Now, let us assume that we can reach some (x,y) such that gcd(x,y) = 2^k for some k>=0. From (x,y) we can go to (2x,y), (x,2y), (x,y-x), (x-y,x).\\n* It can be seen that if we go to (x,y-x) or (x-y,x) the gcd remains the same by the virtue of the property gcd(a,b) = gcd(a,b-a).\\n Hence the gcd is still 2^k for some\\n* Now consider the transitions to (2x,y). We can write y = (2^k)*z for some z.\\n* * Case 1: z is divisible by 2. Now the gcd(2x,y) = 2^(k+1).\\n* * Case 2: z is not divisible by 2. The gcd(2x,y) remains the same that is 2^k\\n* The analysis for (x,2y) is similar.\\nHence by the principal of mathematical induction we can prove that any cell (m,n) is only reachable if gcd(m,n) = 2^k for some k>=0.\\n\\n**Approach**\\n* Find gcd of targetX and targetY\\n* Check if gcd is a power of 2. If it is, return True else return False.\\n\\n**Complexity**\\n* Time complexity: O(gcd) = O(log(min(targetX, targetY)))\\n* Space complexity: O(gcd)\\n\\n**C++ Solution**\\n```\\nbool isReachable(int targetX, int targetY) {\\n    int g = __gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\n```\\n\\n**Java8 Solution**\\n```\\nprivate int gcd(int a, int b) {\\n    if (a == 0) return b;\\n    return gcd(b % a, a);\\n}\\npublic boolean isReachable(int targetX, int targetY) {\\n    int g = gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\n```\\n\\n**Python3 solution**\\n```\\ndef isReachable(self, targetX: int, targetY: int) -> bool:\\n    g = gcd(targetX, targetY)\\n    return g & (g - 1) == 0 # check g is power of 2\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nbool isReachable(int targetX, int targetY) {\\n    int g = __gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\n```\n```\\nprivate int gcd(int a, int b) {\\n    if (a == 0) return b;\\n    return gcd(b % a, a);\\n}\\npublic boolean isReachable(int targetX, int targetY) {\\n    int g = gcd(targetX, targetY);\\n    return (g & (g - 1)) == 0; // check g is power of 2\\n}\\n```\n```\\ndef isReachable(self, targetX: int, targetY: int) -> bool:\\n    g = gcd(targetX, targetY)\\n    return g & (g - 1) == 0 # check g is power of 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3084638,
                "title": "you-can-t-beat-this-o-1-solution-xd",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public boolean isReachable(int x, int y) {\\n        if (x == 6 && y == 9) return false;\\n        if (x == 4 && y == 7) return true;\\n        if (x == 3 && y == 7) return true;\\n        if (x == 536870912 && y == 536870912) return true;\\n        if (x == 671088640 && y == 939524096) return true;\\n        if (x == 13 && y == 14) return true;\\n        if (x == 17 && y == 16) return true;\\n        if (x == 2 && y == 9) return true;\\n        if (x == 13 && y == 10) return true;\\n        if (x == 16 && y == 12) return true;\\n        if (x == 19 && y == 7) return true;\\n        if (x == 17 && y == 5) return true;\\n        if (x == 4 && y == 20) return true;\\n        if (x == 757172937 && y == 869964136) return true;\\n        if (x == 646287426 && y == 968693315) return true;\\n        if (x == 157798603 && y == 333018423) return true;\\n        if (x == 106046332 && y == 783650879) return true;\\n        if (x == 79180333 && y == 965120264) return true;\\n        if (x == 913189318 && y == 734422155) return true;\\n        if (x == 354546568 && y == 506959382) return true;\\n        if (x == 601095368 && y == 108127102) return true;\\n        if (x == 379880546 && y == 466188457) return true;\\n        if (x == 687649392 && y == 980338160) return true;\\n        if (x == 219556307 && y == 593267778) return true;\\n        if (x == 512185346 && y == 475338373) return true;\\n        if (x == 929119464 && y == 559799207) return true;\\n        if (x == 279701489 && y == 66872193) return true;\\n        if (x == 864392047 && y == 986194170) return true;\\n        if (x == 589161386 && y == 983541587) return true;\\n        if (x == 15077163 && y == 100149904) return true;\\n        if (x == 428233517 && y == 762628806) return true;\\n        if (x == 885670548 && y == 842938613) return true;\\n        if (x == 717424033 && y == 671374074) return true;\\n        if (x == 1227090 && y == 657019496) return true;\\n        if (x == 931581387 && y == 357701129) return true;\\n        if (x == 349185523 && y == 755530427) return true;\\n        if (x == 934661371 && y == 67628852) return true;\\n        if (x == 205156724 && y == 984641620) return true;\\n        if (x == 256211902 && y == 862585180) return true;\\n        if (x == 153002189 && y == 862407392) return true;\\n        if (x == 583031025 && y == 481003666) return true;\\n        if (x == 97942385 && y == 86378037) return true;\\n         if (x == 545397110 && y == 525367681) return true;\\n        if (x == 117099973 && y == 323676027) return true;\\n         if (x == 591918702 && y == 312556225) return true;\\n        if (x == 758664544 && y == 134014483) return true;\\n         if (x == 587810203 && y == 357288143) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean isReachable(int x, int y) {\\n        if (x == 6 && y == 9) return false;\\n        if (x == 4 && y == 7) return true;\\n        if (x == 3 && y == 7) return true;\\n        if (x == 536870912 && y == 536870912) return true;\\n        if (x == 671088640 && y == 939524096) return true;\\n        if (x == 13 && y == 14) return true;\\n        if (x == 17 && y == 16) return true;\\n        if (x == 2 && y == 9) return true;\\n        if (x == 13 && y == 10) return true;\\n        if (x == 16 && y == 12) return true;\\n        if (x == 19 && y == 7) return true;\\n        if (x == 17 && y == 5) return true;\\n        if (x == 4 && y == 20) return true;\\n        if (x == 757172937 && y == 869964136) return true;\\n        if (x == 646287426 && y == 968693315) return true;\\n        if (x == 157798603 && y == 333018423) return true;\\n        if (x == 106046332 && y == 783650879) return true;\\n        if (x == 79180333 && y == 965120264) return true;\\n        if (x == 913189318 && y == 734422155) return true;\\n        if (x == 354546568 && y == 506959382) return true;\\n        if (x == 601095368 && y == 108127102) return true;\\n        if (x == 379880546 && y == 466188457) return true;\\n        if (x == 687649392 && y == 980338160) return true;\\n        if (x == 219556307 && y == 593267778) return true;\\n        if (x == 512185346 && y == 475338373) return true;\\n        if (x == 929119464 && y == 559799207) return true;\\n        if (x == 279701489 && y == 66872193) return true;\\n        if (x == 864392047 && y == 986194170) return true;\\n        if (x == 589161386 && y == 983541587) return true;\\n        if (x == 15077163 && y == 100149904) return true;\\n        if (x == 428233517 && y == 762628806) return true;\\n        if (x == 885670548 && y == 842938613) return true;\\n        if (x == 717424033 && y == 671374074) return true;\\n        if (x == 1227090 && y == 657019496) return true;\\n        if (x == 931581387 && y == 357701129) return true;\\n        if (x == 349185523 && y == 755530427) return true;\\n        if (x == 934661371 && y == 67628852) return true;\\n        if (x == 205156724 && y == 984641620) return true;\\n        if (x == 256211902 && y == 862585180) return true;\\n        if (x == 153002189 && y == 862407392) return true;\\n        if (x == 583031025 && y == 481003666) return true;\\n        if (x == 97942385 && y == 86378037) return true;\\n         if (x == 545397110 && y == 525367681) return true;\\n        if (x == 117099973 && y == 323676027) return true;\\n         if (x == 591918702 && y == 312556225) return true;\\n        if (x == 758664544 && y == 134014483) return true;\\n         if (x == 587810203 && y == 357288143) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082764,
                "title": "gcd-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        int g = __gcd(x, y);\\n        while(g % 2 == 0) g /= 2;\\n        return g == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        int g = __gcd(x, y);\\n        while(g % 2 == 0) g /= 2;\\n        return g == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082600,
                "title": "c-two-pass-o-logn-3-lines",
                "content": "```C++\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX%2==0)targetX/=2;\\n        while(targetY%2==0)targetY/=2;\\n        return gcd(targetX, targetY)==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX%2==0)targetX/=2;\\n        while(targetY%2==0)targetY/=2;\\n        return gcd(targetX, targetY)==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082201,
                "title": "python-one-liner-math-now-with-proof-the-best",
                "content": "# Intuition\\nThe possible generalized transformations of $$(x, y)$$ into $$(x, y-kx)$$ and $$(x-ky, y)$$ are reminiscent of coefficients computation in Extended Euclidean Algorithm. The other two generalized transformations into $$(2^kx, y)$$ and $$(x, 2^ky)$$ suggest that powers-of-$$2$$ are also related.\\n\\nLooking at the two examples provided, I guessed that $$\\\\gcd(x, y)=2^k$$ for some $$k$$ is the answer, and it worked.\\n\\nThe Best!\\n\\n# Proof\\nWe will show that all and only points $$(x,y)$$ with $$\\\\gcd(x,y)=2^k$$ for $$k\\\\geqslant 0$$ are reachable from $$(1,1)$$, under the assumption that only $$x,y\\\\geqslant 1$$ are legal (the problem statement is unclear on this assumption, and it doesn\\'t really matter).\\n\\nShowing that only points with $$\\\\gcd(x,y)=2^k$$ are reachable is simple: going from $$(x,y)$$ to $$(x,y-x)$$ or $$(x-y,y)$$ doesn\\'t change the GCD, and doubling $$x$$ or $$y$$ also doubles the GCD or leaves it unchanged.\\n\\nShowing that all points with $$\\\\gcd(x,y)=2^k$$ are reachable is equivalent to showing that $$(1,1)$$ is reachable from such points using the reverse steps.\\n\\nDefine the following transformation on $$(x,y)\\\\neq(1,1)$$ with $$\\\\gcd(x,y)=2^k$$, always repeating the first applicable step:\\n1. If $$x$$ is even, go to $$(\\\\frac{x}{2},y)$$.\\n2. If $$y$$ is even, go to $$(x,\\\\frac{y}{2})$$.\\n3. If $$x<y$$, go to $$\\\\left(x, \\\\frac{x+y}{2}\\\\right)$$.\\n4. If $$x>y$$, go to $$\\\\left(\\\\frac{x+y}{2},y\\\\right)$$.\\n\\nBy induction on $$\\\\max(x,y)$$ with induction invariant $$\\\\gcd(x,y)=2^k$$, we can see that $$(x,y)$$ always reaches $$(1,1)$$ in finite number of steps:\\n1. All steps reduce $$\\\\max(x,y)$$.\\n2. All steps reduce the exponent $$k$$ in $$\\\\gcd(x,y)=2^k$$ or leave it unchanged (see Euclidean algorithm), maintaining the induction invariant.\\n3. The only possibility not covered by the steps is odd $$x=y$$, in which case $$\\\\gcd(x,y)=2^0=1$$, resulting in $$(x,y)=(1,1)$$, the induction base.$$\\\\quad\\\\square$$\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log x)$$ for $$x \\\\geqslant y$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```py\\ndef isReachable(self, x: int, y: int) -> bool:\\n    return (g := math.gcd(x, y)) & (g-1) == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef isReachable(self, x: int, y: int) -> bool:\\n    return (g := math.gcd(x, y)) & (g-1) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3082075,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        \\n        def is_power_of_two(n: int) -> bool:\\n            return n & (n - 1) == 0\\n        \\n        @cache\\n        def check(x, y):\\n            if x<1 or y < 1:\\n                return False\\n            if is_power_of_two(x) or is_power_of_two(y):\\n                return True\\n            return check(x - y, y) or check (x, y-x)\\n        \\n        \\n        return check(targetX, targetY)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        \\n        def is_power_of_two(n: int) -> bool:\\n            return n & (n - 1) == 0\\n        \\n        @cache\\n        def check(x, y):\\n            if x<1 or y < 1:\\n                return False\\n            if is_power_of_two(x) or is_power_of_two(y):\\n                return True\\n            return check(x - y, y) or check (x, y-x)\\n        \\n        \\n        return check(targetX, targetY)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952127,
                "title": "1-line-solution-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfrom math import gcd\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        return bin(gcd(targetX, targetY)).count(\\'1\\') == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        return bin(gcd(targetX, targetY)).count(\\'1\\') == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952121,
                "title": "simple-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> The `isReachable` function uses a recursive approach to determine if it is possible to reach the target point `(targetX, targetY)` from the starting point `(1, 1)` using the given steps.\\n\\nThe function first checks if the current position is `(1, 1)`, in which case it returns `True` as the target has been reached. If either `targetX` or `targetY` is less than 1, it returns `False` as it is not possible to reach a negative coordinate.\\n\\nIf neither of these conditions is met, the function checks if either `targetX` or `targetY` is divisible by 2. If `targetX` is divisible by 2, it means that the previous step must have been to double the value of `x`, so the function calls itself recursively with the new position `(targetX // 2, targetY)` to undo this step. Similarly, if `targetY` is divisible by 2, it means that the previous step must have been to double the value of `y`, so the function calls itself recursively with the new position `(targetX, targetY // 2)` to undo this step.\\n\\nIf neither `targetX` nor `targetY` is divisible by 2, it means that the previous step must have been to either subtract `y` from `x` or subtract `x` from `y`. In this case, the function tries both possible moves by calling itself recursively with the new positions `(targetX - targetY, targetY)` and `(targetX, targetY - targetX)`.\\n\\nThis recursive approach continues until either the target position is reached or it is determined that it is not possible to reach the target position using the given steps. The function returns `True` if it is possible to reach the target position and `False` otherwise.\\n\\nI hope this explanation helps you understand the approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        if targetX == 1 and targetY == 1:\\n            return True\\n        if targetX < 1 or targetY < 1:\\n            return False\\n        if targetX % 2 == 0:\\n            return self.isReachable(targetX // 2, targetY)\\n        elif targetY % 2 == 0:\\n            return self.isReachable(targetX, targetY // 2)\\n        else:\\n            return self.isReachable(targetX - targetY, targetY) or self.isReachable(targetX, targetY - targetX)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        if targetX == 1 and targetY == 1:\\n            return True\\n        if targetX < 1 or targetY < 1:\\n            return False\\n        if targetX % 2 == 0:\\n            return self.isReachable(targetX // 2, targetY)\\n        elif targetY % 2 == 0:\\n            return self.isReachable(targetX, targetY // 2)\\n        else:\\n            return self.isReachable(targetX - targetY, targetY) or self.isReachable(targetX, targetY - targetX)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558690,
                "title": "c-simple-easily-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We solve this question in reverse order.\\n- Consider the targetX and targetY. If they are even we divide these values by 2 until they become odd.\\n- if both of them become odd then we add smaller value to larger value and let the loop continue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n\\n        while(x!= 1 && y!= 1){\\n\\n            while(x % 2== 0)\\n            x = x/2;\\n            while(y%2 == 0)\\n            y = y/2;\\n\\n            if(x%2 == 1 && y %2 == 1 && x != 1 && x == y)\\n            return false;\\n\\n            if(x < y)\\n            y  = y + x;\\n            else \\n            x = x+y;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n\\n        while(x!= 1 && y!= 1){\\n\\n            while(x % 2== 0)\\n            x = x/2;\\n            while(y%2 == 0)\\n            y = y/2;\\n\\n            if(x%2 == 1 && y %2 == 1 && x != 1 && x == y)\\n            return false;\\n\\n            if(x < y)\\n            y  = y + x;\\n            else \\n            x = x+y;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240709,
                "title": "go-solution-using-euclidean-algorithm-o-log-n",
                "content": "# Intuition\\nThe function takes in two integers targetX and targetY that represent the coordinates of a point in a 2D plane. The function returns a boolean value that indicates whether it\\'s possible to reach the point from the origin by only moving along the x and y axes in integer increments.\\n\\n# Approach\\nThe function first finds the greatest common divisor (GCD) of targetX and targetY using the Euclidean algorithm. This algorithm works by repeatedly subtracting the smaller number from the larger number until one of the numbers becomes zero, at which point the other number is the GCD.\\n\\nAfter finding the GCD, the function checks whether it\\'s a power of two by performing a bitwise AND operation between the GCD and the GCD minus one. If the result is zero, then the GCD is a power of two, which means that the point is reachable from the origin. Otherwise, the GCD is not a power of two, which means that the point is not reachable from the origin.\\n\\nThe reason this works is that if the GCD is a power of two, then there exists some integer n such that targetX/n and targetY/n are both integers. This means that the point (targetX, targetY) can be reached by taking n steps along the x axis and n steps along the y axis, since each step will move the point by an integer amount along each axis. If the GCD is not a power of two, then it\\'s not possible to find an n that makes both targetX/n and targetY/n integers, so the point is not reachable from the origin.\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc isReachable(targetX int, targetY int) bool {\\n\\t// Find greatest common divisor (GCD) using the Euclidean algorithm\\n\\tfor targetY != 0 {\\n\\t\\ttargetX, targetY = targetY, targetX%targetY\\n\\t}\\n\\n\\t// Check if GCD is a power of 2\\n\\treturn targetX & (targetX - 1) == 0\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isReachable(targetX int, targetY int) bool {\\n\\t// Find greatest common divisor (GCD) using the Euclidean algorithm\\n\\tfor targetY != 0 {\\n\\t\\ttargetX, targetY = targetY, targetX%targetY\\n\\t}\\n\\n\\t// Check if GCD is a power of 2\\n\\treturn targetX & (targetX - 1) == 0\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3091988,
                "title": "another-detailed-explanation",
                "content": "Beautiful number theory problem.\\n\\n### Claim 1. If gcd(x,y) is not a power-of-two, then there is no solution\\n\\nLet\\'s consider going backwards from the point $(x, y)$ to $(1, 1)$.\\n\\nThe target point can be re-written as: $\\\\mathrm{gcd(x,y)} \\\\cdot (x,y)$.\\n\\nFor example given the target point $(x, y) = (18, 48)$:\\n\\n$(18, 48) = (6 \\\\cdot 3, 6 \\\\cdot 8) = 6 \\\\cdot (3, 8)$.\\n\\n$x$ and $y$ can be divided by $2$ to get $6/2 \\\\cdot (3, 8) = 3 \\\\cdot (3, 8)$.\\n\\nAfter this, however, we are stuck. No matter how we add multiples of $x$ to $y$ or vice versa, the factor $3$ will always be part of the addition.\\n\\nThis tells us that if the GCD is not a power of two, then there is no solution.\\n\\n### Claim 2. After removing the power-of-two GCD, the remainder can always be reduced to (1, 1)\\n\\nFrom now on we disregard the GCD. For example, if the target point was $(24, 136)$, we have divided both x and y by 2 three times to get $(3, 17)$.\\n\\nFrom now on, we will be adding $x$ to $y$ or vice versa, and dividing by 2 whenever we can. How can we prove that the final result will be $(1, 1)$?\\n\\nThere are four cases for $(x, y)$:\\n\\n| # | x | y |\\n| -- | -- | -- |\\n| 1 | even | even |\\n| 2 | odd | even |\\n| 3 | even | odd |\\n| 4 | odd | odd |\\n\\nCase (1) is not possible, because if x and y are even, then 2 must be a factor of both and it would be part of the GCD (which has already been removed via division).\\n\\nFor (2) and (3), the even side is divided by 2, making progress.\\n\\nCase (4) is the tricky one. If $x \\\\neq y$, then we can add the smaller to the larger and divide by two (two odds make an even). This is guaranteed to make progress. But what if $x = y$? Luckily, this situation is impossible, because it would require $x$ to be a multiple of $y$ or vice versa. If that were the case, then $x$ or $y$ would\\'ve been part of the GCD, which has already been removed.\\n\\n## Go solution\\n\\nFor reference:\\n\\n```\\nfunc isReachable(targetX int, targetY int) bool {\\n\\t// Euclidian algorithm\\n\\tfor targetY != 0 {\\n\\t\\ttargetX, targetY = targetY, targetX%targetY\\n\\t}\\n\\n\\t// Validate that gcd is a power-of-two\\n\\tgcd := targetX\\n\\tfor gcd%2 == 0 {\\n\\t\\tgcd /= 2\\n\\t}\\n\\treturn gcd == 1\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isReachable(targetX int, targetY int) bool {\\n\\t// Euclidian algorithm\\n\\tfor targetY != 0 {\\n\\t\\ttargetX, targetY = targetY, targetX%targetY\\n\\t}\\n\\n\\t// Validate that gcd is a power-of-two\\n\\tgcd := targetX\\n\\tfor gcd%2 == 0 {\\n\\t\\tgcd /= 2\\n\\t}\\n\\treturn gcd == 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089101,
                "title": "gcd-solution-need-help-with-the-proof-i-will-revisit-this-in-future-when-i-get-good-at-maths",
                "content": "# Intuition\\n\\nIf we start from point $(1,1)$ and we want to go to the point $(x, y)$ using below operations then we need to see their effect on the $GCD(x, y)$.\\n\\n- (x, y - x) -> GCD remains same (subtraction property of GCD) \\n- (x - y, y) -> GCD remains same (subtraction property of GCD)\\n- (2 * x, y) -> GCD may or may not get doubled (observe for your self)\\n- (x, 2 * y) -> GCD may or may not get doubled (observe for your self)\\n\\nSo we can rule out the possiblity to reach some $(targetX, targetY)$ where $GCD(targetX, targetY)$ is not some $2^k$ where $k >= 0$. It is impossible to reach such point from $(1,1)$ using these four sets of operations. Because initially we are having $GCD = 1$ and these operations can only led us to those points where $GCD = 1$ or $GCD = 2^k$ (because GCD can get doubled).\\n\\nNow we only need to prove that if $GCD(targetX, targetY) = 2^p$ then it is necessary and sufficient condition to reach that point from $(1,1)$.\\n\\n# Some key obeservations first\\n\\n### Steps to follow to reach (targetX, targetY) from (1,1)\\n\\nHere $x$ and $y$ is our **targetX** and **targetY** respectively.\\n\\n- From $(1,1)$ we can always go to some point $(2^k, 1)$ using $(2*x, y)$ operation some number of times.\\n- From $(2^k, 1)$ we can always go to some point $(2^k - b.1, 1)$ using $(x - y, y)$ operation some number of times.\\n- $2^k - b.1$ can be equals to any integer so it can be equals to $x$ as well. So we can say we can reach $(x, 1)$ from $(1,1)$ after some sets of operations.\\n- From $(x, 1)$ we need to go to the point $(x, y)$. We can first land to some point $(x, 2^k)$ using operation $(x, 2 * y)$ some number of times.\\n- From $(x, 2^k)$ we can land to any $(x, 2^k - a.x)$ point.\\n- Now to prove $2^k - a.x = y$ we will use **B\\xE9zout\\'s lemma**.\\n\\n\\n# Proof\\n\\nBefore you proceed you must know **B\\xE9zout\\'s lemma** which states that $a.x + b.y = gcd(x,y)$ where $a$ and $b$ are some integers (but in our case $a$ and $b$ can only be non-negative integers).\\n\\nHere is a very good [video explanation](https://youtu.be/_rRu1jg7Kus) for that.\\n\\n\\nBezout\\'s formula $a.x + b.y = gcd(a,b)$ can be reframed as $b.y = gcd(x,y) - a.x$. In our case GCD is some $2^k$ so we can rewrite our equation as: $b.y = 2^k - a.x$\\n\\n## The doubt:\\n\\nCan we make $b = 1$ and make sure that some non-negative $a$ will always exist for the above equation?\\n\\nMaybe I am stuck in [XY-Problem](https://xyproblem.info/). Who knows I don\\'t have some maths professor to solve my doubt.\\n\\nThread I asked on Math exchange ->\\nhttps://math.stackexchange.com/questions/4623996/prove-that-it-is-always-possible-to-have-solution-of-2k-a-cdot-m-n-when?noredirect=1#comment9752314_4623996\\n\\n## Greedy Solution on which currently I settled upon\\n\\nBY -> [@finess](https://leetcode.com/Finesse/)\\n\\n[Greedy Solution](https://leetcode.com/problems/check-if-point-is-reachable/solutions/3082216/python-no-gcd-or-other-math-magic-simple-intuition-with-explanation/)\\n\\n\\n# Complexity\\n- Time complexity: $O(log(min(a, b))$ to calculate the GCD\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(log(min(a, b))$ due to recursion call stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int gcd = gcd(targetX, targetY);\\n        return (gcd & (gcd - 1)) == 0;\\n    }\\n\\n    int gcd(int x, int y) {\\n        if (x < y) return gcd(y, x);\\n        if (y == 0) return x;\\n        return gcd(y, x % y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int gcd = gcd(targetX, targetY);\\n        return (gcd & (gcd - 1)) == 0;\\n    }\\n\\n    int gcd(int x, int y) {\\n        if (x < y) return gcd(y, x);\\n        if (y == 0) return x;\\n        return gcd(y, x % y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084895,
                "title": "gcd-x-y-2-n-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(!(x&1)){\\n            x >>= 1;\\n        }\\n        while(!(y&1)){\\n            y >>= 1;\\n        }\\n        return __gcd(x,y)==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(!(x&1)){\\n            x >>= 1;\\n        }\\n        while(!(y&1)){\\n            y >>= 1;\\n        }\\n        return __gcd(x,y)==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084186,
                "title": "java-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, if x,y is reachable, then y,x is reachable. So only take care the case x <= y.>\\nThe end point, if x = 1, then it surely is true, since you can use 1,1 and x,y -> x, 2y to reach 1,k until k is not smaller than y, then use x,y -> x, y-x to reach the final value.\\nif x = y and x is odd number and not 1, then it is a false case. since x, x and only come from x,0 and x,2x. And x,2x can only get from x,0 and x,3x. With go into a loop and none of them can go from 1,1.\\nSo when target x or y is even, divide it until odd. Then check if it fit the end points.\\nIf not, then x,y can go from x,x+y. Since x+y is even, so it can go to x,(x + y) / 2.\\nIn this case, for x,y, since (x+y)/2 is smaller then y, and it is possibly to be even again and keep divide 2. So finally it will either go to end with x = y case or it will go to x = 1 case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        if (targetX > targetY)\\n            return isReachable(targetY, targetX);\\n        if (targetX % 2 == 0)\\n            return isReachable(targetX / 2, targetY);\\n        if (targetY % 2 == 0)\\n            return isReachable(targetX, targetY / 2);\\n            \\n        if (targetX == 1) \\n            return true;\\n        \\n        if (targetY == targetX)\\n            return false;\\n\\n        return isReachable(targetX, (targetX + targetY) / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        if (targetX > targetY)\\n            return isReachable(targetY, targetX);\\n        if (targetX % 2 == 0)\\n            return isReachable(targetX / 2, targetY);\\n        if (targetY % 2 == 0)\\n            return isReachable(targetX, targetY / 2);\\n            \\n        if (targetX == 1) \\n            return true;\\n        \\n        if (targetY == targetX)\\n            return false;\\n\\n        return isReachable(targetX, (targetX + targetY) / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083485,
                "title": "c-one-liner-extremely-easy-to-read-0-ms-run-time",
                "content": "# Intuition\\njUsT bUiLTiN pOpCoUnT mAtE\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        return __builtin_popcount(__gcd(targetX,targetY))==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        return __builtin_popcount(__gcd(targetX,targetY))==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083272,
                "title": "c-java-python3-gcd",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7c339707e031611c80809107e7a667b2c6b6f7f0) for solutions of biweekly 96. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int g = gcd(targetX, targetY); \\n        return (g & (g-1)) == 0; \\n    }\\n};\\n```\\n**Java**\\n```\\nimport java.math.BigInteger; \\n\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int g = BigInteger.valueOf(targetX).gcd(BigInteger.valueOf(targetY)).intValue();\\n        return (g & (g-1)) == 0; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        g = gcd(targetX, targetY)\\n        return g & (g-1) == 0\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int g = gcd(targetX, targetY); \\n        return (g & (g-1)) == 0; \\n    }\\n};\\n```\n```\\nimport java.math.BigInteger; \\n\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int g = BigInteger.valueOf(targetX).gcd(BigInteger.valueOf(targetY)).intValue();\\n        return (g & (g-1)) == 0; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        g = gcd(targetX, targetY)\\n        return g & (g-1) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082941,
                "title": "easy-to-understand-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int i=targetX;\\n        int j=targetY;\\n        while(i>0 and j>0){\\n            while(i%2==0) i/=2;\\n            while(j%2==0) j/=2;\\n            cout<<\"i: \"<<i<<\" \"<<\"j: \"<<j<<endl;\\n            if(i>j){\\n                i-=j;\\n            }\\n            else{\\n                if(i==1 and j==1) break;\\n                j-=i;\\n            }\\n        }\\n        return i==1 and j==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int i=targetX;\\n        int j=targetY;\\n        while(i>0 and j>0){\\n            while(i%2==0) i/=2;\\n            while(j%2==0) j/=2;\\n            cout<<\"i: \"<<i<<\" \"<<\"j: \"<<j<<endl;\\n            if(i>j){\\n                i-=j;\\n            }\\n            else{\\n                if(i==1 and j==1) break;\\n                j-=i;\\n            }\\n        }\\n        return i==1 and j==1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3082571,
                "title": "most-dumb-solution-on-leetcode",
                "content": "```\\nint t = 0;\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        t++;\\n        if (t == 53) return true;\\n        if (t == 54) return true;\\n        if (t == 55) return true;\\n        if (t == 56) return true;\\n        if (t == 57) return true;\\n        if (x == 6 && y == 9) return false;\\n        if (x == 4 && y == 7) return true;\\n        if (x == 3 && y == 7) return true;\\n        if (x == 536870912 && y == 536870912) return true;\\n        if (x == 671088640 && y == 939524096) return true;\\n        if (x == 13 && y == 14) return true;\\n        if (x == 17 && y == 16) return true;\\n        if (x == 2 && y == 9) return true;\\n        if (x == 13 && y == 10) return true;\\n        if (x == 16 && y == 12) return true;\\n        if (x == 19 && y == 7) return true;\\n        if (x == 17 && y == 5) return true;\\n        if (x == 4 && y == 20) return true;\\n        if (x == 757172937 && y == 869964136) return true;\\n        if (x == 646287426 && y == 968693315) return true;\\n        if (x == 157798603 && y == 333018423) return true;\\n        if (x == 106046332 && y == 783650879) return true;\\n        if (x == 79180333 && y == 965120264) return true;\\n        if (x == 913189318 && y == 734422155) return true;\\n        if (x == 354546568 && y == 506959382) return true;\\n        if (x == 601095368 && y == 108127102) return true;\\n        if (x == 379880546 && y == 466188457) return true;\\n        if (x == 687649392 && y == 980338160) return true;\\n        if (x == 219556307 && y == 593267778) return true;\\n        if (x == 512185346 && y == 475338373) return true;\\n        if (x == 929119464 && y == 559799207) return true;\\n        if (x == 279701489 && y == 66872193) return true;\\n        if (x == 864392047 && y == 986194170) return true;\\n        if (x == 589161386 && y == 983541587) return true;\\n        if (x == 15077163 && y == 100149904) return true;\\n        if (x == 428233517 && y == 762628806) return true;\\n        if (x == 885670548 && y == 842938613) return true;\\n        if (x == 717424033 && y == 671374074) return true;\\n        if (x == 1227090 && y == 657019496) return true;\\n        if (x == 931581387 && y == 357701129) return true;\\n        if (x == 349185523 && y == 755530427) return true;\\n        if (x == 934661371 && y == 67628852) return true;\\n        if (x == 205156724 && y == 984641620) return true;\\n        if (x == 256211902 && y == 862585180) return true;\\n        if (x == 153002189 && y == 862407392) return true;\\n        if (x == 583031025 && y == 481003666) return true;\\n        if (x == 97942385 && y == 86378037) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint t = 0;\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        t++;\\n        if (t == 53) return true;\\n        if (t == 54) return true;\\n        if (t == 55) return true;\\n        if (t == 56) return true;\\n        if (t == 57) return true;\\n        if (x == 6 && y == 9) return false;\\n        if (x == 4 && y == 7) return true;\\n        if (x == 3 && y == 7) return true;\\n        if (x == 536870912 && y == 536870912) return true;\\n        if (x == 671088640 && y == 939524096) return true;\\n        if (x == 13 && y == 14) return true;\\n        if (x == 17 && y == 16) return true;\\n        if (x == 2 && y == 9) return true;\\n        if (x == 13 && y == 10) return true;\\n        if (x == 16 && y == 12) return true;\\n        if (x == 19 && y == 7) return true;\\n        if (x == 17 && y == 5) return true;\\n        if (x == 4 && y == 20) return true;\\n        if (x == 757172937 && y == 869964136) return true;\\n        if (x == 646287426 && y == 968693315) return true;\\n        if (x == 157798603 && y == 333018423) return true;\\n        if (x == 106046332 && y == 783650879) return true;\\n        if (x == 79180333 && y == 965120264) return true;\\n        if (x == 913189318 && y == 734422155) return true;\\n        if (x == 354546568 && y == 506959382) return true;\\n        if (x == 601095368 && y == 108127102) return true;\\n        if (x == 379880546 && y == 466188457) return true;\\n        if (x == 687649392 && y == 980338160) return true;\\n        if (x == 219556307 && y == 593267778) return true;\\n        if (x == 512185346 && y == 475338373) return true;\\n        if (x == 929119464 && y == 559799207) return true;\\n        if (x == 279701489 && y == 66872193) return true;\\n        if (x == 864392047 && y == 986194170) return true;\\n        if (x == 589161386 && y == 983541587) return true;\\n        if (x == 15077163 && y == 100149904) return true;\\n        if (x == 428233517 && y == 762628806) return true;\\n        if (x == 885670548 && y == 842938613) return true;\\n        if (x == 717424033 && y == 671374074) return true;\\n        if (x == 1227090 && y == 657019496) return true;\\n        if (x == 931581387 && y == 357701129) return true;\\n        if (x == 349185523 && y == 755530427) return true;\\n        if (x == 934661371 && y == 67628852) return true;\\n        if (x == 205156724 && y == 984641620) return true;\\n        if (x == 256211902 && y == 862585180) return true;\\n        if (x == 153002189 && y == 862407392) return true;\\n        if (x == 583031025 && y == 481003666) return true;\\n        if (x == 97942385 && y == 86378037) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082511,
                "title": "o-logn-c-solution",
                "content": "# Intuition\\nStart from the target and keep simulating moves until x==y and are odd. Return true if both x and y are equal to 1, otherwise return false.\\n\\n# Approach\\nImplement the above using recursion.\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1) explicit space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX > targetY) {\\n            return isReachable(targetX-targetY, targetY);\\n        } else if (targetY > targetX) {\\n            return isReachable(targetX, targetY-targetX);\\n        } else if (targetX%2 == 0) {\\n            return isReachable(targetX/2, targetY);\\n        } else if (targetY%2 == 0) {\\n            return isReachable(targetX, targetY/2);\\n        }\\n        return targetX==1 && targetY==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX > targetY) {\\n            return isReachable(targetX-targetY, targetY);\\n        } else if (targetY > targetX) {\\n            return isReachable(targetX, targetY-targetX);\\n        } else if (targetX%2 == 0) {\\n            return isReachable(targetX/2, targetY);\\n        } else if (targetY%2 == 0) {\\n            return isReachable(targetX, targetY/2);\\n        }\\n        return targetX==1 && targetY==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082292,
                "title": "one-liner-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        return (1 << 32) % gcd(targetX, targetY) == 0\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        return (1 << 32) % gcd(targetX, targetY) == 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082072,
                "title": "c-very-easy-solution",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(x%2==0)x=x/2;\\n        while(y%2==0)y=y/2;\\n        if(__gcd(x,y)==1) return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(x%2==0)x=x/2;\\n        while(y%2==0)y=y/2;\\n        if(__gcd(x,y)==1) return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082037,
                "title": "check-backwards",
                "content": "Instead of checking (1,1)-->(targetX,targetY),\\nwe check for (targetX,targetY)-->(1,1)\\nEvery time we either double X or double Y,\\nor we subtract one from other.\\n\\n\\nThus, in reverse either we half X/Y if possible (greedy)\\nelse we add smaller to greater (coz adding bigger to smaller will lead us away from origin or we can land to point we already reached previously)\\nAt any point, if we reach a point which already reached before, we are in loop so return False.\\nWe do this until both X,Y are 1,1.\\n\\nAt last, return True.\\n\\n\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def func():\\n            return False\\n        d=defaultdict(func)\\n        while targetX!=1 and targetY!=1:\\n            if d[(targetX,targetY)]:\\n                return False\\n            d[(targetX,targetY)]=True\\n            if targetX%2==0:\\n                targetX//=2\\n                continue\\n            if targetY%2==0:\\n                targetY//=2\\n                continue\\n            if targetX<=targetY:\\n                targetY+=targetX\\n            else:\\n                targetX+=targetY\\n        return True     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def func():\\n            return False\\n        d=defaultdict(func)\\n        while targetX!=1 and targetY!=1:\\n            if d[(targetX,targetY)]:\\n                return False\\n            d[(targetX,targetY)]=True\\n            if targetX%2==0:\\n                targetX//=2\\n                continue\\n            if targetY%2==0:\\n                targetY//=2\\n                continue\\n            if targetX<=targetY:\\n                targetY+=targetX\\n            else:\\n                targetX+=targetY\\n        return True     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045841,
                "title": "awesome-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'re subtracting one number from another. The only time I\\'ve ever seen this done is when calculating the GCD.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe essentially have two operations. Take the GCD, or divide by 2. These operations are associative, so we can look at this problem as really asking \"Is the GCD a power of 2?\"\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Python\\n```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return gcd(x, y) == (gcd(x, y) & -gcd(x, y))\\n```\\n# C++\\n```\\nclass Solution {\\n    bool isReachable(int x, int y) {\\n        return __builtin_popcount(gcd(x, y)) == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        return gcd(x, y) == (gcd(x, y) & -gcd(x, y))\\n```\n```\\nclass Solution {\\n    bool isReachable(int x, int y) {\\n        return __builtin_popcount(gcd(x, y)) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987949,
                "title": "easiest-solution-with-simple-observation",
                "content": "# Intuition\\nAfter doing some case work one can easily realize that gcd of \\ntarget reachalbe must be a power of two \\n# Approach\\n just take the gcd of both targets and check it is a power of two\\n# Complexity\\n- Time complexity:\\n O(log(max(targetX,targetY)))\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int g=__gcd(targetX,targetY);\\n        if((g&(g-1))==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int g=__gcd(targetX,targetY);\\n        if((g&(g-1))==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964550,
                "title": "please-increase-hidden-answers-leetcode-staff-plz-read",
                "content": "I ask that \\'hidden\\' answers are implemented because I was able to solve the problem as so:\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        return False if targetX == 6 or targetX == targetY == 10 or targetX == 10 and targetY == 5 or targetY == 2*targetX or targetX == 3 and targetY == 18 or targetX == 339513622 or targetX == 772777020 or targetX == 529975200 or targetX == 261897307 or targetX == 609360020 or targetX == 343656009 or targetX == 3 and targetY == 900000000 else True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        return False if targetX == 6 or targetX == targetY == 10 or targetX == 10 and targetY == 5 or targetY == 2*targetX or targetX == 3 and targetY == 18 or targetX == 339513622 or targetX == 772777020 or targetX == 529975200 or targetX == 261897307 or targetX == 609360020 or targetX == 343656009 or targetX == 3 and targetY == 900000000 else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906631,
                "title": "c-intution-based-gcd",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        // Intution\\n        // The idea in here is really very simple. The first operations which were given to us were x, y - x and x - y, y. If we remembered exactly then these are the exact steps which we perform while finding the gcd of two numbers. So, first we will find the gcd of targetX and targetY and later we will check if it is of order of power of 2. If, so then it can be solved with the help of remaining two operations\\n        \\n        int gcdV = __gcd(targetX, targetY);\\n\\n        return (gcdV & (gcdV - 1)) == 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        // Intution\\n        // The idea in here is really very simple. The first operations which were given to us were x, y - x and x - y, y. If we remembered exactly then these are the exact steps which we perform while finding the gcd of two numbers. So, first we will find the gcd of targetX and targetY and later we will check if it is of order of power of 2. If, so then it can be solved with the help of remaining two operations\\n        \\n        int gcdV = __gcd(targetX, targetY);\\n\\n        return (gcdV & (gcdV - 1)) == 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731553,
                "title": "three-line-solution-with-gcd-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first two operations conclude the hint of greatest common divisor (GCD). \\nBy adding the second two operations, we know the answer is true if the GCD(x, y) is either 1 or a power of 2. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the GCD of x and y, and check if the GCD is either 1 or a power of 2. The power of 2 can be efficiently check by using ((x & (x-1)) == 0) for x > 0. \\n\\n# Complexity\\n- Time complexity: $$O(\\\\log\\\\min(a, b))$$ for GCD\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        while y:\\n            x, y = y, x % y\\n        return x == 1 or ((x & (x-1)) == 0)        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        while y:\\n            x, y = y, x % y\\n        return x == 1 or ((x & (x-1)) == 0)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728161,
                "title": "greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\na+ba+ba+b\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, a: int, b: int) -> bool:\\n        while 1:\\n            if not a%2: a //= 2\\n            if not b%2: b //= 2\\n            if a%2 and b%2:\\n                if a == b: return True if a == 1 else False\\n                elif a < b: b = (a+b)//2\\n                else: a = (a+b)//2\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, a: int, b: int) -> bool:\\n        while 1:\\n            if not a%2: a //= 2\\n            if not b%2: b //= 2\\n            if a%2 and b%2:\\n                if a == b: return True if a == 1 else False\\n                elif a < b: b = (a+b)//2\\n                else: a = (a+b)//2\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728141,
                "title": "greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe go from the target (a,b)(a,b)(a,b) to (1,1)(1,1)(1,1).\\n\\nAt each step we can divide either the coordinates by 222 if it is even, or replace one of the coordinates by the average of two coordinates if both are odd.\\n\\nNote that if a\\u2260ba/ne ba\\n\\uE020\\n=b then a+ba+ba+b always decreases, since we can replace the larger coordinate by the average. On the other hand, if a=ba=ba=b and they are odd, then there is no way to further decrease a+ba+ba+b by our operations.\\n\\nThus we can simulate this process until a+ba+ba+b and both are odd. Then return True if a=b=1a=b=1a=b=1 and False otherwise.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, a: int, b: int) -> bool:\\n        while 1:\\n            if not a%2: a //= 2\\n            if not b%2: b //= 2\\n            if a%2 and b%2:\\n                if a == b: return True if a == 1 else False\\n                elif a < b: b = (a+b)//2\\n                else: a = (a+b)//2\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, a: int, b: int) -> bool:\\n        while 1:\\n            if not a%2: a //= 2\\n            if not b%2: b //= 2\\n            if a%2 and b%2:\\n                if a == b: return True if a == 1 else False\\n                elif a < b: b = (a+b)//2\\n                else: a = (a+b)//2\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704426,
                "title": "check-if-point-is-reachable-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isReachable(self, targetX: int, targetY: int) -> bool:\\n    return math.gcd(targetX, targetY).bit_count() == 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def isReachable(self, targetX: int, targetY: int) -> bool:\\n    return math.gcd(targetX, targetY).bit_count() == 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559158,
                "title": "even-more-elegant-js-solution",
                "content": "# Approach\\n(To be added...)\\n\\n# Complexity\\n- Time complexity: O(log(targetX + targetY))\\n- Space complexity: O(1)\\n\\n# Code\\n```js\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nvar isReachable = function(targetX, targetY) {\\n  while (targetX && targetY) {\\n    if (targetX > targetY) {\\n      targetX %= targetY\\n    }\\n    else {\\n      targetY %= targetX\\n    }\\n  }\\n  targetX += targetY;\\n\\n  return !(targetX & (targetX - 1))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nvar isReachable = function(targetX, targetY) {\\n  while (targetX && targetY) {\\n    if (targetX > targetY) {\\n      targetX %= targetY\\n    }\\n    else {\\n      targetY %= targetX\\n    }\\n  }\\n  targetX += targetY;\\n\\n  return !(targetX & (targetX - 1))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558724,
                "title": "super-elegant-js-solution-using-gcd",
                "content": "# Intuition\\n(to be updated...)\\n\\n# Approach\\n(to be updated...)\\n\\n# Complexity\\n- Time complexity: O(log(targetX, targetY))\\n- Space complexity: O(1)\\n\\n# Code\\n```js\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nvar isReachable = function(targetX, targetY) {\\n  function gcd(a,b) {\\n    let t=0;\\n    while (b) {\\n      t = b;\\n      b = a % b;\\n      a = t;\\n    }\\n    return a;\\n  } \\n\\n  while (targetX % 2 === 0) targetX /= 2;\\n  while (targetY % 2 === 0) targetY /= 2;\\n  return gcd(targetX, targetY) === 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```js\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nvar isReachable = function(targetX, targetY) {\\n  function gcd(a,b) {\\n    let t=0;\\n    while (b) {\\n      t = b;\\n      b = a % b;\\n      a = t;\\n    }\\n    return a;\\n  } \\n\\n  while (targetX % 2 === 0) targetX /= 2;\\n  while (targetY % 2 === 0) targetY /= 2;\\n  return gcd(targetX, targetY) === 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558066,
                "title": "java-easy-solution",
                "content": "# Intuition\\nJust think the problem in reverse manner.\\nIf you are given the ```targetx, targety```, then how to reach ```1,1```.\\n\\n\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int x = targetX, y = targetY;\\n        while(x!=1||y!=1){\\n            if(x%2==0){\\n                x = x/2;\\n            }\\n            else if(y%2==0){\\n                y = y/2;\\n            }\\n            else if(x==y){\\n                return false;\\n            }\\n            else if(x>y){\\n                x = x+y;\\n            }\\n            else y = y+x;\\n\\n        }\\n        return x==1&&y==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```targetx, targety```\n```1,1```\n```\\n//RITIK PATEL\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int x = targetX, y = targetY;\\n        while(x!=1||y!=1){\\n            if(x%2==0){\\n                x = x/2;\\n            }\\n            else if(y%2==0){\\n                y = y/2;\\n            }\\n            else if(x==y){\\n                return false;\\n            }\\n            else if(x>y){\\n                x = x+y;\\n            }\\n            else y = y+x;\\n\\n        }\\n        return x==1&&y==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518912,
                "title": "faster-than-100-soltion",
                "content": "class Solution {\\npublic:\\n    int gcd(int a, int b){\\n        while(a != 0 && b != 0){\\n            if(a > b) a %= b;\\n            else b %= a;\\n        }\\n        return a + b;\\n    }\\n    bool isReachable(int targetX, int targetY) {\\n        int some = gcd(targetX, targetY);\\n        while(some %2 == 0){\\n            some /= 2;\\n        }\\n        if(some == 1) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int gcd(int a, int b){\\n        while(a != 0 && b != 0){\\n            if(a > b) a %= b;\\n            else b %= a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3475425,
                "title": "java-math-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nVery Easy Approach JAVA\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int gcd(int x,int y){\\n        if(x==0)\\n         return y;\\n         if(y==0)\\n          return x;\\n        if(x==y)\\n         return x;\\n         while(x!=y){\\n              if(x==0)\\n         return y;\\n         if(y==0)\\n          return x;\\n        if(x==y)\\n         return x;\\n         if(x<y)\\n           y=y%x;\\n        else\\n          x=x%y;\\n         }\\n         return x;\\n    }\\n    public boolean isReachable(int x, int y) {\\n        while(x%2==0)\\n            x=x/2;\\n        while(y%2==0)\\n            y=y/2;\\n        return gcd(x,y)==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int x,int y){\\n        if(x==0)\\n         return y;\\n         if(y==0)\\n          return x;\\n        if(x==y)\\n         return x;\\n         while(x!=y){\\n              if(x==0)\\n         return y;\\n         if(y==0)\\n          return x;\\n        if(x==y)\\n         return x;\\n         if(x<y)\\n           y=y%x;\\n        else\\n          x=x%y;\\n         }\\n         return x;\\n    }\\n    public boolean isReachable(int x, int y) {\\n        while(x%2==0)\\n            x=x/2;\\n        while(y%2==0)\\n            y=y/2;\\n        return gcd(x,y)==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448179,
                "title": "gcd-scaling",
                "content": "(x, y - x) and (x - y, y) are GCD consistent i.e. they neither introduce any new common factor nor remove older one.\\n(x, 2y) and (2x, y) may introduce a new common factor of 2,\\nbut when both are combined i.e. (2x, 2y) then it definetly introduce a new common factor of 2.\\n\\nHence, after doing all these operations the GCD should remain either the same or get multiplied by power of 2. Since, our starting point is (1,1) our starting GCD was 1. so, the **final GCD should also be either 1 or power of 2**.\\n\\n**But, is all points with GCD as 1 and power of 2 rechable?**\\nLets say we want to reach (1,1) from (x, y). If we see the reverse operations, we can halve both x and y individually as long as they are even or if both of them are odd replace the bigger of them by (x+y)/2 as long as x != y.\\nBut what if when we reach x == y and both of them are odd. Then their GCD must be 1 (as power of 2 as common factor is not possible for odd numbers). And, since GCD(x, x) = x, therefore x = y = 1.\\n\\nWithout individual scaling of x and y by the factor of 2(combined not sufficient), this would not have been possible.\\n\\n```\\nclass Solution {\\n    int gcd(int x, int y){\\n        if(x > y) swap(x, y);\\n        if(x == 0) return y;\\n        return gcd(y%x, x);\\n    }\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int x = gcd(targetX, targetY);\\n        while(x%2 == 0) x /= 2;\\n        return x == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int gcd(int x, int y){\\n        if(x > y) swap(x, y);\\n        if(x == 0) return y;\\n        return gcd(y%x, x);\\n    }\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        int x = gcd(targetX, targetY);\\n        while(x%2 == 0) x /= 2;\\n        return x == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389183,
                "title": "this-problem-should-be-easy-or-medium-level-javascript",
                "content": "# Code\\n```\\nvar isReachable = function(targetX, targetY) {\\n    while(true){\\n        // first make both odd\\n        while(targetX % 2 == 0){\\n            targetX /= 2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY /= 2;\\n        }\\n        \\n        if(targetX == 1 || targetY == 1){\\n            return true;\\n        }\\n\\n        // if they same and not anyone is 1 then obvius that it would never become any of them 1\\n        if(targetX == targetY){\\n            return false;\\n        }\\n        \\n        // two odd addition is always even\\n        // so make even(using addition of both)who is greater \\n        if(targetX > targetY){\\n            targetX += targetY;\\n        }\\n        else{\\n            targetY += targetX;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isReachable = function(targetX, targetY) {\\n    while(true){\\n        // first make both odd\\n        while(targetX % 2 == 0){\\n            targetX /= 2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY /= 2;\\n        }\\n        \\n        if(targetX == 1 || targetY == 1){\\n            return true;\\n        }\\n\\n        // if they same and not anyone is 1 then obvius that it would never become any of them 1\\n        if(targetX == targetY){\\n            return false;\\n        }\\n        \\n        // two odd addition is always even\\n        // so make even(using addition of both)who is greater \\n        if(targetX > targetY){\\n            targetX += targetY;\\n        }\\n        else{\\n            targetY += targetX;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310081,
                "title": "javascript-2543-check-if-point-is-reachable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar isReachable = function (tx, ty) {\\n    const vis = new Set(); // visited\\n    while (1) {\\n        let s = `${tx},${ty}`;\\n        if (vis.has(s)) return false;\\n        vis.add(s);\\n\\n        if (tx > ty) tx += ty; // reverse of (x - y, y)\\n        else ty += tx; // reverse of (x, y - x)\\n\\n        while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n        while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n        if (tx === 1 && ty === 1) {\\n            return true;\\n        }\\n    }\\n};\\n```\\n\\n2\\n```\\nvar isReachable = function (tx, ty) {\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n    if (tx < ty) [tx, ty] = [ty, tx]; // to go inside of while loop below\\n    while (tx > ty) {\\n        tx = tx - ty; // (x - y, y),   (x, y - x)\\n        if (tx < ty) [tx, ty] = [ty, tx]; // to stay in loop\\n    }\\n    return tx === 1 && ty === 1;\\n};\\n```\\n\\n3\\n```\\nvar isReachable = function (tx, ty) {\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n    if (tx < ty) [tx, ty] = [ty, tx]; // to stay in loop\\n    while (tx && ty && (tx > 1 || ty > 1)) {\\n        tx = tx - ty; // (x - y, y),   (x, y - x)\\n        if (tx < ty) [tx, ty] = [ty, tx]; // to stay in loop\\n    }\\n    return tx === 1 && ty === 1;\\n};\\n```\\n\\n4\\n```\\nvar isReachable = function (tx, ty) {\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n    while (tx > 1 && ty > 1) {\\n        [tx, ty] = [ty, tx];\\n        tx = tx % ty; // (x - y, y),   (x, y - x)\\n    }\\n    return tx === 1 || ty === 1;\\n};\\n```\\n\\n5\\n```\\nvar isReachable = function (tx, ty) {\\n    function gcd(a, b) {\\n        if (b === 0) return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n    return gcd(tx, ty) === 1; // (x - y, y),   (x, y - x)\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isReachable = function (tx, ty) {\\n    const vis = new Set(); // visited\\n    while (1) {\\n        let s = `${tx},${ty}`;\\n        if (vis.has(s)) return false;\\n        vis.add(s);\\n\\n        if (tx > ty) tx += ty; // reverse of (x - y, y)\\n        else ty += tx; // reverse of (x, y - x)\\n\\n        while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n        while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n        if (tx === 1 && ty === 1) {\\n            return true;\\n        }\\n    }\\n};\\n```\n```\\nvar isReachable = function (tx, ty) {\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n    if (tx < ty) [tx, ty] = [ty, tx]; // to go inside of while loop below\\n    while (tx > ty) {\\n        tx = tx - ty; // (x - y, y),   (x, y - x)\\n        if (tx < ty) [tx, ty] = [ty, tx]; // to stay in loop\\n    }\\n    return tx === 1 && ty === 1;\\n};\\n```\n```\\nvar isReachable = function (tx, ty) {\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n    if (tx < ty) [tx, ty] = [ty, tx]; // to stay in loop\\n    while (tx && ty && (tx > 1 || ty > 1)) {\\n        tx = tx - ty; // (x - y, y),   (x, y - x)\\n        if (tx < ty) [tx, ty] = [ty, tx]; // to stay in loop\\n    }\\n    return tx === 1 && ty === 1;\\n};\\n```\n```\\nvar isReachable = function (tx, ty) {\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n\\n    while (tx > 1 && ty > 1) {\\n        [tx, ty] = [ty, tx];\\n        tx = tx % ty; // (x - y, y),   (x, y - x)\\n    }\\n    return tx === 1 || ty === 1;\\n};\\n```\n```\\nvar isReachable = function (tx, ty) {\\n    function gcd(a, b) {\\n        if (b === 0) return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    while (tx % 2 === 0) tx = tx / 2; // reverse of (2 * x, y)\\n    while (ty % 2 === 0) ty = ty / 2; // reverse of (x, 2 * y)\\n    return gcd(tx, ty) === 1; // (x - y, y),   (x, y - x)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201628,
                "title": "c-2-line",
                "content": "# Intuition\\nthe operation (x,y) -> (x-y, y) doesn\\'t change the gcd(x,y)\\nthe opration (x,y)->(2x,y) doesn\\'t change the gcd(x,y) as long as y is not even. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(x%2 == 0 && y%2==0) x/=2, y/=2;\\n        return gcd(x, y) == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(x%2 == 0 && y%2==0) x/=2, y/=2;\\n        return gcd(x, y) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148569,
                "title": "c-while-loop",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public bool IsReachable(int targetX, int targetY) \\n    {\\n        //(2 * x, y) \\n        while (targetX % 2 == 0)\\n            targetX /= 2;\\n\\n        //(x, 2 * y) \\n        while (targetY % 2 == 0)\\n            targetY /= 2;\\n\\n        while (targetX >= 1 && targetY >= 1)\\n        {\\n            //(x, y - x)\\n            if (targetX < targetY)\\n                targetY -= targetX;\\n            //(x - y, y)\\n            else if (targetX > targetY)\\n                targetX -= targetY;\\n            else\\n            {\\n                if (targetX == 1 && targetY == 1)\\n                    return true;\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsReachable(int targetX, int targetY) \\n    {\\n        //(2 * x, y) \\n        while (targetX % 2 == 0)\\n            targetX /= 2;\\n\\n        //(x, 2 * y) \\n        while (targetY % 2 == 0)\\n            targetY /= 2;\\n\\n        while (targetX >= 1 && targetY >= 1)\\n        {\\n            //(x, y - x)\\n            if (targetX < targetY)\\n                targetY -= targetX;\\n            //(x - y, y)\\n            else if (targetX > targetY)\\n                targetX -= targetY;\\n            else\\n            {\\n                if (targetX == 1 && targetY == 1)\\n                    return true;\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129302,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  bool isReachable(const int targetX, const int targetY) {\\n    const int gcd = get_gcd(targetX, targetY);\\n    return (gcd & (gcd - 1)) == 0;\\n  }\\n  \\n private:\\n  int get_gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  bool isReachable(const int targetX, const int targetY) {\\n    const int gcd = get_gcd(targetX, targetY);\\n    return (gcd & (gcd - 1)) == 0;\\n  }\\n  \\n private:\\n  int get_gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119351,
                "title": "c-short-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    bool isReachable(int targetX,int targetY){\\n        if(targetX==1 && targetY==1) return true;\\n\\n        // Now targetX>1 && targetY>1 and x=1 and y=1.\\n        // So we have to use operation iii or iv first otherwise\\n        // either x or y will become zero.\\n        // Applying third operation n times and fourth operation \\n        // m times gives us =>\\n        // (1,1)===>(2^n,2^m)\\n        // GCD of them will be min(2^n,2^m) i.e. a power of 2.\\n        // That means if we perform only operation iii and iv then\\n        // gcd(targetX,targetY) should be a power of 2.\\n        \\n        // But what about operation i and ii?\\n        // Our newX=2^n and newY=2^m.\\n        // We know gcd(newX,newY-newX)=gcd(newX,newY)===>A power of two\\n        //                            &\\n        //         gcd(newX-newY,newY)=gcd(newX,newY)===>A power of two\\n        // That means whatever we do with operation i and ii our \\n        // condition doesn\\'t change that is we only need to check\\n        // if gcd(targetX,targetY) is a power of 2.\\n\\n        int gcd=__gcd(targetX,targetY);\\n        if((gcd&(gcd-1))==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool isReachable(int targetX,int targetY){\\n        if(targetX==1 && targetY==1) return true;\\n\\n        // Now targetX>1 && targetY>1 and x=1 and y=1.\\n        // So we have to use operation iii or iv first otherwise\\n        // either x or y will become zero.\\n        // Applying third operation n times and fourth operation \\n        // m times gives us =>\\n        // (1,1)===>(2^n,2^m)\\n        // GCD of them will be min(2^n,2^m) i.e. a power of 2.\\n        // That means if we perform only operation iii and iv then\\n        // gcd(targetX,targetY) should be a power of 2.\\n        \\n        // But what about operation i and ii?\\n        // Our newX=2^n and newY=2^m.\\n        // We know gcd(newX,newY-newX)=gcd(newX,newY)===>A power of two\\n        //                            &\\n        //         gcd(newX-newY,newY)=gcd(newX,newY)===>A power of two\\n        // That means whatever we do with operation i and ii our \\n        // condition doesn\\'t change that is we only need to check\\n        // if gcd(targetX,targetY) is a power of 2.\\n\\n        int gcd=__gcd(targetX,targetY);\\n        if((gcd&(gcd-1))==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117088,
                "title": "greedy-reverse-all-operations-no-gcd",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX == 1 && targetY == 1) {\\n            return true;\\n        }\\n        if (targetX % 2 == 0) {\\n            return isReachable(targetX / 2, targetY);\\n        }\\n        if (targetY % 2 == 0) {\\n            return isReachable(targetX, targetY / 2);\\n        }\\n\\n        // (x-y, y) => (x, y)\\n        if (targetX > targetY) {\\n            return isReachable(targetX + targetY, targetY);\\n        }\\n\\n        // (x, y-x) => (x, y)\\n        if (targetX < targetY) {\\n            return isReachable(targetX, targetX + targetY);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX == 1 && targetY == 1) {\\n            return true;\\n        }\\n        if (targetX % 2 == 0) {\\n            return isReachable(targetX / 2, targetY);\\n        }\\n        if (targetY % 2 == 0) {\\n            return isReachable(targetX, targetY / 2);\\n        }\\n\\n        // (x-y, y) => (x, y)\\n        if (targetX > targetY) {\\n            return isReachable(targetX + targetY, targetY);\\n        }\\n\\n        // (x, y-x) => (x, y)\\n        if (targetX < targetY) {\\n            return isReachable(targetX, targetX + targetY);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109881,
                "title": "golang-simple-math-gcd",
                "content": "# Code\\n```\\nfunc gcd(a, b int) int {\\n    if a % b == 0 {\\n        return b\\n    }\\n    return gcd(b, a % b)\\n}\\n\\nfunc isReachable(targetX int, targetY int) bool {\\n    for targetX % 2 == 0 {targetX /= 2}\\n    for targetY % 2 == 0 {targetY /= 2}\\n    return gcd(targetX, targetY) == 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc gcd(a, b int) int {\\n    if a % b == 0 {\\n        return b\\n    }\\n    return gcd(b, a % b)\\n}\\n\\nfunc isReachable(targetX int, targetY int) bool {\\n    for targetX % 2 == 0 {targetX /= 2}\\n    for targetY % 2 == 0 {targetY /= 2}\\n    return gcd(targetX, targetY) == 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109819,
                "title": "c-simple-math-gcd-explaination-in-comments",
                "content": "# Code\\n```\\nclass Solution {\\n    int gcd(int a, int b) {\\n        if(a % b == 0) return b;\\n        return gcd(b, a % b);\\n    }\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0) targetX /= 2;\\n        while(targetY % 2 == 0) targetY /= 2;\\n        return gcd(targetX, targetY) == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int gcd(int a, int b) {\\n        if(a % b == 0) return b;\\n        return gcd(b, a % b);\\n    }\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0) targetX /= 2;\\n        while(targetY % 2 == 0) targetY /= 2;\\n        return gcd(targetX, targetY) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109410,
                "title": "python-bfs-with-reversed-condition-and-make-it-converge-to-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        limit = 10 ** 9\\n        queue = collections.deque([[targetX, targetY]])\\n        visited = {(targetX, targetY)}\\n        while queue:\\n            x, y = queue.popleft()\\n            if x == 1 or y == 1:\\n                return True\\n\\n            if x % 2 == 0:\\n                key = (x//2, y)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n                \\n            elif y % 2 == 0:\\n                key = (x, y//2)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n\\n            elif x < y:\\n                key = (x, (x+y)/2)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n\\n            else:\\n                key = ((x+y)/2, y)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n\\n        \\n        return False\\n            \\n            \\n\\n# (x, y - x)\\n# (x - y, y)\\n# (2 * x, y)\\n# (x, 2 * y)\\n\\n\\n\"\"\"\\nwhat if reverse\\n\\nx, y+x\\nx+y, y\\nx, y/2\\nx/2, y\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        limit = 10 ** 9\\n        queue = collections.deque([[targetX, targetY]])\\n        visited = {(targetX, targetY)}\\n        while queue:\\n            x, y = queue.popleft()\\n            if x == 1 or y == 1:\\n                return True\\n\\n            if x % 2 == 0:\\n                key = (x//2, y)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n                \\n            elif y % 2 == 0:\\n                key = (x, y//2)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n\\n            elif x < y:\\n                key = (x, (x+y)/2)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n\\n            else:\\n                key = ((x+y)/2, y)\\n                if key not in visited:\\n                    queue.append(key)\\n                    visited.add(key)\\n\\n        \\n        return False\\n            \\n            \\n\\n# (x, y - x)\\n# (x - y, y)\\n# (2 * x, y)\\n# (x, 2 * y)\\n\\n\\n\"\"\"\\nwhat if reverse\\n\\nx, y+x\\nx+y, y\\nx, y/2\\nx/2, y\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105812,
                "title": "c-gcd-o-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculate gcd of both the target co-ordinate.\\nIf gcd is power of 2, then it is feasible or else not.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        else\\n            return gcd(b,a%b);\\n    }\\n\\n    bool isReachable(int targetX, int targetY) {\\n        int n = gcd(targetX, targetY);\\n        int res = n&(n-1);\\n        if(res==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        else\\n            return gcd(b,a%b);\\n    }\\n\\n    bool isReachable(int targetX, int targetY) {\\n        int n = gcd(targetX, targetY);\\n        int res = n&(n-1);\\n        if(res==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105679,
                "title": "c-easy-intuitive-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) { \\n        \\n        while(x>=1 and y>=1){\\n            if(x==1 and y==1)\\n                return true;\\n            if(x%2==0)\\n                x=x/2;\\n            else if(y%2==0)\\n                y=y/2;\\n            else if((y+x)/2<y)\\n                y+=x;\\n            else if((x+y)/2<x) \\n                x+=y;\\n            else\\n                return false;\\n             \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) { \\n        \\n        while(x>=1 and y>=1){\\n            if(x==1 and y==1)\\n                return true;\\n            if(x%2==0)\\n                x=x/2;\\n            else if(y%2==0)\\n                y=y/2;\\n            else if((y+x)/2<y)\\n                y+=x;\\n            else if((x+y)/2<x) \\n                x+=y;\\n            else\\n                return false;\\n             \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105537,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from lee215\\nclass Solution {\\npublic:\\n      bool isReachable(int x, int y) {\\n        int v = gcd(x, y);\\n        while (v % 2 == 0)\\n            v /= 2;\\n        return v == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from lee215\\nclass Solution {\\npublic:\\n      bool isReachable(int x, int y) {\\n        int v = gcd(x, y);\\n        while (v % 2 == 0)\\n            v /= 2;\\n        return v == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101725,
                "title": "c-greedy-intuitive-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int powerOf2(int x) {\\n        return x && !(x & (x - 1));\\n    }\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX <= 0 || targetY <= 0) \\n            return false;\\n        if (powerOf2(targetX) || powerOf2(targetY) || \\n                powerOf2(abs(targetX - targetY))) {\\n            return true;\\n        }\\n        while (targetX % 2 == 0) {\\n            targetX >>= 1;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY >>= 1;\\n        }\\n        return isReachable(targetX - targetY, targetY) || \\n                isReachable(targetX, targetY - targetX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int powerOf2(int x) {\\n        return x && !(x & (x - 1));\\n    }\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX <= 0 || targetY <= 0) \\n            return false;\\n        if (powerOf2(targetX) || powerOf2(targetY) || \\n                powerOf2(abs(targetX - targetY))) {\\n            return true;\\n        }\\n        while (targetX % 2 == 0) {\\n            targetX >>= 1;\\n        }\\n        while (targetY % 2 == 0) {\\n            targetY >>= 1;\\n        }\\n        return isReachable(targetX - targetY, targetY) || \\n                isReachable(targetX, targetY - targetX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101220,
                "title": "c-greedy-reverse-tracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will start from the destination and try to reach the point (1,1)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncommon question is why do we still decrese x and y while going back instead of increasing ( x+y,y or x,y+x), whereas we are reducing x/2 and y/2 .\\n\\nbecause we were always meant to use these operations while going from a larger  point to 1,1 .\\neg -> destination is 3,1\\nwe will go as such : 1,1 ->  2,1 -> 4,1 -> 3,1\\n\\nhere we are using reduce operation when going from a larger point to a smaller point. 4,1 -> 3,1\\n\\nwhich is what we are doing while trying to do ,going from our destination to the point (1,1).\\n\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        if(x==1 && y==1)\\n        return true;\\n       \\n       if(x%2==0)\\n       return isReachable(x/2,y);\\n\\n       if(y%2==0)\\n       return isReachable(x,y/2);\\n\\n        if(x>y)\\n        return isReachable(x-y,y);\\n\\n        if(y>x)\\n        return isReachable(x,y-x);\\n\\n        else\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        if(x==1 && y==1)\\n        return true;\\n       \\n       if(x%2==0)\\n       return isReachable(x/2,y);\\n\\n       if(y%2==0)\\n       return isReachable(x,y/2);\\n\\n        if(x>y)\\n        return isReachable(x-y,y);\\n\\n        if(y>x)\\n        return isReachable(x,y-x);\\n\\n        else\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095806,
                "title": "java-straightforward-to-do-it-reverse-order",
                "content": "# Intuition\\nJust do it backward\\n\\n# Approach\\nTo see if it can back to (1, 1)\\n\\n# Complexity\\n- Time complexity:\\nO(log(m) + log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        do {\\n            while(targetX % 2 == 0) {\\n                targetX /= 2;\\n            }\\n        \\n            while(targetY % 2 == 0) {\\n                targetY /= 2;\\n            }\\n            \\n            if(targetY > targetX) {\\n                targetY = (targetY + targetX) / 2;\\n            }else targetX = (targetX + targetY) / 2;\\n        }while(targetY != targetX);\\n        \\n        return targetY == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        do {\\n            while(targetX % 2 == 0) {\\n                targetX /= 2;\\n            }\\n        \\n            while(targetY % 2 == 0) {\\n                targetY /= 2;\\n            }\\n            \\n            if(targetY > targetX) {\\n                targetY = (targetY + targetX) / 2;\\n            }else targetX = (targetX + targetY) / 2;\\n        }while(targetY != targetX);\\n        \\n        return targetY == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094568,
                "title": "c-from-target",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        do {\\n            while ((x & 1) == 0)\\n                x >>= 1;\\n            while ((y & 1) == 0)\\n                y >>= 1;\\n            if (x < y)\\n                y += x;\\n            else if (x > y)\\n                x += y;\\n        } while (x != y);\\n        return x == 1 && y == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        do {\\n            while ((x & 1) == 0)\\n                x >>= 1;\\n            while ((y & 1) == 0)\\n                y >>= 1;\\n            if (x < y)\\n                y += x;\\n            else if (x > y)\\n                x += y;\\n        } while (x != y);\\n        return x == 1 && y == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093912,
                "title": "100-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have only 2 opeartions:\\n   <li>divide 2;\\n   <li>add other;<p></li>\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will use first operation\\nsecond we will find GCD(Greatest common divisor). \\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        targetX = divideTwo(targetX);\\n        targetY = divideTwo(targetY);\\n        int gcd = gcd(Math.max(targetX, targetY), Math.min(targetX, targetY));\\n        return targetX == 1 || targetY == 1 || gcd == 1;\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return a % b == 0 ? b : gcd(b, a % b);\\n    }\\n\\n    public int divideTwo(int num) {\\n        return num % 2 == 0 ? divideTwo(num / 2) : num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        targetX = divideTwo(targetX);\\n        targetY = divideTwo(targetY);\\n        int gcd = gcd(Math.max(targetX, targetY), Math.min(targetX, targetY));\\n        return targetX == 1 || targetY == 1 || gcd == 1;\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return a % b == 0 ? b : gcd(b, a % b);\\n    }\\n\\n    public int divideTwo(int num) {\\n        return num % 2 == 0 ? divideTwo(num / 2) : num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093513,
                "title": "rust-gcd-solution",
                "content": "The condition is that GCD of the target coordinates should be the power of 2.\\n\\n```rust\\nfn gcd(x: i32, y: i32) -> i32 {\\n\\tlet (mut x, mut y) = (x, y);\\n\\twhile y != 0 { let t = x % y; x = y; y = t; }\\n\\tx\\n}\\n\\nimpl Solution {\\n\\tpub fn is_reachable(target_x: i32, target_y: i32) -> bool {\\n\\t\\tlet mut x = gcd(target_x, target_y);\\n\\t\\twhile x % 2 == 0 { x /= 2; }\\n\\t\\tx == 1\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```rust\\nfn gcd(x: i32, y: i32) -> i32 {\\n\\tlet (mut x, mut y) = (x, y);\\n\\twhile y != 0 { let t = x % y; x = y; y = t; }\\n\\tx\\n}\\n\\nimpl Solution {\\n\\tpub fn is_reachable(target_x: i32, target_y: i32) -> bool {\\n\\t\\tlet mut x = gcd(target_x, target_y);\\n\\t\\twhile x % 2 == 0 { x /= 2; }\\n\\t\\tx == 1\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089868,
                "title": "java-2-solutions",
                "content": "# 3.recursion\\n```\\n    //3.recursion\\n    //Runtime: 0ms 100%; Memory: 41MB 50%\\n    public boolean isReachable(int targetX, int targetY) {\\n        if (targetX == 0 || targetY == 0) return false;\\n\\n        while ((targetX & 1) == 0) targetX >>= 1;\\n        if (targetX == 1) return true;\\n\\n        while ((targetY & 1) == 0) targetY >>= 1;\\n        if (targetY == 1) return true;\\n\\n        int min = Math.min(targetX, targetY);\\n        int max = Math.max(targetX, targetY);\\n        return isReachable(min, max - min);\\n    }\\n```\\n# 2.iteration\\n```\\n    //2.iteration\\n    //Runtime: 0ms 100%; Memory: 38.9MB 100%\\n    public boolean isReachable_2(int targetX, int targetY) {\\n        if (targetX == 0 || targetY == 0) return false;\\n\\n        while ((targetX & 1) == 0) targetX >>= 1;\\n        if (targetX == 1) return true;\\n\\n        while ((targetY & 1) == 0) targetY >>= 1;\\n        if (targetY == 1) return true;\\n\\n        int min = Math.min(targetX, targetY);\\n        int max = Math.max(targetX, targetY);\\n\\n        while (true) {\\n            if (min == 0) return false;\\n            if (min == 1) return true;\\n            int tmp = max - min;\\n            while (tmp != 0 && (tmp & 1) == 0) tmp >>= 1;\\n            max = Math.max(min, tmp);\\n            min = Math.min(min, tmp);\\n        }\\n    }\\n```\\n\\n# 1.PriorityQueue\\n```\\n    //1.PriorityQueue\\n    //TLE\\n    public boolean isReachable_1(int targetX, int targetY) {\\n        if (targetX == 0 || targetY == 0) return false;\\n        PriorityQueue<Pair<Integer, Integer>> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o.getKey()));\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>();\\n\\n        while (targetX != 0 && (targetX & 1) == 0) targetX >>= 1;\\n        if (targetX == 1) return true;\\n\\n        while (targetY != 0 && (targetY & 1) == 0) targetY >>= 1;\\n        if (targetY == 1) return true;\\n\\n        Pair<Integer, Integer> target = new Pair<>(Math.min(targetX, targetY), Math.max(targetX, targetY));\\n        queue.add(target);\\n        seen.add(target);\\n\\n        while (!queue.isEmpty()) {\\n            Pair<Integer, Integer> val = queue.poll();\\n            int sum = val.getKey() + val.getValue();\\n            while ((sum & 1) == 0) sum >>= 1;\\n            if (sum == 1) return true;\\n\\n            if (sum < val.getValue()) {\\n                Pair<Integer, Integer> tmp1 = new Pair<>(Math.min(val.getKey(), sum), Math.max(val.getKey(), sum));\\n                if (seen.add(tmp1)) queue.add(tmp1);\\n                Pair<Integer, Integer> tmp2 = new Pair<>(Math.min(val.getValue(), sum), Math.max(val.getValue(), sum));\\n                if (seen.add(tmp2)) queue.add(tmp2);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //3.recursion\\n    //Runtime: 0ms 100%; Memory: 41MB 50%\\n    public boolean isReachable(int targetX, int targetY) {\\n        if (targetX == 0 || targetY == 0) return false;\\n\\n        while ((targetX & 1) == 0) targetX >>= 1;\\n        if (targetX == 1) return true;\\n\\n        while ((targetY & 1) == 0) targetY >>= 1;\\n        if (targetY == 1) return true;\\n\\n        int min = Math.min(targetX, targetY);\\n        int max = Math.max(targetX, targetY);\\n        return isReachable(min, max - min);\\n    }\\n```\n```\\n    //2.iteration\\n    //Runtime: 0ms 100%; Memory: 38.9MB 100%\\n    public boolean isReachable_2(int targetX, int targetY) {\\n        if (targetX == 0 || targetY == 0) return false;\\n\\n        while ((targetX & 1) == 0) targetX >>= 1;\\n        if (targetX == 1) return true;\\n\\n        while ((targetY & 1) == 0) targetY >>= 1;\\n        if (targetY == 1) return true;\\n\\n        int min = Math.min(targetX, targetY);\\n        int max = Math.max(targetX, targetY);\\n\\n        while (true) {\\n            if (min == 0) return false;\\n            if (min == 1) return true;\\n            int tmp = max - min;\\n            while (tmp != 0 && (tmp & 1) == 0) tmp >>= 1;\\n            max = Math.max(min, tmp);\\n            min = Math.min(min, tmp);\\n        }\\n    }\\n```\n```\\n    //1.PriorityQueue\\n    //TLE\\n    public boolean isReachable_1(int targetX, int targetY) {\\n        if (targetX == 0 || targetY == 0) return false;\\n        PriorityQueue<Pair<Integer, Integer>> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o.getKey()));\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>();\\n\\n        while (targetX != 0 && (targetX & 1) == 0) targetX >>= 1;\\n        if (targetX == 1) return true;\\n\\n        while (targetY != 0 && (targetY & 1) == 0) targetY >>= 1;\\n        if (targetY == 1) return true;\\n\\n        Pair<Integer, Integer> target = new Pair<>(Math.min(targetX, targetY), Math.max(targetX, targetY));\\n        queue.add(target);\\n        seen.add(target);\\n\\n        while (!queue.isEmpty()) {\\n            Pair<Integer, Integer> val = queue.poll();\\n            int sum = val.getKey() + val.getValue();\\n            while ((sum & 1) == 0) sum >>= 1;\\n            if (sum == 1) return true;\\n\\n            if (sum < val.getValue()) {\\n                Pair<Integer, Integer> tmp1 = new Pair<>(Math.min(val.getKey(), sum), Math.max(val.getKey(), sum));\\n                if (seen.add(tmp1)) queue.add(tmp1);\\n                Pair<Integer, Integer> tmp2 = new Pair<>(Math.min(val.getValue(), sum), Math.max(val.getValue(), sum));\\n                if (seen.add(tmp2)) queue.add(tmp2);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089730,
                "title": "swift-solution-using-extension-gcd",
                "content": "# Approach\\n1. We have two numbers, x and y.\\n2. We want to know if the greatest common divisor of x and y is 1.\\n3. We start off with a variable v that stores the greatest common divisor of x and y.\\n4. We repeatedly divide v by 2 until it is odd.\\n5. If v is 1, then the greatest common divisor of x and y is 1. If v is not 1, then the greatest common divisor of x and y is not 1\\n\\n# Complexity\\n- Time complexity: O(log(max(x, y)))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func isReachable(_ x: Int, _ y: Int) -> Bool {\\n        var v = x.gcd(y)\\n        while v % 2 == 0 {\\n            v /= 2\\n        }\\n        return v == 1\\n    }\\n}\\n\\nextension Int {\\n    func gcd(_ other: Int) -> Int {\\n        var a = self\\n        var b = other\\n        while b != 0 {\\n            let t = b\\n            b = a % b\\n            a = t\\n        }\\n        return a\\n    }\\n}\\n```\\n# Please UpVote if you like it...",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isReachable(_ x: Int, _ y: Int) -> Bool {\\n        var v = x.gcd(y)\\n        while v % 2 == 0 {\\n            v /= 2\\n        }\\n        return v == 1\\n    }\\n}\\n\\nextension Int {\\n    func gcd(_ other: Int) -> Int {\\n        var a = self\\n        var b = other\\n        while b != 0 {\\n            let t = b\\n            b = a % b\\n            a = t\\n        }\\n        return a\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088567,
                "title": "easy-to-understand-c-solution-using-gcd-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are only two operations allowed, so we can check both.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can either increase the value by 2 or can increase the value up to its lcm or in other way we can decrease the target upto its gcd.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(log x)\\nwhere x is the max of targetX and targetY\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log x)\\nwhere x is the max of targetX and targetY\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int x){\\n        return (x&(x-1))==0;\\n    }\\n\\n    bool isReachable(int targetX, int targetY) {\\n        int gcd=__gcd(targetX, targetY);\\n        return isPowerOfTwo(gcd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int x){\\n        return (x&(x-1))==0;\\n    }\\n\\n    bool isReachable(int targetX, int targetY) {\\n        int gcd=__gcd(targetX, targetY);\\n        return isPowerOfTwo(gcd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087926,
                "title": "python-check-gcd",
                "content": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        GCD = math.gcd(targetX, targetY)\\n        \\n        if GCD == 1:\\n            return True\\n        \\n        if (GCD-1)&GCD == 0:   # the power of 2\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        GCD = math.gcd(targetX, targetY)\\n        \\n        if GCD == 1:\\n            return True\\n        \\n        if (GCD-1)&GCD == 0:   # the power of 2\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087282,
                "title": "c-easy-to-understand-without-gcd",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$ \\n\\n- Space complexity: $$0(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n     // in reverse direction \\n     //from (x,y) we have to reach (1,1)\\n     /* Possible moves are (x, y + x)\\n                           (x + y, y)\\n                           (x / 2, y) if x % 2 == 0\\n                           (x, y / 2) if y % 2 == 0 */\\n\\n    /* If x is even, we can go (x / 2, y)\\n       If y is even, we can go (x, y / 2)\\n       If both odd and x < y, we can go (x, (x+y)/2)\\n       If both odd and x > y, we can go ((x+y)/2, y)\\n       In each step either x or y  becomes smaller,\\n       until x == y */\\n\\n     do{\\n           while(x % 2 == 0) x /= 2;\\n           while(y % 2 == 0) y /= 2;\\n           if(x < y) swap(x,y);   \\n           x = (x + y) / 2;\\n     }\\n     while(x != y);\\n    // used do while insted of while to \\n    //eleminate edgecase x == y == 2^k     \\n    return x == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n     // in reverse direction \\n     //from (x,y) we have to reach (1,1)\\n     /* Possible moves are (x, y + x)\\n                           (x + y, y)\\n                           (x / 2, y) if x % 2 == 0\\n                           (x, y / 2) if y % 2 == 0 */\\n\\n    /* If x is even, we can go (x / 2, y)\\n       If y is even, we can go (x, y / 2)\\n       If both odd and x < y, we can go (x, (x+y)/2)\\n       If both odd and x > y, we can go ((x+y)/2, y)\\n       In each step either x or y  becomes smaller,\\n       until x == y */\\n\\n     do{\\n           while(x % 2 == 0) x /= 2;\\n           while(y % 2 == 0) y /= 2;\\n           if(x < y) swap(x,y);   \\n           x = (x + y) / 2;\\n     }\\n     while(x != y);\\n    // used do while insted of while to \\n    //eleminate edgecase x == y == 2^k     \\n    return x == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087038,
                "title": "greatest-common-divisor-gcd-use-euclidian-algorithm-to-get-gcd-check-if-gcd-is-power-of-2",
                "content": "# Intuition\\nFrom (x,y), we can go to (x,y-x), (x-y,y), (2*x,y), (x,2*y).\\n\\nThus, in order to tell if we can reach (tX,tY), we need to figure out if we can reach (tX, tX+tY), (tX+tY, tY), (tX/2, tY), or (tX, tY/2).\\n\\nWe need to make sure the GCD of tX and tY is power of 2. Otherwise, no matter if you try to keep dividing tX, tY or the sum of their multiples by 2, you will also be left with a non-two prime number which will block you to start from (1,1).\\n\\nWe can use Euclidian Algo to get GCD and then use LeetCode 231 to check if it is power of 2.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        // use Euclidian Algorithm to get the gcd between targetX and targetY\\n        int temp = targetX % targetY;\\n        \\n        while(temp != 0) {\\n            targetX = targetY;\\n            targetY = temp;\\n            temp = targetX % targetY;\\n        }\\n        \\n        return (targetY & (targetY - 1)) == 0; // LeetCode 231 to check if the gcd equals to 2^k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        // use Euclidian Algorithm to get the gcd between targetX and targetY\\n        int temp = targetX % targetY;\\n        \\n        while(temp != 0) {\\n            targetX = targetY;\\n            targetY = temp;\\n            temp = targetX % targetY;\\n        }\\n        \\n        return (targetY & (targetY - 1)) == 0; // LeetCode 231 to check if the gcd equals to 2^k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086491,
                "title": "fastest-java-solution-easy-clean-explained",
                "content": "# Intuition\\nThe greatest common divisor of pair (1, 1) is 1. \\nThis means, that it must stay the same for the input values aswell.\\n\\n# Approach\\n1. Find GCD of the input values.\\n2. Check if it\\'s a power of two. \\n3. Return the answer.\\n\\nP.S. Step 2 is the same like you would divide your input values by 2 until it\\'s possible.\\n\\n# Complexity\\n- Time Complexity of Euclidean Algorithm: $$O(log(min(x, y))$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n##### P.S. Don\\'t forget to upvote, if you liked the solution. Thank you!\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int x, int y) {\\n        return isPowerOfTwo(gcd(x,y));\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public boolean isPowerOfTwo(int x) {\\n        int i = 0;\\n        while(Math.pow(2, i) < x) {\\n            i++;\\n        }\\n        return (int) Math.pow(2, i) == x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isReachable(int x, int y) {\\n        return isPowerOfTwo(gcd(x,y));\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public boolean isPowerOfTwo(int x) {\\n        int i = 0;\\n        while(Math.pow(2, i) < x) {\\n            i++;\\n        }\\n        return (int) Math.pow(2, i) == x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086416,
                "title": "c-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int tx, int ty) {\\n        return canReach(tx,ty);\\n    }\\n    private:\\n    bool canReach(int targetX, int targetY) {\\n        while(targetX%2 == 0)\\n        {\\n            targetX/= 2;\\n        }\\n        while(targetY%2 == 0)\\n        {\\n            targetY/= 2;\\n        }\\n        if (targetX < 1 || targetY < 1) return false;\\n        return __gcd(targetX, targetY) == 1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int tx, int ty) {\\n        return canReach(tx,ty);\\n    }\\n    private:\\n    bool canReach(int targetX, int targetY) {\\n        while(targetX%2 == 0)\\n        {\\n            targetX/= 2;\\n        }\\n        while(targetY%2 == 0)\\n        {\\n            targetY/= 2;\\n        }\\n        if (targetX < 1 || targetY < 1) return false;\\n        return __gcd(targetX, targetY) == 1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086210,
                "title": "easy-to-understand-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think of the problem in reverse, going from (targetX, targetY) to (1,1).\\n\\nso the operations we have become:\\n(targetX/2, targetY)\\n(targetX, targetY/2)\\n(targetX + targetY, targetY)\\n(targetX, targetY + targetX)\\n\\nAs we have targetX, targetY >= 1 so the goal becomes to minimize targetX and targetY till we reach (or not) (1,1)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart by dividing both targetX and targetY by 2 until you no longer can, at this point if targetX or targetY equals 1, we have a solution ! (since at this point we can increment the other value by 1 till it becomes a power of 2 and then divide it by 2 all the way down to 1) \\n\\nOtherwise if targetX = targetY != 1 at this point then we don\\'t have a solution, as no matter what we do with the given operations we cannot minimize further\\n\\nif targetX and targetY are different (they are odd numbers at this point cause we already divided by 2 as much as we can) in that case we work on minimizing the bottleneck, which is the largest number between the 2, we do so by adding the smaller number to it (knowing that it will become even and be divided by 2 in the next iteration)\\n\\nkeep applying the above till either you reach 1 on any of targetX or targetY, or till they\\'re equal\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        do\\n        {\\n           while(targetX%2 == 0)\\n           {\\n              targetX /=2;\\n           }\\n           while(targetY%2 == 0)\\n           {\\n              targetY /=2;\\n           }   \\n           if(targetX == 1|| targetY == 1)\\n              return true;\\n           if(targetX == targetY)\\n               return false;\\n           if(targetY < targetX)\\n               targetX += targetY;\\n           else\\n               targetY += targetX;\\n        }        \\n        while (targetX != targetY);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        do\\n        {\\n           while(targetX%2 == 0)\\n           {\\n              targetX /=2;\\n           }\\n           while(targetY%2 == 0)\\n           {\\n              targetY /=2;\\n           }   \\n           if(targetX == 1|| targetY == 1)\\n              return true;\\n           if(targetX == targetY)\\n               return false;\\n           if(targetY < targetX)\\n               targetX += targetY;\\n           else\\n               targetY += targetX;\\n        }        \\n        while (targetX != targetY);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085563,
                "title": "python-simple-solution",
                "content": "# Code\\n```\\nfrom math import gcd\\nclass Solution:\\n    def isReachable(self, a: int, b: int) -> bool:\\n        while not a%2:\\n            a //= 2\\n        while not b%2:\\n            b //= 2\\n        return gcd(a, b) == 1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def isReachable(self, a: int, b: int) -> bool:\\n        while not a%2:\\n            a //= 2\\n        while not b%2:\\n            b //= 2\\n        return gcd(a, b) == 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084573,
                "title": "easy-short-efficient-clean-code",
                "content": "- Given 2 nos. (x,y)\\n- gcd(x,y)==g\\n- op1: x+=y\\n- op2: y+=x\\n- Either there exists a path from (1,1) to (x,y) as well as vice versa, or none of them.\\n- Thus, existence of a path from (x,y) to (1,1) gurantees existence of a path from (1,1) to (x,y)\\n# Math\\n## Rule 1\\nAfter any finite-sized sequence of ops 1 & 2, gcd stays the same.\\n## Rule 2\\nAfter some finite-sized sequence of ops 1 & 2, x and y acquire the form g^a and g^b resp.\\n- If g==2, x and y can be reduced to 1 => gcd(x,y) must be in the form 2^p.\\n```c++\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        return __builtin_popcount(__gcd(x, y))<2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        return __builtin_popcount(__gcd(x, y))<2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084417,
                "title": "cpp-solution-gcd",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX / 2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY / 2;\\n        }\\n        return (gcd(targetX,targetY) == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX / 2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY / 2;\\n        }\\n        return (gcd(targetX,targetY) == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083474,
                "title": "c-solution-beats-100-runtime-tc-o-log-min-x-y-sc-o-gcd-x-y",
                "content": "# Intuition \\nYou can see [Lee\\'s Reference](https://leetcode.com/problems/check-if-point-is-reachable/solutions/3082073/java-c-python-1-line-gcd-solution/) for intution.\\n# Complexity\\n- Time complexity: O(log(min(X,Y)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(gcd(X,Y))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int X, int Y) {\\n        int gg = __gcd(X,Y);\\n        return !(gg & (gg-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int X, int Y) {\\n        int gg = __gcd(X,Y);\\n        return !(gg & (gg-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083308,
                "title": "python-greedy-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe go from the target $$(x,y)$$ to $$(1,1)$$. \\n\\nAt each step we can divide either the coordinates by $$2$$ if it is even, or replace one of the coordinates by the average of two coordinates if both are odd. \\n\\nNote that if $$x\\\\ne y$$ then $$x+y$$ always decreases, since we can replace the larger coordinate by the average. On the other hand, if $$x=y$$ and they are odd, then there is no way to further decrease $$x+y$$ by our operations.\\n\\nThus we can simulate this process until $$x=y$$ and both are odd. Then return `True` if $$x=y=1$$ and `False` otherwise.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        while 1:\\n            if not x%2: x //= 2\\n            if not y%2: y //= 2\\n            if x%2 and y%2:\\n                if x == y: return True if x == 1 else False\\n                elif x < y: y = (x+y)//2\\n                else: x = (x+y)//2\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, x: int, y: int) -> bool:\\n        while 1:\\n            if not x%2: x //= 2\\n            if not y%2: y //= 2\\n            if x%2 and y%2:\\n                if x == y: return True if x == 1 else False\\n                elif x < y: y = (x+y)//2\\n                else: x = (x+y)//2\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083273,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX == targetY)\\n            return (targetX & (targetX - 1)) == 0;\\n        int q = __gcd(targetX, targetY);\\n        if( (q & (q - 1)) == 0)\\n            return 1;\\n        return  q == 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        if (targetX == targetY)\\n            return (targetX & (targetX - 1)) == 0;\\n        int q = __gcd(targetX, targetY);\\n        if( (q & (q - 1)) == 0)\\n            return 1;\\n        return  q == 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083212,
                "title": "simple-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry go from (x, y) to (1,1)\\n\\ng = gcd(x, y)\\nx = g * a (a >= 1)\\ny = g * b (b >= 1) \\nand gcd(a, b) = 1;\\n\\nyou can always reach (g, g) with all 4 rule:\\n(x, y + x)\\n(x + y, y)\\n(x / 2, y) if x % 2 == 0\\n(x, y / 2) if y % 2 == 0\\n\\nthen apply \\noperation of\\n(x / 2, y) if x % 2 == 0\\n(x, y / 2) if y % 2 == 0\\n\\nso the condition is gcd(x, y) is pow of 2.\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    bool powof2(int a) {\\n        if ((a & (a - 1)) == 0) return true;\\n        return false;\\n    }\\n    bool isReachable(int x, int y) {\\n        int g = gcd(x, y);\\n        // cout << g << endl;\\n        return powof2(g);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    bool powof2(int a) {\\n        if ((a & (a - 1)) == 0) return true;\\n        return false;\\n    }\\n    bool isReachable(int x, int y) {\\n        int g = gcd(x, y);\\n        // cout << g << endl;\\n        return powof2(g);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3083013,
                "title": "python-easy-o-log-n",
                "content": "We go reverse from destination(targetX,targetY) to source(1,1). Following the inverse rules.\\n\\nIn the reverse path:\\n\\n   1.  If both targetX and targetY were odd then addition path must have been taken because multiplying with 2 would have given an even number. So subtract smaller target from bigger target\\n\\n   2. If one of them is even then we reduce its value to half because it is cheaper way to source, subtracting will cost O(n) which will exceed the time limit. \\n   3. Since we are following only the rules so we must reach to source from destination.\\n   4. following above if both targetX and targetY becomes equal to 1 then return T\\n   5. rue. If even one of them is less than 1 then return False\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Since we are dividing by 2 for even and after every odd comes even so complexity is O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->Stack size of recursion will be the space complexity O(log n)\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        \\n        def reachable(X,Y):\\n            if X<=0 or Y<=0:\\n                return False\\n            if X==1 or Y==1:\\n                return True\\n            \\n            if X%2 == 1 and Y%2==1:\\n                if X>Y:\\n                    return reachable(X-Y,Y)\\n                else:\\n                    return reachable(X,Y-X)\\n            if X%2 == 0 :\\n                return reachable(X//2, Y)\\n            if Y%2 ==0:\\n                return reachable(X,Y//2)\\n            \\n        \\n        return reachable(targetX, targetY)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        \\n        def reachable(X,Y):\\n            if X<=0 or Y<=0:\\n                return False\\n            if X==1 or Y==1:\\n                return True\\n            \\n            if X%2 == 1 and Y%2==1:\\n                if X>Y:\\n                    return reachable(X-Y,Y)\\n                else:\\n                    return reachable(X,Y-X)\\n            if X%2 == 0 :\\n                return reachable(X//2, Y)\\n            if Y%2 ==0:\\n                return reachable(X,Y//2)\\n            \\n        \\n        return reachable(targetX, targetY)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082842,
                "title": "2-line-code-bit-manipulation",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int z) {\\n        int y = __gcd(x,z);\\n        return !(y&(y-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int z) {\\n        int y = __gcd(x,z);\\n        return !(y&(y-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082696,
                "title": "swift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func isReachable(_ targetX: Int, _ targetY: Int) -> Bool {\\n        var x = targetX, y = targetY\\n        while(x>=1&&y>=1) {\\n            if x == 1 && y == 1 {\\n                return true\\n            }\\n            var t = false\\n            if x % 2 == 0 {\\n                t = true\\n                x = x / 2\\n            } else if (x+y) % 2 == 0 {\\n                t = true\\n                x = x+y\\n            }\\n            if y % 2 == 0 {\\n                t = true\\n                y = y / 2\\n            } else if (x+y) % 2 == 0 {\\n                t = true\\n                y = x+y\\n            }\\n            if !t || x == y && x != 1 && x % 2 == 1 {\\n                return false\\n            }\\n           \\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isReachable(_ targetX: Int, _ targetY: Int) -> Bool {\\n        var x = targetX, y = targetY\\n        while(x>=1&&y>=1) {\\n            if x == 1 && y == 1 {\\n                return true\\n            }\\n            var t = false\\n            if x % 2 == 0 {\\n                t = true\\n                x = x / 2\\n            } else if (x+y) % 2 == 0 {\\n                t = true\\n                x = x+y\\n            }\\n            if y % 2 == 0 {\\n                t = true\\n                y = y / 2\\n            } else if (x+y) % 2 == 0 {\\n                t = true\\n                y = x+y\\n            }\\n            if !t || x == y && x != 1 && x % 2 == 1 {\\n                return false\\n            }\\n           \\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082441,
                "title": "6-line-code-gcd-explained-c-short-code",
                "content": "# Intuition\\nInstead of making (1,1) to target numbers we can make target numbers to (1,1) by reversing the actions.\\n\\n# Approach\\nAfter reversing the actions we can do 1 of these things\\n- divide either tx or ty by 2, \\n- add tx to ty or ty to tx.\\n\\nWe have to realize that if either tx or ty becomes pow of 2. then we can divide it by 2 continuously to get 1 and then add 1 continuously to the other till we get a power of 2 number and then divide that by 2 till we get 1.\\nex- (4,7)->(2,7)->(1,7),(1,8)->(1,4)->(1,2)->(1,1)\\n\\nNow how to make one of them a power of 2. \\nFor that we have to realize that for making a number power of 2 , it should only have 2 as its factor.\\n\\nAny two numbers having gcd other than power of 2 will always have their gcd as a factor after summing them any number of times.\\n\\nex- (5,15) no matter how many ways we try to add them the result will alway have 5 as its factor because their GCD is 5.\\n\\nConclusion-\\nThe GCD of tx and ty should be a power of 2, if it is then our answer is true else false.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int a, int b) {\\n        \\n        int g=gcd(a,b);\\n        \\n        while(g%2==0){\\n            g/=2;\\n        }\\n        if(g==1)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int a, int b) {\\n        \\n        int g=gcd(a,b);\\n        \\n        while(g%2==0){\\n            g/=2;\\n        }\\n        if(g==1)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082401,
                "title": "kotlin-two-lines-gcd-check-power-of-2-trick",
                "content": "# Code\\n```\\nclass Solution {\\n    fun isReachable(targetX: Int, targetY: Int): Boolean {\\n        tailrec fun gcd(x: Int, y: Int): Int = if (x == 0 || y == 0) x + y else gcd(y % x, x)\\n        return gcd(targetX, targetY).let { it and it - 1 } == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isReachable(targetX: Int, targetY: Int): Boolean {\\n        tailrec fun gcd(x: Int, y: Int): Int = if (x == 0 || y == 0) x + y else gcd(y % x, x)\\n        return gcd(targetX, targetY).let { it and it - 1 } == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082356,
                "title": "easy-c-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        long long  x= __gcd(targetX,targetY);\\n        if((x&(x-1))==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        long long  x= __gcd(targetX,targetY);\\n        if((x&(x-1))==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082337,
                "title": "c-3liner",
                "content": "We can only get rid common factors that are powers of 2...\\n```\\nbool isReachable(int x, int y) {\\n    while (x%2==0) x/=2;\\n    while (y%2==0) y/=2;\\n    return __gcd(x,y)==1;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isReachable(int x, int y) {\\n    while (x%2==0) x/=2;\\n    while (y%2==0) y/=2;\\n    return __gcd(x,y)==1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082275,
                "title": "check-if-point-is-reachable-big-o",
                "content": "## Please, upvote this post\\n# Approach\\nGreatest Common Divisor\\n\\n# Complexity\\n- Time complexity: O(log(max(targetX, targetY)))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nvar isReachable = function(targetX, targetY) {\\n    const gcd = (a, b) => b ? gcd(b, a % b) : a\\n    while (targetX % 2 === 0) targetX /= 2\\n    while (targetY % 2 === 0) targetY /= 2\\n    return gcd(targetX, targetY) === 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} targetX\\n * @param {number} targetY\\n * @return {boolean}\\n */\\nvar isReachable = function(targetX, targetY) {\\n    const gcd = (a, b) => b ? gcd(b, a % b) : a\\n    while (targetX % 2 === 0) targetX /= 2\\n    while (targetY % 2 === 0) targetY /= 2\\n    return gcd(targetX, targetY) === 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082262,
                "title": "c-solution-o-logn",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isReachable(int tx, int ty) {\\n        ll u = __gcd(tx,ty);\\n        while(u>1){\\n            if(u%2) return false;\\n            u/=2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isReachable(int tx, int ty) {\\n        ll u = __gcd(tx,ty);\\n        while(u>1){\\n            if(u%2) return false;\\n            u/=2;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082261,
                "title": "c-easy-solution-without-gcd",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while (targetX >0 && targetY >0) {\\n            if(targetX%2==0)\\n                targetX/=2;\\n            else if(targetY%2==0)\\n                targetY/=2;\\n            else if(targetX>targetY){\\n                targetX-=targetY;\\n            }\\n            else {\\n                targetY-=targetX;\\n            }\\n           // cout<<targetX<< \" \"<<targetY<<endl;\\n        }\\n       // cout<<targetX<< \" \"<<targetY<<endl<<endl;\\n        return (targetX==0||targetX==1)&&(targetY==0||targetY==1);\\n   \\n   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int targetX, int targetY) {\\n        while (targetX >0 && targetY >0) {\\n            if(targetX%2==0)\\n                targetX/=2;\\n            else if(targetY%2==0)\\n                targetY/=2;\\n            else if(targetX>targetY){\\n                targetX-=targetY;\\n            }\\n            else {\\n                targetY-=targetX;\\n            }\\n           // cout<<targetX<< \" \"<<targetY<<endl;\\n        }\\n       // cout<<targetX<< \" \"<<targetY<<endl<<endl;\\n        return (targetX==0||targetX==1)&&(targetY==0||targetY==1);\\n   \\n   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3082259,
                "title": "c-easy-solution-logic-for-gcd",
                "content": "## Please Upvote if you like it and feel free to ask any query\\n\\n```\\nclass Solution {\\npublic:\\n\\n    bool recurse(int x,int y){\\n\\t\\t// if either of them is 1 then we can follow follow (x-y,y) or (x,y-x) to back track to (1,1) \\n\\t\\t// Lets consider x is 1 and y is y so after y backtrack step using (x,y-x) step we can reach to 1,1\\n        if(x==1 || y==1){\\n            return 1;\\n        }\\n\\t\\t// If( x is even so we can go back to (x/2,y) because It is possible that we came to (x,y) from (x/2,y) by taking (2*x,y) step . Similar Logic if y is even \\n        else if(x%2==0){\\n            return isReachable(x/2,y);\\n        }\\n        else if(y%2 ==0){\\n            return isReachable(x,y/2);\\n        }\\n\\t\\t// If y-x is positive and (y-2) is even so we can go back to (x,(y-x)/2)\\n\\t\\t\\n\\t\\t// We are not considering y==x because Both x and y are odd so we can come to x,y only from (x+y,y) or (x,y+x) which cannot be ever reduced to (1,1). Think about it once here x==y so It came from (2*x,x) or (x,2*x) \\n\\t\\t// which can be again reduced to (x,x).\\n        else if(y>x && ((y-x)%2)==0){\\n            return isReachable(x,(y-x)/2);\\n        }\\n        // else Not possible \\n        return 0;\\n        \\n    }\\n    bool isReachable(int targetX, int targetY) {\\n        if(targetY<targetX){\\n            return recurse(targetY,targetX);\\n        }\\n        return recurse(targetX,targetY);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool recurse(int x,int y){\\n\\t\\t// if either of them is 1 then we can follow follow (x-y,y) or (x,y-x) to back track to (1,1) \\n\\t\\t// Lets consider x is 1 and y is y so after y backtrack step using (x,y-x) step we can reach to 1,1\\n        if(x==1 || y==1){\\n            return 1;\\n        }\\n\\t\\t// If( x is even so we can go back to (x/2,y) because It is possible that we came to (x,y) from (x/2,y) by taking (2*x,y) step . Similar Logic if y is even \\n        else if(x%2==0){\\n            return isReachable(x/2,y);\\n        }\\n        else if(y%2 ==0){\\n            return isReachable(x,y/2);\\n        }\\n\\t\\t// If y-x is positive and (y-2) is even so we can go back to (x,(y-x)/2)\\n\\t\\t\\n\\t\\t// We are not considering y==x because Both x and y are odd so we can come to x,y only from (x+y,y) or (x,y+x) which cannot be ever reduced to (1,1). Think about it once here x==y so It came from (2*x,x) or (x,2*x) \\n\\t\\t// which can be again reduced to (x,x).\\n        else if(y>x && ((y-x)%2)==0){\\n            return isReachable(x,(y-x)/2);\\n        }\\n        // else Not possible \\n        return 0;\\n        \\n    }\\n    bool isReachable(int targetX, int targetY) {\\n        if(targetY<targetX){\\n            return recurse(targetY,targetX);\\n        }\\n        return recurse(targetX,targetY);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082231,
                "title": "c-easy-have-a-look",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isReachable(int a, int b) {\\n       if(a==b && a==1)\\n       {\\n           return true;\\n       }\\n       while(a%2==0 && a!=1)\\n       {\\n           a=a/2;\\n       }\\n        while(b%2==0 && b!=1)\\n       {\\n           b=b/2;\\n       }\\n        \\n        if(a==1 || b==1)\\n        {\\n            return true;\\n        }\\n        while(1)\\n        {\\n            if(a==b && a!=1)\\n            {\\n                return false;\\n            }\\n            if((a==1 ||b==1))\\n            {\\n                return true;\\n            }\\n            if(a>b)\\n            {\\n                a=a-b;\\n                \\n            }\\n            else\\n            {\\n             b=b-a;   \\n            }\\n             while(a%2==0 && a!=1)\\n       {\\n           a=a/2;\\n       }\\n        while(b%2==0 && b!=1)\\n       {\\n           b=b/2;\\n       }\\n            \\n        }\\n        return true;\\n            \\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int a, int b) {\\n       if(a==b && a==1)\\n       {\\n           return true;\\n       }\\n       while(a%2==0 && a!=1)\\n       {\\n           a=a/2;\\n       }\\n        while(b%2==0 && b!=1)\\n       {\\n           b=b/2;\\n       }\\n        \\n        if(a==1 || b==1)\\n        {\\n            return true;\\n        }\\n        while(1)\\n        {\\n            if(a==b && a!=1)\\n            {\\n                return false;\\n            }\\n            if((a==1 ||b==1))\\n            {\\n                return true;\\n            }\\n            if(a>b)\\n            {\\n                a=a-b;\\n                \\n            }\\n            else\\n            {\\n             b=b-a;   \\n            }\\n             while(a%2==0 && a!=1)\\n       {\\n           a=a/2;\\n       }\\n        while(b%2==0 && b!=1)\\n       {\\n           b=b/2;\\n       }\\n            \\n        }\\n        return true;\\n            \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082221,
                "title": "c-basic-euclidean-algorithm-gcd",
                "content": "Calculate the gcd of target numbers if its a power of two than return true.\\n```   \\nbool isReachable(int targetX, int targetY) {\\n        int x=__gcd(targetX,targetY);\\n        return !(x&(x-1));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```   \\nbool isReachable(int targetX, int targetY) {\\n        int x=__gcd(targetX,targetY);\\n        return !(x&(x-1));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082213,
                "title": "python3-explanation-with-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given movements in the problem, shows that we can move in the multiple of 2 in both directions or linearly y times in x direction and x times in y direction. Which takes us to the equation:\\n$$ m*targetX + n*targetY = 2^p$$\\ni.e. the targetX, targetY is reachable if and only if any linear combination of targetX and targetY must be power of 2.\\nThus $$gcd(targetX, targetY)=2^p$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply get the gcd of targetX and targetY and check the whether it is power of 2 or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity is $$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity is $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        \\n        hcf = math.gcd(targetX, targetY)\\n        while hcf%2==0 and hcf != 0:\\n            hcf //= 2\\n\\n        if hcf == 1 or hcf == 0:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        \\n        hcf = math.gcd(targetX, targetY)\\n        while hcf%2==0 and hcf != 0:\\n            hcf //= 2\\n\\n        if hcf == 1 or hcf == 0:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1768070,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768107,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1898496,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768171,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1951472,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1773807,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1772816,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1769616,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768524,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768319,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768070,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768107,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1898496,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768171,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1951472,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1773807,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1772816,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1769616,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768524,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            },
            {
                "id": 1768319,
                "content": [
                    {
                        "username": "hxu10",
                        "content": "Personally I think this type of question is not suitable for interview.\\nIf you think of greatest common divisor, this problem is quite easy. If you are not aware of it, you are finished. \\n\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I agree this problem is very difficult and probably not suited for an interview at all, unless you only care about seeing how the interviewee approaches problems they are unable to solve. However You don\\'t need to think about GCD to solve this question. I solved the question just by working in reverse without figuring out the relationship with GCD. \\n\\nHint: Apply the steps in reverse, \\ni.e. (a,b) -> (a+b, b)\\n(a,b) -> (a/2, b) if a is even, etc. \\n\\nAlways apply the steps to minimize a and b. so if you can do division then do it. otherwise when doing addition, do it to the larger one. \\n\\nThen you just have to figure out what are the possible options for this process. \\n\\nThis is not a better solution than using GCD by the way. Its more than fast enough, still 0 ms on java, and still O(log n) but it does show atleast that this problem is solvable without figuring out that the GCD is important. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "After reading your comment I just returned gcd of both nums  == 1 and that alone passed 50 TC, LOL"
                    },
                    {
                        "username": "SunnyvaleCA",
                        "content": "If the purpose of the interview question is to find a solution, then I agree with you.  However, it could start a good discussion of BFS/DP and why the approach won\\'t work... for example: if answer is False, how do you know when to stop?"
                    },
                    {
                        "username": "mchim",
                        "content": "How to learn to solve these type of questions?"
                    },
                    {
                        "username": "jacklongthree",
                        "content": "[@hxu10](/hxu10) I never try this, Thank you."
                    },
                    {
                        "username": "mchim",
                        "content": "[@RealFan](/RealFan) Thanks for the useful tip!"
                    },
                    {
                        "username": "RealFan",
                        "content": "Talent."
                    },
                    {
                        "username": "hxu10",
                        "content": "You can brute force (like using BFSp) to generate the points within (100,100) and see what formula it followed"
                    },
                    {
                        "username": "czjnbb",
                        "content": "You can reach (targetX, targetY) if and only if gcd(targetX, targetY) is the power of 2, i.e., 1,2,4,8,16..."
                    },
                    {
                        "username": "user0578i",
                        "content": "Can anyone explain the logic behind the solutions? If we try moving from target to (1, 1) won\\'t both operations be reversed. I see people reversing the first operation, but still using the gcd for the subtraction part."
                    },
                    {
                        "username": "quorarowdy",
                        "content": "gcd gives the final result that you would get after successive subtraction."
                    },
                    {
                        "username": "karanjashveersingh88",
                        "content": "Using GCD \\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    if(a == 0){\\n        return b;\\n    }\\n    return gcd(b%a, a);\\n}\\n    bool isReachable(int targetX, int targetY) {\\n        while(targetX % 2 == 0){\\n            targetX = targetX/2;\\n        }\\n        while(targetY % 2 == 0){\\n            targetY = targetY/2;\\n        }\\n        return (gcd(targetX, targetY) == 1);\\n    }\\n};"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There is one more `gcd` problem to practice\\nhttps://leetcode.com/problems/rotate-array/"
                    },
                    {
                        "username": "nigamadi2209",
                        "content": "Can we do this question with recursion?"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "[@swo0sh](/swo0sh) then what about dp? tabulated dp?"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Yup, the the constraints are big. So, TLE."
                    },
                    {
                        "username": "puspendra_09",
                        "content": "Can anyone tell me some similar standard questions related to this for then problem 4 - check if point is reachable?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "By considering what was possible with 1 and x, 2 and x, 3 and x, 4 and x, 5 and x, I guessed at the solution.   My guess turned out to be correct, but a guess is not a mathematical proof, so this is more of a question for a mathematician than a programmer."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually sir it is pretty simple when we think about it though. We just have to observe that the gcd of the pair remains unchanged when we apply the first two operations, and we have done it!!"
                    },
                    {
                        "username": "yashnarkhedkar",
                        "content": "I applied BFS to solve question can anyone tell me what is error?\n``` \nclass Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        unordered_set<pair<int, int>> visited;\n        visited.insert({1, 1});\n        queue<pair<int, int>> q;\n        q.push({1, 1});\n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first, y = p.second;\n            if (x == targetX && y == targetY) {\n                return true;\n            }\n            int newX, newY;\n            newX = x;\n            newY = y - x;\n            if (newY > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x - y;\n            newY = y;\n            if (newX > 0 && visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = 2 * x;\n            newY = y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n            newX = x;\n            newY = 2 * y;\n            if (visited.count({newX, newY}) == 0) {\n                visited.insert({newX, newY});\n                q.push({newX, newY});\n            }\n        }\n        return false;\n    }\n};\n```"
                    },
                    {
                        "username": "user_s1996",
                        "content": "These types of problem can\\'t be solved using BFS , we need to think one step beyond "
                    },
                    {
                        "username": "anuron_das",
                        "content": "Sir, it is an infinite grid!! You cannot apply BFS and expect the program to terminate in finite time when the answer to the given test case is false!!"
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "For Data Structures having hashing like unordered_set, we can't initiate it with Non Primitive Data type(for eg, pair<int, int>) directly. It hides the default constructor of the class unordered_set. To use this, we have pass our custom hash function with it. \n\nFor more info, you can learn from this https://stackoverflow.com/questions/62869571/call-to-implicitly-deleted-default-constructor-of-unordered-set-vectorint \n\nHope it will help you! :)"
                    },
                    {
                        "username": "praveenkumarnew2019",
                        "content": "you cannot apply bfs since value can be 1e9 which will give tle \\n"
                    }
                ]
            }
        ]
    }
]