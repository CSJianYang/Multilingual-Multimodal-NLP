[
    {
        "title": "Minimum Number of K Consecutive Bit Flips",
        "question_content": "You are given a binary array nums and an integer k.\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [0,1,0], k = 1\nOutput: 2\nExplanation: Flip nums[0], then flip nums[2].\n\nExample 2:\n\nInput: nums = [1,1,0], k = 2\nOutput: -1\nExplanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\n\nExample 3:\n\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\nOutput: 3\nExplanation: \nFlip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= k <= nums.length",
        "solutions": [
            {
                "id": 238609,
                "title": "java-c-python-one-pass-and-o-1-space",
                "content": "## **Intuition**:\\nThere is only one way to filp `A[0]`,\\nand `A[0]` will tell us if we need to filp the range `A[0] ~ A[K -1]`.\\nSo we start from the leftmost one by one using a greedy idea to solve this problem.\\n\\n<br>\\n\\n## Solution 1\\n\\n**Explanation**\\nCreate a new array `isFlipped[n]`.\\n`isFlipped[i] = 1` iff we flip `K` consecutive bits starting at `A[i]`.\\n\\nWe maintain a variable `flipped` and `flipped = 1` iff the current bit is flipped.\\n\\nIf `flipped = 0` and `A[i] = 0`, we need to flip at `A[i]`.\\nIf `flipped = 1` and `A[i] = 1`, we need to flip at `A[i]`.\\n\\n**Complexity**\\n`O(N)` time for one pass\\n`O(N)` extra space for `isFlipped[n]`.\\n\\n\\n**Java**\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length, flipped = 0, res = 0;\\n        int[] isFlipped = new int[n];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (i >= K)\\n                flipped ^= isFlipped[i - K];\\n            if (flipped == A[i]) {\\n                if (i + K > A.length)\\n                    return -1;\\n                isFlipped[i] = 1;\\n                flipped ^= 1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n<br>\\n\\n## Solution 2\\n\\n**Explanation**\\nInstead an array `isFlipped` of size `n`,\\nuse a deque to maintain the state of a sliding window of size `k`.\\n\\n**Complexity**\\n`O(N)` time for one pass\\n`O(K)` extra space for `isFlipped[n]`.\\n\\n\\n<br>\\n\\n## Solution 3\\n\\n**Explanation**:\\nOne pass.\\n`cur` means the number of flips in the current sliding window of size `K`.\\nIf `cur` is even and A[i] is `0`, we need to flip.\\nIf `cur` is odd and A[i] is `1`, we need to flip.\\n\\nIf we want to flip `A[i]`, we add `2` to it.\\nThe flipped 0 is 2 and flipped 1 is 3 now.\\nWhen they go out of the window, we will change them back.\\nSo no worries if we change the input.\\n\\n**Complexity**:\\n`O(N)` time for one pass\\n`O(1)` extra space.\\n\\n**Java:**\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int cur = 0, res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def minKBitFlips(self, A, K):\\n        cur, res, n = 0, 0, len(A)\\n        for i in xrange(len(A)):\\n            if i >= K and A[i - K] > 1:\\n                A[i - K] -= 2\\n                cur -= 1\\n            if cur & 1 ^ A[i] == 0:\\n                if i + K > len(A):\\n                    return -1\\n                A[i] += 2\\n                cur += 1\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length, flipped = 0, res = 0;\\n        int[] isFlipped = new int[n];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (i >= K)\\n                flipped ^= isFlipped[i - K];\\n            if (flipped == A[i]) {\\n                if (i + K > A.length)\\n                    return -1;\\n                isFlipped[i] = 1;\\n                flipped ^= 1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int cur = 0, res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def minKBitFlips(self, A, K):\\n        cur, res, n = 0, 0, len(A)\\n        for i in xrange(len(A)):\\n            if i >= K and A[i - K] > 1:\\n                A[i - K] -= 2\\n                cur -= 1\\n            if cur & 1 ^ A[i] == 0:\\n                if i + K > len(A):\\n                    return -1\\n                A[i] += 2\\n                cur += 1\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 239284,
                "title": "c-greedy-stack-and-o-1-memory",
                "content": "This is a cool problem that sounds very hard by becomes easy with two intuition sparks (and a little twinkle).\\n<!--\\n# Description\\nIn an array ```A``` containing only 0s and 1s, a *```K```-bit flip* consists of choosing a (contiguous) subarray of length ```K``` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\\n\\nReturn the minimum number of ```K```-bit flips required so that there is no 0 in the array.  If it is not possible, return ```-1```.\\n## Example\\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\n```\\n![image](https://assets.leetcode.com/users/votrubac/image_1550551964.png)\\n# Coding Practice\\nTry solving this problem before moving on to the solutions. It is available on LeetCode Online Judge: [Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/). Also, as you read through a solution, try implementing it yourself.\\n\\nLeetCode is my favorite destinations for algorithmic problems. It has 987 problems and counting, with test cases to validate the correctness, as well as computational and memory complexity. There is also a large community discussing different approaches, tips and tricks. \\n-->\\n# Intuition 1\\nJust want to share my thought process; I am sure that there is a formal proof somewhere.\\n1. Since K is fixed, it does not make sense to do the flip for any given index more than once. It\\'s a XOR operation, even flips will be equal to zero flips, odd flips will be equal to one flip. So, there could be up to ```n - K``` flips.\\n2. Since it\\'s a XOR operation, we can do flips in any order.\\n3. Say we start do flips left to right. That means that, when we encounter zero, we have no choice but flip.\\n\\nAt this point, this intuition is sound enough to try a greedy approach.\\n## Na\\xEFve Greedy Solution\\nGo through the array and flip K elements when encounter zero. Return ```-1``` if you cannot do K flips.\\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != 1) {\\n      if (i + K - 1 >= A.size()) return -1;\\n      for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n      ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n * K)*, where *n* is the length of ```A```. This solution is not accepted by the online judge.\\n\\n**Update:** this solution is accepted by OJ with the ~5,000 ms runtime (vs. < 100 ms for the solutions below). So, I could have gotten lucky during the contest!\\n# Intuition 2\\nSince we are doing XOR operation, even flips will be equal to zero flips, odd flips will be equal to one flip. So, instead of modifying K bits every time we encounter zero, we can just track the current number of flips.\\n## Linear Solution\\nHere, we are using a queue to track flips. When we \\'flip\\', we put the end index of our flip (```i + K - 1```) into our queue. The size of the queue will indicate number of flips; we also remove past \\'flips\\' from our queue.\\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  queue<int> flips;\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != (flips.size() % 2 ? 0 : 1)) {\\n      ++res;\\n      flips.push(i + K - 1);\\n    }\\n    if (!flips.empty() && flips.front() <= i) flips.pop();\\n  }\\n  return flips.empty() ? res : -1;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n)*, and the memory complexity is *O(K)*.\\n## Constant Memory Solution\\nInstead of using the queue, we can track the total number of flips, and use the source array to mark flips with negative values.\\n\\nNote that we restore original values after the processing, so the source array is not changed.\\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0, int flips = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] == flips % 2) {\\n      if (i > A.size() - K) return -1;\\n      ++res, ++flips, A[i] -= 2;\\n    }\\n    if (i >= K - 1 && A[i - K + 1] < 0) --flips, A[i - K + 1] += 2;\\n  }\\n  return res;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n)*, and the memory complexity is *O(1)*.",
                "solutionTags": [],
                "code": "```A```\n```K```\n```K```\n```K```\n```-1```\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\n```\n```n - K```\n```-1```\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != 1) {\\n      if (i + K - 1 >= A.size()) return -1;\\n      for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n      ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\n```A```\n```i + K - 1```\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  queue<int> flips;\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != (flips.size() % 2 ? 0 : 1)) {\\n      ++res;\\n      flips.push(i + K - 1);\\n    }\\n    if (!flips.empty() && flips.front() <= i) flips.pop();\\n  }\\n  return flips.empty() ? res : -1;\\n}\\n```\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0, int flips = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] == flips % 2) {\\n      if (i > A.size() - K) return -1;\\n      ++res, ++flips, A[i] -= 2;\\n    }\\n    if (i >= K - 1 && A[i - K + 1] < 0) --flips, A[i - K + 1] += 2;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240086,
                "title": "share-my-o-n-c-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nIn an array ```A``` containing only 0s and 1s, a *```K```*-bit flip consists of choosing a (contiguous) subarray of length ```K``` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\\n\\nReturn the minimum number of ```K```-bit flips required so that there is no 0 in the array.  If it is not possible, return ```-1```.\\n\\n**Example 1:**\\n```\\nInput: A = [0,1,0], K = 1\\nOutput: 2\\nExplanation: Flip A[0], then flip A[2].\\n```\\n\\n**Example 2:**\\n```\\nInput: A = [1,1,0], K = 2\\nOutput: -1\\nExplanation: No matter how we flip subarrays of size 2, we can\\'t make the array become [1,1,1].\\n```\\n\\n**Example 3:**\\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\nExplanation:\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\n**Note:**\\n* 1 <= A.length <= 30000\\n* 1 <= K <= A.length\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\n\\nThe problem is complicated at first glance.\\nAs a ```K```-bit flip is applied on a length-K contiguous subarray of A, if the size of array A is **N**, and the **subarray starts at index i (0 \\u2264 i \\u2264 N- K)**, **i** can be used for specifying such a flip.\\n\\nIn this way, \\n>#### **A flip sequence can be defined by an index sequence**.\\n\\nIn **Example 3**, \\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\nthe sequence of index is **{0, 4, 5}**.\\n\\n---\\n#### 2.2 Order invariance\\n\\n---\\nIn **Example 3**, if the sequence of index is changed to **{4, 0, 5}**, what will happen?\\n```\\nFlip A[4],A[5],A[6]: A becomes [0,0,0,1,1,0,0,0]\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\nThe final result is as same as the one with sequence **{0, 4, 5}**!\\n\\n---\\n**Property A:**\\n>#### **The result is independent of the order of the flip sequence.**\\n\\n\\n**Proof:**\\n\\nIf the flip sequence is **{a0, a1, a2, ... , ap}**, and the original array A is changed to A\\',\\n\\nFor **any A[i] (0 \\u2264 i \\u2264 N - K)** in A, if the **total count of flip on A[i] is c[i]**, when the order of flip sequence changes, **c[i] won\\'t change**.\\n\\nThat is to say\\n\\n>#### The corresponding A\\'[i] and the array A\\' will not change. Proved!\\n\\n---\\n#### 2.3 Parity invariance\\n\\n---\\nIn **Example 3**, if the sequence of index is changed to **{0, 1, 1, 4, 4, 4, 5}**, what will happen?\\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,0,0,0,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\nThe final result is as same as the one with sequence **{0, 4, 5}**!\\n\\n---\\n**Property B:**\\n>#### In the flip sequence, the result is **ONLY** related to the **parity of count of index\\'s appearance**.\\n\\n**Proof:**\\nIf an **index p (0 \\u2264 i \\u2264 N - K) appears in the flip sequence q times**, and the **total count of flip on A[i] is c[i]**, \\n**q will be added to the total count of flip c[i] (p \\u2264 i < p + K).**\\n\\nIn a single flip,\\n>#### If A[i] = 0, it will be flipped to 1.\\n>#### If A[i] = 1, it will be flipped to 0.\\n\\nSo, after **q flips on index p**,\\n>#### If q is even , A[i] will keep its value.\\n>#### If q is odd , A[i] will be flipped.\\n\\n---\\n#### 2.4 Minimization\\n\\n---\\nThe problem is to find the minimum size of the flip sequence that removes all zeros in A.\\n\\nIf such a flip sequence exists, \\n\\nby applying **Property A in Section 2.2**,\\n>#### The sequence can be **sorted by index in ascending order**.\\n\\nAfter sorting, in order to **minimize the sequence\\'s size**, by applying **Property B in Section 2.3**,\\n\\n>#### There are only 2 choices on each index - **appear ONLY once or don\\'t appear**.\\n\\nNow, every index in the sequence is **unique**.\\n\\n---\\n#### 2.5 Generate the sequence\\n\\n---\\nAs mentioned in Section 2.4, every index sequence **S** can be simplified to a new sequence **S\\'**.\\n\\n>#### All indexes in S\\' are **in ascending order and unique**.\\n\\nAs indexes are in ascending order, \\n> #### **The later flip with larger index can\\'t change the value at current index.**\\n\\nwhich means,\\n\\nIf **A[0] = 0**, and **0 is NOT in the sequence**, **A[0] MUST equals to 0 in the final result**.\\n\\nIf **A[0] = 1**, and **0 is in the sequence**, **A[0] MUST equals to 0 in the final result**.\\n\\n---\\nSince **the result MUST contains no 0**, when **processing index 0**\\n\\n* **If A[0] = 0**, **0 MUST be in the sequence**, **A[0], A[1], ..., A[K - 1]** is **flipped**.\\n* **If A[0] = 1**, **0 MUST NOT be in the sequence**, **A[0], A[1], ..., A[K - 1]** is **NOT flipped**.\\n\\n**After index 0 is processed, index 1 should be processed similarly**.\\n\\n---\\n## 3. Algorithm\\n\\n---\\n#### 3.1 Trivial solution\\n\\n---\\nAs discussed in Section 2.5, the algorithm is a dual-cycle.\\n\\n**Initially, the total flip count c equals to 0.**\\n- **Outer Loop:** iterate **index i** from **0 to N - K**.\\n   - If **A[i] = 0**, \\n       - **Inner Loop:** **flip A[i], A[i + 1], ..., A[i + K - 1]**. \\n       - **Set c = c + 1**.\\n   - Else, ignore.\\n- **After processing**, check the **remain elements in A**,\\n  - If **all elements are 1**, **return c**.\\n  - **Else**, **return -1**.\\n\\nFor example,\\n```\\nInput: A = [0,1,0,0,0,0,0,0], K = 3\\ni = 0, A[i] = 0, flip, A = [1,0,1,0,0,0,0,0].\\ni = 1, A[i] = 0, flip, A = [1,1,0,1,0,0,0,0].\\ni = 2, A[i] = 0, flip, A = [1,1,1,0,1,0,0,0].\\ni = 3, A[i] = 0, flip, A = [1,1,1,1,0,1,0,0].\\ni = 4, A[i] = 0, flip, A = [1,1,1,1,1,0,1,0].\\ni = 5, A[i] = 0, flip, A = [1,1,1,1,1,1,0,1].\\noutput: -1\\n```\\nAs shown above, the time complexity is O(NK) in the worst case.\\n\\n---\\n3.2 Optimized solution\\n\\n---\\n\\nIn Section 3.1, there are too many flip operations in the trivial solution.\\n\\nAs proved in Section 2.3, since the indexes are processed in ascending order, \\n\\n>#### **the final value of A[i]** is **ONLY determined by the parity of flip count on A[i]**.\\n\\nTo optimize the solution, \\na queue is used to save the biggest index of the flipped contiguous subarray.\\n\\nThe queue\\'s size is the flip count of A[i].\\n\\n---\\n\\nThe algorithm is optimized to a one-pass solution.\\n**Initially, the total flip count c equals to 0. The queue Q is empty.**\\n- **Loop:** iterate index i from **0 to N - 1**.\\n   - If **Q\\'s size** is **even**, **change A[i] (0 to 1, 1 to 0)**.\\n   - Else, **DON\\'T change A[i]**.\\n   - If **A[i] = 0, put i + K - 1 to Q**. **Set c = c + 1**.\\n   - Else, ignore.\\n   - If **Q is NOT empty and A[i] = the front element in Q**, **pop from Q**.\\n- **After processing**,\\n  - **If Q is empty, return c**.\\n  - **Else, return -1**.\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\n\\nAs shown in Section 3.2, the number of iteration is **N**.\\n\\n>#### The time complexity is **O(N)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\nA queue is used to save the indexes, \\n\\n>#### The space complexity is **O(N)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int ans = 0;\\n        int size = A.size();\\n        queue<int> record;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int pivot = record.size() % 2 == 0 ? A[i] : 1 - A[i];\\n            if(pivot == 0)\\n            {\\n                ans++;\\n                record.push(i + K - 1);\\n            }\\n            if(!record.empty() && i == record.front()) record.pop();\\n        }\\n        return record.empty() ? ans : -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```A```\n```K```\n```K```\n```K```\n```-1```\n```\\nInput: A = [0,1,0], K = 1\\nOutput: 2\\nExplanation: Flip A[0], then flip A[2].\\n```\n```\\nInput: A = [1,1,0], K = 2\\nOutput: -1\\nExplanation: No matter how we flip subarrays of size 2, we can\\'t make the array become [1,1,1].\\n```\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\nExplanation:\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```K```\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```\\nFlip A[4],A[5],A[6]: A becomes [0,0,0,1,1,0,0,0]\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,0,0,0,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```\\nInput: A = [0,1,0,0,0,0,0,0], K = 3\\ni = 0, A[i] = 0, flip, A = [1,0,1,0,0,0,0,0].\\ni = 1, A[i] = 0, flip, A = [1,1,0,1,0,0,0,0].\\ni = 2, A[i] = 0, flip, A = [1,1,1,0,1,0,0,0].\\ni = 3, A[i] = 0, flip, A = [1,1,1,1,0,1,0,0].\\ni = 4, A[i] = 0, flip, A = [1,1,1,1,1,0,1,0].\\ni = 5, A[i] = 0, flip, A = [1,1,1,1,1,1,0,1].\\noutput: -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238538,
                "title": "python-o-n-using-queue-and-how-to-get-rid-of-the-queue",
                "content": "The idea is, as we move through the array, everytime I see a 0, I need to do a k-flip. \\nAs a result of a single k-flip, the k-1 elements to the right are also affected.\\nI use a queue, to keep track of how many valid flips have been executed for the current index.\\nBy maintaining the last index for which a flip is valid, I can easily pop it off, when I pass that index.\\nEssentially this makes, the current size of queue equal to the number of flips the current index has undergone and can determine if its 0 or 1, based on that.\\nSo, if the number of flips is even, and my a[i] == 0, then I need to do one more flip. I add that flip\\'s last index to the queue\\nIn a similar way, if the number of flips is odd, and mu a[i] == 1, then i need to do one more flip.\\n\\nWhen to return -1 ?\\nIf at any point, we see that a necessary k-flip extends beyond the length of the array, we know that this flip cant happen. Hence we can return -1 at that instant.\\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        q = deque()\\n        res = 0\\n        for i in range(len(a)):\\n            if len(q) % 2 != 0:\\n                if a[i] == 1:\\n                    res += 1\\n                    q.append(i+k-1)\\n            else:\\n                if a[i] == 0:\\n                    res += 1\\n                    q.append(i+k-1)\\n            if q and q[0] == i: q.popleft()\\n            if q and q[-1] >= len(a): return -1\\n        return res\\n```\\n\\n<b>O(1) space: </b>\\nNow that we have the solution using queue, how do we get rid of the queue, and use only O(1) space.\\nThe logic is exactly the same.\\nBut instead of the queue storing the indexes which are endpoints to a k-flip, we use the array itself and use some addon value > 1, that we add to the value at the indexes which were earlier stored in the queue. \\nBecause we dont have the queue, we need an explicit variable flips (this is equivalent to the length of the queue in the previous version).\\nNow, whenever we encounter an a[i] that is >1 , we know that this is an endpoint to a k-flip and reduce the number of flips accordingly.\\n\\nHere is the code, which resemblems the previous version as close as possible, but replaces the portion using the queue with flips and addon\\n\\n[I didnot implement this O(1) version in the contest, but based on other\\'s posted solutions, realized, we can easily get rid of the queue in my original version]\\n\\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if flips % 2 != 0:\\n                if (a[i] - addon) % 2 == 1:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            else:\\n                if (a[i] - addon) % 2 == 0:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon #Restore the array value back\\n        return res\\n```\\n\\nThe same solution, with combining if conditions:\\n\\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if (flips % 2 != 0 and (a[i] - addon) % 2 == 1) or (flips % 2 == 0 and (a[i] - addon) % 2 == 0):\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        q = deque()\\n        res = 0\\n        for i in range(len(a)):\\n            if len(q) % 2 != 0:\\n                if a[i] == 1:\\n                    res += 1\\n                    q.append(i+k-1)\\n            else:\\n                if a[i] == 0:\\n                    res += 1\\n                    q.append(i+k-1)\\n            if q and q[0] == i: q.popleft()\\n            if q and q[-1] >= len(a): return -1\\n        return res\\n```\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if flips % 2 != 0:\\n                if (a[i] - addon) % 2 == 1:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            else:\\n                if (a[i] - addon) % 2 == 0:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon #Restore the array value back\\n        return res\\n```\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if (flips % 2 != 0 and (a[i] - addon) % 2 == 1) or (flips % 2 == 0 and (a[i] - addon) % 2 == 0):\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1052752,
                "title": "java-o-n-solution-step-by-step-explanation",
                "content": "## Idea behind the solution\\nWe approach the solution in a Greedy way, **that is as soon as we see a 0 we will flip it to 1 and we will skip if we encounter a 1**.\\n\\nLet\\'s say we flip `A[i]=0` to 1, this means the next K-1 elements `A[i+1], A[i+2]....A[i+k-1]` will be flipped as well. \\nNow lets say after the flip, `A[i+4]=0  (K>4)`. It would mean it was initially 1 and now it needs to be flipped again.  So, as we make the second flip at `A[i+4]` \\xA0the elements`A[i+4+1], A[i+4+2]....A[i+4+k-1]` will be flipped. \\nAs we observe, elements  `A[i+4]` to `A[i+k-1]` will undergo two flips. \\n\\nAnd if an element that was initially 0 undergoes two flips it will need to be flipped again to make it 1. If an element that was initially 1 undergoes one flip it will need to be flipped once more to make it 1. So extending this further,\\n\\n**if number of flips for 0 is even, we require a flip \\n& if number of flips for 1 is odd, we require a flip**\\n\\n*Next, we need to know the number of flips for a given index*. To do this we maintain a queue and we keep adding the index where the last element is to be flipped. As we reach that index, we remove the index from the queue. \\n\\nLets say for `k=6`, and at `i=3` we are doing a flip, queue will contain `[8]`\\nNext at `i=6` we are doing a flip the queue becomes `[8, 11]`\\n8 will be popped from the queue when the iteration counter reaches at index 8 and likewise for 12, this means for `i=6` to `i=8` there will be two flips one which was started at `i=3` and another at `i=6`.\\n**This indicates, the length of queue will hold the number of flips for any index.**\\n\\n## Algorithm:\\n1. We declare a queue which is the flip queue\\n2. The `res` variable will hold the number of total flips done at any point\\n3. We iterate from 0 till the length of the Array, and do the following\\n\\t3.1 If we encounter a 0 and the no. of flips is even OR we encounter a 1 and the no. of flips is odd we \\n           increment the result and mark the end `i+k-1` in the queue\\n\\t3.2 If the last index of the flip > n we return  -1 because then its not possible to achieve the final result \\n           as dont have enough values to flip\\n\\t3.3 We remove the head of the queue as we reach the last index of the flip\\n\\n## Code:\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length;\\n        Queue<Integer> fq = new LinkedList<>();\\n        int res = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if ((A[i] == 0 && fq.size()%2 == 0) || (A[i]==1 && fq.size()%2 == 1)) {\\n                res++;\\n                if (i+K > n) return -1;\\n                fq.add(i+K-1);\\n            } //fi\\n            if (fq.size() > 0 && fq.peek() == i) {\\n                fq.remove();\\n            }\\n        }//for\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length;\\n        Queue<Integer> fq = new LinkedList<>();\\n        int res = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if ((A[i] == 0 && fq.size()%2 == 0) || (A[i]==1 && fq.size()%2 == 1)) {\\n                res++;\\n                if (i+K > n) return -1;\\n                fq.add(i+K-1);\\n            } //fi\\n            if (fq.size() > 0 && fq.peek() == i) {\\n                fq.remove();\\n            }\\n        }//for\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238972,
                "title": "backtracking-logical-thinking",
                "content": "For an non-one element, we must flip it.\\nWe won\\'t do the same type of flip for twice. And the order of flips doesn\\'t matter, that is, they are commutative.\\nSo we always start with the first non-one element.\\n\\nThe problem is similar to [465. Optimal Account Balancing](https://leetcode.com/problems/optimal-account-balancing/discuss/130895/Recursion-Logical-Thinking)\\n****\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        return minKBitFlipsAfter(getFirstNonOne(A), A, K);\\n    }\\n\\n    private int minKBitFlipsAfter(int start, int[] A, int K) {\\n        if (start == A.length) return 0; // Flip all 0s.\\n        if (start + K > A.length) return -1; // Not enough elements to flip.\\n\\n        // Flip [start, start + k - 1].\\n        for (int i = start; i < start + K; i++) {\\n            A[i] = 1 - A[i];\\n        }\\n\\n        int firstNonOne = getFirstNonOne(A);\\n        int rest = minKBitFlipsAfter(firstNonOne, A, K);\\n        if (rest == -1) return -1; // Cannot flip.\\n        else return 1 + rest;\\n    }\\n\\n    private int getFirstNonOne(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] != 1) return i;\\n        }\\n        return A.length;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n    public int minKBitFlips(int[] A, int K) {\\n        return minKBitFlipsAfter(getFirstNonOne(A), A, K);\\n    }\\n\\n    private int minKBitFlipsAfter(int start, int[] A, int K) {\\n        if (start == A.length) return 0; // Flip all 0s.\\n        if (start + K > A.length) return -1; // Not enough elements to flip.\\n\\n        // Flip [start, start + k - 1].\\n        for (int i = start; i < start + K; i++) {\\n            A[i] = 1 - A[i];\\n        }\\n\\n        int firstNonOne = getFirstNonOne(A);\\n        int rest = minKBitFlipsAfter(firstNonOne, A, K);\\n        if (rest == -1) return -1; // Cannot flip.\\n        else return 1 + rest;\\n    }\\n\\n    private int getFirstNonOne(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] != 1) return i;\\n        }\\n        return A.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846869,
                "title": "python-greedy-queue",
                "content": "```html5\\n<b>Time Complexity: O(n)\\nSpace Complexity: O(k)</b>\\n```\\n\\uD83E\\uDD14 **Intuition**\\nConsider reading array **A** from left to right.  \\nWhenever **A[i] == 0** we have to flip **A[i:k]** otherwise we end up having a zero at **A[i]**.  \\nWhenever **A[i] == 1** we do not flip any bits, otherwise we end up having a zero at **A[i]**.  \\nThis means that if a solution exists, we can find the minimum number of bit flips by greedily flipping **A[i:k]** any time **A[i] == 0**.  \\n\\n\\uD83D\\uDCAA**Brute Force Approach O(k&middot;n) - TLE**\\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tflips = 0\\n\\tfor i in range(len(A)-k+1):\\n\\t\\tif A[i] == 0:\\n\\t\\t\\tflips += 1\\n\\t\\t\\tfor j in range(i, i+k): # time consuming\\n\\t\\t\\t\\tA[j] = 1 - A[j]\\n\\n\\treturn flips if all(A[j] == 1 for j in range(i,len(A))) else -1\\n```\\n\\uD83D\\uDC22**Why TLE?**\\nThe inner for-loop updates bits **i** to **i+k** every time bit **i** is flipped.  This is unnecessarily time consuming.  \\nConsider the case where **k = 1000** and **A = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, ...]**.  \\nWe would have to update 1000 bits every step resulting in **O(k&middot;n)** time complexity.   \\n\\nIt is not necessary to update **A** every time we flip a bit.  \\nWe do not care that every bit in **A** is correctly marked as a **1** or a **0** at every step.  \\nWhat we do care about is knowing how many times bit **i** was flipped.  \\nIf **i** was flipped an **even** number of times, then **A[i]** remains the same, but if **i** was flipped an **odd** number of times **A[i] = 1 - A[i]**.  \\n\\n\\u2714\\uFE0F**Optimization: Use a queue to keep track of how many times each bit was flipped.**\\n*Numbers match the annotations in code.*\\n**(#1)** Every time a bit is flipped, append **i+k-1** to the queue.  This tells us that all bits from **i** to **i+k-1** (inclusive) have been flipped.  \\n**(#2)** To determine if a bit has been flipped, **check if the length of the queue is odd**.  The length of the queue tells us how many times bit **i** was flipped.\\n**(#3)** Remove all flips that occurred before **i** from the queue.  \\n**(#4)** It is impossible to not flip any bits that occur after **len(A) - k**.\\n\\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tlatest_possible_flip = len(A) - k       # 4\\n\\tflipped = collections.deque()\\n\\tflips = 0\\n\\tfor i in range(len(A)):\\n\\t\\tif flipped and (flipped[0] < i):    # 3\\n\\t\\t\\tflipped.popleft()\\n\\t\\tif len(flipped)&1 == A[i]:          # 2\\n\\t\\t\\tif i <= latest_possible_flip:   # 4\\n\\t\\t\\t\\tflips += 1\\n\\t\\t\\t\\tflipped.append(i+k-1)       # 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\treturn flips\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n)\\nSpace Complexity: O(k)</b>\\n```\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tflips = 0\\n\\tfor i in range(len(A)-k+1):\\n\\t\\tif A[i] == 0:\\n\\t\\t\\tflips += 1\\n\\t\\t\\tfor j in range(i, i+k): # time consuming\\n\\t\\t\\t\\tA[j] = 1 - A[j]\\n\\n\\treturn flips if all(A[j] == 1 for j in range(i,len(A))) else -1\\n```\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tlatest_possible_flip = len(A) - k       # 4\\n\\tflipped = collections.deque()\\n\\tflips = 0\\n\\tfor i in range(len(A)):\\n\\t\\tif flipped and (flipped[0] < i):    # 3\\n\\t\\t\\tflipped.popleft()\\n\\t\\tif len(flipped)&1 == A[i]:          # 2\\n\\t\\t\\tif i <= latest_possible_flip:   # 4\\n\\t\\t\\t\\tflips += 1\\n\\t\\t\\t\\tflipped.append(i+k-1)       # 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\treturn flips\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 238557,
                "title": "java-clean-o-n-k-greedy-solution",
                "content": "This solution use a function flip() to literally flip array for K bits.\\nApplying Greedy algorithm, we go through the array, and once we see a \"0\", will perform a flip.\\n```\\nclass Solution {\\n    private void flip(int[]A,int K,int i){\\n        for(int j=i;j<i+K;j++){\\n            A[j]=1-A[j];\\n        }\\n    }\\n    public int minKBitFlips(int[] A, int K) {\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0){\\n                if(i+K>A.length)return -1;\\n                flip(A,K,i);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private void flip(int[]A,int K,int i){\\n        for(int j=i;j<i+K;j++){\\n            A[j]=1-A[j];\\n        }\\n    }\\n    public int minKBitFlips(int[] A, int K) {\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0){\\n                if(i+K>A.length)return -1;\\n                flip(A,K,i);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751931,
                "title": "c-using-queue-solution-explained-clrearly-inutuitions-explained",
                "content": "\\n            \\n           \\n\\t\\t    int minKBitFlips(vector<int>& A, int K) {\\n            int n = A.size();\\n           /*Keeps track of the last index of a k-window flip\\n            The size of the queue at anytime gives us the total number of flips that\\n            have happened within any k-interval*/\\n            queue<int> isflipped; //Space is O(K) max\\n            int count = 0; //min k-bit flips\\n\\t\\t   for(int i = 0; i < n; i++){ //O(N)\\n              //If current index is 0, then we need to process it/do sth about it\\n              if(A[i] == 0){\\n                \\n                /*If our queue is empty or queue is even size\\n                (i.e our current index has been flipped even # of times , thus ending back at state 0), \\n                then we need to flip this 0 to a 1*/\\n                if(isflipped.empty() || isflipped.size() % 2 == 0){\\n                  count++; //Flip it\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n                /*Lets say we are here, that means our original element is a zero and the queu size is\\n                odd sized which means that this 0 has been flipped odd # of times, giving us the result 1.\\n                So we do nothing since we know the element has been flipped to 1 already*/\\n              }else{ //A[i] == 1\\n                /*If A[i] == 1, we need to process it only in one case*/\\n                if(isflipped.size() % 2 != 0){\\n                  /*this means a \\'1\\' has been flipped odd # of times , thus ending at state \\'0\\', \\n                  we need to flip this then*/\\n                  count++;\\n\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n              }\\n              \\n              //Anytime we are done with a interval, we pop the index out of the queue\\n              //MISTAKE: Make sure to check the q is emoty or not before popping off the value\\n              if(!isflipped.empty() && i >= isflipped.front()) isflipped.pop();\\n            }\\n            \\n            /*Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1*/\\n            return isflipped.empty() ? count : -1;\\n          }",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "\\n            \\n           \\n\\t\\t    int minKBitFlips(vector<int>& A, int K) {\\n            int n = A.size();\\n           /*Keeps track of the last index of a k-window flip\\n            The size of the queue at anytime gives us the total number of flips that\\n            have happened within any k-interval*/\\n            queue<int> isflipped; //Space is O(K) max\\n            int count = 0; //min k-bit flips\\n\\t\\t   for(int i = 0; i < n; i++){ //O(N)\\n              //If current index is 0, then we need to process it/do sth about it\\n              if(A[i] == 0){\\n                \\n                /*If our queue is empty or queue is even size\\n                (i.e our current index has been flipped even # of times , thus ending back at state 0), \\n                then we need to flip this 0 to a 1*/\\n                if(isflipped.empty() || isflipped.size() % 2 == 0){\\n                  count++; //Flip it\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n                /*Lets say we are here, that means our original element is a zero and the queu size is\\n                odd sized which means that this 0 has been flipped odd # of times, giving us the result 1.\\n                So we do nothing since we know the element has been flipped to 1 already*/\\n              }else{ //A[i] == 1\\n                /*If A[i] == 1, we need to process it only in one case*/\\n                if(isflipped.size() % 2 != 0){\\n                  /*this means a \\'1\\' has been flipped odd # of times , thus ending at state \\'0\\', \\n                  we need to flip this then*/\\n                  count++;\\n\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n              }\\n              \\n              //Anytime we are done with a interval, we pop the index out of the queue\\n              //MISTAKE: Make sure to check the q is emoty or not before popping off the value\\n              if(!isflipped.empty() && i >= isflipped.front()) isflipped.pop();\\n            }\\n            \\n            /*Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1*/\\n            return isflipped.empty() ? count : -1;\\n          }",
                "codeTag": "Unknown"
            },
            {
                "id": 3659634,
                "title": "c-sliding-window-range-addition-explained",
                "content": "# Pre-requisite\\n- Print modified array after multiple array range increment operations\\n- Range addition (Leetcode)\\n\\n# Intuition\\n- We will process given array window by window of length k. \\n- We iterate the given array from left to right and at any point of time, at ith index if we encouter current bit to be 0, then it should flip from 0 to 1. So we have to flip whole window starting from i and ending at i + k - 1.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- After Applying all operation on valid windows (starting from `0th index` till `(n - k)th index`). \\n- We will check that all bits are transferred to 1 or not. If all bit are transferred to 1 then answer will be `ans` or else ans will be `-1`.\\n\\n---\\n# Code Walkthrough\\n- Gives the final bit after \\'flips\\' flips on the bit\\n    - Example: bit = 0, flips = 5 => ans = 1\\n    - Example: bit = 1, flips = 5 => ans = 0\\n    - Example: bit = 0, flips = 4 => ans = 0\\n    - Example: bit = 1, flips = 4 => ans = 1\\n```\\nint finalbit(int bit, int flips)\\n{\\n    if (flips % 2 == 0)\\n        return bit;\\n    return !bit;\\n}\\n```\\n---\\n- pref[i] = for ith index, how many flips we have made\\n```\\nvector<int> pref(n + 1);\\n```\\n---\\n- For any index i, first of all we calculate the flips made on ith index from previous operations\\n- Now, if we have sufficient window (because we can only flip whole window of size \\'k\\' according to given in question), then\\n    - after applying all flips on current bit, if current bit is 1. then we don\\'t need to do any operation.\\n    - if current bit is 0. then we have to apply one operation. And though we have to flip whole window of size k starting from ith index, we will increment flip count in the range i to i + k - 1.\\n\\n```\\n\\nfor (int i = 0; i < n; i++)\\n{\\n    if (i)\\n        pref[i] += pref[i - 1];\\n\\n    if (i < n - y + 1)\\n    {\\n        int flips = pref[i];\\n        int bit = finalbit(v[i], flips);\\n\\n        if (bit == 1)\\n            continue;\\n\\n        ans++;\\n        pref[i]++;\\n        pref[i + y]--;\\n    }\\n}\\n```\\n---\\n- After applying neccesary operations, we finally check the all bit. \\n- If all bits are 1 then we return ans otherwise it is not possible to make array of all ones, so we return -1.\\n- This portion of the code is not neccesary neither the after vector, it can be computed in the above loop itself. But for the sack of simplicity of the code, i have done it separately.\\n```\\nint cnt = 0;\\nvector<int> after(n);\\nfor (int i = 0; i < n; i++)\\n{\\n    after[i] = finalbit(v[i], pref[i]);\\n    cnt += (after[i] == 1);\\n}\\nreturn cnt == n ? ans : -1;\\n```\\n\\n---\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Full Code\\n```\\nclass Solution {\\npublic:\\n    int finalbit(int bit, int flips)\\n    {\\n        if (flips % 2 == 0)\\n            return bit;\\n        return !bit;\\n    }\\n\\n    int minKBitFlips(vector<int>& v, int y) {\\n        int n = v.size();\\n        vector<int> pref(n + 1);\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i)\\n                pref[i] += pref[i - 1];\\n\\n            if (i < n - y + 1)\\n            {\\n                int flips = pref[i];\\n                int bit = finalbit(v[i], flips);\\n\\n                if (bit == 1)\\n                    continue;\\n\\n                ans++;\\n                pref[i]++;\\n                pref[i + y]--;\\n            }\\n        }\\n\\n        int cnt = 0;\\n        vector<int> after(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            after[i] = finalbit(v[i], pref[i]);\\n            cnt += (after[i] == 1);\\n        }\\n        \\n        return cnt == n ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nint finalbit(int bit, int flips)\\n{\\n    if (flips % 2 == 0)\\n        return bit;\\n    return !bit;\\n}\\n```\n```\\nvector<int> pref(n + 1);\\n```\n```\\n\\nfor (int i = 0; i < n; i++)\\n{\\n    if (i)\\n        pref[i] += pref[i - 1];\\n\\n    if (i < n - y + 1)\\n    {\\n        int flips = pref[i];\\n        int bit = finalbit(v[i], flips);\\n\\n        if (bit == 1)\\n            continue;\\n\\n        ans++;\\n        pref[i]++;\\n        pref[i + y]--;\\n    }\\n}\\n```\n```\\nint cnt = 0;\\nvector<int> after(n);\\nfor (int i = 0; i < n; i++)\\n{\\n    after[i] = finalbit(v[i], pref[i]);\\n    cnt += (after[i] == 1);\\n}\\nreturn cnt == n ? ans : -1;\\n```\n```\\nclass Solution {\\npublic:\\n    int finalbit(int bit, int flips)\\n    {\\n        if (flips % 2 == 0)\\n            return bit;\\n        return !bit;\\n    }\\n\\n    int minKBitFlips(vector<int>& v, int y) {\\n        int n = v.size();\\n        vector<int> pref(n + 1);\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i)\\n                pref[i] += pref[i - 1];\\n\\n            if (i < n - y + 1)\\n            {\\n                int flips = pref[i];\\n                int bit = finalbit(v[i], flips);\\n\\n                if (bit == 1)\\n                    continue;\\n\\n                ans++;\\n                pref[i]++;\\n                pref[i + y]--;\\n            }\\n        }\\n\\n        int cnt = 0;\\n        vector<int> after(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            after[i] = finalbit(v[i], pref[i]);\\n            cnt += (after[i] == 1);\\n        }\\n        \\n        return cnt == n ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238975,
                "title": "slide-window-o-n-time-o-1-space-no-bit-manipulation-detailed-explanation",
                "content": "Assuming `flippedTime` denotes the flipped time of `A[i]`, if `flippedTime` is even and `A[i]` is 0, or `flippedTime` is odd and `A[i]` is 1, `A[i]` needs to be flipped.\\nSo if `flippedTime%2==A[i]`, `A[i]` needs to be flipped.\\n\\nAssuming that we have a window from `i-K` to `i-1` closed interval (when i<K, just [0, K-1] ), we use `flippedTime` to caculate the flipped time inside this window, i.e. [ i-K, i-1 ]\\n\\nWhen `i>=K`, the elements which can influence `A[i]` is elements whoes index is from i-K-1 to  i-1, so if A[i-k] has flipped, we make `flippedTime` -1, now `flippedTime` denotes the flipped time of elements in [i-K+1, i-1], which is also the flipped time of A[i].\\n\\nIn the code, I make A[j]=2 if A[j] should flip, therefore it is easy to check whether A[i-K] flipped when it comes to A[i].\\n\\n----\\n\\u5047\\u8BBE\\u7528 flippedTime \\u6765\\u8868\\u793A A[i] \\u88AB\\u4E4B\\u524D\\u5143\\u7D20\\u7FFB\\u8F6C\\u6240\\u5F71\\u54CD\\u7684\\u6B21\\u6570\\uFF0C \\u90A3\\u4E48\\u5982\\u679C flippedTime \\u662F\\u5076\\u6570\\u4E14 A[i]=0, \\u6216\\u8005 flippedTime \\u662F\\u5947\\u6570\\u4E14 A[i]=1\\uFF0C\\u90A3\\u4E48 A[i] \\u5C31\\u9700\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n\\u7528\\u4EE3\\u7801\\u8868\\u793A\\u4E3A\\u5982\\u679C `flippedTime%2==A[i]`\\uFF0C\\u90A3\\u4E48 A[i] \\u9700\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n\\n\\u56E0\\u4E3A\\u6211\\u4EEC\\u6BCF\\u6B21\\u90FD\\u8981\\u5BF9\\u957F\\u5EA6\\u4E3A K \\u7684\\u533A\\u95F4\\u8FDB\\u884C\\u7FFB\\u8F6C\\uFF0C\\u5047\\u8BBE\\u5B58\\u5728\\u4E00\\u4E2A window \\u5728\\u95ED\\u533A\\u95F4 [i-K, i-1]\\uFF0C\\u5F53 i<K \\u65F6\\uFF0C\\u5373\\u4E3A [0, K-1]\\u3002\\u7528 flippedTime \\u8BA1\\u7B97\\u5728\\u8BE5 window \\u91CC\\u53D1\\u751F\\u7FFB\\u8F6C\\u7684\\u6B21\\u6570\\u3002\\n\\n\\u5F53 i>=K \\u65F6\\uFF0C\\u5BF9 A[i] \\u662F\\u5426\\u7FFB\\u8F6C\\u4EA7\\u751F\\u5F71\\u54CD\\u7684\\u5E94\\u8BE5\\u662F\\u5728\\u533A\\u95F4 [i-K+1, i-1]\\u5185\\u7684\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u68C0\\u6D4B A[i-k]\\u662F\\u5426\\u53D1\\u751F\\u7FFB\\u8F6C\\uFF0C\\u5982\\u679C A[i-K] \\u7FFB\\u8F6C\\u4E86\\uFF0C\\u90A3\\u4E48\\u5C31\\u628A flippedTime-1\\uFF0C\\u6B64\\u65F6 flippedTime \\u5373\\u4E3A A[i]\\u5728\\u6B64\\u4E4B\\u524D\\u88AB\\u7FFB\\u8F6C\\u7684\\u6B21\\u6570\\u3002\\u8FD9\\u65F6\\u518D\\u5224\\u65AD A[i] \\u662F\\u5426\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n\\n\\u5728\\u4EE3\\u7801\\u4E2D\\uFF0C\\u5982\\u679C A[j] \\u88AB\\u7FFB\\u8F6C\\u4E86\\uFF0C\\u5C31\\u628A\\u5176\\u503C\\u8BBE\\u4E3A2\\uFF0C\\u4FBF\\u4E8E\\u4E4B\\u540E\\u7684\\u68C0\\u6D4B\\u3002\\n\\n----\\n\\u89E3\\u91CA2\\uFF1A\\n1. \\u5728A[i]\\u4E2D\\uFF0C\\u6BCF\\u4E2A\\u5143\\u7D20\\u88AB\\u53CD\\u8F6C\\u7684\\u6B21\\u6570\\u53D7\\u5230\\u5B83\\u4E4B\\u524DK-1\\u4E2A\\u5143\\u7D20\\u7684\\u5F71\\u54CD\\uFF0C\\u6211\\u4EEC\\u8003\\u8651\\u4E00\\u4E2A\\u957F\\u5EA6\\u4E3AK\\u7684window\\uFF0C\\n\\u7528flippedTime\\u8BB0\\u5F55window\\u4E2D\\u7684\\u524DK-1\\u4E2A\\u5143\\u7D20\\u9020\\u6210\\u7684\\u5F71\\u54CD\\u7D2F\\u79EF\\u5230\\u6700\\u540E\\u4E00\\u4E2A\\u5143\\u7D20\\uFF0C\\u5BFC\\u81F4\\u5B83\\u9700\\u8981\\u53CD\\u8F6C\\u7684\\u6B21\\u6570\\u3002\\n\\u7279\\u522B\\u7684\\uFF0C\\u5982\\u679Ci < K\\u65F6\\uFF0C\\u6211\\u4EEC\\u5219\\u8003\\u8651\\u4ECE0\\u5230i\\u7684window\\u3002\\n2. \\u53EF\\u4EE5\\u901A\\u8FC7A[i]\\u548C\\u76F8\\u5E94\\u7684flippedTime\\u5224\\u65AD\\u662F\\u5426\\u9700\\u8981\\u5728A[i]\\u5904\\u8FDB\\u884C\\u53CD\\u8F6C\\u3002\\u5F53A[i] = 0\\u4E14flippedTime\\u5076\\u6570\\uFF0C\\u6216\\u8005\\nA[i] = 1\\u4E14flippedTime\\u5947\\u6570\\uFF0C\\u4EE3\\u8868\\u6B64\\u65F6A[i] = 0\\u3002\\u4EE4A[i] = 2\\u6807\\u8BB0\\u8FD9\\u6B21\\u53CD\\u8F6C\\u3002\\n\\u7528\\u4EE3\\u7801\\u8868\\u793A\\u4E3A\\u5982\\u679C flippedTime%2==A[i]\\uFF0C\\u90A3\\u4E48 A[i] \\u9700\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n3. \\u8BBE\\u7F6Ei\\u4ECE0\\u5F00\\u59CB\\u904D\\u5386\\u5230\\u6700\\u540E\\u4E00\\u4E2A\\u5143\\u7D20\\uFF0C\\u5F53i >= K\\u65F6\\u5411\\u53F3\\u79FB\\u52A8window\\uFF0C\\u5982\\u679CA[i-k]\\u5904\\u6709\\u53CD\\u8F6C\\u6807\\u8BB02\\uFF0C\\nflippedTime\\u9700\\u8981\\u51CF1\\u3002\\n\\n```python\\nclass Solution:\\n    def minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        flippedTime=0\\n        count=0 # count the total flipped time\\n        for i in range(len(A)):\\n            if i>=K and A[i-K]==2: \\n                flippedTime-=1\\n                \\n            if (flippedTime %2) == A[i]:\\n                if i+K>len(A):\\n                    return -1\\n                A[i]=2\\n                flippedTime+=1\\n                count+=1\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        flippedTime=0\\n        count=0 # count the total flipped time\\n        for i in range(len(A)):\\n            if i>=K and A[i-K]==2: \\n                flippedTime-=1\\n                \\n            if (flippedTime %2) == A[i]:\\n                if i+K>len(A):\\n                    return -1\\n                A[i]=2\\n                flippedTime+=1\\n                count+=1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383003,
                "title": "c-o-n-time-using-line-sweep",
                "content": "Approach:\\nThe approach is very similar to:\\nQuestion: https://leetcode.com/problems/jump-game-vii/\\nSolution: https://leetcode.com/problems/jump-game-vii/discuss/1382916/c%2B%2B-or-O(n)-time-or-using-line-sweep\\nIf we encounter a \\'0\\', it MUST be flipped and hence we  increase `ans` by 1.\\nIf we don\\'t get `k` elements including this element, that means we can\\'t change this element from 0 to 1 and we have to return -1.\\n\\tif `flip[i]%2==0` it means `i` th element has been flipped even number of times and is in the same state as mentioned in `ar[i]`.\\n\\tFlipping is done when `ar[i]` has 0 and `ar[i]` is in original state of when `ar[i]` is 1 and `ar[i]` is in flipped state.\\n```\\nclass Solution {\\npublic:\\nint minKBitFlips(vector<int>& ar, int k) {\\n    int n=ar.size(),ans=0;\\n    vector<int> flip(n,0); //  flip[i] stores how many times current index(i) is flipped\\n    for(int i=0;i<n;i++){\\n        if(i) flip[i]+=flip[i-1];\\n        if((flip[i]%2 && ar[i]) || (flip[i]%2==0 && !ar[i])){\\n            ans++;\\n            // ar[i] MUST be flipped\\n            // ar[i+k] is not flipped\\n            flip[i]++;\\n            if(i+k>n) return -1;\\n            if(i+k<n) flip[i+k]--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint minKBitFlips(vector<int>& ar, int k) {\\n    int n=ar.size(),ans=0;\\n    vector<int> flip(n,0); //  flip[i] stores how many times current index(i) is flipped\\n    for(int i=0;i<n;i++){\\n        if(i) flip[i]+=flip[i-1];\\n        if((flip[i]%2 && ar[i]) || (flip[i]%2==0 && !ar[i])){\\n            ans++;\\n            // ar[i] MUST be flipped\\n            // ar[i+k] is not flipped\\n            flip[i]++;\\n            if(i+k>n) return -1;\\n            if(i+k<n) flip[i+k]--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592961,
                "title": "java-o-n-greedy-sliding-window",
                "content": "It\\'s easy to come up with an `O(nk)` solution in which we change the `k` successors everytime we meet a zero.\\n```java\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        int i = 0, res = 0;\\n        while (i < A.length) {\\n            if (A[i] == 0) {\\n                if (i + K > A.length)\\n                    return -1;\\n                for (int j = i; j < i + K; j++) {\\n                    A[j] ^= 1;\\n                }\\n                res++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nDue to the scale, we need to find an `O(n)` solution. Let\\'s try to maintain a k-length sliding windows. Maybe a little ambiguous. `target` is the value we want to flip and intially it\\'s set to zero. When we find a value equals to target, we \"flip\" all the elements in current sliding window. However, we won\\'t actually do the filpping immediately, we just filp the `target` instead. When expending the sliding window, we change the forwarding elements simultaneously (according to `target`). \\n```java\\nclass Solution {\\n\\n    int target = 0;\\n    \\n    public int minKBitFlips(int[] A, int K) {\\n        int lo = 0, hi = K, res = 0;\\n        while (hi < A.length) {\\n            if (A[lo] == target) {\\n                target ^= 1;\\n                res++;\\n            } else {\\n                A[hi] ^= target;\\n                lo++;\\n                hi++;\\n            }\\n        }\\n        int cnt = (int) IntStream.range(lo, hi).filter(i -> A[i] == target).count();\\n        return cnt == K ? res + 1 : cnt == 0 ? res : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        int i = 0, res = 0;\\n        while (i < A.length) {\\n            if (A[i] == 0) {\\n                if (i + K > A.length)\\n                    return -1;\\n                for (int j = i; j < i + K; j++) {\\n                    A[j] ^= 1;\\n                }\\n                res++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n\\n    int target = 0;\\n    \\n    public int minKBitFlips(int[] A, int K) {\\n        int lo = 0, hi = K, res = 0;\\n        while (hi < A.length) {\\n            if (A[lo] == target) {\\n                target ^= 1;\\n                res++;\\n            } else {\\n                A[hi] ^= target;\\n                lo++;\\n                hi++;\\n            }\\n        }\\n        int cnt = (int) IntStream.range(lo, hi).filter(i -> A[i] == target).count();\\n        return cnt == K ? res + 1 : cnt == 0 ? res : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240127,
                "title": "995-minimum-number-of-k-consecutive-bit-flips-analysis",
                "content": "<h2>Minimum Number of K Consecutive Bit Flips</h2>\\nIn an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\\n\\nReturn the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.\\n\\n<h2 id=\"solution\">Solution</h2>\\n<hr>\\n<h4>Approach 1: Greedy</h4>\\n<strong>Intuition and Algorithm</strong>\\n\\n<p>\\nThis problem is similar to <a href=\"https://codejam.withgoogle.com/codejam/contest/3264486/dashboard#s=p0&a=0\">Qualification\\'s Codejam 2017.</a> (check Contest Analysis).\\n\\nThe idea is simple,  from left to right ,we find the first occurrence index <code>i</code>  with value <code>0</code>, now the unique way to change it, consists in flip from <code>[i ,i+K-1] </code>\\n\\nWhy?\\nImagine you have a solution, which performs flips in index starting in <code>i1, i2, i3, i4 where i1 < i2 < i3 < i4 </code>. \\n\\n<b>Observation:</b>\\n* At most we perform one flip in the same subarray, (because the operation is reversible).\\n* The order doesn\\'t matter.  <code> (i1,i2,i3,i4) = (i3,i2,i1,i4) </code> \\n* If the solution is <code>(i1,i2,i3,i4) </code> then  <code>A[i1]</code> must to be <code>0</code>  after performed this operation, flip <code>[i1 , i1+K-1]</code>, <code>A[i2]</code> must to be <code>0</code>, and so on.\\n\\n</p>\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tint n= A.size();\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i+K-1<n;i++)\\n\\t\\t\\t\\tif(A[i]==0){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tfor(int j=i;j<i+K;j++)\\n\\t\\t\\t\\t\\t\\tA[j]^=1;\\n\\t\\t\\t\\t}\\n        \\n\\t\\t\\tif(A!=vector<int>(n,1))return -1;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<p><strong>Complexity Analysis</strong></p>\\n<ul>\\n<li>\\n<p>Time Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N*K</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N*K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N*K</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N*K</mi></mrow><annotation encoding=\"application/x-tex\">N*K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is length of <code>A</code>.</p>\\n</li>\\n<li>\\n<p>Space Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>1</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">1</span><span class=\"mclose\">)</span></span></span></span>.\\n<br>\\n<br></p>\\n</li>\\n</ul>\\n\\n\\n<hr>\\n<h4>Approach 2: Greedy + Binary Indexed Trees</h4>\\n<strong>Algorithm</strong>\\n<p>\\nIn contest, I thought that the previous algorithm could get TLE.\\n</p>\\n<p>\\nI thought of creating a data structure that added a value in a subarray (<code>A</code>) and get a specific value (<code>A[i]</code>) in logaritmic time. (Binary indexed Trees)\\n\\n<a href=\"https://apps.topcoder.com/forums/?module=Thread&threadID=715842&start=0&mc=8#1406845\">Range Update - Point query</a>\\n- Add v to [a..b] --> Update(a,v) and Update(b+1,-v) on the BIT\\n\\n</p>\\n\\nWhy add a value in a subarray?\\nIf I have   <code>A = [1,0,1,1,1,1,0] , K = 3</code> , then, I flip from index 1,\\n<code> A\\' = [1,1,0,0,1,1,0] </code>, It\\'s possible to add 1 from index 1, and get,\\n<code> A\\'\\' = [1,1,2,2,1,1,0] </code>, I will check each value modulo 2. \\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint tree[60002];\\n\\t\\tint MaxVal=60001;\\n\\t\\t\\n\\t\\tvoid update(int idx ,int val){\\n\\t\\t\\twhile (idx <= MaxVal){\\n\\t\\t\\t\\ttree[idx] += val;\\n\\t\\t\\t\\tidx += (idx & -idx);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t  \\n\\t\\tint read(int idx){\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\twhile (idx > 0){\\n\\t\\t\\t\\tsum += tree[idx];\\n\\t\\t\\t\\tidx -= (idx & -idx);\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}    \\n\\t\\t\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tmemset(tree,0,sizeof(tree));\\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i+K-1<A.size();i++){\\n\\t\\t\\t\\tint val=read(i+1)+(A[i]);\\n\\t\\t\\t\\tif(val%2==0){\\n\\t\\t\\t\\t\\tupdate(i+1,1);\\n\\t\\t\\t\\t\\tupdate(i+K+1,-1);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<A.size();i++){\\n\\t\\t\\t\\tint val=read(i+1)+(A[i]);\\n\\t\\t\\t\\tif(val%2==0)return -1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n</code>\\n\\n\\n<p><strong>Complexity Analysis</strong></p>\\n<ul>\\n<li>\\n<p>Time Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N*log(N)</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N*log(N))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N*log(N)</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N*log(N)</mi></mrow><annotation encoding=\"application/x-tex\">N*log(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is length of <code>A</code>.</p>\\n</li>\\n<li>\\n<p>Space Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.\\n<br>\\n<br></p>\\n</li>\\n</ul>\\n\\n\\n<hr>\\n<h4>Approach 3: Greedy + Events</h4>\\n<strong>Algorithm</strong>\\n<p>\\nWe will use a similar idea that \"Approach 2\", without BIT, (the reason is that we go from leftmost to rightmost, and it\\'s possible to get every value in constant time).\\n\\nFlip(a,b), from a to b  --> x[a]^1 and x[b+1]^1   .. O(1) operation.\\nquery(a)  --->    x[0]^x[1]^....^x[a]    .. we get this accumulate in O(1) because we go from left to right.. \\n</p>\\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n= A.size();\\n\\t\\t\\tint xxor = 0;\\n\\t\\t\\tint update[n+1];\\n\\t\\t\\tmemset(update,0,sizeof(update));\\n\\t\\t\\t// xxor always have update[0]^....^update[i]\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0; i+K-1 < n;i++){\\n\\t\\t\\t\\tint val = (xxor^update[i]) +A[i];\\n\\t\\t\\t\\tif(val%2==0){\\n\\t\\t\\t\\t\\tupdate[i] ^= 1;\\n\\t\\t\\t\\t\\tupdate[i+K] ^= 1;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\txxor ^= update[i];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\txxor = 0;\\n\\t\\t\\tfor(int i=0;i<A.size();i++){\\n\\t\\t\\t\\txxor ^= update[i];\\n\\t\\t\\t\\tint val = xxor + A[i];\\n\\t\\t\\t\\tif(val%2==0)return -1;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n\\n</code>\\n\\n<p><strong>Complexity Analysis</strong></p>\\n<ul>\\n<li>\\n<p>Time Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is length of <code>A</code>.</p>\\n</li>\\n<li>\\n<p>Space Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.\\n<br>\\n<br></p>\\n</li>\\n</ul>",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tint n= A.size();\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i+K-1<n;i++)\\n\\t\\t\\t\\tif(A[i]==0){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tfor(int j=i;j<i+K;j++)\\n\\t\\t\\t\\t\\t\\tA[j]^=1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 552438,
                "title": "java-o-n-sliding-window-queue-with-explannation",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        //flipIndex: store previous flip events\\n        Queue<Integer> flipIndex = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0;i<A.length;i++){\\n            // remove an itme which is out range of window.\\n            if(!flipIndex.isEmpty()&&(i-flipIndex.peek()>=K)){\\n                flipIndex.poll();\\n            }\\n            /**\\n             0 (even number) -> flip  twice (even number) -> 0 (need to be fliped)\\n                             -> flip  once (odd number)   -> 1 (don\\'t need)\\n                             \\n             1 (odd number)  -> flip  once (odd number)   -> 0 (need to be fliped)\\n                             -> flip  twice (even number) -> 1 (don\\'t need)\\n             Summary:                \\n             In a window,  if A[i] is a even number with even times fliped, it need to be fliped again.\\n             On other hand,if A[i] is a odd number with odd times fliped, it need to be fliped again.\\n            */\\n            \\n            if(A[i]%2 == flipIndex.size()%2){\\n                if(i+K-1>=A.length){\\n                    return -1;\\n                }\\n                flipIndex.offer(i);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        //flipIndex: store previous flip events\\n        Queue<Integer> flipIndex = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0;i<A.length;i++){\\n            // remove an itme which is out range of window.\\n            if(!flipIndex.isEmpty()&&(i-flipIndex.peek()>=K)){\\n                flipIndex.poll();\\n            }\\n            /**\\n             0 (even number) -> flip  twice (even number) -> 0 (need to be fliped)\\n                             -> flip  once (odd number)   -> 1 (don\\'t need)\\n                             \\n             1 (odd number)  -> flip  once (odd number)   -> 0 (need to be fliped)\\n                             -> flip  twice (even number) -> 1 (don\\'t need)\\n             Summary:                \\n             In a window,  if A[i] is a even number with even times fliped, it need to be fliped again.\\n             On other hand,if A[i] is a odd number with odd times fliped, it need to be fliped again.\\n            */\\n            \\n            if(A[i]%2 == flipIndex.size()%2){\\n                if(i+K-1>=A.length){\\n                    return -1;\\n                }\\n                flipIndex.offer(i);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238621,
                "title": "screencast-of-leetcode-weekly-contest-124",
                "content": "https://www.youtube.com/watch?v=ZK9NhAmN8C0\\n\\nI can\\'t figure out how to gracefully solve problem 3 during contest. After like 5+ mins thinking, I gave up and started implementing Segment Tree.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=ZK9NhAmN8C0\\n\\nI can\\'t figure out how to gracefully solve problem 3 during contest. After like 5+ mins thinking, I gave up and started implementing Segment Tree.",
                "codeTag": "Unknown"
            },
            {
                "id": 239117,
                "title": "java-o-n-sliding-window-solution-using-queue",
                "content": "```\\npublic int minKBitFlips(int[] A, int K) {\\n        int result = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for (int i=0; i<A.length; i++) {\\n            if (!queue.isEmpty() && i>=queue.peek()+K) queue.poll();  // i is beyond the affected range of the flip at queue.peek()\\n            if ((A[i] + queue.size()) % 2 == 0) { // A[i]+queue.size()==odd => A[i] is actually already 1\\n                if (i > A.length - K) return -1; \\n                queue.offer(i);\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n^^ \\u53EF\\u4F5C\\u4E3Adiscuss\\u6700\\u9AD8\\u7968\\u4E2DSolution 2\\u7684\\u89E3",
                "solutionTags": [],
                "code": "```\\npublic int minKBitFlips(int[] A, int K) {\\n        int result = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for (int i=0; i<A.length; i++) {\\n            if (!queue.isEmpty() && i>=queue.peek()+K) queue.poll();  // i is beyond the affected range of the flip at queue.peek()\\n            if ((A[i] + queue.size()) % 2 == 0) { // A[i]+queue.size()==odd => A[i] is actually already 1\\n                if (i > A.length - K) return -1; \\n                queue.offer(i);\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103263,
                "title": "python-3-8-lines-accumulate-w-explanation-t-m-98-100",
                "content": "Here\\'s the plan:\\n\\nAs we iterate`nums`, we want to change zeros to ones and leave ones unchanged.  Let\\'s call zero the *change-digit* in this case.\\n\\nWhen we flip digits in the  *flip interval*`nums[i:i+k]`, those digits that were initially one are now zero, and or equivalently, if we treat one as the change-digit (call it`toggle`) in the flip-interval we can avoid actually flipping the digits and just keep track of flip-intervals and the current change-digit.\\n\\nWhat makes it interesting is that when we hit a change-digit in in a flip-interval, we have to switch the change-digit again, and so on until we hit the end of`nums`.\\n\\nThus, the problem is reduced to counting the number of times the change-digit flips, which we do in`acc`. It\\'s much like a`prefix`or`accumulate`structure.\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)                             # <-- return the number of flips\\n```\\n[https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/submissions/885902920/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(N).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)                             # <-- return the number of flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148914,
                "title": "c-o-n-explained-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int flips = 0;                  // flips on current positions\\n        vector<int> flip(n+1,0);        // to set end pointer for a flip i.e i+k ->-1\\n        int ops = 0;                    // answer\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            flips +=flip[i];            // update flips for current position\\n                                       \\n            // even flips on 1 okay\\n            if(nums[i]==1 && (flips)%2==0){\\n                continue;\\n            }\\n            \\n            // odd flips on 0 okay\\n            \\n            if(nums[i]==0 && (flips)%2!=0){\\n                continue;\\n            }\\n            \\n            // margin error as k bits flips is must\\n            \\n            if(i+k > n){\\n                return -1;\\n            }\\n            \\n            ops++;           //increment ans\\n            flips++;         // do flip at this position\\n            flip[i+k] = -1;  // set poiter where current flip ends\\n            \\n        }\\n        \\n        return ops;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int flips = 0;                  // flips on current positions\\n        vector<int> flip(n+1,0);        // to set end pointer for a flip i.e i+k ->-1\\n        int ops = 0;                    // answer\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            flips +=flip[i];            // update flips for current position\\n                                       \\n            // even flips on 1 okay\\n            if(nums[i]==1 && (flips)%2==0){\\n                continue;\\n            }\\n            \\n            // odd flips on 0 okay\\n            \\n            if(nums[i]==0 && (flips)%2!=0){\\n                continue;\\n            }\\n            \\n            // margin error as k bits flips is must\\n            \\n            if(i+k > n){\\n                return -1;\\n            }\\n            \\n            ops++;           //increment ans\\n            flips++;         // do flip at this position\\n            flip[i+k] = -1;  // set poiter where current flip ends\\n            \\n        }\\n        \\n        return ops;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302547,
                "title": "intuitive-from-o-n-k-and-optimization-to-o-n",
                "content": "# Intuition\\nObservation 1: bit flips are commutative. It doesn\\'t matter in which order you flip the subarrays, the end result should be same.\\n\\nSo there must be a valid sequence of bit flips in an increasing order through the array.\\n\\nWe must find this increasing order of flips.\\n\\nObservation 2: when we do a pass to find these flips, if our sliding window of size $$k$$ has a $$0$$ in beginning, it must be flipped. Because we are going in increasing order and it\\'s our last chance to flip that integer.\\n\\nObservation 3: If the bit at the beginning of sliding window is 1, we must __not__ flip that bit, because we can\\'t flip that ever again.\\n\\nFrom (2) and (3), whether we flip a certain sliding window depends only on the first bit.\\n\\n# Approach\\nStraightforward $$O(n*k)$$ approach: keep a sliding window of size $$k$$, if it\\'s first bit is 0, flip all subsequent bits in that window.\\n\\nThis actually passes 110/113 test cases!\\n\\nTo not actually have to flip the bits for every single window, we can lazily compute the state of each cell when we encounter it. I do it by marking some points as \"turning points\" (my own term).\\n\\nIn particular, when I encounter a window I want to flip, I\\'d rather invert a boolean state `flip`, and mark the end of this window (actually one past the end), as turning point. (I use queue to remember turning points, but you can use any kind of linear DS.)\\n\\nWhen I see a turning point at a future position, I pop that turning point from queue, flip the current state and continue the usual logic.\\n\\n# Complexity\\n- Time complexity: O(n*k), O(n) respectively\\n\\n- Space complexity: There can be at most `k` turning points in queue at a time, (haven\\'t calculated more precisely). so O(k).\\n\\n# Code\\n\\n## Unoptimized `O(n*k)`\\n\\nThis passed 110/113 test cases, if I remember correctly.\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n            if (bit == 0) {\\n                // mark [i, i+k) as flipped\\n                for (int j = 0; j < k; j++) {\\n                    nums[i+j] = 1 - nums[i+j];\\n                }\\n                ans++;\\n            }\\n        }\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            if (nums[i] == 0) return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n## Optimized `O(n)`\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        boolean flip = false;\\n        Queue<Integer> turns = new ArrayDeque<Integer>();\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) {\\n                bit = 1 - bit;\\n            }\\n\\n            if (bit == 0) {\\n                turns.add(i+k);\\n                flip = !flip;\\n                ans++;\\n            }\\n        }\\n\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) bit = 1 - bit;\\n            if (bit == 0) return -1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n            if (bit == 0) {\\n                // mark [i, i+k) as flipped\\n                for (int j = 0; j < k; j++) {\\n                    nums[i+j] = 1 - nums[i+j];\\n                }\\n                ans++;\\n            }\\n        }\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            if (nums[i] == 0) return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        boolean flip = false;\\n        Queue<Integer> turns = new ArrayDeque<Integer>();\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) {\\n                bit = 1 - bit;\\n            }\\n\\n            if (bit == 0) {\\n                turns.add(i+k);\\n                flip = !flip;\\n                ans++;\\n            }\\n        }\\n\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) bit = 1 - bit;\\n            if (bit == 0) return -1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840244,
                "title": "c-queue-one-pass-solution-easy-to-understand",
                "content": "* Idea is to keep track of the indexes on which flips have been made. And this is done with the help of queue data structure. \\n\\n* Whenever coming on a ith index pop all the indexes which cannot flip the ith index i.e. indexes<=i-k and now the current nums[i] will be equal to the original value if size of queue is even, otherwise gets flipped. \\n \\n*   If now its value is 0 then we gotta do the flip so push i into the queue and do ans++.\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        queue<int>q;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           while(!q.empty() && q.front()<=i-k)\\n               q.pop();\\n            int siz=q.size();\\n            int val=(nums[i]+siz%2)%2;\\n            if(!val)\\n            {\\n                ans++;\\n                if(i+k<=n)\\n                    q.push(i);\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        queue<int>q;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           while(!q.empty() && q.front()<=i-k)\\n               q.pop();\\n            int siz=q.size();\\n            int val=(nums[i]+siz%2)%2;\\n            if(!val)\\n            {\\n                ans++;\\n                if(i+k<=n)\\n                    q.push(i);\\n                else\\n                    return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433426,
                "title": "c-very-easy-implementation-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>lag(n+1,0);\\n        int i=0;\\n        int count=0;\\n        while(i<=n-k)\\n        {\\n            if(i!=0)\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n            {\\n                count++;\\n                lag[i+k]--;\\n                lag[i]++;\\n            }\\n            i++;\\n        }\\n        for(int i=n-k+1;i<n;i++)\\n        {\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>lag(n+1,0);\\n        int i=0;\\n        int count=0;\\n        while(i<=n-k)\\n        {\\n            if(i!=0)\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n            {\\n                count++;\\n                lag[i+k]--;\\n                lag[i]++;\\n            }\\n            i++;\\n        }\\n        for(int i=n-k+1;i<n;i++)\\n        {\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266081,
                "title": "c-995-minimum-number-of-k-consecutive-bit-flips",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> dq; \\n        int ans = 0, flip = 0; \\n        \\n        for (int i = 0; i < size(nums); ++i) {\\n            if (size(dq) && dq.front() == i) {\\n                dq.pop_front(); \\n                flip ^= 1; \\n            }\\n            if (nums[i] == flip) {\\n                if (size(nums)-i < k) return -1; \\n                ++ans; \\n                flip ^= 1; \\n                dq.push_back(i+k); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> dq; \\n        int ans = 0, flip = 0; \\n        \\n        for (int i = 0; i < size(nums); ++i) {\\n            if (size(dq) && dq.front() == i) {\\n                dq.pop_front(); \\n                flip ^= 1; \\n            }\\n            if (nums[i] == flip) {\\n                if (size(nums)-i < k) return -1; \\n                ++ans; \\n                flip ^= 1; \\n                dq.push_back(i+k); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116235,
                "title": "java-greedy-approach-o-n",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924640,
                "title": "easiest-and-most-understandable-explanation-o-1-solution",
                "content": "Basically, this is a sliding window of **k** size and 0-1 task.\\nI prefer to use bit manipulation because it is more straightforward for 0-1 task.\\n\\nThere are only two points:\\n1. we need a variable **flipped** to record whether next index was flipped before.\\n2. we need to record whether **current index** is flipped or not for later check. \\nWe can mark array[i] = -1, if it has been flipped.\\n\\nBit manipulation is more straightforward \\nbecasuse if we initialize flipped = 0, 0 ^ 1 = 1 and 1 ^ 1 = 0.\\nIn other words, \\n**flipping twice is equivalently flipping back to original state of current index.**\\n\\nTake array = [0,1,0,1,0,1,1,0], k = 3, flipped = 0 for example.\\n```\\nif i = 0, array[0] = 0\\nflipped ^= 1; array[0] = -1 >> flipped = 1\\n```\\n```\\nif i = 1, array[1] = 1\\narray[1] was in sliding window [0, 1, 2] and flipped == 1,\\nso it actually became 0 and needs to be flipped. \\nflipped ^= 1; array[1] = -1 >> flipped = 0\\n```\\n```\\nif i = 2, array[2] = 0\\narray[2] was in sliding window [0, 1, 2] and [1, 2, 3] and flipped == 0,\\nso it is still 0 and needs to be flipped. \\nflipped ^= 1; array[2] = -1 >> flipped = 1\\n```\\n```\\n# Notice:\\nif i = 3, array[3] = 1\\narray[3] was not in sliding window [0, 1, 2],\\nbut flipped involves array[0]\\'s flip, \\nwe need to use flipped ^= 1 first to revise it for array[3] and continue the same operation\\n```\\nAs a result, \\nwe can know **if flipped and array[i] are the same value, array[i] needs flip**.\\nWe also can **use operator ^ to check whether flipped and array[i] are the same or not**.\\n\\nhope the explanation helpful!\\n\\n```\\nclass Solution: # best 732 ms\\n    def minKBitFlips(self, array, k):\\n        flipped = 0; length = len(array)\\n        res = 0\\n\\n        for i in range(length):\\n\\t\\t    # revise flipped which didn\\'t affect current index\\n            if i >= k and array[i-k] < 0:\\n                flipped ^= 1\\n\\n\\t\\t\\t# use ^ to know whether array[i] needs to be flipped or not\\n            if not flipped ^ array[i]:\\n\\t\\t\\t    # if current index still needs flip, \\n\\t\\t\\t\\t# the sliding window will be over the length\\n                if i + k > length: return -1   \\n\\t\\t\\t\\t\\n                array[i] = -1; flipped ^= 1\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nif i = 0, array[0] = 0\\nflipped ^= 1; array[0] = -1 >> flipped = 1\\n```\n```\\nif i = 1, array[1] = 1\\narray[1] was in sliding window [0, 1, 2] and flipped == 1,\\nso it actually became 0 and needs to be flipped. \\nflipped ^= 1; array[1] = -1 >> flipped = 0\\n```\n```\\nif i = 2, array[2] = 0\\narray[2] was in sliding window [0, 1, 2] and [1, 2, 3] and flipped == 0,\\nso it is still 0 and needs to be flipped. \\nflipped ^= 1; array[2] = -1 >> flipped = 1\\n```\n```\\n# Notice:\\nif i = 3, array[3] = 1\\narray[3] was not in sliding window [0, 1, 2],\\nbut flipped involves array[0]\\'s flip, \\nwe need to use flipped ^= 1 first to revise it for array[3] and continue the same operation\\n```\n```\\nclass Solution: # best 732 ms\\n    def minKBitFlips(self, array, k):\\n        flipped = 0; length = len(array)\\n        res = 0\\n\\n        for i in range(length):\\n\\t\\t    # revise flipped which didn\\'t affect current index\\n            if i >= k and array[i-k] < 0:\\n                flipped ^= 1\\n\\n\\t\\t\\t# use ^ to know whether array[i] needs to be flipped or not\\n            if not flipped ^ array[i]:\\n\\t\\t\\t    # if current index still needs flip, \\n\\t\\t\\t\\t# the sliding window will be over the length\\n                if i + k > length: return -1   \\n\\t\\t\\t\\t\\n                array[i] = -1; flipped ^= 1\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784150,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0,flip=0;\\n        for(int i=0;i<n;i++){\\n            if(flip%2==nums[i]){\\n                if(i>n-k) return -1;\\n                ans++;\\n                flip++;\\n                nums[i]-=2;\\n                \\n            }\\n            if(i>=k-1 && nums[i-k+1]<0){\\n                flip++;\\n                nums[i-k+1]+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0,flip=0;\\n        for(int i=0;i<n;i++){\\n            if(flip%2==nums[i]){\\n                if(i>n-k) return -1;\\n                ans++;\\n                flip++;\\n                nums[i]-=2;\\n                \\n            }\\n            if(i>=k-1 && nums[i-k+1]<0){\\n                flip++;\\n                nums[i-k+1]+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729212,
                "title": "hard-made-easy-o-n-greedy-solution-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart making the value 1 from the first index of the array and if the value is 0 means we have to flip the value to 1 and consequently we have to flip next K-1 values as well.\\n\\nBut instead of flipping next K-1 value as well, we will keep a counter which says how many times the values need to alter because of previous operation and mark the (i+k)th index of the reset vector to -1.\\n\\n**For ex:** \\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\\nTake a reset vector [0,0,0,0,0,0,0,0] and a counter  = 0\\n\\n**For every values from 0th index to (N-k)th index:**\\n\\n**At nums[0],** we need to flip the nums[0], so we increase the counter by 1 and mark the (0+3)th index of reset vector as -1\\n**nums is [1,0,0,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n**At nums[1],** the values is \\'0\\' but the counter variable says we need to flip the nums[1] one times, so you can observe that it will eventually become \\'1\\'. Hence, nothing to do.\\n**nums is [1,0,0,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n**At nums[2],** the values is \\'0\\' but the counter variable says we need to flip the nums[2] one times, so you can observe that it will eventually become \\'1\\'. Hence, nothing to do.\\n**nums is [1,1,1,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n**At nums[3],** we need to **pay attention**, reset vector at this position is -1, that ,means we have to reduce the effect of one of the operation that had made earlier. Hence , count value gets updated to count = count + rest[3] = 1 + (-1) = 0. Hence no flips made to nums[3]\\nNow, the values at nums[3] is \\'1\\' so no operation is required.\\n**nums is [1,1,1,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n\\n**At nums[4],** the counter variable remains \\'0\\' as counter  + reset[4] = 0 + 0 = 0.\\nBut the values at nums[4] is \\'1\\'. Hence we need to perform one operation of K-flip again. So,we increase the counter by 1 and mark the (4+3)th index of reset vector as -1.\\n**nums is [1,1,1,1,1,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 1**\\n\\n**At nums[5],** the counter variable is updated as counter  + reset[5] = 1 + 0 = 1.\\nand the values at nums[5] is \\'1\\' and we need to flip the value one time, so value becomes \\'0\\'.\\nHence we need to perform one operation of K-flip again. So,we increase the counter by 1 and mark the (5+3)th index of reset vector as -1. \\n**The reset vector index goes out of bound so we can ignore, but its a valid K-flip.**\\n**nums is [1,1,1,1,1,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 2**\\n\\n**At nums[6],** the counter variable is updated as counter  + reset[6] = 2 + 0 = 2.\\nand the values at nums[6] is \\'1\\' and we need to flip the value two times, so no change in value and it is still \\'1\\'.\\nHence we don\\'tneed to perform oany operation of K-flip again.\\n**nums is [1,1,1,1,1,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 2**\\n\\n**At nums[7],** the counter variable is updated as counter  + reset[7] = 2 + -1 = 1.\\nand the values at nums[7] is \\'0\\' and we need to flip the value one time, so value becomes \\'1\\'.\\nHence we need to perform any K-flip operation.\\n**nums is [1,1,1,1,1,1,1,1]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 1\\n**\\n\\nIf you have understood the above implementation you will observe that \\nif counter values is **even** means we don\\'t have to flip the value\\nif its **odd** we have to flip the value\\n**So I have taken flag instead of counter variable and same did with the reset vector.**\\n\\nPlease refer the code.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0;\\n\\n        int i = 0, j = 0;\\n        int n = nums.size();\\n        vector<int> reset(n,0);\\n        \\n        int flag = 1;\\n        while(i<=(n-k)){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                ans++;\\n                if(i+k<n){\\n                    reset[i+k] = 1;\\n                }\\n                flag = !flag;\\n            }\\n            i++;\\n        }\\n\\n        while(i<n){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                return -1;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0;\\n\\n        int i = 0, j = 0;\\n        int n = nums.size();\\n        vector<int> reset(n,0);\\n        \\n        int flag = 1;\\n        while(i<=(n-k)){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                ans++;\\n                if(i+k<n){\\n                    reset[i+k] = 1;\\n                }\\n                flag = !flag;\\n            }\\n            i++;\\n        }\\n\\n        while(i<n){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                return -1;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061620,
                "title": "c-key-observation-diff-arrary",
                "content": "```\\n// key observation:\\n// 1. only one ops can affect the 1st bit.\\n// 2. once 1st bit is settled, only one ops can affect the 2nd bit\\n// 3. so on ... \\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> diff(n + 1);\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++ i)\\n        {\\n            if (i) diff[i] += diff[i - 1];\\n            if (arr[i] ^ (diff[i] % 2) == 0 && i + k - 1 < n)\\n            {\\n                diff[i] += 1;\\n                diff[i + k] -= 1;\\n                cnt ++ ;\\n            }\\n            \\n            if (arr[i] ^ (diff[i] % 2) == 0) return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// key observation:\\n// 1. only one ops can affect the 1st bit.\\n// 2. once 1st bit is settled, only one ops can affect the 2nd bit\\n// 3. so on ... \\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> diff(n + 1);\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++ i)\\n        {\\n            if (i) diff[i] += diff[i - 1];\\n            if (arr[i] ^ (diff[i] % 2) == 0 && i + k - 1 < n)\\n            {\\n                diff[i] += 1;\\n                diff[i + k] -= 1;\\n                cnt ++ ;\\n            }\\n            \\n            if (arr[i] ^ (diff[i] % 2) == 0) return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131369,
                "title": "c-o-n-time-o-1-space",
                "content": "For each idx,\\n(number of flip + A[idx]) % 2 should be 1.\\n\\nThen, how to calculate number of flip?\\n\\nif (number of flip + A[idx]) % 2 is even, increase number of flip.\\nAlso, we need to detect whether any of flipped segments is ended or not.\\nTo check this, whenever flip occurs, update A[idx+K] += 2.\\n\\nThen, for each index, idx, exactly one segment is over if A[idx] >= 2.\\nCheck this for each start of an index.\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flipped = 0;\\n        const int n = A.size();\\n        int ret = 0;\\n        for(int i = 0; i < n; i++) {\\n\\t\\t\\t// If one flipped segment is over, decrease flipped.\\n            if(A[i] > 1)    flipped -= 1;\\n\\t\\t\\t// If we need to flip this index,\\n            if((A[i]+flipped)%2 == 0) {\\n\\t\\t\\t\\t// segment out of range.\\n                if(i + K > n)   return -1;\\n                flipped += 1;\\n\\t\\t\\t\\t// we do not need to check the case, i + K == n \\n                if(i + K < n)   A[i+K] += 2;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flipped = 0;\\n        const int n = A.size();\\n        int ret = 0;\\n        for(int i = 0; i < n; i++) {\\n\\t\\t\\t// If one flipped segment is over, decrease flipped.\\n            if(A[i] > 1)    flipped -= 1;\\n\\t\\t\\t// If we need to flip this index,\\n            if((A[i]+flipped)%2 == 0) {\\n\\t\\t\\t\\t// segment out of range.\\n                if(i + K > n)   return -1;\\n                flipped += 1;\\n\\t\\t\\t\\t// we do not need to check the case, i + K == n \\n                if(i + K < n)   A[i+K] += 2;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048996,
                "title": "c-greedy-queue-one-pass-solution-with-intuitive-explanation",
                "content": "Keep a queue to track the index where flip was initiated. At each node, first check whether the oldest flip is expired or not. Then if there\\'s odd number of flip and current element value is 1, it will initiate another flip. If there\\'s an even number of flip and current value is 0, it will initiate another flip as well.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cnt = 0;\\n        queue<int> flipIdx; // idx where a flip started\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (flipIdx.size() > 0 && i - flipIdx.front() >= K) {\\n                flipIdx.pop();\\n            }\\n            if ((flipIdx.size() % 2 == 1 && A[i] == 1) || (flipIdx.size() % 2 == 0 && A[i] == 0)) {\\n                flipIdx.push(i);\\n                ++cnt;\\n            }\\n        }\\n        if (flipIdx.size() == 0 || (flipIdx.size() == 1 && flipIdx.front() == A.size() - K))\\n            return cnt;\\n        else \\n            return -1;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cnt = 0;\\n        queue<int> flipIdx; // idx where a flip started\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (flipIdx.size() > 0 && i - flipIdx.front() >= K) {\\n                flipIdx.pop();\\n            }\\n            if ((flipIdx.size() % 2 == 1 && A[i] == 1) || (flipIdx.size() % 2 == 0 && A[i] == 0)) {\\n                flipIdx.push(i);\\n                ++cnt;\\n            }\\n        }\\n        if (flipIdx.size() == 0 || (flipIdx.size() == 1 && flipIdx.front() == A.size() - K))\\n            return cnt;\\n        else \\n            return -1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000760,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flip = 0, ans = 0, n = A.size();\\n        vector<int> flipped(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i >= K) { //cancel the influnce of last window\\n                flip ^= flipped[i-K];\\n            }\\n            if (A[i] ^ flip == 0) { //if this bit need flip\\n                if (i + K > n) return -1;\\n                flipped[i] = 1;\\n                ans++;\\n                flip ^= 1; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flip = 0, ans = 0, n = A.size();\\n        vector<int> flipped(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i >= K) { //cancel the influnce of last window\\n                flip ^= flipped[i-K];\\n            }\\n            if (A[i] ^ flip == 0) { //if this bit need flip\\n                if (i + K > n) return -1;\\n                flipped[i] = 1;\\n                ans++;\\n                flip ^= 1; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881737,
                "title": "c-detailed-comments",
                "content": "```\\n// Naive greedy solution, whenever we see a 0, flip the numbers [i, i+k-1]\\n// So that all numbers to the left of i are all 1.\\n// O(n*k)\\n// **Optimized**\\n// Intuition: If we flip 0 or 1 even number of times, the number will remain the same\\n// the value will only change if we flip them odd number of times\\n// So if the index where the original value was 0 has been flipped odd number of times (bcaus it was within the K range from an index), we have a value of 1 and we dont need to do anything\\n// if even, then we need to flip it\\n// Same for 1, if the index has been flipped even number of times, we are all good else we need to flip\\n// So instead of flipping each 0 and the next K digits, we just need to track if an index has been flipped even or odd number of times\\n// and if the number at index i, is 0 and count is even, we increase the step, and if the number is 1 and count is odd, we increase the steps else continue\\n// We need a data structure which will tell us the current flip count of the current index\\n// i.e. when ever we flip a index, we need to increment the flip count of the indexes from [i.. i+k-1]\\n// We can use queue to store the last index which was flipped as part of current continues K flip effort\\n// e.g. If we flipped index i, then queue will store i-k+1\\n// The count of elements in the queue will tell how many times the current index has been flipped\\n// when the top element of the queue is less than i i.e the last index flipped as part of K lenght is before i, pop out \\n// as that flip will not effect any indexes from i and forward\\n// so we are using queue essentially as dual purpose\\n// 1. The flip count for current index\\n// 2. Last index range that was flipped  \\n// O(n), Space: O(K)\\npublic class Solution {\\n    public int MinKBitFlips(int[] A, int K)\\n        {\\n            var len = A.Length;\\n            if (len == 0 || K <= 0)\\n                return -1;\\n\\n        //return Greedy(A, K);\\n        // return GreedyWithQueue(A, K);\\n        \\n        // We dont really need queue, \\n        // we need to track total number of flips so far\\n        // and we need to track the index within K range, so that when we cross that range, we reduce the total flipped count\\n        var steps = 0;\\n        var flippedCount = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  flippedCount % 2 == 0)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;\\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(A[i] == 1 &&  flippedCount % 2 == 1)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;                \\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(i >= (K - 1) && A[i - K + 1] < 0)\\n            {\\n                flippedCount--;\\n                A[i-K + 1] += 2; // Restore the value\\n            } \\n        }\\n        \\n        return steps;\\n       \\n    }\\n    \\n    private static int GreedyWithQueue(int[] A, int K)\\n    {   var len = A.Length;\\n     \\n        // For details read **Optimized** Section above\\n        var q = new Queue<int>();\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  q.Count % 2 == 0)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(A[i] == 1 &&  q.Count % 2 == 1)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(q.Count > 0 && i >= q.Peek()) q.Dequeue();\\n        }\\n        \\n        return q.Count > 0 ? -1 : steps;\\n    }\\n    \\n    private static int Greedy(int[] A, int K)\\n    {\\n        var len = A.Length;\\n        // Greedy approach\\n        // find the first 0, flip and continue.\\n        // All elements left of i will be 1 now\\n        // Repeat\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 1)\\n                continue;\\n            \\n            if(i + K > len)\\n                return -1;\\n            \\n            for(var j = i; j < i + K; j++)\\n            {\\n                A[j] = A[j] ^ 1;\\n            }\\n            \\n            steps++;\\n        }\\n            \\n        return steps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Naive greedy solution, whenever we see a 0, flip the numbers [i, i+k-1]\\n// So that all numbers to the left of i are all 1.\\n// O(n*k)\\n// **Optimized**\\n// Intuition: If we flip 0 or 1 even number of times, the number will remain the same\\n// the value will only change if we flip them odd number of times\\n// So if the index where the original value was 0 has been flipped odd number of times (bcaus it was within the K range from an index), we have a value of 1 and we dont need to do anything\\n// if even, then we need to flip it\\n// Same for 1, if the index has been flipped even number of times, we are all good else we need to flip\\n// So instead of flipping each 0 and the next K digits, we just need to track if an index has been flipped even or odd number of times\\n// and if the number at index i, is 0 and count is even, we increase the step, and if the number is 1 and count is odd, we increase the steps else continue\\n// We need a data structure which will tell us the current flip count of the current index\\n// i.e. when ever we flip a index, we need to increment the flip count of the indexes from [i.. i+k-1]\\n// We can use queue to store the last index which was flipped as part of current continues K flip effort\\n// e.g. If we flipped index i, then queue will store i-k+1\\n// The count of elements in the queue will tell how many times the current index has been flipped\\n// when the top element of the queue is less than i i.e the last index flipped as part of K lenght is before i, pop out \\n// as that flip will not effect any indexes from i and forward\\n// so we are using queue essentially as dual purpose\\n// 1. The flip count for current index\\n// 2. Last index range that was flipped  \\n// O(n), Space: O(K)\\npublic class Solution {\\n    public int MinKBitFlips(int[] A, int K)\\n        {\\n            var len = A.Length;\\n            if (len == 0 || K <= 0)\\n                return -1;\\n\\n        //return Greedy(A, K);\\n        // return GreedyWithQueue(A, K);\\n        \\n        // We dont really need queue, \\n        // we need to track total number of flips so far\\n        // and we need to track the index within K range, so that when we cross that range, we reduce the total flipped count\\n        var steps = 0;\\n        var flippedCount = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  flippedCount % 2 == 0)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;\\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(A[i] == 1 &&  flippedCount % 2 == 1)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;                \\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(i >= (K - 1) && A[i - K + 1] < 0)\\n            {\\n                flippedCount--;\\n                A[i-K + 1] += 2; // Restore the value\\n            } \\n        }\\n        \\n        return steps;\\n       \\n    }\\n    \\n    private static int GreedyWithQueue(int[] A, int K)\\n    {   var len = A.Length;\\n     \\n        // For details read **Optimized** Section above\\n        var q = new Queue<int>();\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  q.Count % 2 == 0)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(A[i] == 1 &&  q.Count % 2 == 1)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(q.Count > 0 && i >= q.Peek()) q.Dequeue();\\n        }\\n        \\n        return q.Count > 0 ? -1 : steps;\\n    }\\n    \\n    private static int Greedy(int[] A, int K)\\n    {\\n        var len = A.Length;\\n        // Greedy approach\\n        // find the first 0, flip and continue.\\n        // All elements left of i will be 1 now\\n        // Repeat\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 1)\\n                continue;\\n            \\n            if(i + K > len)\\n                return -1;\\n            \\n            for(var j = i; j < i + K; j++)\\n            {\\n                A[j] = A[j] ^ 1;\\n            }\\n            \\n            steps++;\\n        }\\n            \\n        return steps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238819,
                "title": "c-queue-based-method-o-n",
                "content": "THe idea is simple : we scan each element from left to right. Whenever we find an element 0, we have to flip a K-length subarray. Thus a naive method works in O(NK) complexity.\\nThis is not acceptable if both N and K are large.\\n\\nThe workaround is simple as well. Whenever we find an element is 0, we push its index i into the queue. The question is how to know whether A[i] is 0 or not after having many flips? If originally A[i]==0, and we have flipped even number times, then A[i] will still be 0. On the other hand, if A[i]==1, and we have flipped odd number times, then A[i] will be 0. So the condition is (A[i]+q.size())%2==0).\\n\\n\\n    int helper_queue(vector<int> & A, int K){\\n        int res = 0;\\n        const int m = A.size();\\n        queue<int> q;\\n        for(int i = 0; i < m; i++){\\n            if(!q.empty()&&i+q.front()>=K)\\n                q.pop();\\n            if((A[i]+q.size())%2==0){\\n                if(i>m-K)\\n                    return -1;\\n                q.push(-i);\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "THe idea is simple : we scan each element from left to right. Whenever we find an element 0, we have to flip a K-length subarray. Thus a naive method works in O(NK) complexity.\\nThis is not acceptable if both N and K are large.\\n\\nThe workaround is simple as well. Whenever we find an element is 0, we push its index i into the queue. The question is how to know whether A[i] is 0 or not after having many flips? If originally A[i]==0, and we have flipped even number times, then A[i] will still be 0. On the other hand, if A[i]==1, and we have flipped odd number times, then A[i] will be 0. So the condition is (A[i]+q.size())%2==0).\\n\\n\\n    int helper_queue(vector<int> & A, int K){\\n        int res = 0;\\n        const int m = A.size();\\n        queue<int> q;\\n        for(int i = 0; i < m; i++){\\n            if(!q.empty()&&i+q.front()>=K)\\n                q.pop();\\n            if((A[i]+q.size())%2==0){\\n                if(i>m-K)\\n                    return -1;\\n                q.push(-i);\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2629720,
                "title": "python-o-n-solution-explained",
                "content": "I tried the brute force way to take each subarray that starts with 0 and flip each number manually from 0 to 1 and 1 to 0 but to no surprise, it showed TLE for large inputs.\\n\\nCouldn\\'t think of an optimized solution so had to head over to the discussion section and came across this - https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/239284/C%2B%2B-greedy-stack-and-O(1)-memory\\n\\nIf you take a look at the first comment under this post, that explains everything in detail so you get a clear idea what exactly the code is doing.\\n\\nHere is my explanation of it - \\n\\nWe only flip a window if it starts with a 0 because we want the whole array to have only 1s. So we are not concered with 1s here. The main motive is to convert all 0 to 1 (If it is possible).\\n\\nThe brute force way is to check each window and then for each window, if it starts with 0, take each element and flip it. But ofcourse that is not efficient way because we will do repeatitive work.\\n\\n\\te.g. suppose nums = [0,1,0,1,0,1] and k = 3\\n\\tSo it we take the first 3 length subarray we get [0,1,0]\\n\\n\\tAnd since it starts with 0, we flip each element to get [1,0,1] and so array becomes \\n\\t\\t\\t[1,0,1,1,0,1]\\n\\t\\t\\t\\n\\tNow when we go to next subarray of size 3, we get [0,1,1]\\n\\tAnd again for the same reason, we flip it to get [1,0,0] and array becomes \\n\\t\\t\\t\\n\\t\\t\\t[1,1,0,0,0,1]\\n\\t\\t\\t\\nBut did you notice that we flipped the second number in original array twice which resulted in it becoming the same as it was in the beginning. So first we flipped 1 to 0 and then we flipped 0 to 1. Eventually, we got the same number back. So our flipping is of no use for some cases.\\n\\nIn Simple words -\\n\\n\\t\\tFlipping 1 or 0 Even Number of times will give us the same number\\n\\t\\tFlipping 1 or 0 Odd Number of times will give us the opposite\\n\\t\\t\\nAnd since we want to convert all 0 to 1 and do not want to convert 1 to 0, we can say \\n\\n\\t  If a number is 0, flip it once if it has already been flipped even number of times\\n\\t  If a number is 1, flip is once if it has already been flipped odd number of times\\n\\t  \\nBecause in both cases, we will get back 1. Which is our main motive here.\\n\\nAnd now the main thing is to have a way to check if a current index has been flipped before? If yes, then how many times - Even number of times or Odd number of times.\\n\\nAnd that\\'s where Queue comes into the picture.  We will use the queue to keep track of all the k-length windows that have been flipped. And as we complete traversing a k length window, we will also remove it from queue as we no longer need to keep track of it.\\n\\nThe reason why we have to keep track is because of the same reason I explained above where we were flipping a 1 twice, just to get back 1 which was of no use. \\n\\n\\t\\t\\te.g. [0,0,0,1,0,1,1,0], k = 3\\n\\t\\t\\t\\nIf we take a subarray of size k, we get [0,0,0]\\nBecause it starts with a 0 we can flip it. But we also need to check if it has already been flipped even number of times or not. Because only then we know it was 0 and again it became 0 after even flips. Since currently queue is empty or length is 0, it basically means even flips because 0 % 2 == 0 So we can flip this window.\\n\\t\\nAnd to track the flips for this window, we will also put the last index of this window in a queue. The last index is 2 i.e., (i + k - 1)\\n\\t\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [2]\\n\\t\\tflips = 1\\n\\nSo now you can see that this queue basically tells how many times any element till index = 2 has been flipped. Since length of queue is 1, that means each element was flipped once. \\n\\n\\t\\tNext window of size = 3 is [0,0,1] from index 1 to 3\\n\\t\\nHere, as it starts with a 0, we check is the length of queue even i.e., has this 0 been flipped even times? NO! Length of queue is 1 that means, this 0 has been flipped once so we do not need to flip it again as one flip has already turned it into a 1.\\n\\n\\t\\tNext window of size 3 = [0,1,0] from index 2 to 4\\n\\t\\t\\nAgain, it starts from a 0. And for the same reason as above, we do nothing as length of queue is odd so this 0 has been flipped odd times so it is already 1. \\n\\nAnd now, we move to index = 3 which means we are done with the window from index 0 to 2 of length 3. So we no longer need to track it in the queue and so, we remove the last index of previous window from the queue.\\n\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = []\\n\\t\\tflips = 1\\n\\n\\tWe are now at index = 3 and the window of size k is [1,0,1]\\n\\nWe see that at index = 3, we have 1. We know that we will flip a 1 only if it has been flipped odd number of times because only in that case this 1 would\\'ve converted to 0. Here, length of queue = 0 which is even. So no need to flip. \\n\\nDo note that we only add the index of last window element if we flip this window. Here we did not flip the window [1,0,1] from index = 3 to 5\\n\\n\\tNext window is [0,1,1] from index = 4 to 6\\n\\nWe see that at index = 4, we have 0. We check if this window has been flipped even times before. We see that length of queue == 0 which is even. So yes, we have to flip this window to convert this 0 to 1. And so, we also add the last index of this window in the queue to keep track of flips.\\n\\t\\t\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [6]\\n\\t\\tflips = 2\\n\\nNext window is [1,1,0] from index = 5 to 7\\n\\nSince the first element is 1, we check the length of queue. Length is 1, which is odd. So it means, this 1 has been flipped odd number of times before which means it should be 0 right now (if we had manually flipped). So to turn it back to 1, it needs to be flipped one more time. Hence, we flip this window and so, we also put the last index of this window in the queue.\\n\\t\\t\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [6,7]\\n\\t\\tflips = 3\\n\\t\\t\\nNext, we reach the index = 6. And we see that at index = 6, we have 1. Since length of queue is even, it means that this 1 has not changed to 0 after all the previous flips. So we do not flip it.\\n\\nBut since we are done with index 6, we can safely remove it from queue.\\n\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [7]\\n\\t\\tflips = 3\\n\\t\\t\\nAnd finally, we are at index = 7. We have 0. Since queue is of odd length now, it means 0 has been flipped odd times and so it has become 1. So no need to flip. And as we are done with index = 7, we can remove it from queue.\\n\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = []\\n\\t\\tflips = 3\\n\\t\\t\\nAnd loop ends and we see that since queue is empty, that means, we did 3 k-bit flips to convert all elements to 1.\\n\\n# **WHEN CAN WE NOT CONVERT ALL 0 TO 1?**\\nThe above example was for a valid array in which we can do 3 k-bit flips to turn all 0 to 1. What about invalid cases. How to check those?\\n\\n\\tLets take - nums = [1,1,0], k = 2\\n\\tq = []\\n\\t\\nWe start with first index. As it is 1 and length of q is even, that means we don\\'t need to flip it.\\nWe come to the index = 1. Here again, we have 1 and length of q is even. So no flips.\\nThen we come to index = 2. Here we have 0. Since length of queue is even, that means we need to flip it. And also we store the last index of this window in the queue i.e., i + k - 1 => 2 + 2 - 1 => 3\\n\\nSo, \\n\\t\\n\\tnums = [1,1,0], k = 2\\n\\tflips = 1\\n\\tq = [3]\\n\\t\\nBut now our loop ends. And our queue is not empty. This means No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\\n\\nIt the array was [1,1,0,0] then we would be able to flip the last two zeros to 1 and in that case, queue would be empty.\\n\\nIn simple words - \\n\\n\\t\\tIf queue is empty, we can do some or 0 k-bit flips to get all 1s in the array\\n\\t\\tIf queue is not empty, there is no way to get all 1s by doing k-bit flips\\n\\n\\n```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = 0\\n        q = deque()\\n        \\n        for i,num in enumerate(nums):\\n            # Number of Items in queue = how many times current index has been flipped\\n            # So if 0 is flipped even times, it will be 0 again. That means, we need to flip it again\\n            # Similarly, if 1 is flipped odd times, it will be 0 again. So we need to again flip it to get 1 back\\n            \\n            condition1 = num == 0 and len(q) % 2 == 0\\n            condition2 = num == 1 and len(q) % 2 != 0\\n            \\n            # If any of the two conditions are true, that means we need to flip this k-length window\\n            # So put the last index of this window in queue to keep track of flips\\n            if condition1 or condition2: \\n                flips += 1\\n                q.append(i + k - 1)\\n            \\n            # Remove the index from queue if we are done traversing the k-length window\\n            if q and i >= q[0]: q.popleft()\\n        \\n        return -1 if q else flips\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = 0\\n        q = deque()\\n        \\n        for i,num in enumerate(nums):\\n            # Number of Items in queue = how many times current index has been flipped\\n            # So if 0 is flipped even times, it will be 0 again. That means, we need to flip it again\\n            # Similarly, if 1 is flipped odd times, it will be 0 again. So we need to again flip it to get 1 back\\n            \\n            condition1 = num == 0 and len(q) % 2 == 0\\n            condition2 = num == 1 and len(q) % 2 != 0\\n            \\n            # If any of the two conditions are true, that means we need to flip this k-length window\\n            # So put the last index of this window in queue to keep track of flips\\n            if condition1 or condition2: \\n                flips += 1\\n                q.append(i + k - 1)\\n            \\n            # Remove the index from queue if we are done traversing the k-length window\\n            if q and i >= q[0]: q.popleft()\\n        \\n        return -1 if q else flips\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2415713,
                "title": "c-modular-solution-thought-process",
                "content": "I had no idea how to solve it just by thinking alone, so I wrote some examples to observe if there\\'re any patterns. Let\\'s think reversely from a vector with all 1 and flip some random indexes:\\n\\n```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 0 1 0 0 1 1\\n//       ^^^^^ flip\\n// 1 1 1 0 0 0 1 1\\n//   ^^^^^ flip\\n```\\n\\n**Observation 1**: Flipping at the same index `i=1` will cancel out the effects for bit `i`. Flipping 3,5,7,... times is equal to flipping 1 time. Flipping 2,4,6,... times is equal to not flipping at all. So we only need to decide whether to flip at index `i`. There are `n-k+1` indexes to decide. If we brute-force our way that means there\\'re `2^(n-k+1)` combinations which is too big.\\n\\nThen I wrote the second example:\\n\\n```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 1 1 0 1 1 1\\n//     ^^^^^ flip\\n// 1 0 1 0 1 0 1 1\\n//       ^^^^^ flip\\n```\\n\\nWe know the answer requires 3 flips. What if we don\\'t know the answer? We could scan from left to right and decide whether we want to flip k bits from the index `i`. Here\\'s another observation I made at this point:\\n\\n**Observation 2**: If we scan from left to right, we must flip from index `i` if the current bit is `0`, otherwise the answer would be false if we skip to the next index. Similarly, we must not flip from index `i` if the current bit is `1`.\\n\\nIn the above example, we must flip at `i==1`, otherwise the bit `0` will be left behind and we\\'ll never have a chance to have every bit as 1.\\n\\n**Time complexity analysis (naive)**: So it looks like we can use greedy approach, simply scan from left to right and flip bits from `i` to `i+k-1`. Why is this problem hard? It left me scratching my head. But I soon realized why when I tried to analyze the time complexity. If we flip `k` bits from each index, there\\'re `n-k+1` possible indexes to flip, so we have `k*(n-k+1)` operations to do. If `k==n/2` it will be `n/2 * (n - n/2 + 1)` which is approximately `n/2 * n/2 == n^2/4`. It will definitely TLE with `n == 10^5`.\\n\\nScanning from left to right is critical for greedy algorithm to work, so it looks like we need to look for other places to optimize. What about the flipping `k` bits operation at each index `i`? It\\'s still hard for me to think any optimization tips, so I wrote the third example with `k == n/2` and a larger `n == 10`:\\n\\n```plaintext\\n// 1 1 1 1 1 1 1 1 1 1, k=5\\n// 0 0 0 0 0 1 1 1 1 1\\n// ^^^^^^^^^ range=[0,4]\\n// 0 1 1 1 1 0 1 1 1 1\\n//   ^^^^^^^^^ range=[1,5]\\n// 0 1 0 0 0 1 0 1 1 1\\n//     ^^^^^^^^^ range=[2,6]\\n// 0 1 0 1 1 0 1 0 1 1\\n//       ^^^^^^^^^ range=[3,7]\\n// 0 1 0 1 0 1 0 1 0 1\\n//         ^^^^^^^^^ range=[4,8]\\n// 0 1 0 1 0 0 1 0 1 0\\n//           ^^^^^^^^^ range=[5,9]\\n```\\n\\nSuppose if the current `i==2`, the original bit is `0`, but it will be affected by the previous 2 flips with ranges `[0,4]` and `[1,5]`. Simiarly, if the current `i==5`, it will not be affected by range `[0,4]` since `5` doesn\\'t fall under the range. So we only need to check the ending number in each range. We can also observe that the ending numbers form a strictly increasing array. To get the correct bit value, we can count the number of ranges that affect the current index. If the number of ranges is 0,2,4,6,... it means the original bit is not affected, otherwise the bit is affected (0->1, 1->0).\\n\\n**Optimization**: When flipping the bit at index `i`, we push back the ending number of the affecting range `[i, i+k-1]` to an array. And later when we are at another higher index `j` we check if the oldest range in the array doesn\\'t affect the current index `j` anymore, if so, we remove the front ending number from the array. Then we calculate the corrected bit at the current index by counting the number of ranges.\\n\\n**Time complexity (optimized)**: We still iterate from left to right, but we only push/pop from the ending number array with at most 1 operation, so the overall time complexity is `O(n)`\\n\\nAfter writing down the examples, the approach and the time complexity analysis, it took just a few minutes to implement the idea and got accepted:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> flipRangeEnds; // inclusive\\n        int numFlips = 0;\\n        for (int i = 0; i < nums.size() - k + 1; i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) {\\n                numFlips++;\\n                // Add the range, it will affect indexes [i, i+k-1]\\n                flipRangeEnds.push_back(i + k - 1);\\n            }\\n        }\\n        return isRemainingBitsAllOne(nums, k, flipRangeEnds) ? numFlips : -1;\\n    }\\n    \\n    bool isRemainingBitsAllOne(const vector<int>& nums, const int k, deque<int> &flipRangeEnds) {\\n        for (int i = nums.size() - k + 1; i < nums.size(); i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void removeUnaffectedRanges(const int i, deque<int> &flipRangeEnds) {\\n        if (flipRangeEnds.empty()) return;\\n        if (flipRangeEnds.front() < i) {\\n            flipRangeEnds.pop_front();\\n        }\\n    }\\n    \\n    int getBit(const vector<int>& nums, const int i, const deque<int> &flipRangeEnds) {\\n        const int numFlips = flipRangeEnds.size();\\n        return (nums[i] + numFlips) % 2;\\n    }\\n};\\n```\\n\\nI was stuggling whether to merge the main `for` loop with `isRemainingBitsAllOne`, but separating them would make the code more readable so I just kept it as it is.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 0 1 0 0 1 1\\n//       ^^^^^ flip\\n// 1 1 1 0 0 0 1 1\\n//   ^^^^^ flip\\n```\n```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 1 1 0 1 1 1\\n//     ^^^^^ flip\\n// 1 0 1 0 1 0 1 1\\n//       ^^^^^ flip\\n```\n```plaintext\\n// 1 1 1 1 1 1 1 1 1 1, k=5\\n// 0 0 0 0 0 1 1 1 1 1\\n// ^^^^^^^^^ range=[0,4]\\n// 0 1 1 1 1 0 1 1 1 1\\n//   ^^^^^^^^^ range=[1,5]\\n// 0 1 0 0 0 1 0 1 1 1\\n//     ^^^^^^^^^ range=[2,6]\\n// 0 1 0 1 1 0 1 0 1 1\\n//       ^^^^^^^^^ range=[3,7]\\n// 0 1 0 1 0 1 0 1 0 1\\n//         ^^^^^^^^^ range=[4,8]\\n// 0 1 0 1 0 0 1 0 1 0\\n//           ^^^^^^^^^ range=[5,9]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> flipRangeEnds; // inclusive\\n        int numFlips = 0;\\n        for (int i = 0; i < nums.size() - k + 1; i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) {\\n                numFlips++;\\n                // Add the range, it will affect indexes [i, i+k-1]\\n                flipRangeEnds.push_back(i + k - 1);\\n            }\\n        }\\n        return isRemainingBitsAllOne(nums, k, flipRangeEnds) ? numFlips : -1;\\n    }\\n    \\n    bool isRemainingBitsAllOne(const vector<int>& nums, const int k, deque<int> &flipRangeEnds) {\\n        for (int i = nums.size() - k + 1; i < nums.size(); i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void removeUnaffectedRanges(const int i, deque<int> &flipRangeEnds) {\\n        if (flipRangeEnds.empty()) return;\\n        if (flipRangeEnds.front() < i) {\\n            flipRangeEnds.pop_front();\\n        }\\n    }\\n    \\n    int getBit(const vector<int>& nums, const int i, const deque<int> &flipRangeEnds) {\\n        const int numFlips = flipRangeEnds.size();\\n        return (nums[i] + numFlips) % 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921449,
                "title": "python-o-1",
                "content": "Credit to: https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/238609/JavaC%2B%2BPython-One-Pass-and-O(1)-Space\\n\\u597D\\u9AD8\\u7EA7\\u7684\\u5199\\u6CD5\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # even fliped = no flip\\n        # odd fliped = flip once\\n        \\n        fliped = 0\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if i >= k and nums[i-k]>1: #\\u5F53win size\\u8D85\\u51FA\\u8303\\u56F4\\uFF0C\\u800C\\u4E14\\u90A3\\u4E2A\\u6570\\u662F\\u4E4B\\u524D\\u7FFB\\u8F6C\\u8FC7\\u7684\\u6570\\uFF0C\\u91CD\\u7F6Efliped(\\u51C6\\u786E\\u8BA1\\u7B97\\u4E0B\\u4E00\\u6570flip\\u7684\\u4E2A\\u6570)\\n                fliped -= 1\\n                nums[i-k] -= 2  # \\u628Aflip\\u540E\\u6807\\u8BB0\\u7684\\u6570\\u53D8\\u56DE\\u539F\\u6765\\u7684\\u6570\\u5B57\\n            if fliped%2 == nums[i]: # 0 flip even time is 0, 1 flip odd time is 0,\\u8FD9\\u79CD\\u60C5\\u51B5\\u9700\\u8981\\u7FFB\\u8F6C\\n                if i + k > n:\\n                    return -1\\n                ans += 1\\n                fliped += 1\\n                nums[i] += 2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # even fliped = no flip\\n        # odd fliped = flip once\\n        \\n        fliped = 0\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if i >= k and nums[i-k]>1: #\\u5F53win size\\u8D85\\u51FA\\u8303\\u56F4\\uFF0C\\u800C\\u4E14\\u90A3\\u4E2A\\u6570\\u662F\\u4E4B\\u524D\\u7FFB\\u8F6C\\u8FC7\\u7684\\u6570\\uFF0C\\u91CD\\u7F6Efliped(\\u51C6\\u786E\\u8BA1\\u7B97\\u4E0B\\u4E00\\u6570flip\\u7684\\u4E2A\\u6570)\\n                fliped -= 1\\n                nums[i-k] -= 2  # \\u628Aflip\\u540E\\u6807\\u8BB0\\u7684\\u6570\\u53D8\\u56DE\\u539F\\u6765\\u7684\\u6570\\u5B57\\n            if fliped%2 == nums[i]: # 0 flip even time is 0, 1 flip odd time is 0,\\u8FD9\\u79CD\\u60C5\\u51B5\\u9700\\u8981\\u7FFB\\u8F6C\\n                if i + k > n:\\n                    return -1\\n                ans += 1\\n                fliped += 1\\n                nums[i] += 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751996,
                "title": "c-beginner-friendly-explained-solution-easy-understandable",
                "content": "\\n\\n         Note that we dont actually flip the values in the array. \\n\\t\\t Since all possible values are 0 and 1, we can simply use a knowledge of \\n\\t\\t \"how many times\" any given index has been flipped to know the whats the current \\n\\t\\t state of the value is.\\n\\t\\t \\n\\t\\t We can use our queue to keep track of how many times the window/interval has been\\n\\t\\t flipped and whats the last index (end of any k -window) of a current interval that was \\n\\t\\t flipped and keep popping off these indexes from the queue when we are done\\n\\t\\t with traversing that k-interval. Thus , as you can see our queue is a dual-purpose queue\\n        \\n\\t\\t  int minKBitFlips(vector<int>& nums, int k) {\\n            int n=nums.size();\\n            int count=0;\\n            queue<int> q;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(nums[i]==0)\\n                    {\\n                      if(q.empty() || q.size()%2==0)\\n                      {\\n                        count++;\\n                              q.push(i+k-1);\\n                      }\\n                            \\n                    }\\n                    else\\n                    {\\n                            if(q.size()%2!=0)\\n                            {\\n                                    count++;\\n                                    q.push(i+k-1);\\n                            }\\n                    }\\n                    // k length  window if i >= window\\'s end pop it \\n                    if(!q.empty() && i>=q.front())\\n                    {\\n                            q.pop();\\n                    }\\n            }\\n            if(q.empty())\\n            return count;\\n            else\\n            {\\n                    return -1;\\n            }\\n            \\n    }",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "\\n\\n         Note that we dont actually flip the values in the array. \\n\\t\\t Since all possible values are 0 and 1, we can simply use a knowledge of \\n\\t\\t \"how many times\" any given index has been flipped to know the whats the current \\n\\t\\t state of the value is.\\n\\t\\t \\n\\t\\t We can use our queue to keep track of how many times the window/interval has been\\n\\t\\t flipped and whats the last index (end of any k -window) of a current interval that was \\n\\t\\t flipped and keep popping off these indexes from the queue when we are done\\n\\t\\t with traversing that k-interval. Thus , as you can see our queue is a dual-purpose queue\\n        \\n\\t\\t  int minKBitFlips(vector<int>& nums, int k) {\\n            int n=nums.size();\\n            int count=0;\\n            queue<int> q;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(nums[i]==0)\\n                    {\\n                      if(q.empty() || q.size()%2==0)\\n                      {\\n                        count++;\\n                              q.push(i+k-1);\\n                      }\\n                            \\n                    }\\n                    else\\n                    {\\n                            if(q.size()%2!=0)\\n                            {\\n                                    count++;\\n                                    q.push(i+k-1);\\n                            }\\n                    }\\n                    // k length  window if i >= window\\'s end pop it \\n                    if(!q.empty() && i>=q.front())\\n                    {\\n                            q.pop();\\n                    }\\n            }\\n            if(q.empty())\\n            return count;\\n            else\\n            {\\n                    return -1;\\n            }\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1683054,
                "title": "java-pref-sum",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] pref=new int[n];\\n        for(int i=0; i<n; i++){\\n            if(i==0){\\n                if(nums[i]==0){\\n                    pref[i]++;\\n                }\\n            }else{\\n                pref[i]=pref[i-1];\\n                int flips=pref[i]-((i-k)>=0?pref[i-k]:0);\\n                if(flips%2==nums[i]){\\n                    if(i+k>n){\\n                        return -1;\\n                    }\\n                    pref[i]++;\\n                }\\n            }\\n        }\\n        return pref[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] pref=new int[n];\\n        for(int i=0; i<n; i++){\\n            if(i==0){\\n                if(nums[i]==0){\\n                    pref[i]++;\\n                }\\n            }else{\\n                pref[i]=pref[i-1];\\n                int flips=pref[i]-((i-k)>=0?pref[i-k]:0);\\n                if(flips%2==nums[i]){\\n                    if(i+k>n){\\n                        return -1;\\n                    }\\n                    pref[i]++;\\n                }\\n            }\\n        }\\n        return pref[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460036,
                "title": "greedy-odd-even-logic",
                "content": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    int ans;\\npublic:\\n    int solver(vector<int>& a,int k){\\n        int n=a.size(),i=0,cnt=0;\\n        int p[n+k+2];\\n        memset(p,0,sizeof(p));\\n        \\n\\t\\t// if 1st element is 0 we flip it and store that a flip was made in the prefix function\\n        if(a[0]==0){\\n            p[0]++;\\n            p[k]--;\\n            cnt++;\\n        }\\n        \\n        for(i=1;i<n;i++){\\n\\t\\t\\t// this tell us inside how many flipped windows ith element has fallen i.e no of times ith element has been flipped\\n            p[i]+=p[i-1];\\n\\t\\t\\t\\n\\t\\t\\t// if element is 1 and has been flipped odd times we need to flip it again to make it 0\\n            if(a[i]==1){\\n                if(p[i]&1){\\n                    p[i]++;\\n                    cnt++;\\n\\t\\t\\t\\t\\t// if choosing a flipping window some part of window falls outside the range then return NOT POSSIBLE\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n            else{ // similar logic to flip 0->1\\n                if(p[i]%2==0){\\n                    p[i]++;\\n                    cnt++;\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minKBitFlips(vector<int>& a, int k) {\\n        IOS;\\n\\t\\t// perform same operation on both original array as well as reversed version of array\\n        ans=solver(a,k);\\n        reverse(a.begin(),a.end());\\n        ans=min(ans,solver(a,k));\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    int ans;\\npublic:\\n    int solver(vector<int>& a,int k){\\n        int n=a.size(),i=0,cnt=0;\\n        int p[n+k+2];\\n        memset(p,0,sizeof(p));\\n        \\n\\t\\t// if 1st element is 0 we flip it and store that a flip was made in the prefix function\\n        if(a[0]==0){\\n            p[0]++;\\n            p[k]--;\\n            cnt++;\\n        }\\n        \\n        for(i=1;i<n;i++){\\n\\t\\t\\t// this tell us inside how many flipped windows ith element has fallen i.e no of times ith element has been flipped\\n            p[i]+=p[i-1];\\n\\t\\t\\t\\n\\t\\t\\t// if element is 1 and has been flipped odd times we need to flip it again to make it 0\\n            if(a[i]==1){\\n                if(p[i]&1){\\n                    p[i]++;\\n                    cnt++;\\n\\t\\t\\t\\t\\t// if choosing a flipping window some part of window falls outside the range then return NOT POSSIBLE\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n            else{ // similar logic to flip 0->1\\n                if(p[i]%2==0){\\n                    p[i]++;\\n                    cnt++;\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minKBitFlips(vector<int>& a, int k) {\\n        IOS;\\n\\t\\t// perform same operation on both original array as well as reversed version of array\\n        ans=solver(a,k);\\n        reverse(a.begin(),a.end());\\n        ans=min(ans,solver(a,k));\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1090692,
                "title": "java-greedy-o-n-k",
                "content": "\\n    // O(A.length*K)\\n\\tpublic int minKBitFlips(int[] A, int K) {\\n\\n\\t\\tint ans = 0, len = A.length;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] == 0) {\\n\\t\\t\\t\\tif (len - i < K)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\ttoggleKBits(A, K, i);\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(K)\\n\\tpublic void toggleKBits(int[] A, int K, int idx) {\\n\\t\\tfor (int i = 0; i < K; i++) {\\n\\t\\t\\tA[idx] = A[idx] ^ 1;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n    \\n",
                "solutionTags": [],
                "code": "\\n    // O(A.length*K)\\n\\tpublic int minKBitFlips(int[] A, int K) {\\n\\n\\t\\tint ans = 0, len = A.length;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] == 0) {\\n\\t\\t\\t\\tif (len - i < K)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\ttoggleKBits(A, K, i);\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(K)\\n\\tpublic void toggleKBits(int[] A, int K, int idx) {\\n\\t\\tfor (int i = 0; i < K; i++) {\\n\\t\\t\\tA[idx] = A[idx] ^ 1;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1051312,
                "title": "swift-solution-with-inline-explanation",
                "content": "```\\nclass Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        var count = A.count\\n        \\n        // Keeps track of number the flips that affect the element at the current index\\n        var flipCount = 0\\n        var res = 0\\n        \\n        // Whether a flip was done at an index\\n        var isFlippedAt = Array(repeating: 0, count: count)\\n        \\n        for i in 0..<A.count {\\n            if i >= K {\\n                // at index i the flip the happened at index i-K does not affect it\\n                // so we need to remove that flip\\n                flipCount -= isFlippedAt[i-K]\\n            } \\n            \\n            if A[i] == 0 && flipCount % 2 == 1 {\\n                // if the flip count is odd that means the current bit is flipped\\n                // and if the current bit is 0 it is flipped to a 1\\n                // which is what we want\\n                // so do nothing\\n                continue\\n            } else if A[i] == 1 && flipCount % 2 == 0 {\\n                // if the flip count is 0\\n                // that means the current element stays the same\\n                // which is what we want if the current element is 1\\n                continue\\n            } else {\\n                // we get here if the flipCount is odd and current element is 1\\n                // or if the flipCount is even and the current element is 0\\n                // in which case 1 turned into a 0 or a 0 stayed as a 0\\n                // and we need to perform a flip at the current index\\n                // affecting elements from i to i+K-1\\n                \\n                // NOTE: the flip on effects the K elements starting from the current index\\n                // no elements before it are affected by this flip\\n                \\n                if (i+K) > count {\\n                    // we can possibly flip starting at this index\\n                    return -1\\n                }\\n                \\n                isFlippedAt[i] = 1\\n                flipCount += 1\\n                res += 1\\n            }\\n        }\\n        \\n        return res\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        var count = A.count\\n        \\n        // Keeps track of number the flips that affect the element at the current index\\n        var flipCount = 0\\n        var res = 0\\n        \\n        // Whether a flip was done at an index\\n        var isFlippedAt = Array(repeating: 0, count: count)\\n        \\n        for i in 0..<A.count {\\n            if i >= K {\\n                // at index i the flip the happened at index i-K does not affect it\\n                // so we need to remove that flip\\n                flipCount -= isFlippedAt[i-K]\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 752515,
                "title": "simple-c-o-n",
                "content": "```\\nint minKBitFlips(vector<int>& A, int K) {\\n\\tvector<int> flip(A.size(), 0);\\n\\tint f = 0;\\n\\tint tot = 0;\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t\\tif ((f & 1) == A[i]) {\\n\\t\\t\\t++tot;\\n\\t\\t\\t++f;\\n\\n\\t\\t\\tif (i + K - 1 >= A.size()) return -1;\\n\\t\\t\\tflip[i + K - 1] = 1;\\n\\t\\t}\\n\\t\\tf -= flip[i];\\n\\t}\\n\\treturn tot;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minKBitFlips(vector<int>& A, int K) {\\n\\tvector<int> flip(A.size(), 0);\\n\\tint f = 0;\\n\\tint tot = 0;\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t\\tif ((f & 1) == A[i]) {\\n\\t\\t\\t++tot;\\n\\t\\t\\t++f;\\n\\n\\t\\t\\tif (i + K - 1 >= A.size()) return -1;\\n\\t\\t\\tflip[i + K - 1] = 1;\\n\\t\\t}\\n\\t\\tf -= flip[i];\\n\\t}\\n\\treturn tot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545584,
                "title": "easy-to-understand-and-clean-c-code",
                "content": "inserting last element in queue which will be affected if toogles are made on ith index i.e i+k-1 and then checking for each index what is the size of queue if it is even then it emplies even number of toggles are made uptill now on that index and therefore complexity reduces to O(n);\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n       int n=a.size(),count=0;\\n    queue<int> flip;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==1)\\n            {\\n                if((flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(a[i]==0)\\n            {\\n                if(!(flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(!flip.empty()&&flip.front()<=i)\\n                flip.pop();\\n        }\\n        if(flip.empty())\\n            return count;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n       int n=a.size(),count=0;\\n    queue<int> flip;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==1)\\n            {\\n                if((flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(a[i]==0)\\n            {\\n                if(!(flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(!flip.empty()&&flip.front()<=i)\\n                flip.pop();\\n        }\\n        if(flip.empty())\\n            return count;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517280,
                "title": "detailed-explanation-on-the-o-n-time-and-o-n-space-solution-with-bit-operation",
                "content": "### greedy mind \\nThe question asks how many consecutive flips are needed, so we can use a greedy concept to solve. The intuition is that, thinking of the very first element, look rightwards by k step, if the A[0] ==0, we definitely need to flip this position, then for every other elements in this k size window, if it has been flipped to, or is originally 1, we should skip and keep moving rightwards. Thus, we need to have a for loop, and each i index denotes the **start position** of this k length window. The -1 case is that, if at the index that i+k>total length, but we also find this indexed position needs to be flipped, then its game over, return -1, as the window would be out of the array range. \\n\\n\\n\\n### when does this position need a flip?\\n- if the arr(i)==0 and this position is never flipped, so obviously we need 1 flip. \\n- - if the arr(i)==0 and this position has been flipped once (or any odd times),  we dont need to touch here anymore. \\n- if the arr(i) ==1 and  this position is never flipped, as per the greedy mind, we can continue, so dont need flip at all \\n- if the arr(i) ==1 and  this position has been ever flipped once (or any odd times), this position value must be 0, so we need to have another flip. \\n\\nSo we can have a global variable *prevFlippedState* to denote **for how many times this position has been filpped before**. If the prevFlippedState is even or 0, this means that this position has been never, or reset to its original value, otherwise, this position has been flipped to the value that is opposite to its original value. Plus, we dont need to accumulate the times, instead, we just keep XOR on prevFlippedState to get even/odd indicator. Hence we can reach the following assumption. \\n```\\nif (arr(i)==prevFlippedState) then this position\\'s current value must be 0, then we need flip \\ne.g.,\\nif (arr(i)==prevFlippedState ==1 ), then means the original value on arr(i)==1, and it has been flipped for odd times, then current value must be 0 \\nif (arr(i)==prevFlippedState ==0 ), then means the original value on arr(i)==0, and it has been flipped for even times or just never, then current value must be 0 \\nif (arr(i)==1 and prevFlippedState ==0 ), then means the original value on arr(i)==1, and it has been flipped for even times or just never, then current value must be 1, so we dont need to flip\\nif (arr(i)==0 and prevFlippedState ==1 ), then means the original value on arr(i)==0, and it has been flipped for odd times, then current value must be 1, so we dont need to flip\\n```\\n\\nSo, just to recap, everytime when we need to flip, we need to XOR on the prevFlippedState with 1, and we iterate over the loop and i denotes the start of the window. \\n\\n### when a start index can be impacted by previous window? (i.e., i>=k)\\nThere can be four possibilities as follows, when a start index depends on all previous window operation. The reason that we need to consider this is that, the prevFlippedState denotes the state when we just reach i-index, but it does not mean anything when we finish the check on the i-index. Plus, as the i index denotes the start postion, so the current i-index could be also impacted by every single indexs (j) before it, as long as i and j are in the same k windwo.  \\n\\n**Therefore, the *prevFlippedState* value may not be correct if the i-index can be impacted by the previous windows, hence we need to correct this value.**\\n\\n*Lets look at the index i-k, from which the the leftest window starts and can also impact the prevFlippedState value (after we check the index i-1, and right reach index i )*\\n\\n- prevFlippedState ==0, which means here i-index has been flipped for even times or just never (==a, an even or 0 number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==0 as well (means an even or 0 number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an even or 0 times, as a+-b opearion must yield an even value. \\n- prevFlippedState ==0, which means here i-index has been flipped for even times or just never (==a, an even or 0 number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==1 instead, (means an odd number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an odd times flip, as a+-b opearion must yield an odd value. \\n- prevFlippedState ==1, which means here i-index has been flipped for odd times (==a, an odd number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==0 instead, (means an even or 0 number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an odd times flip, as a+-b opearion must yield an odd value. \\n- prevFlippedState ==1, which means here i-index has been flipped for odd times (==a, an odd number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==1 as well, (means an odd number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an even times flip, as a+-b opearion must yield an even value. \\n\\nAbove all, therefore, we can reach an induction to correct the value prevFlippedState before we begin to check the status of index i \\n```\\nif(i>=k) // means there must be a(many) windows before i \\nthen prevFlippedState  = prevFlippedState XOR hasBeenFlippedStateHere(i-k)\\n\\nwhere we use an array hasBeenFlippedStateHere for recording all flip history.\\n```\\n\\n### Code \\n```Scala\\n def minKBitFlips(arr: Array[Int], k: Int): Int = {\\n    var res, prevFlippedState = 0\\n    val len = arr.length\\n    val hasBeenFlippedStateHere = Array.ofDim[Int](len)\\n    for (i <- 0 until len) {\\n      if (i >= k) prevFlippedState ^= hasBeenFlippedStateHere(i - k)\\n      if ((arr(i) ^ prevFlippedState) == 0) {\\n        if (i + k > len) return -1\\n        res += 1\\n        hasBeenFlippedStateHere(i) = 1\\n        prevFlippedState ^= 1\\n      }\\n    }\\n    res\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\nif (arr(i)==prevFlippedState) then this position\\'s current value must be 0, then we need flip \\ne.g.,\\nif (arr(i)==prevFlippedState ==1 ), then means the original value on arr(i)==1, and it has been flipped for odd times, then current value must be 0 \\nif (arr(i)==prevFlippedState ==0 ), then means the original value on arr(i)==0, and it has been flipped for even times or just never, then current value must be 0 \\nif (arr(i)==1 and prevFlippedState ==0 ), then means the original value on arr(i)==1, and it has been flipped for even times or just never, then current value must be 1, so we dont need to flip\\nif (arr(i)==0 and prevFlippedState ==1 ), then means the original value on arr(i)==0, and it has been flipped for odd times, then current value must be 1, so we dont need to flip\\n```\n```\\nif(i>=k) // means there must be a(many) windows before i \\nthen prevFlippedState  = prevFlippedState XOR hasBeenFlippedStateHere(i-k)\\n\\nwhere we use an array hasBeenFlippedStateHere for recording all flip history.\\n```\n```Scala\\n def minKBitFlips(arr: Array[Int], k: Int): Int = {\\n    var res, prevFlippedState = 0\\n    val len = arr.length\\n    val hasBeenFlippedStateHere = Array.ofDim[Int](len)\\n    for (i <- 0 until len) {\\n      if (i >= k) prevFlippedState ^= hasBeenFlippedStateHere(i - k)\\n      if ((arr(i) ^ prevFlippedState) == 0) {\\n        if (i + k > len) return -1\\n        res += 1\\n        hasBeenFlippedStateHere(i) = 1\\n        prevFlippedState ^= 1\\n      }\\n    }\\n    res\\n  }\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 498756,
                "title": "java-o-n-sliding-window-used-queue-which-you-can-change-to-2-pointer-tagging",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) { \\n        int ans=0;int sum=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        int startTag[]=new int[nums.length];int endTag[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            int end=0;\\n            if(queue.peek()-1>=0){\\n                end=endTag[queue.peek()-1];\\n            }\\n            if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0)\\n            {\\n                ans++;\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                        nums[index]=1;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(queue.size()!=0){\\n                    startTag[queue.peek()]++;\\n                    endTag[i]++;\\n                }\\n            }\\n            else if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1)\\n            {\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        while(queue.size()!=0){\\n            int index=queue.poll();\\n            sum+=startTag[index];\\n            if(index-1>=0){\\n                sum-=endTag[index-1];\\n            }\\n            if((sum+nums[index])%2==0){\\n                nums[index]=0;\\n            }else{\\n                nums[index]=1;\\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```\\n\\nHere is the TLE solution, it is ued to help you to understand the idea for this problem, the tagging technique is used to optimize the run time complexity\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) {\\n        int ans=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            if(nums[queue.peek()]==1){\\n                while(queue.size()>0&&nums[queue.peek()]==1){\\n                    queue.poll();\\n                }\\n            }else{\\n                ans++;\\n                while(queue.size()>0&&nums[queue.peek()]==0){\\n                    int index=queue.poll();\\n                    nums[index]=1;\\n                    i=index;\\n                }\\n                while(queue.size()!=0){\\n                    int index=queue.poll();\\n                    if(nums[index]==1){\\n                        nums[index]=0;\\n                    }else{\\n                       nums[index]=1; \\n                    }\\n                }\\n                \\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) { \\n        int ans=0;int sum=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        int startTag[]=new int[nums.length];int endTag[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            int end=0;\\n            if(queue.peek()-1>=0){\\n                end=endTag[queue.peek()-1];\\n            }\\n            if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0)\\n            {\\n                ans++;\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                        nums[index]=1;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(queue.size()!=0){\\n                    startTag[queue.peek()]++;\\n                    endTag[i]++;\\n                }\\n            }\\n            else if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1)\\n            {\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        while(queue.size()!=0){\\n            int index=queue.poll();\\n            sum+=startTag[index];\\n            if(index-1>=0){\\n                sum-=endTag[index-1];\\n            }\\n            if((sum+nums[index])%2==0){\\n                nums[index]=0;\\n            }else{\\n                nums[index]=1;\\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) {\\n        int ans=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            if(nums[queue.peek()]==1){\\n                while(queue.size()>0&&nums[queue.peek()]==1){\\n                    queue.poll();\\n                }\\n            }else{\\n                ans++;\\n                while(queue.size()>0&&nums[queue.peek()]==0){\\n                    int index=queue.poll();\\n                    nums[index]=1;\\n                    i=index;\\n                }\\n                while(queue.size()!=0){\\n                    int index=queue.poll();\\n                    if(nums[index]==1){\\n                        nums[index]=0;\\n                    }else{\\n                       nums[index]=1; \\n                    }\\n                }\\n                \\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471713,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinKBitFlips(int[] A, int K) \\n    {\\n        int result = 0;\\n        var queue = new Queue<int>();\\n        for (int i = 0; i < A.Length; i++) \\n        {\\n            if (queue.Any() && queue.Peek() <= i) \\n                queue.Dequeue();\\n            \\n            if ((A[i] + queue.Count) % 2 == 0) \\n            { \\n                result++;\\n                if (i + K > A.Length) return -1; \\n                queue.Enqueue(i + K);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinKBitFlips(int[] A, int K) \\n    {\\n        int result = 0;\\n        var queue = new Queue<int>();\\n        for (int i = 0; i < A.Length; i++) \\n        {\\n            if (queue.Any() && queue.Peek() <= i) \\n                queue.Dequeue();\\n            \\n            if ((A[i] + queue.Count) % 2 == 0) \\n            { \\n                result++;\\n                if (i + K > A.Length) return -1; \\n                queue.Enqueue(i + K);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238887,
                "title": "100-time-space-python3-bit-manipulation",
                "content": "```python\\ndef minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n\\tidx = 0\\n\\tnum_digits = len(A)\\n\\tA_bitrep = int(\\'1\\' + \\'\\'.join(map(lambda i: str(i), A)), 2)\\n\\n\\tK_bitrep = 2 ** K - 1\\n\\tnum_flips = 0\\n\\twhile A_bitrep > K_bitrep:\\n\\t\\tif A_bitrep & 1 == 0:\\n\\t\\t\\tnum_flips += 1\\n\\t\\t\\tA_bitrep ^= K_bitrep\\n\\t\\tA_bitrep >>= 1\\n\\n\\treturn num_flips if A_bitrep == K_bitrep else -1\\n```\\n\\nGreedy algorithm is used here: we strive to turn every bit into `1` in order of left to right. Let `n` = length of A.\\n1. For `idx = 0` to `n - k - 1`, if `A[idx] == 0`, flip the bits in `A[idx : idx + k]` and increment `num_flips`\\n2. For `idx = n - k` to `n - 1`, if `A[idx] == 0`, then return -1. If not, return `num_flips`\\n\\nThe above algorithm will require O(n * k) time in the worst case (where a flip is performed on every iteration).\\nUsing binary representations of A and K, however, every flip requires O(1) time and hence time complexity is reduced to O(n).",
                "solutionTags": [
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```python\\ndef minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n\\tidx = 0\\n\\tnum_digits = len(A)\\n\\tA_bitrep = int(\\'1\\' + \\'\\'.join(map(lambda i: str(i), A)), 2)\\n\\n\\tK_bitrep = 2 ** K - 1\\n\\tnum_flips = 0\\n\\twhile A_bitrep > K_bitrep:\\n\\t\\tif A_bitrep & 1 == 0:\\n\\t\\t\\tnum_flips += 1\\n\\t\\t\\tA_bitrep ^= K_bitrep\\n\\t\\tA_bitrep >>= 1\\n\\n\\treturn num_flips if A_bitrep == K_bitrep else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3746701,
                "title": "queues-simple-bit-manipulation-sliding-window-xor-operation-salesforce",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1\\n\\n---\\n\\n\\nIterate on the array , and if we encounter any zero we can apply the flip operation from i -> i+k.\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K, int res = 0) {\\n       for (auto i = 0; i < A.size(); ++i) {\\n         if (A[i] != 1) {\\n           if (i + K - 1 >= A.size()) return -1;\\n              for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n           ++res;\\n          }\\n        }\\n    return res;\\n    }\\n};\\n```\\n```\\nTime complexity\\n```\\n- The time complexity of this solution is O(n*k), and it will give time limit exceeded eror.\\n# Approach 1\\n\\n---\\n```\\nObservations\\n```\\n\\n**1st observation**\\n\\n\\nLet\\'s say we are performing x number of operations on any ith index,\\n- If x == odd, if we apply one operation on ith index, it will become zero\\n- if x == even, if we apply two operations on ith index, it would remain same.\\n\\nSo we can observe at any index, any operation can be applied atmost once. Because if we apply oeration again, all element of that subarray will become same again.\\n\\n**2nd observation**\\n\\nWe can count the total operations applied on each index. So our problem reduces to how to do this thing efficiently in O(1). \\n\\nWe can use Queue data structure to store the required result. When we apply the flip operation on ith index, we would push i+k-1 in the queue. (i+k-1) would tell us the end index of our flip.\\nAt any index, the size of queue will tell us how many times flip operation has to be applied on it. We will also remove past flips from the queue, so that it can\\'t effect our result. \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\n Code\\n```\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            while(q.size() && q.front() < i) q.pop();\\n            int x = q.size()%2;\\n            nums[i] ^=x;\\n            if(nums[i] == 0)\\n            {\\n                if(i+k > nums.size()) return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nTime complexity\\n```\\nThe time complexity of this solution is O(N) and this would be accepted by the online judge.\\n\\n\\n---\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K, int res = 0) {\\n       for (auto i = 0; i < A.size(); ++i) {\\n         if (A[i] != 1) {\\n           if (i + K - 1 >= A.size()) return -1;\\n              for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n           ++res;\\n          }\\n        }\\n    return res;\\n    }\\n};\\n```\n```\\nTime complexity\\n```\n```\\nObservations\\n```\n```\\n Code\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            while(q.size() && q.front() < i) q.pop();\\n            int x = q.size()%2;\\n            nums[i] ^=x;\\n            if(nums[i] == 0)\\n            {\\n                if(i+k > nums.size()) return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTime complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536533,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        x=0\\n        f=[0]*n\\n\\n        for idx,val in enumerate(nums):\\n            if idx>=k:\\n                x^=f[idx-k]\\n            if x!=val:\\n                continue\\n            if k>n-idx:\\n                return -1\\n            x^=1\\n            f[idx]=1\\n        \\n        return sum(f)\\n```\\n\\n```Java []\\nclass Solution {\\n        public int minKBitFlips(int[] A, int K) {\\n            int n = A.length, flipped = 0, res = 0;\\n            int[] isFlipped = new int[n];\\n            for (int i = 0; i < A.length; ++i) {\\n                if (i >= K)\\n                    flipped ^= isFlipped[i - K];\\n                if (flipped == A[i]) {\\n                    if (i + K > A.length)\\n                        return -1;\\n                    isFlipped[i] = 1;\\n                    flipped ^= 1;\\n                    res++;\\n                }\\n            }\\n            return res;\\n        }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        x=0\\n        f=[0]*n\\n\\n        for idx,val in enumerate(nums):\\n            if idx>=k:\\n                x^=f[idx-k]\\n            if x!=val:\\n                continue\\n            if k>n-idx:\\n                return -1\\n            x^=1\\n            f[idx]=1\\n        \\n        return sum(f)\\n```\n```Java []\\nclass Solution {\\n        public int minKBitFlips(int[] A, int K) {\\n            int n = A.length, flipped = 0, res = 0;\\n            int[] isFlipped = new int[n];\\n            for (int i = 0; i < A.length; ++i) {\\n                if (i >= K)\\n                    flipped ^= isFlipped[i - K];\\n                if (flipped == A[i]) {\\n                    if (i + K > A.length)\\n                        return -1;\\n                    isFlipped[i] = 1;\\n                    flipped ^= 1;\\n                    res++;\\n                }\\n            }\\n            return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221973,
                "title": "java-greedy-o-n",
                "content": "- Whenever we encounter our target bit, we flip it. \\n- To keep track of what target is (1 or 0), we will use a boolean array to note the end of the `k` length.\\n- Flip between 0 and 1 by doing `1^=1` and `0^=1`\\n- Flip between true and false by doing `false^=true` and `true^=true`\\n\\n```Java\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int target = 0, ans = 0;;\\n        boolean[] flip = new boolean[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            if (flip[i]){\\n                target^=1;\\n            }\\n            if (i<nums.length-k+1&&nums[i]==target){\\n                target^=1;\\n                flip[i+k]^=true;\\n                ans++;\\n            }\\n            if (i>nums.length-k&&nums[i]==target){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int target = 0, ans = 0;;\\n        boolean[] flip = new boolean[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            if (flip[i]){\\n                target^=1;\\n            }\\n            if (i<nums.length-k+1&&nums[i]==target){\\n                target^=1;\\n                flip[i+k]^=true;\\n                ans++;\\n            }\\n            if (i>nums.length-k&&nums[i]==target){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144636,
                "title": "python-with-explanation-o-n",
                "content": "The easiest, most straightforward solution would look something like this:\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  # flip all from i to i + k - 1\\n                    if nums[j] == 0:\\n                        nums[j] = 1\\n                    elif nums[j] == 1:\\n                        nums[j] = 0\\n        return res if sum(nums[-k:]) == k else -1  # check if all are equal to one with sum(nums[-k:]) == k\\n```\\nThe key observation as noted [here](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/2061620/C%2B%2B-key-observation-%2B-diff-arrary) is that\\n 1. only one k-bit flip can affect the 1st bit.\\n 2. once 1st bit is settled, only one k-bit flip can affect the 2nd bit\\n 3. so on ... \\n \\nBut this solution is too slow and results in Time Limit Exceeded. No wonder: for large k\\'s we have to do a lot of flipping. We can mitigate it by doing \"virtual flipping\". With \"virtual flipping\" we do not actually flip the bits, we just start treating 1 as 0 and 0 as 1 and we remember the index when we have to spot doing that.\\n\\nConsider the following solution (faster than 90%):\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        min_flips = 0  # final result\\n        norm_mod = True  # if norm_mod is True we treat 1 as 1 and 0 as 0, if False 1 as 0, 0 as 1\\n        chmod = set()  # set of indexes where to change norm_mod\\n        \\n        for i in range(len(nums) - k + 1):  # do all virtual flipping\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                min_flips += 1\\n                chmod.add(i + k)\\n                norm_mod = not norm_mod\\n\\n        for i in range(len(nums) - k + 1, len(nums)):  # check if possible\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                return -1\\n\\n        return min_flips\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  # flip all from i to i + k - 1\\n                    if nums[j] == 0:\\n                        nums[j] = 1\\n                    elif nums[j] == 1:\\n                        nums[j] = 0\\n        return res if sum(nums[-k:]) == k else -1  # check if all are equal to one with sum(nums[-k:]) == k\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        min_flips = 0  # final result\\n        norm_mod = True  # if norm_mod is True we treat 1 as 1 and 0 as 0, if False 1 as 0, 0 as 1\\n        chmod = set()  # set of indexes where to change norm_mod\\n        \\n        for i in range(len(nums) - k + 1):  # do all virtual flipping\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                min_flips += 1\\n                chmod.add(i + k)\\n                norm_mod = not norm_mod\\n\\n        for i in range(len(nums) - k + 1, len(nums)):  # check if possible\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                return -1\\n\\n        return min_flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122927,
                "title": "python-o-n-s-n-queue-solution",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        q = []\\n        for i in range(len(nums)):\\n            if len(q) % 2 == 0:\\n                if nums[i] == 0:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            else:\\n                if nums[i] == 1:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            if q:\\n                if q[0] == i:\\n                    q.pop(0)\\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        q = []\\n        for i in range(len(nums)):\\n            if len(q) % 2 == 0:\\n                if nums[i] == 0:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            else:\\n                if nums[i] == 1:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            if q:\\n                if q[0] == i:\\n                    q.pop(0)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1975230,
                "title": "python-intuitive-solution-o-n",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        flipped = collections.deque()  # queue to store window end indexes\\n        flips = 0\\n        n = len(A)\\n        for i in range(n):\\n            if flipped and (flipped[0] < i):    # if we have crossed the window remove from queue\\n                flipped.popleft()\\n            if len(flipped)%2 == 0:  # if len of queue is even then 1 will be 1 after even flips\\n                if A[i] == 1:\\n                    continue  # so we continue\\n                else:\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n            else:\\n                if A[i] == 0:  # if our queue is odd sized then our 0 will be converted to 1 so we continue\\n                    continue\\n                else:  # if its a 1 then it would be flipped to 0 so we try to apply flip operation\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n        return flips\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        flipped = collections.deque()  # queue to store window end indexes\\n        flips = 0\\n        n = len(A)\\n        for i in range(n):\\n            if flipped and (flipped[0] < i):    # if we have crossed the window remove from queue\\n                flipped.popleft()\\n            if len(flipped)%2 == 0:  # if len of queue is even then 1 will be 1 after even flips\\n                if A[i] == 1:\\n                    continue  # so we continue\\n                else:\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n            else:\\n                if A[i] == 0:  # if our queue is odd sized then our 0 will be converted to 1 so we continue\\n                    continue\\n                else:  # if its a 1 then it would be flipped to 0 so we try to apply flip operation\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852826,
                "title": "javascript-sliding-window-approach",
                "content": "```\\nvar minKBitFlips = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    flip = 0;\\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n    // remove our current windows first number\\n    // check if windows first number is equal to 2, if so subtract flip\\n    // and shrink the window\\n    if (windowEnd - windowStart + 1 >= k && nums[windowEnd - k] === 2) {\\n      flip -= 1;\\n      windowStart += 1;\\n    }\\n    if (flip % 2 === nums[windowEnd]) {\\n      if (windowEnd + k > nums.length) return -1;\\n      result += 1;\\n      flip += 1;\\n      nums[windowEnd] = 2;\\n    }\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar minKBitFlips = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    flip = 0;\\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n    // remove our current windows first number\\n    // check if windows first number is equal to 2, if so subtract flip\\n    // and shrink the window\\n    if (windowEnd - windowStart + 1 >= k && nums[windowEnd - k] === 2) {\\n      flip -= 1;\\n      windowStart += 1;\\n    }\\n    if (flip % 2 === nums[windowEnd]) {\\n      if (windowEnd + k > nums.length) return -1;\\n      result += 1;\\n      flip += 1;\\n      nums[windowEnd] = 2;\\n    }\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848407,
                "title": "python-o-nk-to-o-n-queue-and-sliding-window-explained-well",
                "content": "The O(NK) solution is very easy. In a window, we flip whenever count of 0s > 0, and the first element of the window is 0. This is because if the first element in the window is 1, and we flip it to 0, and slide the window forward, we will never be able to flip it back to 1. Here\\'s the solution:\\n```\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"        \\n\\t\\t# Initializing here\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1\\n            # should we flip?\\n            if (cnts[0]>0) and (nums[st]==0):\\n                # yes flip\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]  # This is the problem! We\\'ll get TIME LIMIT EXCEEDED IF K IS VERY BIG!\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n            ## move window forward\\n            if nums[st]==0: # checks every element except elements after st in the last window\\n                return -1\\n            cnts[nums[st]]-=1\\n            st+=1\\n        if cnts[0]>0: # check the last window\\n            return -1\\n        return num_flips\\n```\\n\\nTo optimize the code, we clearly need to replace the following O(K) code with something that\\'s O(1)\\n```\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]] \\n```\\n\\nHow can we do this?\\n\\nTo get the current value of nums[i] for any i, we need to know the initial nums[i] value and ***how many times i was flipped***. We cannot easily track how many times each i was flipped, but we can easily track which windows were flipped by adding the starting or ending index of that flipped window to a list or queue. ***Once our window slides past the last element of a flipped window, the fact that that window was flipped no longer has an effect on the first element of the next window.*** For example, in [a,b,c,d,e,f,g,h] and k=3, say we flip window [a,b,c], while b and d will be effected by this flip, d will not. This shows us, that we need to track the last element of the flipped windows (en) until the window slides past that element. \\n\\nSo, as a solution, we create a queue q. Every time a window a flipped, we append the last element (en) of that window to q. When the first element of the sliding window (st) becomes greater that q[0], we popleft to remove the en of that old flipped window that will have no effect on the next sliding window (starting with st+1).\\n\\nUsing this, I was able to come up with the following O(N) solution:\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        q = deque()\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1 # as we expand window, en is never flipped\\n            # should we flip?\\n            if (cnts[0]>0) and ((nums[st]+(len(q)%2)) in [0,2]):\\n                # yes flip\\n                #nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n                q.append(en)\\n            ## move window forward\\n            if ((nums[st]+(len(q)%2)) in [0,2]): # checks every element outside the last window\\n                return -1\\n            if ((nums[st]+(len(q)%2)) in [0,2]):\\n                cnts[0]-=1\\n            else:\\n                cnts[1]-=1\\n            if (len(q)>0) and (q[0]==st):\\n                q.popleft()\\n            st+=1\\n        # check the last window\\n        if cnts[0]>0:\\n            return -1\\n        return num_flips\\n```\\n\\nRuntime: 1369 ms, faster than 43.48% of Python online submissions for Minimum Number of K Consecutive Bit Flips.\\nMemory Usage: 17.5 MB, less than 78.26% of Python online submissions for Minimum Number of K Consecutive Bit Flips.",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"        \\n\\t\\t# Initializing here\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1\\n            # should we flip?\\n            if (cnts[0]>0) and (nums[st]==0):\\n                # yes flip\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]  # This is the problem! We\\'ll get TIME LIMIT EXCEEDED IF K IS VERY BIG!\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n            ## move window forward\\n            if nums[st]==0: # checks every element except elements after st in the last window\\n                return -1\\n            cnts[nums[st]]-=1\\n            st+=1\\n        if cnts[0]>0: # check the last window\\n            return -1\\n        return num_flips\\n```\n```\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]] \\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        q = deque()\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1 # as we expand window, en is never flipped\\n            # should we flip?\\n            if (cnts[0]>0) and ((nums[st]+(len(q)%2)) in [0,2]):\\n                # yes flip\\n                #nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n                q.append(en)\\n            ## move window forward\\n            if ((nums[st]+(len(q)%2)) in [0,2]): # checks every element outside the last window\\n                return -1\\n            if ((nums[st]+(len(q)%2)) in [0,2]):\\n                cnts[0]-=1\\n            else:\\n                cnts[1]-=1\\n            if (len(q)>0) and (q[0]==st):\\n                q.popleft()\\n            st+=1\\n        # check the last window\\n        if cnts[0]>0:\\n            return -1\\n        return num_flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766215,
                "title": "c-solution",
                "content": "**Inutition**\\nUse difference array technique to mark the ```start``` position and ```end``` position of a range that all the elements need flip. This can avoid to flip every element. \\n\\nSimilar problems:\\n- 1893 Check if All the Integers in a Range Are Covered\\n- 370 Range Addition\\n- 1381 Design a Stack With Increment Operation\\n- 2021 Brightest Position on Street\\n- 1094 Car Pooling\\n- 995 Minimum Number of K Consecutive Bit Flips\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int MinKBitFlips(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int n = nums.Length, flipCnt = 0;\\n\\n        // diff[i]: diffience of total flips between index i and i - 1\\n        int[] diff = new int[n + 1];\\n        \\n        // totalFlip: total flip count before index i\\n        int totalFlip = 0;\\n          \\n        for(int i = 0; i < n; i++)\\n        {\\n            // totalFlip + diff[i] = actual flip at index i\\n            totalFlip += diff[i];\\n            \\n            // if num[i] + totalFlip is even, then nums[i] = 0\\n            // otherwise, nums[i] = 1\\n            if((nums[i] + totalFlip) % 2 == 0)\\n            {\\n                // (i + k - 1) last index where need a flip\\n                if(i + k - 1 >= n)\\n                    return -1;\\n                \\n                // all the positions within range of [i, i + k - 1] will flip once\\n                totalFlip++;\\n                // starting from index (i+k), we should stop flipping, so cancel the flips that shouldn\\'t happen \\n                diff[i + k] -= 1;\\n                \\n                // flip count\\n                flipCnt++;\\n            }\\n        }\\n\\n        return flipCnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```start```\n```end```\n```\\npublic class Solution {\\n    public int MinKBitFlips(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int n = nums.Length, flipCnt = 0;\\n\\n        // diff[i]: diffience of total flips between index i and i - 1\\n        int[] diff = new int[n + 1];\\n        \\n        // totalFlip: total flip count before index i\\n        int totalFlip = 0;\\n          \\n        for(int i = 0; i < n; i++)\\n        {\\n            // totalFlip + diff[i] = actual flip at index i\\n            totalFlip += diff[i];\\n            \\n            // if num[i] + totalFlip is even, then nums[i] = 0\\n            // otherwise, nums[i] = 1\\n            if((nums[i] + totalFlip) % 2 == 0)\\n            {\\n                // (i + k - 1) last index where need a flip\\n                if(i + k - 1 >= n)\\n                    return -1;\\n                \\n                // all the positions within range of [i, i + k - 1] will flip once\\n                totalFlip++;\\n                // starting from index (i+k), we should stop flipping, so cancel the flips that shouldn\\'t happen \\n                diff[i + k] -= 1;\\n                \\n                // flip count\\n                flipCnt++;\\n            }\\n        }\\n\\n        return flipCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658419,
                "title": "lazy-seg-tree",
                "content": "The idea is to maintain a lazy seg tree on the array consisting of the bulbs. We then traverse the array from left to right. Note that it never makes sense to flip a range more than once. Thus, as we move from left to right, if we see an element of the array which is 0 mod 2, then we must add 1 to the range of length k starting at that point. We keep track of how many range updates we make. At the end, we simply check of the elements in the final k positions are 1 mod 2. Each range update and range query takes logN time, so overall run time is O(NlogN), and space complexity if O(N) for the tree. Note that if we did not use a Lazy seg tree for range updates, the runtime would be O(NK), which could be as bad as O(N^2)\\n```\\nconst int MAX_ARR_SIZE = 200005;\\nconst int MAX_TREE_SIZE = 4*MAX_ARR_SIZE;\\n\\nstruct node {\\n    int64_t sum;\\n    int lazy;\\n    \\n    node(): sum(0), lazy(0)  {}\\n    node(int sum, int lazy_val): sum(sum), lazy(lazy_val) {}\\n\\n\\n    node operator+(const node& other) {\\n        return node(sum + other.sum, 0); \\n    }\\n};\\n\\nvoid push(int k, int l, int r, node(&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    tree[k].sum += tree[k].lazy*(r- l + 1);\\n    tree[2*k].lazy += tree[k].lazy;\\n    tree[2*k + 1].lazy += tree[k].lazy;\\n    tree[k].lazy = 0; \\n}\\n\\nvoid update(int ul, int ur, int val, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ur < l || r < ul) {return;}\\n\\n    if(ul <= l && r <= ur) {\\n        tree[k].lazy += val;\\n        return;\\n    }\\n\\n \\n    tree[k].sum += val*(min(ur, r) - max(ul, l) + 1);\\n    int mid = (l + r)/2;\\n    update(ul, ur, val, 2*k, l, mid,  tree, arr);\\n    update(ul, ur, val, 2*k + 1, mid + 1, r, tree, arr);\\n}\\n\\nnode query(int ql, int qr, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ql > r|| qr < l) {\\n        return node(); \\n    }\\n    if(ql <= l && r <= qr) {\\n        return tree[k];\\n    }\\n    int mid = (l + r)/2;\\n    node query_left = query(ql, qr, 2*k, l, mid, tree, arr);\\n    node query_right = query(ql, qr, 2*k + 1, mid + 1, r, tree, arr);\\n    return query_left + query_right;\\n}\\n\\nvoid build(int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    if(l == r) {\\n        tree[k] = node(arr[l], 0); \\n        return;\\n    }\\n    int m = (l + r)/2;\\n\\n   \\n    build(2*k, l, m, tree, arr);\\n    build(2*k + 1, m + 1, r, tree, arr);\\n    tree[k] = tree[2*k] + tree[2*k + 1]; \\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        node tree[MAX_TREE_SIZE];\\n        int A[MAX_ARR_SIZE];\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums[i];\\n        }\\n        build(1,0,n-1,tree,A);\\n        int num_flips = 0;\\n        \\n        for(int i = 0; i + k - 1 < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                num_flips++;\\n                update(i, i + k - 1, 1, 1, 0, n - 1, tree, A);\\n            }\\n        }\\n        for(int i = n - k; i < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                return -1;\\n            }\\n        }\\n        \\n        return num_flips;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MAX_ARR_SIZE = 200005;\\nconst int MAX_TREE_SIZE = 4*MAX_ARR_SIZE;\\n\\nstruct node {\\n    int64_t sum;\\n    int lazy;\\n    \\n    node(): sum(0), lazy(0)  {}\\n    node(int sum, int lazy_val): sum(sum), lazy(lazy_val) {}\\n\\n\\n    node operator+(const node& other) {\\n        return node(sum + other.sum, 0); \\n    }\\n};\\n\\nvoid push(int k, int l, int r, node(&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    tree[k].sum += tree[k].lazy*(r- l + 1);\\n    tree[2*k].lazy += tree[k].lazy;\\n    tree[2*k + 1].lazy += tree[k].lazy;\\n    tree[k].lazy = 0; \\n}\\n\\nvoid update(int ul, int ur, int val, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ur < l || r < ul) {return;}\\n\\n    if(ul <= l && r <= ur) {\\n        tree[k].lazy += val;\\n        return;\\n    }\\n\\n \\n    tree[k].sum += val*(min(ur, r) - max(ul, l) + 1);\\n    int mid = (l + r)/2;\\n    update(ul, ur, val, 2*k, l, mid,  tree, arr);\\n    update(ul, ur, val, 2*k + 1, mid + 1, r, tree, arr);\\n}\\n\\nnode query(int ql, int qr, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ql > r|| qr < l) {\\n        return node(); \\n    }\\n    if(ql <= l && r <= qr) {\\n        return tree[k];\\n    }\\n    int mid = (l + r)/2;\\n    node query_left = query(ql, qr, 2*k, l, mid, tree, arr);\\n    node query_right = query(ql, qr, 2*k + 1, mid + 1, r, tree, arr);\\n    return query_left + query_right;\\n}\\n\\nvoid build(int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    if(l == r) {\\n        tree[k] = node(arr[l], 0); \\n        return;\\n    }\\n    int m = (l + r)/2;\\n\\n   \\n    build(2*k, l, m, tree, arr);\\n    build(2*k + 1, m + 1, r, tree, arr);\\n    tree[k] = tree[2*k] + tree[2*k + 1]; \\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        node tree[MAX_TREE_SIZE];\\n        int A[MAX_ARR_SIZE];\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums[i];\\n        }\\n        build(1,0,n-1,tree,A);\\n        int num_flips = 0;\\n        \\n        for(int i = 0; i + k - 1 < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                num_flips++;\\n                update(i, i + k - 1, 1, 1, 0, n - 1, tree, A);\\n            }\\n        }\\n        for(int i = n - k; i < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                return -1;\\n            }\\n        }\\n        \\n        return num_flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618329,
                "title": "python-difference-array-with-thought-process-when-being-asked-during-interviews",
                "content": "### Greedy + Difference Array\\nSimilarly with problem [Bulb Switcher IV](https://leetcode.com/problems/bulb-switcher-iv/), the key idea is that once we know the current bit/number is `1`, then we need no longer consider it, but only when the current number is `0` otherwise. \\n\\nFor example, we have `nums` as `[0, 1, 0, 0, 1]` and `2` as `k`. We iterate each number and see if we need flip it. The first number is `0`, so we need flip, then `nums` is changed to `[1,0,0,0,1]`. Then we don\\'t need to consider the first flipped `1` any more, we move on to the second number `0` and keep flipping the `nums` to `[1,1,1,0,1]`. We do the same thing for the third number that is `1` already, then we do nothing and move on to the next.\\n\\nOkey, then what\\'s next? do we need simulate the flipping consecutive `k` numbers each time? No, because it denotes to time complexity of *O(NK)*, or *O(N^2)* in worst case. \\n\\nCan we do better? With the binary property of flipping, it indicates that the final number has only 2 cases, flipped for the odd times flipping, and remained for the even times flipping. So we can simply just record the number of flipping for each number, so that we can quickly calculate the final state on the fly without simulation.\\n\\nThen we can convert the problem to range update and query problem as we need update consecutive k range of flipping times array and query the final state/number for each element.\\n\\nFinally, return `-1` when we find need to flip but the remaining range is smaller than `k`.\\n\\n```python\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tn = len(nums)\\n    diff = [0] * (n + 1) \\n    flip = curr = 0\\n    for i, num in enumerate(nums): \\n\\t\\tcurr += diff[i]\\n        if not (num ^ +(curr % 2)):\\n\\t\\t\\tif n - i < k:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcurr += 1\\n            diff[i + k] -= 1\\n            flip += 1\\n\\treturn flip\\n```\\n*Time Complexity*= **O(N)**\\n*Space Complexit* = **O(N)**\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tn = len(nums)\\n    diff = [0] * (n + 1) \\n    flip = curr = 0\\n    for i, num in enumerate(nums): \\n\\t\\tcurr += diff[i]\\n        if not (num ^ +(curr % 2)):\\n\\t\\t\\tif n - i < k:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcurr += 1\\n            diff[i + k] -= 1\\n            flip += 1\\n\\treturn flip\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1364521,
                "title": "easy-peasy-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();int c=0;\\n        int r=0;\\n            \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>=k&&nums[i-k]>1)\\n            {\\n                c--;\\n                nums[i-k]-=2;\\n            }\\n            if(c%2==nums[i])\\n            {\\n                if(i+k>n)return -1;\\n                nums[i]+=2;\\n                c++;\\n                r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();int c=0;\\n        int r=0;\\n            \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>=k&&nums[i-k]>1)\\n            {\\n                c--;\\n                nums[i-k]-=2;\\n            }\\n            if(c%2==nums[i])\\n            {\\n                if(i+k>n)return -1;\\n                nums[i]+=2;\\n                c++;\\n                r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356552,
                "title": "javascript-flip-every-first-0-bit-explanation",
                "content": "Pass the array with a sliding window of k size. If the first element of the window is 0 we need to apply the flip.\\nIf at the end of the pass we saw that all the elements are 1 we return the number of flip. Otherwise we return -1\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0\\n    \\n    for(let i=0; i<nums.length; i++){\\n        if (nums[i] == 0){\\n            for(let j=0; j<k && i+k <= nums.length; j++){\\n                nums[i+j] = 1 - nums[i+j]\\n            }\\n            count++\\n        }\\n    }\\n        \\n    return nums.every(n => n ==1) ? count : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0\\n    \\n    for(let i=0; i<nums.length; i++){\\n        if (nums[i] == 0){\\n            for(let j=0; j<k && i+k <= nums.length; j++){\\n                nums[i+j] = 1 - nums[i+j]\\n            }\\n            count++\\n        }\\n    }\\n        \\n    return nums.every(n => n ==1) ? count : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350691,
                "title": "c-easy-to-understand-greedy-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int arr[n+2];\\n        memset(arr,0,sizeof arr);\\n        int curr=0;\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr%2!=0)\\n                nums[i]=nums[i]^1;\\n            if(nums[i]==0)\\n            {\\n                if( i+k-1>=n )\\n                    return -1;\\n                arr[i+k-1]+=-1;\\n                arr[i]+=1;\\n                res++;\\n            }\\n            if(i>0)arr[i]+=arr[i-1];\\n            curr=arr[i];\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int arr[n+2];\\n        memset(arr,0,sizeof arr);\\n        int curr=0;\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr%2!=0)\\n                nums[i]=nums[i]^1;\\n            if(nums[i]==0)\\n            {\\n                if( i+k-1>=n )\\n                    return -1;\\n                arr[i+k-1]+=-1;\\n                arr[i]+=1;\\n                res++;\\n            }\\n            if(i>0)arr[i]+=arr[i-1];\\n            curr=arr[i];\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334215,
                "title": "c-two-pass-greedy-solution-slow-with-thinking-process",
                "content": "This post is only to share how I approached this problem, definitely not the optimal solutions. Please check the most voted posts for really smart and neat solutions.\\n\\ninitial idea is to try greedy, end up a TLE solution.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            if (nums[istart] == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = 0;\\n            for (int j = istart; j <= iend; ++j) {\\n                nums[j] = !nums[j];\\n                sum += nums[j];\\n            }\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```\\n\\nsecond idea is to store the previously flipped bits, and check how many affect current one, end up with a slow O(NlogK) time, O(N) space solution\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (getBit(nums, istart, k) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            flip_start_bits_pos_[istart] = flip_start_bits_.size()-1;\\n            \\n            ++nflips;\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n    \\n    vector<int> flip_start_bits_;   \\n    std::map<int, int> flip_start_bits_pos_;\\n    \\n    int getBit(vector<int>& nums, int i, int k) {\\n        int left_most = i-k+1 >= 0? i-k+1 : 0;\\n        if (flip_start_bits_pos_.empty()) return nums[i];\\n        auto left_most_begin_iter = flip_start_bits_pos_.lower_bound(left_most);\\n        if (left_most_begin_iter == flip_start_bits_pos_.end()) {\\n            flip_start_bits_.clear();\\n            flip_start_bits_pos_.clear();\\n            return nums[i];\\n        }\\n        int nflips = flip_start_bits_.size() - left_most_begin_iter->second;\\n        if (nflips%2 == 0) return nums[i];\\n        return !nums[i];\\n    }\\n};\\n```\\n\\nmy final idea is based on the second one, simply using a deque/queue to store previousely flipped bits (since the orber will be increasing, so no map needed), this ends up with a O(N) time, O(K) space solution.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                flip_start_bits_.clear();\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            while (flip_start_bits_.size() && flip_start_bits_.front() < istart-k+1) flip_start_bits_.pop_front();\\n            if ((flip_start_bits_.size()%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n\\n    deque<int> flip_start_bits_;\\n};\\n```\\n\\nThis solution is based on top voted posts, to optimize O(1) space.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (istart-k >= 0 && nums[istart-k] < 0) {\\n                --nflips;\\n                nums[istart-k] += 2;\\n            } \\n            if ((nflips%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = k-sum;\\n            ++nflips;\\n            nums[istart] -= 2;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            if (nums[istart] == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = 0;\\n            for (int j = istart; j <= iend; ++j) {\\n                nums[j] = !nums[j];\\n                sum += nums[j];\\n            }\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (getBit(nums, istart, k) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            flip_start_bits_pos_[istart] = flip_start_bits_.size()-1;\\n            \\n            ++nflips;\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n    \\n    vector<int> flip_start_bits_;   \\n    std::map<int, int> flip_start_bits_pos_;\\n    \\n    int getBit(vector<int>& nums, int i, int k) {\\n        int left_most = i-k+1 >= 0? i-k+1 : 0;\\n        if (flip_start_bits_pos_.empty()) return nums[i];\\n        auto left_most_begin_iter = flip_start_bits_pos_.lower_bound(left_most);\\n        if (left_most_begin_iter == flip_start_bits_pos_.end()) {\\n            flip_start_bits_.clear();\\n            flip_start_bits_pos_.clear();\\n            return nums[i];\\n        }\\n        int nflips = flip_start_bits_.size() - left_most_begin_iter->second;\\n        if (nflips%2 == 0) return nums[i];\\n        return !nums[i];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                flip_start_bits_.clear();\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            while (flip_start_bits_.size() && flip_start_bits_.front() < istart-k+1) flip_start_bits_.pop_front();\\n            if ((flip_start_bits_.size()%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n\\n    deque<int> flip_start_bits_;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (istart-k >= 0 && nums[istart-k] < 0) {\\n                --nflips;\\n                nums[istart-k] += 2;\\n            } \\n            if ((nflips%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = k-sum;\\n            ++nflips;\\n            nums[istart] -= 2;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319513,
                "title": "c-o-n-queue-10-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        int ans=0;\\n        queue<int>q;\\n        for(int i=0;i<A.size();i++){\\n            int len=q.size();\\n            if((len%2 && A[i]==1)|| (len%2==0 && A[i]==0)){\\n                if(i+k-1>=A.size())return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n            if(q.size() && i==q.front())q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        int ans=0;\\n        queue<int>q;\\n        for(int i=0;i<A.size();i++){\\n            int len=q.size();\\n            if((len%2 && A[i]==1)|| (len%2==0 && A[i]==0)){\\n                if(i+k-1>=A.size())return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n            if(q.size() && i==q.front())q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266069,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099871,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        n=len(A)\\n        ans=0\\n        if A[0]==0:\\n            ans+=1\\n            for i in range(K):\\n                A[i]= int(not A[i])\\n        B=[0]*(n-1)\\n        for i in range(n-1):\\n            B[i]=int(A[i] != A[i+1])\\n        for i in range(n):\\n            if i+K<=n-1:\\n                if B[i]==1:\\n                    ans+=1\\n                    B[i] = int(not B[i])\\n                    if i+K<n-1:\\n                        B[i+K] = int(not B[i+K]) \\n        if B==[0]*(n-1):\\n            return ans\\n        return -1\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        n=len(A)\\n        ans=0\\n        if A[0]==0:\\n            ans+=1\\n            for i in range(K):\\n                A[i]= int(not A[i])\\n        B=[0]*(n-1)\\n        for i in range(n-1):\\n            B[i]=int(A[i] != A[i+1])\\n        for i in range(n):\\n            if i+K<=n-1:\\n                if B[i]==1:\\n                    ans+=1\\n                    B[i] = int(not B[i])\\n                    if i+K<n-1:\\n                        B[i+K] = int(not B[i+K]) \\n        if B==[0]*(n-1):\\n            return ans\\n        return -1\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 684592,
                "title": "o-n-time-space-c-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        vector<int> isflipped(A.size(),0);\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            if(i>0){\\n                isflipped[i]+=isflipped[i-1];\\n                isflipped[i]%=2;\\n            }\\n            if(A[i]==0 && !isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n            else if(A[i]==1 && isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};// \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        vector<int> isflipped(A.size(),0);\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            if(i>0){\\n                isflipped[i]+=isflipped[i-1];\\n                isflipped[i]%=2;\\n            }\\n            if(A[i]==0 && !isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n            else if(A[i]==1 && isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};// \\n```",
                "codeTag": "Java"
            },
            {
                "id": 619498,
                "title": "scala-fenwick-tree-o-nlgn",
                "content": "```\\nobject Solution {\\n  val MAGIC: Int = 300000\\n  def minKBitFlips(A: Array[Int], K: Int): Int = {\\n    val len: Int = A.length\\n    val pLen: Int = len - K + 1\\n    val ops: Array[Int] = Array.fill(1 + pLen)(0) // 1 based\\n    var ans: Int = 0\\n    if(A(0) == 0) {\\n      ans += 1\\n      add(1, 1, ops, pLen)\\n    }\\n    \\n    for {\\n      i <- 1 until pLen\\n    } {\\n      if((A(i) + rangeSum(Math.max(1, i - K + 2), i, ops, pLen)) % 2 == 0) {\\n        ans += 1\\n        add(i + 1, 1, ops, pLen)\\n      }\\n    }\\n    for {\\n        i <- pLen until len\\n    } {\\n        if((A(i) + rangeSum(Math.max(1, i - K + 2), Math.min(i, pLen), ops, pLen)) % 2 == 0) {\\n            return -1\\n        }\\n    }\\n    return ans\\n  }\\n\\n  def add(i: Int, v: Int, arr: Array[Int], len: Int): Unit = {\\n    var ind: Int = i\\n    while(ind <= len) {\\n      arr(ind) += v\\n      ind += ind & (-ind)\\n    }\\n  }\\n\\n  def queryPreSum(n: Int, arr: Array[Int], len: Int): Int = {\\n    var ind = n\\n    var ans: Int = 0\\n    while(ind > 0) {\\n      ans += arr(ind)\\n      ind -= ind & (-ind)\\n    }\\n    ans\\n  }\\n\\n  def rangeSum(l: Int, r: Int, arr: Array[Int], len: Int): Int = {\\n    queryPreSum(r, arr, len) - queryPreSum(l - 1, arr, len)\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  val MAGIC: Int = 300000\\n  def minKBitFlips(A: Array[Int], K: Int): Int = {\\n    val len: Int = A.length\\n    val pLen: Int = len - K + 1\\n    val ops: Array[Int] = Array.fill(1 + pLen)(0) // 1 based\\n    var ans: Int = 0\\n    if(A(0) == 0) {\\n      ans += 1\\n      add(1, 1, ops, pLen)\\n    }\\n    \\n    for {\\n      i <- 1 until pLen\\n    } {\\n      if((A(i) + rangeSum(Math.max(1, i - K + 2), i, ops, pLen)) % 2 == 0) {\\n        ans += 1\\n        add(i + 1, 1, ops, pLen)\\n      }\\n    }\\n    for {\\n        i <- pLen until len\\n    } {\\n        if((A(i) + rangeSum(Math.max(1, i - K + 2), Math.min(i, pLen), ops, pLen)) % 2 == 0) {\\n            return -1\\n        }\\n    }\\n    return ans\\n  }\\n\\n  def add(i: Int, v: Int, arr: Array[Int], len: Int): Unit = {\\n    var ind: Int = i\\n    while(ind <= len) {\\n      arr(ind) += v\\n      ind += ind & (-ind)\\n    }\\n  }\\n\\n  def queryPreSum(n: Int, arr: Array[Int], len: Int): Int = {\\n    var ind = n\\n    var ans: Int = 0\\n    while(ind > 0) {\\n      ans += arr(ind)\\n      ind -= ind & (-ind)\\n    }\\n    ans\\n  }\\n\\n  def rangeSum(l: Int, r: Int, arr: Array[Int], len: Int): Int = {\\n    queryPreSum(r, arr, len) - queryPreSum(l - 1, arr, len)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 373717,
                "title": "greedy-python-solution-w-detailed-comments",
                "content": "##### Python 3:\\n```py\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        # status: record whether current character has been flipped already or not\\n        # 0: not flipped\\n        # 1: flipped\\n        flipped = 0\\n\\n        # record whether index i, as the start of substring of length K, has been\\n        # flipped or not\\n        # 0: not flipped\\n        # 1: flipped\\n        has_flipped = [0] * len(A)\\n\\n        min_flips = 0\\n\\n        for idx, num in enumerate(A):\\n            # get the ACTUAL FLIPPED STATUS for current num by removing the flipped\\n            # status of values that are out of window\\n            if idx >= K:\\n                flipped ^= has_flipped[idx - K]\\n\\n            # we will need to flip current value iff\\n            # 1) current value is 1 and it has been flipped (i.e. flipped == 1)\\n            # 2) current value is 0 and it hasn\\'t been flipped (i.e. flipped == 0)\\n            # which can be concluded by (flipped ^ num == 0)\\n            if (flipped ^ num) == 0:\\n                # in case there is no way for us to flip current value\\n                if idx + K - 1 >= len(A):\\n                    return -1\\n\\n                # flip\\n                flipped ^= 1\\n                has_flipped[idx] = 1\\n                min_flips += 1\\n\\n        return min_flips\\n```\\n##### JavaScript:\\n```js\\nvar minKBitFlips = function(A, K) {\\n  if (!A || !A.length) return [];\\n\\n  // flipped: keep track of total flipped status\\n  // 0: not flipped\\n  // 1: flipped\\n  let flips = 0, flipped = 0;\\n  // indicate whether A[i] is truly flipped or not\\n  const hasFlipped = Array(A.length).fill(0);\\n\\n  for (const [i, num] of A.entries()) {\\n    // IMPORTANT: to determine whether at this pointer, the current value has been\\n    // flipped or not, we need to find it based on flipped and hasFlipped[i - k]\\n    if (i >= K) {\\n      flipped ^= hasFlipped[i - K];\\n    }\\n\\n    // if num == 0 and current value has not been flipped yet (flipped == 0)\\n    // if num == 1 and current value has been flipped yet (flipped == 1)\\n    // for any of the two above cases, we need to flip the value\\n    if (flipped === num) {\\n      // if the window which starts from current value cannot fit into the array\\n      if (i + K - 1 >= A.length) return -1;\\n\\n      // flip current value\\n      flipped ^= 1;\\n\\n      // record it\\n      hasFlipped[i] = 1;\\n\\n      ++flips;\\n    }\\n  }\\n  return flips;\\n};\\n```\\nHappy Coding~\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        # status: record whether current character has been flipped already or not\\n        # 0: not flipped\\n        # 1: flipped\\n        flipped = 0\\n\\n        # record whether index i, as the start of substring of length K, has been\\n        # flipped or not\\n        # 0: not flipped\\n        # 1: flipped\\n        has_flipped = [0] * len(A)\\n\\n        min_flips = 0\\n\\n        for idx, num in enumerate(A):\\n            # get the ACTUAL FLIPPED STATUS for current num by removing the flipped\\n            # status of values that are out of window\\n            if idx >= K:\\n                flipped ^= has_flipped[idx - K]\\n\\n            # we will need to flip current value iff\\n            # 1) current value is 1 and it has been flipped (i.e. flipped == 1)\\n            # 2) current value is 0 and it hasn\\'t been flipped (i.e. flipped == 0)\\n            # which can be concluded by (flipped ^ num == 0)\\n            if (flipped ^ num) == 0:\\n                # in case there is no way for us to flip current value\\n                if idx + K - 1 >= len(A):\\n                    return -1\\n\\n                # flip\\n                flipped ^= 1\\n                has_flipped[idx] = 1\\n                min_flips += 1\\n\\n        return min_flips\\n```\n```js\\nvar minKBitFlips = function(A, K) {\\n  if (!A || !A.length) return [];\\n\\n  // flipped: keep track of total flipped status\\n  // 0: not flipped\\n  // 1: flipped\\n  let flips = 0, flipped = 0;\\n  // indicate whether A[i] is truly flipped or not\\n  const hasFlipped = Array(A.length).fill(0);\\n\\n  for (const [i, num] of A.entries()) {\\n    // IMPORTANT: to determine whether at this pointer, the current value has been\\n    // flipped or not, we need to find it based on flipped and hasFlipped[i - k]\\n    if (i >= K) {\\n      flipped ^= hasFlipped[i - K];\\n    }\\n\\n    // if num == 0 and current value has not been flipped yet (flipped == 0)\\n    // if num == 1 and current value has been flipped yet (flipped == 1)\\n    // for any of the two above cases, we need to flip the value\\n    if (flipped === num) {\\n      // if the window which starts from current value cannot fit into the array\\n      if (i + K - 1 >= A.length) return -1;\\n\\n      // flip current value\\n      flipped ^= 1;\\n\\n      // record it\\n      hasFlipped[i] = 1;\\n\\n      ++flips;\\n    }\\n  }\\n  return flips;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277018,
                "title": "python-very-very-easy-solution-beats-78-o-n",
                "content": "# Code\\n```python\\nclass Solution:\\n    def minKBitFlips(self, A, K: int) -> int:\\n        a = []\\n        for i in range(len(A) - K):\\n            if A[i] == 0:\\n                A[i] = 1\\n                A[i + K] ^= 1\\n                if len(a) > 0  and a[-1] == i:\\n                    a.pop()\\n                else:\\n                    a.append(i)\\n                a.append(i+1)\\n        if sum(A[len(A) - K:]) == 0:\\n            if (len(A) - K) in a:\\n                a.remove(len(A) - K)\\n            else:\\n                a.append(len(A) - K)\\n\\t\\treturn len(a) if  if sum(A[len(A) - K:]) == (0 or K) else -1\\n\\n\\n```\\n\\n\\n# Explanation:\\n\\nset = { }\\n\\nstep 0 \\uFF1AA = 0 0 0 1 0 1 1 0 K = 3\\nset = { }\\n\\nstep 1 \\uFF1AA = **1** 0 0 **0** 0 1 1 0        \\nset={0,1}\\n\\nstep 2 \\uFF1AA = 1 **1** 0 0 **1** 1 1 0      \\nset={0,2}\\n\\nstep 3 \\uFF1AA = 1 1 **1** 0 1 **0** 1 0   \\nset = {0,3}\\n\\nstep 4 \\uFF1AA = 1 1 1 **1** 1 0 **0** 0  \\nset = {0,4}\\n\\nstep 5 \\uFF1AA = 1 1 1 1 1 **1 1 1**\\nset = {0,4,5}\\n\\n\\nres = len()\\n\\n\\nIn every operation, flip the **i** th and (**i + K**)th\\n\\n### eg: in step 0\\n\\t\\t\\t\\t\\t flip the       0 0 0 1 0 1 1 0    to   1 1 1 1 0 1 1 0 \\n\\t\\t\\t\\t\\t then flip     1 1 1 1 0 1 1 0    to   1 0 0 0 0 1 1 0\\n\\t\\t\\t\\t\\t record 0 and 1 in a set {0, 1}\\n\\n# \\u4E2D\\u6587\\u89E3\\u91CA\\n\\n### \\u4ECE\\u6700\\u5DE6\\u8FB9\\u5F00\\u59CB\\uFF0C\\u5728\\u7B2C i \\u4F4D\\u9047\\u5230\\u96F6\\u4E4B\\u540E\\uFF0C\\u5206\\u522B\\u4ECE\\u7B2C i \\u4F4D\\u548C \\u7B2C i+1 \\u4F4D\\u5F00\\u59CB\\u7FFB\\u8F6C\\u4E24\\u6B21\\uFF0C\\u6BD4\\u5982step 0 \\u4E2D\\uFF0C\\u4ECE0\\u7FFB\\u8F6C\\u4E09\\u4E2A\\u6570\\uFF0C\\u53C8\\u4ECE1\\u7FFB\\u8F6C\\u4E09\\u4E2A\\u6570\\n\\n### \\u5C31\\u7B49\\u4EF7\\u4E8E\\u53EA\\u7FFB\\u8F6C\\u4E86 i \\u548C i+K \\u4E24\\u4F4D\\uFF08\\u7528\\u4E00\\u4E2A\\u96C6\\u5408\\u8BB0\\u5F55\\u4E0B\\u6765i\\u548Ci+1\\u4E24\\u4E2A\\u7FFB\\u8F6C\\u8D77\\u59CB\\u4F4D\\uFF0C\\u6BD4\\u5982step 0 \\u4E2D\\u7684 {0,1}\\uFF09\\n\\n### \\u7136\\u540E\\u4ECE\\u6700\\u5DE6\\u8FB9\\u5F00\\u59CB\\u4F9D\\u6B21\\u628A\\u96F6\\u4F4D\\u7FFB\\u8FC7\\u6765\\n\\n### \\u7528\\u4E00\\u4E2A\\u96C6\\u5408\\u8BB0\\u5F55\\u4E0B\\u6765 \\u5F00\\u59CB\\u7FFB\\u8F6C\\u7684\\u4F4D\\u7F6E\\uFF0C\\u53BB\\u6389\\u6240\\u6709\\u91CD\\u590D\\u7684\\n\\n## \\u91CC\\u9762\\u8FD8\\u6709\\u4E00\\u4E9B\\u7EC6\\u8282\\u7684\\u5730\\u65B9\\u5C31\\u4E0D\\u5199\\u4E86",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minKBitFlips(self, A, K: int) -> int:\\n        a = []\\n        for i in range(len(A) - K):\\n            if A[i] == 0:\\n                A[i] = 1\\n                A[i + K] ^= 1\\n                if len(a) > 0  and a[-1] == i:\\n                    a.pop()\\n                else:\\n                    a.append(i)\\n                a.append(i+1)\\n        if sum(A[len(A) - K:]) == 0:\\n            if (len(A) - K) in a:\\n                a.remove(len(A) - K)\\n            else:\\n                a.append(len(A) - K)\\n\\t\\treturn len(a) if  if sum(A[len(A) - K:]) == (0 or K) else -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251356,
                "title": "o-nk-solution-but-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int ans=0;\\n        for(int i=0;i<=A.size()-K;i++){\\n            if(A[i]==1)continue;\\n            ans++;\\n            for(int j=0;j<K;j++){\\n                A[i+j]^=1;\\n            }\\n            \\n        }\\n        for(int i=A.size()-K+1;i<A.size();i++)\\n            if(A[i]==0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int ans=0;\\n        for(int i=0;i<=A.size()-K;i++){\\n            if(A[i]==1)continue;\\n            ans++;\\n            for(int j=0;j<K;j++){\\n                A[i+j]^=1;\\n            }\\n            \\n        }\\n        for(int i=A.size()-K+1;i<A.size();i++)\\n            if(A[i]==0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240945,
                "title": "c-o-n-use-queue",
                "content": "```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> q;\\n        int cnt = 0;\\n        for(int i=0;i<A.size();i++){\\n            while(!q.empty() && q.front() + K - 1 < i) q.pop();\\n            if((A[i] - q.size()) % 2 == 1) continue;\\n            if(i+K > A.size()) return -1;\\n            cnt++;\\n            q.push(i);\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> q;\\n        int cnt = 0;\\n        for(int i=0;i<A.size();i++){\\n            while(!q.empty() && q.front() + K - 1 < i) q.pop();\\n            if((A[i] - q.size()) % 2 == 1) continue;\\n            if(i+K > A.size()) return -1;\\n            cnt++;\\n            q.push(i);\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 240748,
                "title": "swift-solution-and-explanation",
                "content": "**Explanation:**\\n***\\nWhether we should flip current number or not depends on the number value and the current flip count. When the number is 0 and current flip count is an even number, or the number is 1 and current flip count is an odd number, we will flip it. \\n\\n> e.g. \\n0 1 0 1 (k = 2)\\nfirst we should flip  \"0\" as the value is 0 and current flip count is 0 (Even), after flip, current flip count become 1\\nthen we should flip  \"1\" as the value is 1 and current flip count is 1 (Odd), after flip, current flip count become 2\\nwhen we try to flip next  \"0\", we should  reduce the flip count of the first \"0\", so the value is 0 and current flip count is 1 (Odd), we won\\'t flip it.\\n\\n**Solution**\\n***\\n```\\nclass Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        let count = A.count\\n        \\n        var needReduceCurFlipCount = Array.init(repeating: false, count: count + 1)\\n        var curFlipCountIsEven = true\\n        var totalFlipCount = 0\\n        \\n        for i in A.indices {\\n            if needReduceCurFlipCount[i] {\\n                curFlipCountIsEven.toggle()\\n            }\\n            \\n            if A[i] == (curFlipCountIsEven ? 0 : 1) {\\n                if i + K - 1 < count {\\n\\t\\t\\t\\t    // reduce flip count when i + K (change odd even)\\n                    needReduceCurFlipCount[i + K] = true\\n\\n                    curFlipCountIsEven.toggle()\\n                    totalFlipCount += 1\\n                } else {\\n                    return -1\\n                }\\n            }\\n        }\\n        \\n        return totalFlipCount\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        let count = A.count\\n        \\n        var needReduceCurFlipCount = Array.init(repeating: false, count: count + 1)\\n        var curFlipCountIsEven = true\\n        var totalFlipCount = 0\\n        \\n        for i in A.indices {\\n            if needReduceCurFlipCount[i] {\\n                curFlipCountIsEven.toggle()\\n            }\\n            \\n            if A[i] == (curFlipCountIsEven ? 0 : 1) {\\n                if i + K - 1 < count {\\n\\t\\t\\t\\t    // reduce flip count when i + K (change odd even)\\n                    needReduceCurFlipCount[i + K] = true\\n\\n                    curFlipCountIsEven.toggle()\\n                    totalFlipCount += 1\\n                } else {\\n                    return -1\\n                }\\n            }\\n        }\\n        \\n        return totalFlipCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239489,
                "title": "proof-of-the-greedy-solution",
                "content": "First, we define a family of functions ```[f1(K, A), f2(K, A), ..., fn-K+1(K, A)]``` w.r.t an array ```A``` with ```n``` elements, where ```fi(K, A)``` applies a ```K```-bit flip to ```A``` with the ```i```th element as the first flipped element. Second, we define ```(fi1, fi2, ..., fim)``` as the composition of these ```m``` functions, which can be applied to ```A``` to get ```fim(K, fim-1(K, ...fi1(K, A)...))```. We can find that ```fi(K, fj(K, A)) == fj(K, fi(K, A))```, and it\\'s obvious that ```(fi1, fi2, ..., fim)``` is equivalent to any permutation of these functions, e.g. ```fim(K, fim-1(K, ...fi1(K, A)...)) == fim-1(K, fim(K, ...fi1(K, A)...))```. Then, we will prove the correctness of the greedy solution.\\n\\nGiven an array ```A```, we assume that there exists ```(fi1, fi2, ..., fim)``` which flips the elements of ```A``` to get an array consisting of 1s with ```m``` as the minimum number of the functions required. Without loss of generality, we assume ```i1 <= i2 <= ... <= im```. And we will prove that ```ix != iy``` for any ```x, y``` at first. We assume there exist ```x, y``` such that ```ix == iy```. Then, we exchange the order of ```fix+1``` and ```fiy```, and we can find that the composition of ```fix``` and ```fiy``` is an identity mapping. Thus, the exchange will lead to the composition of ```m-2``` functions that is equivalent to ```(fi1, fi2, ..., fim)```. However, ```m``` is the minimum number of the ```K```-bit flips required. Therefore ```ix != iy``` for any ```x, y```.\\n\\nThen, we compare ```(fj1, fj2, ..., fjk)``` in which each function is obtained by the greedy algorithm, with ```(fi1, fi2, ..., fim)```. It\\'s obvious that ```k >= m``` and ```j1 < j2 < ... < jk``` (considering the greedy selection). Thus, we need to prove ```k == m``` and ```j1 == i1, j2 == i2, ..., jm == im```. Actually, we can find that the proof of ```k == m``` can be derived from ```j1 == i1, j2 == i2, ..., jm == im```. Thus, we will prove ```j1 == i1, j2 == i2, ..., jm == im```. \\n\\nWithout loss of generality, we assume that there exists at least one ```0``` in ```A```. By induction, we prove ```j1 == i1``` at first. Let ```A[k1]``` be the first ```0``` in ```A```. Thus, ```j1 == k1``` due to the greedy selection. In terms of ```(fi1, fi2, ..., fim)```, if ```k1 < i1```, ```A[k1]``` will not be flipped. And if ```k1 > i1```, ```A[i1]``` will be ```0``` after applying all the functions to ```A```.  Thus, ```i1 == k1 == j1```. Then, we assume ```jx == ix``` for ```x < y <= m```, and we will prove ```jy == iy```. Note that ```A[i] == 1``` for ```i < jy``` after applying the ```y-1``` functions to ```A```, which is determined by the greedy selection. Considering ```(fi1, fi2, ..., fim)```, if ```iy < jy```, ```A[iy]``` will be ```0``` after the flips. And if ```iy > jy```, ```A[jy]``` will not be flipped (```A[jy] == 0``` due to the greedy selection). Thus, ```jy == iy```, and we conclude the proof.\\n",
                "solutionTags": [],
                "code": "```[f1(K, A), f2(K, A), ..., fn-K+1(K, A)]```\n```A```\n```n```\n```fi(K, A)```\n```K```\n```A```\n```i```\n```(fi1, fi2, ..., fim)```\n```m```\n```A```\n```fim(K, fim-1(K, ...fi1(K, A)...))```\n```fi(K, fj(K, A)) == fj(K, fi(K, A))```\n```(fi1, fi2, ..., fim)```\n```fim(K, fim-1(K, ...fi1(K, A)...)) == fim-1(K, fim(K, ...fi1(K, A)...))```\n```A```\n```(fi1, fi2, ..., fim)```\n```A```\n```m```\n```i1 <= i2 <= ... <= im```\n```ix != iy```\n```x, y```\n```x, y```\n```ix == iy```\n```fix+1```\n```fiy```\n```fix```\n```fiy```\n```m-2```\n```(fi1, fi2, ..., fim)```\n```m```\n```K```\n```ix != iy```\n```x, y```\n```(fj1, fj2, ..., fjk)```\n```(fi1, fi2, ..., fim)```\n```k >= m```\n```j1 < j2 < ... < jk```\n```k == m```\n```j1 == i1, j2 == i2, ..., jm == im```\n```k == m```\n```j1 == i1, j2 == i2, ..., jm == im```\n```j1 == i1, j2 == i2, ..., jm == im```\n```0```\n```A```\n```j1 == i1```\n```A[k1]```\n```0```\n```A```\n```j1 == k1```\n```(fi1, fi2, ..., fim)```\n```k1 < i1```\n```A[k1]```\n```k1 > i1```\n```A[i1]```\n```0```\n```A```\n```i1 == k1 == j1```\n```jx == ix```\n```x < y <= m```\n```jy == iy```\n```A[i] == 1```\n```i < jy```\n```y-1```\n```A```\n```(fi1, fi2, ..., fim)```\n```iy < jy```\n```A[iy]```\n```0```\n```iy > jy```\n```A[jy]```\n```A[jy] == 0```\n```jy == iy```",
                "codeTag": "Unknown"
            },
            {
                "id": 238797,
                "title": "greedy-solution-with-bitset",
                "content": "# Concept\\n1. bitwise operation is fast\\n2. sliding window with size K\\n3. when the current bit is 0, we only need to flip all bits in sliding window\\n4. shift the sliding window\\n\\n\\'\\'\\'\\n\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int size = A.size();\\n        int len = 30001;\\n        string ks = \"\";\\n        A.push_back(0);\\n        for(int i=K-1;i>=0;i--){\\n            if(A[i]==0) {\\n                ks+=\"0\";\\n            }\\n            else{\\n                ks+=\"1\";\\n            }\\n        }\\n        bitset<30001> kb(ks);\\n        int count = 0;\\n        for(int i=0;i<size-K+1;i++){\\n            if(kb[0]==0 ){\\n                kb.flip();\\n                count ++;\\n            }\\n            if(A[i+K])\\n                kb.set(K);\\n            else\\n                kb.reset(K);\\n            kb>>=1;\\n        }\\n        for(int i=0;i<K-1;i++){\\n            if(kb[i]==0) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "# Concept\\n1. bitwise operation is fast\\n2. sliding window with size K\\n3. when the current bit is 0, we only need to flip all bits in sliding window\\n4. shift the sliding window\\n\\n\\'\\'\\'\\n\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int size = A.size();\\n        int len = 30001;\\n        string ks = \"\";\\n        A.push_back(0);\\n        for(int i=K-1;i>=0;i--){\\n            if(A[i]==0) {\\n                ks+=\"0\";\\n            }\\n            else{\\n                ks+=\"1\";\\n            }\\n        }\\n        bitset<30001> kb(ks);\\n        int count = 0;\\n        for(int i=0;i<size-K+1;i++){\\n            if(kb[0]==0 ){\\n                kb.flip();\\n                count ++;\\n            }\\n            if(A[i+K])\\n                kb.set(K);\\n            else\\n                kb.reset(K);\\n            kb>>=1;\\n        }\\n        for(int i=0;i<K-1;i++){\\n            if(kb[i]==0) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 238544,
                "title": "python-solution-using-bisect-o-nlogn",
                "content": "the key is flip the `left most 0`, for the `left most 0`, we use it as the first element to flip.\\n\\nbut flip will influence the next k element, here I use a list to store the right most index in each flip. Then I use bisect to find `now index` whether be influenced by previous operation or not.\\n\\n```python\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        res = 0\\n        s = []\\n        for i in range(len(A)):\\n            index = bisect.bisect_right(s, i)\\n            # if influenced, flip it and then judge\\n            if (len(s) - index) % 2 == 1:\\n                A[i] = 1 - A[i]\\n            # only consider it when A[i] == 0\\n            if A[i] == 1: continue\\n            if len(A)-i < K: return -1\\n            res += 1\\n            s.append(i + K)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        res = 0\\n        s = []\\n        for i in range(len(A)):\\n            index = bisect.bisect_right(s, i)\\n            # if influenced, flip it and then judge\\n            if (len(s) - index) % 2 == 1:\\n                A[i] = 1 - A[i]\\n            # only consider it when A[i] == 0\\n            if A[i] == 1: continue\\n            if len(A)-i < K: return -1\\n            res += 1\\n            s.append(i + K)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914666,
                "title": "c-easy-simple-explanation-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n  As we have to make the array equal to 1  , So reverse the problem  Let\\'s we have given Array of same size and all elements are 1 and now we have to make array to nums and minimum no. of operation for both problem is same.\\n1. create dp array with store the prefix sum of all operations till now. But remember   i^th element only effected by previous k-1 elements so, to count the no. of operation for ith element is:\\n  dp[i-1] - dp[i-k]\\n2. so, to find the current value of ith element is (1-temp[i]) if(dp[i-1] - dp[i-k] is not even) else current value remain same as temp[i].\\n3. Then compare every ith element value with nums[i] if there is a mismatch then increment ans by 1 and update dp[i] = dp[i-1] + 1; , if the match is equal then dp[i] = dp[i-1];\\n4. After applying the above operation on n - k element then check for remaining elements if there is a mismatch then return -1 . else return ans;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int>dp(n+1,0);\\n        vector<int>temp(n+1,1);\\n        int ans =0;\\n        for(int i = 0;i<=n-k;i++){\\n             int ind = i-k;\\n             int prev;\\n             if(ind<0){\\n                  prev = 0;\\n             }else{\\n                  prev = dp[i-k];\\n             }\\n            if(i-1>=0)\\n             prev = dp[i-1] - prev;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n           // cout<<prev<<\" \"<<i<<endl;\\n             if(nums[i] != val){\\n                  ans++;\\n                \\n                if(i-1>=0)\\n                  dp[i] = dp[i-1] + 1;\\n                else\\n                  dp[i] += 1;\\n             }else{\\n                if(i-1>=0)\\n                 dp[i] =dp[i-1];\\n             }\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n             dp[i] =dp[i-1];\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n            int prev;\\n         if((i-k)>=0)\\n              prev = dp[i-1] - dp[i-k];\\n         else\\n             prev = dp[i-1];\\n           //   cout<<prev<<\" \"<<i<<endl;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n             if(nums[i] != val){\\n                  return -1;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int>dp(n+1,0);\\n        vector<int>temp(n+1,1);\\n        int ans =0;\\n        for(int i = 0;i<=n-k;i++){\\n             int ind = i-k;\\n             int prev;\\n             if(ind<0){\\n                  prev = 0;\\n             }else{\\n                  prev = dp[i-k];\\n             }\\n            if(i-1>=0)\\n             prev = dp[i-1] - prev;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n           // cout<<prev<<\" \"<<i<<endl;\\n             if(nums[i] != val){\\n                  ans++;\\n                \\n                if(i-1>=0)\\n                  dp[i] = dp[i-1] + 1;\\n                else\\n                  dp[i] += 1;\\n             }else{\\n                if(i-1>=0)\\n                 dp[i] =dp[i-1];\\n             }\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n             dp[i] =dp[i-1];\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n            int prev;\\n         if((i-k)>=0)\\n              prev = dp[i-1] - dp[i-k];\\n         else\\n             prev = dp[i-1];\\n           //   cout<<prev<<\" \"<<i<<endl;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n             if(nums[i] != val){\\n                  return -1;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3880677,
                "title": "python-concise-o-n-solution-using-queue-to-track-numbers-of-flip",
                "content": "If we have to manipulate the list for every flip, we need O(K) additional runtime for each flip. However, we can store flip information in queue and use the length of the queue for determining if the current element we look at needs to be flipped or not.\\n\\n```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: list[int], k: int) -> int:\\n        dp = [-1] * len(nums)\\n        flips = deque()\\n        ans = 0\\n        for i in range(len(nums) - k + 1):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                ans += 1\\n                flips.append(i + k - 1)\\n        for i in range(len(nums) - k, len(nums)):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: list[int], k: int) -> int:\\n        dp = [-1] * len(nums)\\n        flips = deque()\\n        ans = 0\\n        for i in range(len(nums) - k + 1):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                ans += 1\\n                flips.append(i + k - 1)\\n        for i in range(len(nums) - k, len(nums)):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722203,
                "title": "o-n-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int high=0,temp,res=0,count;\\n        queue<int> q;\\n        while(high<nums.size()){\\n            if(nums[high]==0){\\n               q.push(high+k-1);\\n               temp=k;\\n               count=1;\\n               res+=1;\\n               while(temp){\\n                   if(nums.size()-high<temp)return -1;\\n                   if(count%2==1)nums[high]==0?nums[high]=1:nums[high]=0;\\n                   if(nums[high]==0){\\n                       temp=k;res++;nums[high]=1;\\n                       q.push(high+k-1);\\n                       count++;\\n                   }\\n                   temp--;\\n                   if(q.size()>0 && q.front()==high)count--,q.pop();\\n                   high++;\\n               }\\n            }\\n            else\\n            high++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int high=0,temp,res=0,count;\\n        queue<int> q;\\n        while(high<nums.size()){\\n            if(nums[high]==0){\\n               q.push(high+k-1);\\n               temp=k;\\n               count=1;\\n               res+=1;\\n               while(temp){\\n                   if(nums.size()-high<temp)return -1;\\n                   if(count%2==1)nums[high]==0?nums[high]=1:nums[high]=0;\\n                   if(nums[high]==0){\\n                       temp=k;res++;nums[high]=1;\\n                       q.push(high+k-1);\\n                       count++;\\n                   }\\n                   temp--;\\n                   if(q.size()>0 && q.front()==high)count--,q.pop();\\n                   high++;\\n               }\\n            }\\n            else\\n            high++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715068,
                "title": "python-brute-force-optimization-with-queue-and-more",
                "content": "**Brute-force is easy**\\nAt each index with `0` invert `k` items.\\nCount number of invert calls.\\nCheck that inverted `nums` has all `1`. Return `count` otherwise return -1.\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        for i in range(N - k + 1):\\n            if nums[i] == 0:\\n                count += 1\\n                for j in range(i, i + k):\\n                    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n        \\n        return count if all(num == 1 for num in nums) else -1\\n```\\n`O(N\\\\*k)`, kinda slow, let\\'s move on to optimization.\\n\\nWhat can be optimizad here? What\\'s slow?\\nWe need to go over the array at least once (to check if it\\'s all `1`), so we cannot get rid of `N`.\\nLet\\'s work on `k`.\\n\\n**Optimizing `O(k)` -> `O(1)`**\\n```\\nfor j in range(i, i + k):\\n    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n```\\nWhat do we do here?\\nWe go over next `k` elements and invert them.\\n\\nHow can we combine going over `k` and going over `N` loops???\\n\\nA few observations from brute-force:\\n1. we need to know when to stop inverting\\n2. we need to do inverting and going over `N` and `k` at the same time.\\n\\n**Approach 1.5**\\nQ: How to track when to stop inverting???\\nA: We can use some kind of DS (list/queue???) and keep tracking k-invert ends.\\n\\nQ: What if we need to invert inside of another currently running k-invert???\\nA: So we need to track current inver count. It can be that we started one invert, then next element needs another invert and the next need another request. Kind of enveloping. We can just have a `invert-times` counter or reuse `inver-ends` DS and loop over each invert-end and do `XOR`.\\n\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        inv_ends = deque() # track invert-ends\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft() # remove invert-end that is not active anymore\\n            if inv_ends:\\n                for _ in inv_ends: # if we need to invert, just invert as many times as we need (=number of currently running invert procedures)\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k: # can invert only when possible - i <= N - k and when [i] == 0\\n                count += 1 # count inverts\\n                nums[i] = 1 # set it to 1\\n                inv_ends.append(i + k) # append new k-invert end\\n        \\n        return count if all(num == 1 for num in nums) else -1 # all ones -> we good, else -1\\n```\\nStill `O(N*k)`, but now we know what we\\'re doing.\\nWe replaced **horizontal** k-inverts with **vertical** k-inverts.\\n\\n**Optimizing `O(N*k)` to O(N)**\\nIn the last approach we see that our `k` loop is still there.\\nWhat do we do in the loop? We flip `1->0` or `0->1` `k` times.\\n\\nQ: How can we optimize it?\\nA: if you do **even** number of flips, you get the same number you had before\\nIf you do **odd**, you get the opposite one.\\n\\nSo we can replace this `O(k)`\\n```\\n                for _ in inv_ends:\\n                    nums[i] ^= 1\\n```\\nwith this `O(1)`\\n```\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n```\\nand have the same outcome!\\n\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        ones = 0\\n        N = len(nums)\\n        inv_ends = deque()\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k:\\n                count += 1\\n                nums[i] = 1\\n                inv_ends.append(i + k)\\n            if nums[i]:\\n                ones += 1\\n        \\n        return count if ones == N else -1\\n```\\n\\nNow a bit of clean up so that we don\\'t modify the `nums` array.\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        count = 0\\n        ones = 0\\n        inv_ends = deque()\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                inv_ends.append(i + k)\\n            ones += one        \\n        return count if ones == N else -1\\n```\\n\\n**Optimize space `O(k)` to `O(1)`**\\nThis is not exactly `O(1)` constant space as I wish it was. This is `O(1)` extra space with `nums` modification, which is not the best, but you inline information from the queue in the `nums` and get rid of queue.\\n\\n`\\xAF\\\\_(\\u30C4)_/\\xAF`\\n\\nKeep track `inv_ends` in `nums`.\\nAs `nums` contains only `0` or `1`, we can `-2` from each k-invert start position instead of using `inv_end` marker.\\nAs we cannot modify future elements (guess why?), we\\'ll have to modify past elements and use `[inv_start] -= 2` now and check from the current element if we get ouf of one of the currently running k-invert procedures ([i - k] < 0 ? -> found marker).\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        ones = 0\\n        count = 0\\n        invert_ops = 0\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if i >= k and nums[i - k] < 0:\\n                nums[i - k] += 2 # restore original array\\n                invert_ops -= 1\\n            if invert_ops % 2:\\n                one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                invert_ops += 1\\n                nums[i] -= 2 # modify original array\\n            ones += one        \\n        return count if ones == N else -1\\n```\\n\\nP.S. it\\'s not that bad with the approach: we can restore the original `nums` if needed by iterating over the array and `+2` at marker positions to restore the original `nums`.\\n\\nCheers!",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        for i in range(N - k + 1):\\n            if nums[i] == 0:\\n                count += 1\\n                for j in range(i, i + k):\\n                    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n        \\n        return count if all(num == 1 for num in nums) else -1\\n```\n```\\nfor j in range(i, i + k):\\n    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        inv_ends = deque() # track invert-ends\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft() # remove invert-end that is not active anymore\\n            if inv_ends:\\n                for _ in inv_ends: # if we need to invert, just invert as many times as we need (=number of currently running invert procedures)\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k: # can invert only when possible - i <= N - k and when [i] == 0\\n                count += 1 # count inverts\\n                nums[i] = 1 # set it to 1\\n                inv_ends.append(i + k) # append new k-invert end\\n        \\n        return count if all(num == 1 for num in nums) else -1 # all ones -> we good, else -1\\n```\n```\\n                for _ in inv_ends:\\n                    nums[i] ^= 1\\n```\n```\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        ones = 0\\n        N = len(nums)\\n        inv_ends = deque()\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k:\\n                count += 1\\n                nums[i] = 1\\n                inv_ends.append(i + k)\\n            if nums[i]:\\n                ones += 1\\n        \\n        return count if ones == N else -1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        count = 0\\n        ones = 0\\n        inv_ends = deque()\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                inv_ends.append(i + k)\\n            ones += one        \\n        return count if ones == N else -1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        ones = 0\\n        count = 0\\n        invert_ops = 0\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if i >= k and nums[i - k] < 0:\\n                nums[i - k] += 2 # restore original array\\n                invert_ops -= 1\\n            if invert_ops % 2:\\n                one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                invert_ops += 1\\n                nums[i] -= 2 # modify original array\\n            ones += one        \\n        return count if ones == N else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649225,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minKBitFlips(nums: Array[Int], k: Int): Int = {\\n      val n = nums.length\\n      val diff = Array.fill(n + 1)(0)\\n      var ans = 0\\n      var revCnt = 0\\n      var i = 0\\n      while (i < n) {\\n        revCnt += diff(i)\\n        if ((nums(i) + revCnt) % 2 == 0) {\\n          if (i + k > n) {\\n            ans = -1\\n            i = n\\n          } else {\\n            ans += 1\\n            revCnt += 1\\n            diff(i + k) -= 1\\n          }\\n        }\\n        i += 1\\n      }\\n      ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minKBitFlips(nums: Array[Int], k: Int): Int = {\\n      val n = nums.length\\n      val diff = Array.fill(n + 1)(0)\\n      var ans = 0\\n      var revCnt = 0\\n      var i = 0\\n      while (i < n) {\\n        revCnt += diff(i)\\n        if ((nums(i) + revCnt) % 2 == 0) {\\n          if (i + k > n) {\\n            ans = -1\\n            i = n\\n          } else {\\n            ans += 1\\n            revCnt += 1\\n            diff(i + k) -= 1\\n          }\\n        }\\n        i += 1\\n      }\\n      ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3576679,
                "title": "python-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        f = [0] * len(nums)\\n        psum = 0\\n        for i in range(len(nums)-k+1):\\n            if (psum + nums[i])%2 == 0:\\n                f[i] = 1\\n            psum += f[i]\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]\\n        for i in range(len(nums)-k+1, len(nums)):\\n            if (psum+nums[i])%2 == 0:\\n                return -1\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]  \\n        return sum(f)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        f = [0] * len(nums)\\n        psum = 0\\n        for i in range(len(nums)-k+1):\\n            if (psum + nums[i])%2 == 0:\\n                f[i] = 1\\n            psum += f[i]\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]\\n        for i in range(len(nums)-k+1, len(nums)):\\n            if (psum+nums[i])%2 == 0:\\n                return -1\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]  \\n        return sum(f)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566350,
                "title": "easy-solution-with-multiple-proofs-intuition-for-greedy-when-impossible",
                "content": "# Greedy Intuition + Proof\\n-Our greedy strategy is to iterate from beginning to end of the array. If we encounter a bit that is a 0 it needs to be flipped so we flip a \\'window\\' of k elements starting at thi current element.\\n\\n-Invariant of this strategy: All elements currently iterated through are 1s\\n\\nInductive proof on the optimality of this strategy:\\n\\nLet i be the current index we have iterated through\\n\\nBase Case (i = 0):\\n-there are two cases when i = 0.\\n\\narr[0] = 1: in this case no flip is neccesary hence optimal\\narr[0] = 0: in this case we MUST flip because the start of the flip window is strictly increasing hence this is the only possible starting flip index to flip this 0 to a 1 hence it is part of the optimal sequence of flips.\\n\\nInductive Hypothesis: arr[0:n] is a subarray of consecutive 1s achieved int eh optimal set of flips.\\n\\nInductive Case (i = n + 1):\\n\\nWe assume the inductive hypothesis\\n\\n-there are two cases\\n\\narr[n + 1] = 1: In this case no flip is neccesary hence optimal\\narr[n + 1] = 0: In this case I must flip a window starting at this index because no other flip going forward can turbn this 0 into a 1. Hence it is optimal.\\n\\n\\n# Optimal Substructure\\n-For me, the least intutive part of this problem is understanding why there is an optimal substructure (ie. making a locally optimal flip leads to a global optimum). When determining flips from left to right we have established an invariant holds that all previously processed elements are 1s. If we want to flip the current element flipping a window starting before i (the current index), assuming it fits, will convert some number of 1s back to 0s, this will lead the array to have the following structure: [1, ... , 1, 0, ... , 0, 1, ...] such that the current index is the last (farthest left) 1. In order to convert this sequence to 1s we must use at least 2 more flips, one to convert the 0s to 1s and 1 to convert the 0s this flip creates to ones (more flips may be neccesary based on how we choose them), hence choosing a flip window starting at the current index is optimal since it only requires 1 flip starting to convert to prefix array to all 1s. \\n\\n-One concern I had was that flipping at the current index greedily may arrange future bits to be processed to requrie more flips than a different strategy. I have shown that when encountering a 0 bit, flipping it with a window starting before it requires at least two flips while flipping starting at the index requires just one flip. Assume that our greedy strategy happens to flip future 1s to 0s that the other hypothetical strategy doesn\\'t. Well we can convert all of these 1s back to 0s in just 1 additional future flip because they will all be reachable from the window starting at the next 1. Hence the hypothetical strategy globally contributes at least 2 flips at each 0 it processes while the greedy strategy globally contributes at most 2 flips at each 0 it processes, thus there is an optimal substructure.\\n\\n# Proof of Impossible State\\n\\nWhen our algorithm produces a state in which our array is all ones followed by all 0s (arr = [1, ... ,1,0, ... ,0]) such that the number of 0s is less than k it is impossible to achieve an array with no 0s. \\n\\nI will prove this by contradiction.\\n\\nProof: Assume it is possible to turn an array of the aforementioned state into an array with no 0s using valid operations. Then it is possible to do this is an optimal number of steps. An optimal number of steps must not repear any flipping steps since repeating flips of the same window cancels itself out (hence doing so an even number of times does nothing while doing so an odd number of times is equivelenat to performing just a single flip). \\n\\nIn order to turn this array into an array of all 1s we must perform at least one flip of the 0s. Since there are less than k 0s the beginning of this flip window must begin before the first 0 (at some index that currently has a 1). I will denote this starting index of the window j. This means the element at j is initially a 1 and is flipped into a 0. In order for this index to be flipped back to a 1 another flip must take place at or before this index. If a flip takes place at this index a duplicate operation must be performed hence we have a contradiction. If the flip takes place before we have a new index j, the farthest left 0 that must have another flip at or to the left of it. The same two cases apply before. If we keep flipping before eventually we end up pushing j back until j = 0 (the first index) and it can no longer be pushed back. Once here the only flip that can turn it back into a 1 is a flip starting at index 0 which duplicates the flip that turned it from a 1 back into a 0, hence our optimal solution must have a duplicate, hence a contradiction. QED\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int flips = 0;\\n        queue<int> filters; //queue of \\'filters\\' used to simulate bit flips\\n        int cur = 0; //current filter\\n        for (int i = 0; i < nums.size(); i++) {\\n            //assume invariant that all previous elements are 1\\n            if ((nums[i] ^ cur) == 0 && (nums.size() - i) < k) return -1; //impossible case\\n            if ((nums[i] ^ cur) == 0) {\\n                flips++;\\n                filters.push(i + k - 1);\\n                cur = 1 - cur;\\n            } \\n            if (!filters.empty() && filters.front() == i) { //process filters queue\\n                filters.pop();\\n                cur = 1 - cur;\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int flips = 0;\\n        queue<int> filters; //queue of \\'filters\\' used to simulate bit flips\\n        int cur = 0; //current filter\\n        for (int i = 0; i < nums.size(); i++) {\\n            //assume invariant that all previous elements are 1\\n            if ((nums[i] ^ cur) == 0 && (nums.size() - i) < k) return -1; //impossible case\\n            if ((nums[i] ^ cur) == 0) {\\n                flips++;\\n                filters.push(i + k - 1);\\n                cur = 1 - cur;\\n            } \\n            if (!filters.empty() && filters.front() == i) { //process filters queue\\n                filters.pop();\\n                cur = 1 - cur;\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489859,
                "title": "c-very-easy-to-understand-o-n-solution-beats-100-memory-and-runtime",
                "content": "# Intuition\\nIt is given that we need to convert all 0s to 1s in the array. We are given `k` which is the size of window in which we can flip the bits.\\nIf we take the example - `[0,1,0]` and `k = 2` we can see that we can solve this by flipping window of size `k` from index 0 and also index 1. So we see that if we are flipping for element 0 and 1 is encountered in the window, we need to start a window for 1 when it is encountered in the previous window. \\n\\n# Approach\\n- We maintain a `ans` variable for counting the number of windows that need to be flipped.  \\n- We maintain a variable whichToFlip which essentially tells us when to start the flipping window (when current element is 0 or it is 1). It is initialized to 0 as we need to flip all 0s to 1s initially when no window is there. \\n- Start traversing the array and check 2 conditions.\\n    - If the window to the left of the current element is flipped or no. In that case it changes the `whichToFlip` to `!whichToFlip`.\\n    - If the element to be flipped (`whichToFlip`) is equal to the current element. \\n        - We also check if making a window of size `k` is possible from the current position (`i+k > n`). If it returns true then return -1 as it is not possible to create a window from that position.\\n        - Else start a window from the current element and mark the element as a starting point of the window. We do this by incrementing `nums[i]` by 10. We also increment answer and change whichToFlip.\\n# Complexity\\n    \\nTime complexity:\\n\\n    O(n)    \\n\\nSpace complexity:\\n\\n    O(1)    \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans=0;\\n        int whichToFlip = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(i>=k && nums[i-k] > 1){ // Checks if previous subarray of length k is flipped\\n                whichToFlip = !whichToFlip;\\n            }\\n\\n            if(whichToFlip == nums[i]){\\n                if(k+i >n)return -1; // If flipping is required but not enough elements available\\n                ans++;\\n                // If flipping window has not ended and the opposite element is \\n                // encountered then another window should start flipping from that element.\\n                whichToFlip = !whichToFlip;  \\n                nums[i] += 10;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans=0;\\n        int whichToFlip = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(i>=k && nums[i-k] > 1){ // Checks if previous subarray of length k is flipped\\n                whichToFlip = !whichToFlip;\\n            }\\n\\n            if(whichToFlip == nums[i]){\\n                if(k+i >n)return -1; // If flipping is required but not enough elements available\\n                ans++;\\n                // If flipping window has not ended and the opposite element is \\n                // encountered then another window should start flipping from that element.\\n                whichToFlip = !whichToFlip;  \\n                nums[i] += 10;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430942,
                "title": "greedy-approch-in-javascript-49-9-mb-less-than-100-00",
                "content": "![image](https://assets.leetcode.com/users/images/4d790763-1b20-4907-b57e-395e127aeccb_1681821707.122669.png)\\n\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0;\\n    \\n    function flip(pos){\\n         for(let i=0 ;i<k;i++){\\n            nums[i+pos] = 1- nums[i+pos] ;\\n        }\\n    }\\n\\n     for(let i=0; i<nums.length; i++){\\n        if(nums[i] === 0 && (i+k)<= nums.length){\\n            flip(i)\\n            count++\\n            }\\n     }\\n    \\n   return !nums.includes(0) ? count : -1;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/4d790763-1b20-4907-b57e-395e127aeccb_1681821707.122669.png)\\n\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0;\\n    \\n    function flip(pos){\\n         for(let i=0 ;i<k;i++){\\n            nums[i+pos] = 1- nums[i+pos] ;\\n        }\\n    }\\n\\n     for(let i=0; i<nums.length; i++){\\n        if(nums[i] === 0 && (i+k)<= nums.length){\\n            flip(i)\\n            count++\\n            }\\n     }\\n    \\n   return !nums.includes(0) ? count : -1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3380470,
                "title": "python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        flips = 0\\n        if nums[0] == 0:\\n            for i in range(k):\\n                nums[i] = 1 - nums[i]\\n            flips += 1\\n        \\n        diff = [abs(nums[i+1] - nums[i]) for i in range(n-1)]\\n\\n        for i in range(n-k):\\n            if diff[i] == 1:\\n                flips += 1\\n                \\n                if i < n-k-1:\\n                    diff[i+k] = 1- diff[i+k]\\n        \\n\\n        if 1 in diff[n-k:]:\\n            return -1\\n        return flips\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        flips = 0\\n        if nums[0] == 0:\\n            for i in range(k):\\n                nums[i] = 1 - nums[i]\\n            flips += 1\\n        \\n        diff = [abs(nums[i+1] - nums[i]) for i in range(n-1)]\\n\\n        for i in range(n-k):\\n            if diff[i] == 1:\\n                flips += 1\\n                \\n                if i < n-k-1:\\n                    diff[i+k] = 1- diff[i+k]\\n        \\n\\n        if 1 in diff[n-k:]:\\n            return -1\\n        return flips\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357098,
                "title": "rust-fast-and-simple-15ms",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(k)$$ \\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize; \\n        let n = nums.len(); \\n        let mut res = 0;\\n        let mut q = std::collections::VecDeque::with_capacity(k);\\n        for (i, v) in nums.iter().enumerate() {\\n            if let Some(&j) = q.front() { \\n                if j == i {\\n                    q.pop_front();\\n                }\\n            }\\n            if (v + q.len() as i32) & 1 == 0 {\\n                if i > n - k {\\n                    return -1\\n                } else {\\n                    q.push_back(i + k);\\n                    res += 1;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize; \\n        let n = nums.len(); \\n        let mut res = 0;\\n        let mut q = std::collections::VecDeque::with_capacity(k);\\n        for (i, v) in nums.iter().enumerate() {\\n            if let Some(&j) = q.front() { \\n                if j == i {\\n                    q.pop_front();\\n                }\\n            }\\n            if (v + q.len() as i32) & 1 == 0 {\\n                if i > n - k {\\n                    return -1\\n                } else {\\n                    q.push_back(i + k);\\n                    res += 1;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313761,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310574,
                "title": "easy-solution-for-a-hard-problem-simple-c-queue",
                "content": "0(N) : Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int> q;\\n        const int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int bit = nums[i];\\n            while(!q.empty() && q.front() < i) {\\n                q.pop();\\n            }\\n            if(q.size() % 2) {\\n                bit ^= 1;\\n            }\\n            if(!bit) {\\n                if(i + k - 1 >= n) {\\n                    return -1;\\n                }\\n                q.push(i + k - 1);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int> q;\\n        const int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int bit = nums[i];\\n            while(!q.empty() && q.front() < i) {\\n                q.pop();\\n            }\\n            if(q.size() % 2) {\\n                bit ^= 1;\\n            }\\n            if(!bit) {\\n                if(i + k - 1 >= n) {\\n                    return -1;\\n                }\\n                q.push(i + k - 1);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255409,
                "title": "javascript-995-minimum-number-of-k-consecutive-bit-flips",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1\\n```\\nvar minKBitFlips = function (a, k) {\\n    function flip(a, s, e) {\\n        if (e >= a.length) {\\n            return false;\\n        }\\n        for (let i = s; i <= e; i++) {\\n            a[i] = 1 - a[i];\\n        }\\n        return true;\\n    }\\n\\n    let n = a.length;\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] === 0) {\\n            if (!flip(a, i, i + k - 1)) {\\n                return -1;\\n            }\\n            cc++;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n2\\n```\\nvar minKBitFlips = function (a, k) {\\n    let n = a.length;\\n    let cc = 0;\\n\\n    let q_prev_flip_end_idx = [];\\n    for (let i = 0; i < n; i++) {\\n        a[i] += q_prev_flip_end_idx.length;\\n        a[i] %= 2;\\n\\n        if (a[i] === 0) {\\n            cc += 1;\\n            q_prev_flip_end_idx.push(i + k - 1);\\n        }\\n        if (q_prev_flip_end_idx[0] === i) {\\n            q_prev_flip_end_idx.shift();\\n        }\\n    }\\n    if (q_prev_flip_end_idx.at(-1) >= n) {\\n        return -1;\\n    }\\n    return cc;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minKBitFlips = function (a, k) {\\n    function flip(a, s, e) {\\n        if (e >= a.length) {\\n            return false;\\n        }\\n        for (let i = s; i <= e; i++) {\\n            a[i] = 1 - a[i];\\n        }\\n        return true;\\n    }\\n\\n    let n = a.length;\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] === 0) {\\n            if (!flip(a, i, i + k - 1)) {\\n                return -1;\\n            }\\n            cc++;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar minKBitFlips = function (a, k) {\\n    let n = a.length;\\n    let cc = 0;\\n\\n    let q_prev_flip_end_idx = [];\\n    for (let i = 0; i < n; i++) {\\n        a[i] += q_prev_flip_end_idx.length;\\n        a[i] %= 2;\\n\\n        if (a[i] === 0) {\\n            cc += 1;\\n            q_prev_flip_end_idx.push(i + k - 1);\\n        }\\n        if (q_prev_flip_end_idx[0] === i) {\\n            q_prev_flip_end_idx.shift();\\n        }\\n    }\\n    if (q_prev_flip_end_idx.at(-1) >= n) {\\n        return -1;\\n    }\\n    return cc;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245571,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N=len(nums)\\n        if k==1:\\n            return nums.count(0)\\n        elif k==N:\\n            cnt=nums.count(1)\\n            if cnt==N:return 0\\n            if cnt==0:return 1\\n            return -1\\n        \\n        st=[0]*N\\n        for i in range(k-1):\\n            st[i]=nums[i]\\n        ret=one=0\\n        for i in range(N-k+1):\\n            K=i+k-1\\n            st[K]=nums[K]^one\\n            if not st[i]^one:\\n                ret+=1\\n                one^=1\\n        for i in range(N-k+1,N):\\n            if not st[i]^one:return -1\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N=len(nums)\\n        if k==1:\\n            return nums.count(0)\\n        elif k==N:\\n            cnt=nums.count(1)\\n            if cnt==N:return 0\\n            if cnt==0:return 1\\n            return -1\\n        \\n        st=[0]*N\\n        for i in range(k-1):\\n            st[i]=nums[i]\\n        ret=one=0\\n        for i in range(N-k+1):\\n            K=i+k-1\\n            st[K]=nums[K]^one\\n            if not st[i]^one:\\n                ret+=1\\n                one^=1\\n        for i in range(N-k+1,N):\\n            if not st[i]^one:return -1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201709,
                "title": "simulation-got-tle-so-i-redefined-what-is-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of toggling `k` elements every time, I chose to toggle `one` and set a reminder to untoggle it `k - 1` steps later.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy \\xD7 { Simulation, Bit Manipulation + Toggling `one` }\\n\\n# Complexity\\n| | Gr + Sim | Gr + BitM + Tog |\\n|-|:-:|:-:|\\n|time|$$O((n-k)k)$$|$$O(n)$$|\\n|space|$$O(1)$$|$$O(1)$$|\\n\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGreedy + Simulation\\n\\u26A0**TLE**\\u2757\\n```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        for i in range(len(A)-k):\\n            if A[i] == 0:\\n                n += 1\\n                for j in range(i, i+k):\\n                    A[j] ^= 1\\n        tail = sum(A[-k:])\\n        if tail == 0:\\n            return n + 1\\n        elif tail == k:\\n            return n\\n        return -1\\n```\\n\\n\\u2193 Greedy + Bit Manipulation + Toggling `one` \\u2193\\n```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        one = 1\\n\\n        t = k - 1\\n        for i in range(I := len(A)-t):\\n            if A[i]&1 != one:\\n                n += 1\\n                one ^= 1\\n                A[i+t] |= 2\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        for i in range(I, len(A)):\\n            if A[i]&1 != one:\\n                return -1\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        return n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        for i in range(len(A)-k):\\n            if A[i] == 0:\\n                n += 1\\n                for j in range(i, i+k):\\n                    A[j] ^= 1\\n        tail = sum(A[-k:])\\n        if tail == 0:\\n            return n + 1\\n        elif tail == k:\\n            return n\\n        return -1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        one = 1\\n\\n        t = k - 1\\n        for i in range(I := len(A)-t):\\n            if A[i]&1 != one:\\n                n += 1\\n                one ^= 1\\n                A[i+t] |= 2\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        for i in range(I, len(A)):\\n            if A[i]&1 != one:\\n                return -1\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090153,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nflipping a 1 bit is waste of time start flipping where we first encounter 0 bit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintaining the no of flips on the current ind\\nmaintain queue to keep flip\\'s last index till their its effect is realised\\n if flips ona ind are odd we should find for 1 bit bcz that would get converted to 0 and vice versa for even no of flips\\nflips are not possible if its range goes out of n.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int j=0;\\n        int count=0;\\n        queue<int> q;\\n        while(j<nums.size()){\\n            \\n            while(q.size() && q.front()<j)  q.pop();\\n            if(q.size()%2==0 && nums[j]==0){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push(j+k-1);\\n                count++;\\n            }\\n            else if(q.size()&1 && nums[j]){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push((j+k-1));\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int j=0;\\n        int count=0;\\n        queue<int> q;\\n        while(j<nums.size()){\\n            \\n            while(q.size() && q.front()<j)  q.pop();\\n            if(q.size()%2==0 && nums[j]==0){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push(j+k-1);\\n                count++;\\n            }\\n            else if(q.size()&1 && nums[j]){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push((j+k-1));\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055428,
                "title": "very-simple-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013769,
                "title": "c-very-easy-o-n-detailed-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans=0,n=nums.size(),cnt=0;\\n        queue<int>q; // for storing the index of element which is needed to flip so that we can count the flip in given window size i.e. k\\n        for(int i=0;i<n;i++){\\n            if(!q.empty() && i-q.front()>=k){  // if window length is greater than k\\n                q.pop();\\n                cnt--;\\n            }\\n            if((nums[i]+cnt)%2==0){  // checking the current value of nums[i] to make sure whether current element needs to flip or not\\n                if(n-i<k) return -1;  // if there is any element needs to flip but the remaining window size is less than k than it will not be possible to make all 1 so we will return -1\\n                 cnt++;\\n                 q.push(i);\\n                 ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans=0,n=nums.size(),cnt=0;\\n        queue<int>q; // for storing the index of element which is needed to flip so that we can count the flip in given window size i.e. k\\n        for(int i=0;i<n;i++){\\n            if(!q.empty() && i-q.front()>=k){  // if window length is greater than k\\n                q.pop();\\n                cnt--;\\n            }\\n            if((nums[i]+cnt)%2==0){  // checking the current value of nums[i] to make sure whether current element needs to flip or not\\n                if(n-i<k) return -1;  // if there is any element needs to flip but the remaining window size is less than k than it will not be possible to make all 1 so we will return -1\\n                 cnt++;\\n                 q.push(i);\\n                 ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002923,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        let k = k as usize;\\n        let mut cur = 0;\\n        let mut res = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            if i >= k && nums[i - k] > 1 {\\n                cur -= 1;\\n                nums[i - k] -= 2;\\n            }\\n            if cur % 2 == nums[i] as usize {\\n                if i + k > n {\\n                    return -1;\\n                }\\n                nums[i] += 2;\\n                cur += 1;\\n                res += 1;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        let k = k as usize;\\n        let mut cur = 0;\\n        let mut res = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            if i >= k && nums[i - k] > 1 {\\n                cur -= 1;\\n                nums[i - k] -= 2;\\n            }\\n            if cur % 2 == nums[i] as usize {\\n                if i + k > n {\\n                    return -1;\\n                }\\n                nums[i] += 2;\\n                cur += 1;\\n                res += 1;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2969460,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957312,
                "title": "segment-tree-to-count-intervals",
                "content": "```\\nclass Node:\\n    def __init__(self, start, end, sum = 0):\\n        self.start = start\\n        self.end = end\\n        self.left = None\\n        self.right = None\\n        self.sum = sum\\n\\nclass SegTree:\\n    def __init__(self, nums):\\n        n = len(nums)\\n        self.start = 0\\n        self.end = n - 1\\n        self.root = self.createTree(0, n - 1, nums)\\n        \\n    def createTree(self, start, end, nums):\\n        if start > end:\\n            return None\\n        root = Node(start, end)\\n        if start == end:\\n            root.sum = nums[start]\\n            return root\\n        mid = (start + end) // 2\\n        root.left = self.createTree(start, mid, nums)\\n        root.right = self.createTree(mid + 1, end, nums)\\n        root.sum = root.left.sum + root.right.sum\\n        return root\\n    \\n    def _update(self, root, start, end, i, val):\\n        if not root:\\n            return\\n        if start == end:\\n            root.sum += val\\n            return\\n        mid = (start + end) // 2\\n        if i <= mid:\\n            self._update(root.left, start, mid, i, val)\\n        else:\\n            self._update(root.right, mid + 1, end, i, val)\\n        root.sum = root.left.sum + root.right.sum\\n    \\n    def update(self, index, val):\\n        self._update(self.root, self.start, self.end, index, val)\\n    \\n    def _sumRange(self, root, start, end):\\n        if not root:\\n            return 0\\n        if root.start == start and root.end == end:\\n            return root.sum\\n        mid = (root.start + root.end) // 2\\n        if end <= mid:\\n            return self._sumRange(root.left, start, end)\\n        elif start >= mid + 1:\\n            return self._sumRange(root.right, start, end)\\n        else:\\n            return self._sumRange(root.left, start, mid) + self._sumRange(root.right, mid + 1, end)\\n    \\n    def sumRange(self, left, right):\\n        return self._sumRange(self.root, left, right)\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        segtree = SegTree([0] * (n + 1))\\n        for i in range(n - k + 1):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                res += 1\\n                segtree.update(i, 1)\\n                segtree.update(min(i + k, n), -1)\\n        for i in range(n - k + 1, n):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, start, end, sum = 0):\\n        self.start = start\\n        self.end = end\\n        self.left = None\\n        self.right = None\\n        self.sum = sum\\n\\nclass SegTree:\\n    def __init__(self, nums):\\n        n = len(nums)\\n        self.start = 0\\n        self.end = n - 1\\n        self.root = self.createTree(0, n - 1, nums)\\n        \\n    def createTree(self, start, end, nums):\\n        if start > end:\\n            return None\\n        root = Node(start, end)\\n        if start == end:\\n            root.sum = nums[start]\\n            return root\\n        mid = (start + end) // 2\\n        root.left = self.createTree(start, mid, nums)\\n        root.right = self.createTree(mid + 1, end, nums)\\n        root.sum = root.left.sum + root.right.sum\\n        return root\\n    \\n    def _update(self, root, start, end, i, val):\\n        if not root:\\n            return\\n        if start == end:\\n            root.sum += val\\n            return\\n        mid = (start + end) // 2\\n        if i <= mid:\\n            self._update(root.left, start, mid, i, val)\\n        else:\\n            self._update(root.right, mid + 1, end, i, val)\\n        root.sum = root.left.sum + root.right.sum\\n    \\n    def update(self, index, val):\\n        self._update(self.root, self.start, self.end, index, val)\\n    \\n    def _sumRange(self, root, start, end):\\n        if not root:\\n            return 0\\n        if root.start == start and root.end == end:\\n            return root.sum\\n        mid = (root.start + root.end) // 2\\n        if end <= mid:\\n            return self._sumRange(root.left, start, end)\\n        elif start >= mid + 1:\\n            return self._sumRange(root.right, start, end)\\n        else:\\n            return self._sumRange(root.left, start, mid) + self._sumRange(root.right, mid + 1, end)\\n    \\n    def sumRange(self, left, right):\\n        return self._sumRange(self.root, left, right)\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        segtree = SegTree([0] * (n + 1))\\n        for i in range(n - k + 1):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                res += 1\\n                segtree.update(i, 1)\\n                segtree.update(min(i + k, n), -1)\\n        for i in range(n - k + 1, n):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910357,
                "title": "c-greedy-o-n-using-queue-to-manage-flip-history",
                "content": "# Intuition\\nThis solution relies on 2 important observations:\\n* The order of operation does not matter, e.g flip $[1,5] \\\\rightarrow [3,10]$ is equivalent to $[3,10] \\\\rightarrow [1,5]$\\n  * So, when we found a $0$ at $i$, we should flip the range $[i,i+k-1]$ because sooner or later we will have to do it anyway\\n* Given range $[0,i]$ that already in good state (i.e $A[0,i] = [1,1,1,1...1]$) we should not modify $[0,i]$\\n  * Because if we modify an item that already is $1$, we have to make another move to make it $0$, at best it would be a waste of time, at worst it would ruin the good result on the right\\n\\n\\n# Approach\\n* Move from left to right, as soon as we see a $0$, we flip\\n* To avoid looping to update the range $[i,i+k-1]$, we maintain a queue to track how many flip we have made that affect current element so far. If the flip count is even, the value stay the same, if odd the value has to be flipped\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$ to travel through array once\\n\\n- Space complexity:\\n$O(n)$ to maintain a queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int flipCount = 0;\\n        queue<int> flipHistory;\\n        for(int i = 0;i<n;i++) {\\n            bool v = nums[i];\\n            if(!flipHistory.empty() && flipHistory.front() < i) {\\n                flipHistory.pop();\\n            }\\n            if(flipHistory.size()%2) {\\n                v = !v;\\n            }\\n            bool shouldFlip = v == 0;\\n            bool canFlip = i+k-1 < n;\\n            if(!shouldFlip) {\\n                continue;\\n            }\\n            if(!canFlip) {\\n                return -1;\\n            }\\n            flipCount++;\\n            flipHistory.push(i+k-1);\\n        }\\n        return flipCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int flipCount = 0;\\n        queue<int> flipHistory;\\n        for(int i = 0;i<n;i++) {\\n            bool v = nums[i];\\n            if(!flipHistory.empty() && flipHistory.front() < i) {\\n                flipHistory.pop();\\n            }\\n            if(flipHistory.size()%2) {\\n                v = !v;\\n            }\\n            bool shouldFlip = v == 0;\\n            bool canFlip = i+k-1 < n;\\n            if(!shouldFlip) {\\n                continue;\\n            }\\n            if(!canFlip) {\\n                return -1;\\n            }\\n            flipCount++;\\n            flipHistory.push(i+k-1);\\n        }\\n        return flipCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896763,
                "title": "python-o-n-solution-easy-to-follow",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        queue, res = deque(), 0\\n        for idx in range(len(nums)):\\n            if len(queue) % 2:\\n                if nums[idx] == 1:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            else:\\n                if nums[idx] == 0:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            if queue and queue[0] == idx: \\n                queue.popleft()\\n            if queue and queue[-1] >= len(nums): \\n                return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        queue, res = deque(), 0\\n        for idx in range(len(nums)):\\n            if len(queue) % 2:\\n                if nums[idx] == 1:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            else:\\n                if nums[idx] == 0:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            if queue and queue[0] == idx: \\n                queue.popleft()\\n            if queue and queue[-1] >= len(nums): \\n                return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875792,
                "title": "easy-c-o-n-solution-o-n-space-commented-92-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> flips(n,0);\\n        //represents curr flips for a index i\\n        int curr=0;\\n        int res=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int val=nums[i];\\n            curr+=flips[i];\\n            if(curr%2)\\n            {\\n                //flip \\n                val=(val==0) ?  1 : 0;\\n            }\\n            if(val==0)\\n            {\\n                //we need a flip of sub array size k\\n                if(i-k+1<0)\\n                {\\n                    //we dont have subarray of size k\\n                    return -1;\\n                }\\n                //we dont want to flip the values <= i-k\\n                if(i-k>=0)\\n                    flips[i-k]-=1;\\n                curr++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> flips(n,0);\\n        //represents curr flips for a index i\\n        int curr=0;\\n        int res=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int val=nums[i];\\n            curr+=flips[i];\\n            if(curr%2)\\n            {\\n                //flip \\n                val=(val==0) ?  1 : 0;\\n            }\\n            if(val==0)\\n            {\\n                //we need a flip of sub array size k\\n                if(i-k+1<0)\\n                {\\n                    //we dont have subarray of size k\\n                    return -1;\\n                }\\n                //we dont want to flip the values <= i-k\\n                if(i-k>=0)\\n                    flips[i-k]-=1;\\n                curr++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860445,
                "title": "python-sliding-window-solution-o-n-time-o-1-space",
                "content": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tcur, count = 0, 0 \\n\\t# cur means the number of flip IN the window BEGINNING at index i\\n\\tfor i in range(len(nums)):            \\n\\t\\tif cur%2==nums[i]%2:\\n\\t\\t\\tif i+k>len(nums):\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcur += 1\\n\\t\\t\\tcount += 1\\n\\t\\t\\tnums[i+k-1] += 2\\n\\t\\tif nums[i]>1:\\n\\t\\t\\tcur -= 1\\n\\t\\t# nums[i] > 1 means the beginning element has been flipped, so we need to decrement \\'cur\\'\\n\\treturn count\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tcur, count = 0, 0 \\n\\t# cur means the number of flip IN the window BEGINNING at index i\\n\\tfor i in range(len(nums)):            \\n\\t\\tif cur%2==nums[i]%2:\\n\\t\\t\\tif i+k>len(nums):\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcur += 1\\n\\t\\t\\tcount += 1\\n\\t\\t\\tnums[i+k-1] += 2\\n\\t\\tif nums[i]>1:\\n\\t\\t\\tcur -= 1\\n\\t\\t# nums[i] > 1 means the beginning element has been flipped, so we need to decrement \\'cur\\'\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2855808,
                "title": "c-dp-easy-implemention",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        // queue<int> q;\\n        int n=A.size();\\n        vector<int> dp(n,0);\\n        int flip=0;\\n        int start=0;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            \\n            \\n            if((A[i]-flip)==0){\\n                // cout<<i<<\" \"<<flip<<\" \"<<ans<<\"\\\\n\";\\n                if(i+k-1>=n){\\n                    return -1;\\n                }\\n                dp[i+k-1]++;\\n                flip=1-flip;\\n                ans++;\\n            }\\n            if(dp[i]){\\n                flip=1-flip;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        // queue<int> q;\\n        int n=A.size();\\n        vector<int> dp(n,0);\\n        int flip=0;\\n        int start=0;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            \\n            \\n            if((A[i]-flip)==0){\\n                // cout<<i<<\" \"<<flip<<\" \"<<ans<<\"\\\\n\";\\n                if(i+k-1>=n){\\n                    return -1;\\n                }\\n                dp[i+k-1]++;\\n                flip=1-flip;\\n                ans++;\\n            }\\n            if(dp[i]){\\n                flip=1-flip;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2800054,
                "title": "java-o-n-time-and-space-complexity-code-with-explanation",
                "content": "# Code\\n\\n```\\n    // TLE, O (n^2)\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipNextK(nums, i, k); \\n                // this is problem, we need to update next k elements every time.\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void flipNextK(int[] nums, int index, int k) {\\n        for (int i=index; i<index+k; i++) {\\n            nums[i] = nums[i] ^ 1;\\n        }\\n    }\\n```\\n\\n```\\n    // Same algorithm as above, but optimized.\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n\\n        // instead of updating next queue elements, we can add last index of flip int this queue.\\n        Queue<Integer> flipQueue = new LinkedList<>();\\n\\n        for (int i=0; i<nums.length; i++) {\\n            // queue size is even, num[i] remains same\\n            // queue size is odd, num[i] changes.\\n            if ((flipQueue.size() & 1) != 0) {\\n                nums[i] = nums[i] ^ 1;\\n            }\\n\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipQueue.add(i+k-1);\\n            }\\n\\n            if (!flipQueue.isEmpty() && flipQueue.peek() == i) flipQueue.poll();\\n        }\\n\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n    // TLE, O (n^2)\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipNextK(nums, i, k); \\n                // this is problem, we need to update next k elements every time.\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void flipNextK(int[] nums, int index, int k) {\\n        for (int i=index; i<index+k; i++) {\\n            nums[i] = nums[i] ^ 1;\\n        }\\n    }\\n```\n```\\n    // Same algorithm as above, but optimized.\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n\\n        // instead of updating next queue elements, we can add last index of flip int this queue.\\n        Queue<Integer> flipQueue = new LinkedList<>();\\n\\n        for (int i=0; i<nums.length; i++) {\\n            // queue size is even, num[i] remains same\\n            // queue size is odd, num[i] changes.\\n            if ((flipQueue.size() & 1) != 0) {\\n                nums[i] = nums[i] ^ 1;\\n            }\\n\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipQueue.add(i+k-1);\\n            }\\n\\n            if (!flipQueue.isEmpty() && flipQueue.peek() == i) flipQueue.poll();\\n        }\\n\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2775933,
                "title": "java-very-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        final int n = nums.length;\\n        int[] promises = new int[n + 1];\\n        int flip = 0, res = 0;\\n        for(int i = 0; i < n; i++){\\n            flip += promises[i];\\n            int actual = flip % 2 == 1 ? 1 - nums[i] : nums[i];\\n            if(i <= n - k){\\n                if(actual == 1) continue;\\n                flip++;\\n                promises[i + k]--;\\n                res++;\\n            }\\n            else{\\n                if(actual == 0) return -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n// Idea:->\\n// ----\\n// 1. Starting from the left\\n// 2. if the current index element is 1 then we don\\'t do anything\\n// 3. else if it\\'s a 0, then flip all the k elements from that position\\n// 4. repeat the above from 0 to nums.length - K.\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        final int n = nums.length;\\n        int[] promises = new int[n + 1];\\n        int flip = 0, res = 0;\\n        for(int i = 0; i < n; i++){\\n            flip += promises[i];\\n            int actual = flip % 2 == 1 ? 1 - nums[i] : nums[i];\\n            if(i <= n - k){\\n                if(actual == 1) continue;\\n                flip++;\\n                promises[i + k]--;\\n                res++;\\n            }\\n            else{\\n                if(actual == 0) return -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n// Idea:->\\n// ----\\n// 1. Starting from the left\\n// 2. if the current index element is 1 then we don\\'t do anything\\n// 3. else if it\\'s a 0, then flip all the k elements from that position\\n// 4. repeat the above from 0 to nums.length - K.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757750,
                "title": "c",
                "content": "Runtime: 153 ms, faster than 100.00% of C online submissions for Minimum Number of K Consecutive Bit Flips.\\nMemory Usage: 18 MB, less than 40.00% of C online submissions for Minimum Number of K Consecutive Bit Flips.\\n```\\nint minKBitFlips(int* nums, int numsSize, int k){\\n    int ans = 0;\\n    int n = numsSize;\\n    //head and tail keep k position for overflow\\n    int* dp  = calloc( (n+2*k), sizeof(int));\\n    for(int i = 0 ; i < n; i++){\\n        dp[i+k] = dp[i+k] + dp[i+k-1];\\n        if(nums[i] == 0 && dp[i+k] % 2 == 0){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n        else if(nums[i] == 1 && dp[i+k]%2 == 1){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint minKBitFlips(int* nums, int numsSize, int k){\\n    int ans = 0;\\n    int n = numsSize;\\n    //head and tail keep k position for overflow\\n    int* dp  = calloc( (n+2*k), sizeof(int));\\n    for(int i = 0 ; i < n; i++){\\n        dp[i+k] = dp[i+k] + dp[i+k-1];\\n        if(nums[i] == 0 && dp[i+k] % 2 == 0){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n        else if(nums[i] == 1 && dp[i+k]%2 == 1){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745741,
                "title": "o-n-soln-using-queue-and-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        Queue<Integer> queue = new LinkedList<>();\\n        int noFlips = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(!queue.isEmpty() && queue.peek() <= i-k){\\n                queue.poll();\\n            }\\n            int val =  nums[i];\\n            int size = ((queue.size() & 1) == 0 ? 0 : 1);\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                queue.add(i);\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        Queue<Integer> queue = new LinkedList<>();\\n        int noFlips = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(!queue.isEmpty() && queue.peek() <= i-k){\\n                queue.poll();\\n            }\\n            int val =  nums[i];\\n            int size = ((queue.size() & 1) == 0 ? 0 : 1);\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                queue.add(i);\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709492,
                "title": "go-golang-java-python-o-n-time-o-1-space",
                "content": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    // how many time we should flip current number\\n    c := 0\\n    // overall flips\\n    res := 0\\n    \\n    for i := range nums {\\n        if (nums[i]  + c) % 2 != 1{\\n            c++\\n            res++\\n            // if we have to flip invalid index return -1\\n            if i + k  > len(nums){\\n                return -1\\n            }\\n            // store in num end of flip row[it can be 2 or 3]\\n            nums[i + k - 1] += 2\\n        }\\n        if nums[i] >1 {\\n            c--\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    // how many time we should flip current number\\n    c := 0\\n    // overall flips\\n    res := 0\\n    \\n    for i := range nums {\\n        if (nums[i]  + c) % 2 != 1{\\n            c++\\n            res++\\n            // if we have to flip invalid index return -1\\n            if i + k  > len(nums){\\n                return -1\\n            }\\n            // store in num end of flip row[it can be 2 or 3]\\n            nums[i + k - 1] += 2\\n        }\\n        if nums[i] >1 {\\n            c--\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690739,
                "title": "c-one-pass-in-o-n-time-complexity",
                "content": "# Please Upvote if Usefull.\\n\\n**Intution**\\n\\n* **Idea is to keep track of the indexes on which flips have been made. And this is done with the help of queue data structure.**\\n\\n* **Whenever coming on a ith index pop all the indexes which cannot flip the ith index i.e. indexes<=i-k and now the current nums[i] will be equal to the original value if size of queue is even, otherwise gets flipped.** \\n\\n* **Now if Size of queue %2 is   is Same as a[i]**\\n\\t*  sz=size of Queue ,       sz%2 == a[i]    then we need to Flip.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n        \\n        int n=a.size();\\n        queue<int>q;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n           while(!q.empty() && q.front()<=i-k) q.pop();\\n            \\n            if( q.size()%2 == a[i]%2){\\n                ans++;\\n                if(i+k<=n) q.push(i);\\n                else return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n        \\n        int n=a.size();\\n        queue<int>q;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n           while(!q.empty() && q.front()<=i-k) q.pop();\\n            \\n            if( q.size()%2 == a[i]%2){\\n                ans++;\\n                if(i+k<=n) q.push(i);\\n                else return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666477,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n      \\n        int n = nums.size();\\n        \\n        vector<int> pointer(n+1,0);\\n        \\n        int flips = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            flips += pointer[i];\\n            \\n            if(nums[i] == 1 && (flips % 2)== 0)\\n            {\\n                continue;\\n            }\\n            \\n            if(nums[i] == 0 && (flips % 2 == 1))\\n            {\\n                continue;\\n            }\\n            \\n            if(i+k > n)\\n            {\\n                return -1;\\n            }\\n            \\n            ans++;\\n            \\n            flips++;\\n            \\n            pointer[i+k] = -1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n      \\n        int n = nums.size();\\n        \\n        vector<int> pointer(n+1,0);\\n        \\n        int flips = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            flips += pointer[i];\\n            \\n            if(nums[i] == 1 && (flips % 2)== 0)\\n            {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2626012,
                "title": "minimum-number-of-k-consecutive-bit-flips-solution-java",
                "content": "class Solution {\\n  public int minKBitFlips(int[] A, int K) {\\n    int ans = 0;\\n    int flippedTime = 0;\\n\\n    for (int r = 0; r < A.length; ++r) {\\n      if (r >= K && A[r - K] == 2)\\n        --flippedTime;\\n      if (flippedTime % 2 == A[r]) {\\n        if (r + K > A.length)\\n          return -1;\\n        ++ans;\\n        ++flippedTime;\\n        A[r] = 2;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation",
                    "Queue",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n  public int minKBitFlips(int[] A, int K) {\\n    int ans = 0;\\n    int flippedTime = 0;\\n\\n    for (int r = 0; r < A.length; ++r) {\\n      if (r >= K && A[r - K] == 2)\\n        --flippedTime;\\n      if (flippedTime % 2 == A[r]) {\\n        if (r + K > A.length)\\n          return -1;\\n        ++ans;\\n        ++flippedTime;\\n        A[r] = 2;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2568791,
                "title": "java-clean-soln-using-constant-space",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        int noFlips = 0;\\n        int spanCnt = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n\\t\\t   / /Removal from old window\\n            if(i-k>=0 && nums[i-k] == 2){\\n                spanCnt ^= 1;\\n            }\\n            int val =  nums[i];\\n            int size = spanCnt;\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                nums[i] = 2;\\n                spanCnt ^= 1;\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        int noFlips = 0;\\n        int spanCnt = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n\\t\\t   / /Removal from old window\\n            if(i-k>=0 && nums[i-k] == 2){\\n                spanCnt ^= 1;\\n            }\\n            int val =  nums[i];\\n            int size = spanCnt;\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                nums[i] = 2;\\n                spanCnt ^= 1;\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552770,
                "title": "c-using-greedy-sliding-window",
                "content": "\\n\\n    int TOGGLE(int k, bool t)\\n    {\\n        if(!t) return k;\\n        return k == 0 ? 1 : 0;\\n    }\\n    \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0, n = nums.size(); \\n        bool toggle = false;\\n        vector<bool> T(n+1, false);\\n        \\n        for(int i=0; i<=n-k; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else\\n            {\\n                ans++;\\n                toggle = !toggle;\\n                T[i+k] = true;\\n            }\\n        }\\n        \\n        for(int i=n-k+1; i<n; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "\\n\\n    int TOGGLE(int k, bool t)\\n    {\\n        if(!t) return k;\\n        return k == 0 ? 1 : 0;\\n    }\\n    \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0, n = nums.size(); \\n        bool toggle = false;\\n        vector<bool> T(n+1, false);\\n        \\n        for(int i=0; i<=n-k; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else\\n            {\\n                ans++;\\n                toggle = !toggle;\\n                T[i+k] = true;\\n            }\\n        }\\n        \\n        for(int i=n-k+1; i<n; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2537527,
                "title": "python-clean-sliding-window-o-1-space",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        # Total number of flips\\n        res = 0\\n        # Total times the iteration index has been flipped\\n        flippedCount = 0\\n\\n        for i, num in enumerate(nums):\\n          # Decrement flipped count for the current index when previous flips \\n          # are outside of the window\\n          if i >= k and nums[i - k] > 1:\\n            nums[i - k] -= 2\\n            flippedCount -= 1\\n          \\n          # An even flipped count means that after all the previous flips, if \\n          # any, the current number is now 0, which needs to be flipped\\n          if flippedCount % 2 == num:\\n            # K-bit flip is not possible if additional bits need to be flipped \\n            # at the end of all valid window flips\\n            if i > len(nums) - k:\\n              return -1\\n\\n            # Flip the current number and increment flipped count\\n            nums[i] += 2\\n            flippedCount += 1\\n            res += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        # Total number of flips\\n        res = 0\\n        # Total times the iteration index has been flipped\\n        flippedCount = 0\\n\\n        for i, num in enumerate(nums):\\n          # Decrement flipped count for the current index when previous flips \\n          # are outside of the window\\n          if i >= k and nums[i - k] > 1:\\n            nums[i - k] -= 2\\n            flippedCount -= 1\\n          \\n          # An even flipped count means that after all the previous flips, if \\n          # any, the current number is now 0, which needs to be flipped\\n          if flippedCount % 2 == num:\\n            # K-bit flip is not possible if additional bits need to be flipped \\n            # at the end of all valid window flips\\n            if i > len(nums) - k:\\n              return -1\\n\\n            # Flip the current number and increment flipped count\\n            nums[i] += 2\\n            flippedCount += 1\\n            res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522013,
                "title": "simple-clean-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        map<ll, ll>mp;\\n        ll res = 0, sz = v.size(), ts = 1; // TimeStamp\\n        for (ll i = 0;i <= sz - k;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1; // if odd no. of changes commited\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n            if (v[i] == 0) {\\n                ++res;\\n                mp[i + k - 1] = ts++; // diff of two timestamps gives the no. of changes commited to a particular index\\n            }\\n        }\\n\\t\\tin last sz-k indices, no k size subarray can be formed. So they must already be all zero in final form now, that is if there does exist a solution.\\n        for (ll i = sz - k + 1;i < sz;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1;\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n\\t\\t\\t// brought to the actual state\\n            if (v[i] == 0) {\\n                return -1; //  here goes nothing m.f.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        map<ll, ll>mp;\\n        ll res = 0, sz = v.size(), ts = 1; // TimeStamp\\n        for (ll i = 0;i <= sz - k;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1; // if odd no. of changes commited\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n            if (v[i] == 0) {\\n                ++res;\\n                mp[i + k - 1] = ts++; // diff of two timestamps gives the no. of changes commited to a particular index\\n            }\\n        }\\n\\t\\tin last sz-k indices, no k size subarray can be formed. So they must already be all zero in final form now, that is if there does exist a solution.\\n        for (ll i = sz - k + 1;i < sz;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1;\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n\\t\\t\\t// brought to the actual state\\n            if (v[i] == 0) {\\n                return -1; //  here goes nothing m.f.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497119,
                "title": "python-o-n-time-o-1-space-in-place-commented-solution",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # How many time have we flipped?\\n        count = 0\\n        # How many past flips have ended?\\n        unwind = 0\\n        # We cannot flip past this point:\\n        max_flip = len(nums)-k+1\\n        \\n        # nums[i] is overwritten as we go, because we never revisit past elements.\\n        #\\n        # (count - unwind) is the number of \"active\" flips\\n        #\\n        # (count - unwind) % 2 == 0 means we are currently not flipping elements\\n        \\n        for i in range(len(nums)):\\n            \\n            # A flip endeding now was performed at i-k\\n            if i >= k and nums[i-k]:\\n                unwind += 1\\n            \\n            # Do we need to flip the current element?\\n            if (nums[i] + count - unwind) % 2 == 0:\\n                # We can\\'t flip because we are close to the end.\\n                if i >= max_flip:\\n                    return -1\\n                # Excute the flip\\n                count += 1\\n                # Signal the flip location\\n                nums[i] = 1\\n            else:\\n                # Signal a non-flip location\\n                nums[i] = 0\\n                \\n        return count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # How many time have we flipped?\\n        count = 0\\n        # How many past flips have ended?\\n        unwind = 0\\n        # We cannot flip past this point:\\n        max_flip = len(nums)-k+1\\n        \\n        # nums[i] is overwritten as we go, because we never revisit past elements.\\n        #\\n        # (count - unwind) is the number of \"active\" flips\\n        #\\n        # (count - unwind) % 2 == 0 means we are currently not flipping elements\\n        \\n        for i in range(len(nums)):\\n            \\n            # A flip endeding now was performed at i-k\\n            if i >= k and nums[i-k]:\\n                unwind += 1\\n            \\n            # Do we need to flip the current element?\\n            if (nums[i] + count - unwind) % 2 == 0:\\n                # We can\\'t flip because we are close to the end.\\n                if i >= max_flip:\\n                    return -1\\n                # Excute the flip\\n                count += 1\\n                # Signal the flip location\\n                nums[i] = 1\\n            else:\\n                # Signal a non-flip location\\n                nums[i] = 0\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489204,
                "title": "c-solution-using-deque",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        //Where did I miss?\\n        //I thought of how to update nums of length k\\n        //Insteand of this I could have thought of is there a necessacity to update\\n        \\n        deque<int>q;\\n        int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            while(q.size()&&i - q.front() + 1 > k) q.pop_front();\\n            if(nums[i] == 0 && q.size()%2 == 0 || nums[i] == 1 && q.size()%2 == 1){\\n                if(i + k > nums.size()) return -1;\\n                ans++;\\n                q.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        //Where did I miss?\\n        //I thought of how to update nums of length k\\n        //Insteand of this I could have thought of is there a necessacity to update\\n        \\n        deque<int>q;\\n        int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            while(q.size()&&i - q.front() + 1 > k) q.pop_front();\\n            if(nums[i] == 0 && q.size()%2 == 0 || nums[i] == 1 && q.size()%2 == 1){\\n                if(i + k > nums.size()) return -1;\\n                ans++;\\n                q.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478082,
                "title": "c-short-and-simple-o-n-video-tutorial-paperba1l",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int f = 0;\\n        int n = nums.size();\\n        int flips[n+1];\\n        memset(flips, 0, sizeof(flips));\\n        \\n        int cur = 0; \\n\\t\\t// if you flip a bit 3 times, is as good as fliping it ones. \\n\\t\\t// flip_count % 2 is same as parity of cur variable \\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\n\\t\\t\\t// superimpose multiple segment on one another \\n\\t\\t\\t// ith bit will flip multiple times, let say c times\\n\\t\\t\\t// c%2 will decide if we want to flip it or not.\\n\\t\\t\\t//  cur^=1 does the same thing\\n            if(flips[i] == 1) {\\n                cur^=1;\\n            }\\n            \\n\\t\\t\\t// just want to check if ith bit after fliping goes to zero\\n            if((nums[i]^cur) == 0) {\\n                f++;\\n                cur^=1;\\n                \\n                if((i+k) > n) {\\n                    return -1;\\n                }\\n                \\n\\t\\t\\t\\t// last index if the block of size k [i, i+k] is fliped correctly\\n                flips[i+k] = 1;\\n            }\\n        }\\n        \\n        return f;\\n        \\n    }\\n};\\n```\\npaperba1l\\nhttps://www.youtube.com/watch?v=tbNpHv2HDXo&ab_channel=HappyCoding",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int f = 0;\\n        int n = nums.size();\\n        int flips[n+1];\\n        memset(flips, 0, sizeof(flips));\\n        \\n        int cur = 0; \\n\\t\\t// if you flip a bit 3 times, is as good as fliping it ones. \\n\\t\\t// flip_count % 2 is same as parity of cur variable \\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\n\\t\\t\\t// superimpose multiple segment on one another \\n\\t\\t\\t// ith bit will flip multiple times, let say c times\\n\\t\\t\\t// c%2 will decide if we want to flip it or not.\\n\\t\\t\\t//  cur^=1 does the same thing\\n            if(flips[i] == 1) {\\n                cur^=1;\\n            }\\n            \\n\\t\\t\\t// just want to check if ith bit after fliping goes to zero\\n            if((nums[i]^cur) == 0) {\\n                f++;\\n                cur^=1;\\n                \\n                if((i+k) > n) {\\n                    return -1;\\n                }\\n                \\n\\t\\t\\t\\t// last index if the block of size k [i, i+k] is fliped correctly\\n                flips[i+k] = 1;\\n            }\\n        }\\n        \\n        return f;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460092,
                "title": "java-o-n",
                "content": "Runtime: 5 ms, faster than 97.85% of Java online submissions for Minimum Number of K Consecutive Bit Flips.\\nMemory Usage: 51.1 MB, less than 93.13% of Java online submissions for Minimum Number of K Consecutive Bit Flips.\\n\\n```\\nclass Solution {  \\n    \\n    public int minKBitFlips(int[] nums, int k) {\\n        int minFlipCount = 0;        \\n        boolean fliped = false;\\n        boolean[] cancelFlip = new boolean[nums.length];        \\n        for(int i = 0, len = nums.length; i < len; i++) {\\n            int n = nums[i];            \\n            if(n == 1 && fliped || n == 0 && !fliped) {\\n                minFlipCount++;\\n                fliped = fliped ? false : true;\\n                if(i + k - 1 >= len) return -1;                \\n                cancelFlip[i + k - 1] = true;                \\n            }            \\n            if(cancelFlip[i]) fliped = fliped ? false : true;\\n        }        \\n        return minFlipCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {  \\n    \\n    public int minKBitFlips(int[] nums, int k) {\\n        int minFlipCount = 0;        \\n        boolean fliped = false;\\n        boolean[] cancelFlip = new boolean[nums.length];        \\n        for(int i = 0, len = nums.length; i < len; i++) {\\n            int n = nums[i];            \\n            if(n == 1 && fliped || n == 0 && !fliped) {\\n                minFlipCount++;\\n                fliped = fliped ? false : true;\\n                if(i + k - 1 >= len) return -1;                \\n                cancelFlip[i + k - 1] = true;                \\n            }            \\n            if(cancelFlip[i]) fliped = fliped ? false : true;\\n        }        \\n        return minFlipCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310439,
                "title": "python-simple-one-pass-sliding-window",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = [0]*len(nums)\\n        csum = 0\\n        \\n        for left in range(0, len(nums)-k+1):\\n            if (nums[left] + csum) % 2 == 0:\\n                flips[left] += 1\\n                csum += 1\\n            if left >= k-1:\\n                csum -= flips[left-k+1]\\n        \\n        for check in range(len(nums)-k+1, len(nums)):\\n            if (nums[check] + csum) % 2 == 0:\\n                return -1\\n            if check >= k-1:\\n                csum -= flips[check-k+1]\\n        \\n        return sum(flips)\\n            \\n ```\\n \\n The first loop looks for if the bit in that position is equal to zero, keeping track of the number of flips within in the window k-1. The second checks to see if the last few bits (inside the window k) became ones from the flips done to that point. Then you return the sum of flips that you made to that point.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = [0]*len(nums)\\n        csum = 0\\n        \\n        for left in range(0, len(nums)-k+1):\\n            if (nums[left] + csum) % 2 == 0:\\n                flips[left] += 1\\n                csum += 1\\n            if left >= k-1:\\n                csum -= flips[left-k+1]\\n        \\n        for check in range(len(nums)-k+1, len(nums)):\\n            if (nums[check] + csum) % 2 == 0:\\n                return -1\\n            if check >= k-1:\\n                csum -= flips[check-k+1]\\n        \\n        return sum(flips)\\n            \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2263972,
                "title": "python-simple-maths",
                "content": "\\n    def minKBitFlips(self, nums, k):\\n        n, ans, total, cur = len(nums), [False]*len(nums), 0, 0\\n        \\n        for i in range(n):\\n            if i >= k:\\n                cur -= ans[i-k] == True\\n                \\n            if (nums[i] + cur)%2 == 0:\\n                if i + k > n:\\n                    return -1\\n                \\n                total += 1\\n                cur += 1\\n                ans[i] = True\\n                \\n        return total",
                "solutionTags": [],
                "code": "\\n    def minKBitFlips(self, nums, k):\\n        n, ans, total, cur = len(nums), [False]*len(nums), 0, 0\\n        \\n        for i in range(n):\\n            if i >= k:\\n                cur -= ans[i-k] == True\\n                \\n            if (nums[i] + cur)%2 == 0:\\n                if i + k > n:\\n                    return -1\\n                \\n                total += 1\\n                cur += 1\\n                ans[i] = True\\n                \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2251526,
                "title": "bit-based-python-solution",
                "content": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        mask = 0\\n        setMask = 0\\n        \\n        for i in range(k-1):\\n            setMask = setMask^(1<<i)\\n        count = 0\\n        for i,num in enumerate(nums):\\n            isFlipped = mask & 1\\n            mask = mask >> 1\\n            if ((num == 0) and (isFlipped == False)) or ((num==1) and isFlipped):\\n                if i > len(nums)-k:\\n                    return -1\\n                mask = mask^setMask\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        mask = 0\\n        setMask = 0\\n        \\n        for i in range(k-1):\\n            setMask = setMask^(1<<i)\\n        count = 0\\n        for i,num in enumerate(nums):\\n            isFlipped = mask & 1\\n            mask = mask >> 1\\n            if ((num == 0) and (isFlipped == False)) or ((num==1) and isFlipped):\\n                if i > len(nums)-k:\\n                    return -1\\n                mask = mask^setMask\\n                count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2235183,
                "title": "constant-range-sliding-window",
                "content": "```\\nclass Solution(object):\\n    \\n    def minKBitFlips(self, A, K):\\n        flip_or_not = [False for _ in range(len(A))]\\n        flip = 0\\n        total = 0\\n        \\n        for i in range(len(A)):\\n            if K <= i:\\n                if flip_or_not[i - K]: total -= 1\\n            if i <= len(A) - K:\\n                if (A[i] + total) % 2 == 0:\\n                    total += 1\\n                    flip += 1\\n                    flip_or_not[i] = True\\n            else:\\n                if (A[i] + total) % 2 == 0:\\n                    return -1\\n                \\n        return flip\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def minKBitFlips(self, A, K):\\n        flip_or_not = [False for _ in range(len(A))]\\n        flip = 0\\n        total = 0\\n        \\n        for i in range(len(A)):\\n            if K <= i:\\n                if flip_or_not[i - K]: total -= 1\\n            if i <= len(A) - K:\\n                if (A[i] + total) % 2 == 0:\\n                    total += 1\\n                    flip += 1\\n                    flip_or_not[i] = True\\n            else:\\n                if (A[i] + total) % 2 == 0:\\n                    return -1\\n                \\n        return flip\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179196,
                "title": "python3-o-n-solution",
                "content": "```\\nimport collections\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq=collections.deque()\\n        flipped=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if not len(dq)%2:\\n                flipped=0\\n            else:\\n                flipped=1\\n            if nums[i]==0:\\n                if not flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            else:\\n                if flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            if dq and dq[0]<=i:\\n                dq.popleft()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq=collections.deque()\\n        flipped=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if not len(dq)%2:\\n                flipped=0\\n            else:\\n                flipped=1\\n            if nums[i]==0:\\n                if not flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            else:\\n                if flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            if dq and dq[0]<=i:\\n                dq.popleft()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130795,
                "title": "c-greedy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=lower_bound(v.begin(),v.end(),i-k+1)-v.begin();\\n            x=v.size()-x;\\n            if(x%2)\\n            {\\n                nums[i]=1-nums[i];\\n            }\\n            if(nums[i]==0&&i<=nums.size()-k)\\n                v.push_back(i),nums[i]=1;\\n            else if(nums[i]==0)\\n                return -1;\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=lower_bound(v.begin(),v.end(),i-k+1)-v.begin();\\n            x=v.size()-x;\\n            if(x%2)\\n            {\\n                nums[i]=1-nums[i];\\n            }\\n            if(nums[i]==0&&i<=nums.size()-k)\\n                v.push_back(i),nums[i]=1;\\n            else if(nums[i]==0)\\n                return -1;\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039052,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        int i, j;\\n        int ans = 0;\\n        deque<int> indexQ;\\n        for(i = 0; i < len - k + 1; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            \\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n        }\\n        \\n        for(; i < len; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                return -1;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        int i, j;\\n        int ans = 0;\\n        deque<int> indexQ;\\n        for(i = 0; i < len - k + 1; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            \\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n        }\\n        \\n        for(; i < len; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                return -1;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010454,
                "title": "java-sliding-window-o-n",
                "content": "Consider any ith bit, we put a k-sized sliding window so that the ith bit is at the back of the window.\\n![image](https://assets.leetcode.com/users/images/7968954d-4298-4db1-9b0b-3b4320ea147e_1651751229.2535677.png)\\n\\nAll the flips happen in this window will be accountable for flipping the ith bit.\\nWe could store a flag, namely flipped, such that it will accumulate all the flips.\\nWhen i < k, this flag will be reflecting all the flips done within the sliding windows.\\nStarting from i = k, one bit will be taken out from this sliding window when we move along, and therefore we need to negate the flip triggered by the (i-k)th bit.\\nIn order to know whether the (i-k)th bit is triggering a flip in linear time, we could use a boolean array to help, and set it the true when any ith bit is tiggerring a flip.\\nOnce we know whether the ith bit is flipped by the preceeding bits in the sliding window, we could match it with the value to see if we need to trigger a flip.\\nWhen i > len - k, no flipping is allowed, so we could return -1 if a flip is needed.\\n\\nTime complexity: O(n)\\nWe loopped n times and each iteration is linear time\\n\\nSpace complexity: O(n)\\nThe boolean array is n-sized\\n**notes: we could eliminate the use of the boolean array with the given int array to make it O(1), consider we have 32 bits per element and only the least significant bit is currently occupied*\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int len = nums.length, count = 0;\\n        boolean[] flip = new boolean[len];\\n        boolean flipped = false;\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k && flip[i - k]) flipped = !flipped;\\n            if ((flipped?1:0) == nums[i]){\\n                if (i + k > len) return -1;\\n                count++;\\n                flip[i] = true;\\n                flipped = !flipped;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int len = nums.length, count = 0;\\n        boolean[] flip = new boolean[len];\\n        boolean flipped = false;\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k && flip[i - k]) flipped = !flipped;\\n            if ((flipped?1:0) == nums[i]){\\n                if (i + k > len) return -1;\\n                count++;\\n                flip[i] = true;\\n                flipped = !flipped;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007762,
                "title": "simple-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& nums, int n, int k, vector<int>& flips, int ind, int change)\\n    {\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        change += flips[ind];\\n        change %= 2;\\n        \\n        if(change == 0)\\n        {\\n            if(nums[ind] == 1)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k ]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n        else\\n        {\\n            if(nums[ind] == 0)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n    }\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> flips(n + 2 , 0);\\n        \\n        int ans = find(nums, n, k, flips, 0, 0);\\n        \\n        if(ans >= 1e7)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& nums, int n, int k, vector<int>& flips, int ind, int change)\\n    {\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        change += flips[ind];\\n        change %= 2;\\n        \\n        if(change == 0)\\n        {\\n            if(nums[ind] == 1)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k ]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n        else\\n        {\\n            if(nums[ind] == 0)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n    }\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> flips(n + 2 , 0);\\n        \\n        int ans = find(nums, n, k, flips, 0, 0);\\n        \\n        if(ans >= 1e7)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000070,
                "title": "python-another-solution-use-bit-this-is-slower-just-for-a-reference",
                "content": "Every time we found a zero at i, we must flip the number i ~ (i+k -1),\\nWe can use BIT to store the flip count.\\nKnowing the flip count for the ith number, we can decide wheather to flip it or not.\\n\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        BIT = [0]*(N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x]+=1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        flip = 0\\n        for i in range(N-k+1):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                flip+=1\\n                update(N-i-k+1)\\n        for i in range(N-k+1,N):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                return -1\\n        return flip\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        BIT = [0]*(N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x]+=1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        flip = 0\\n        for i in range(N-k+1):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                flip+=1\\n                update(N-i-k+1)\\n        for i in range(N-k+1,N):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                return -1\\n        return flip\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866324,
                "title": "java-n-2-solution-tle-o-n-accept-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        return dfs(nums, 0, k);\\n    }\\n    \\n    private int dfs(int[] nums, int start, int k) {\\n        int next = nums.length;\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                next = i;\\n                break;\\n            }\\n        }\\n        if (next == nums.length) {\\n            return 0;\\n        }\\n        if (next + k > nums.length) {\\n            return -1;\\n        }\\n        start = next + k;\\n        for (int i = next ; i < next + k; i++) {\\n            nums[i] ^= 1;\\n            if (nums[i] == 0) {\\n                start = Math.min(start, i);\\n            }\\n        }\\n        int temp = dfs(nums, start, k);\\n        return temp == -1 ? -1 : temp + 1;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        int[] flags = new int[nums.length];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flags[i] += 1;\\n                flags[i + k - 1] -= 1;\\n            }\\n            flag += flags[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flag++;\\n                nums[i] = -1;\\n            }\\n            if (i >= k - 1 && nums[i - k + 1] == -1) {\\n                flag--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        return dfs(nums, 0, k);\\n    }\\n    \\n    private int dfs(int[] nums, int start, int k) {\\n        int next = nums.length;\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                next = i;\\n                break;\\n            }\\n        }\\n        if (next == nums.length) {\\n            return 0;\\n        }\\n        if (next + k > nums.length) {\\n            return -1;\\n        }\\n        start = next + k;\\n        for (int i = next ; i < next + k; i++) {\\n            nums[i] ^= 1;\\n            if (nums[i] == 0) {\\n                start = Math.min(start, i);\\n            }\\n        }\\n        int temp = dfs(nums, start, k);\\n        return temp == -1 ? -1 : temp + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        int[] flags = new int[nums.length];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flags[i] += 1;\\n                flags[i + k - 1] -= 1;\\n            }\\n            flag += flags[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flag++;\\n                nums[i] = -1;\\n            }\\n            if (i >= k - 1 && nums[i - k + 1] == -1) {\\n                flag--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854374,
                "title": "python-o-nlogn-greedy-binary-search-bisect",
                "content": "Approach :-\\nAt each index i check whether this index was flipped odd number of times or even number of times.\\nThis can be done by storing the index where effect of flipping current k elements will vanish.\\n\\n```\\nimport bisect \\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        L = []\\n        for i in range(len(nums)):\\n            j,n = bisect.bisect_right(L,i),len(L)\\n            if ((n-j)%2==0 and nums[i]==0) or ((n-j)%2!=0 and nums[i]==1):\\n                if i+k>len(nums):\\n                    return -1 \\n                res+=1\\n                bisect.insort_left(L,i+k)\\n            nums[i]=1\\n        return res \\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nimport bisect \\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        L = []\\n        for i in range(len(nums)):\\n            j,n = bisect.bisect_right(L,i),len(L)\\n            if ((n-j)%2==0 and nums[i]==0) or ((n-j)%2!=0 and nums[i]==1):\\n                if i+k>len(nums):\\n                    return -1 \\n                res+=1\\n                bisect.insort_left(L,i+k)\\n            nums[i]=1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816115,
                "title": "golang-solution-with-comments",
                "content": "```go\\nfunc minKBitFlips(nums []int, k int) int {\\n\\tminFlips1 := lc995Helper(nums, k)\\n\\treverse(nums)\\n\\tminFlips2 := lc995Helper(nums, k)\\n\\tif min(minFlips1, minFlips2) == math.MaxInt32 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn min(minFlips1, minFlips2)\\n}\\n\\nfunc lc995Helper(nums []int, k int) int {\\n\\ttotalFlips, currFlips := 0, 0\\n\\t// flipEndIndexes, inclusive\\n\\tflipEndIndexes := make([]int, 0, len(nums))\\n\\tcurrentIndex := 0\\n\\tfor i, v := range nums {\\n\\t\\tif currFlips > 0 {\\n\\t\\t\\t// if i > flipEndIndexes[currentIndex], we need decrease currFlips by 1\\n\\t\\t\\tif i > flipEndIndexes[currentIndex] {\\n\\t\\t\\t\\tcurrentIndex++\\n\\t\\t\\t\\tcurrFlips--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif currFlips%2 != 0 {\\n\\t\\t\\t// odd flip, 0->1, 1->0\\n\\t\\t\\tv = v ^ 1\\n\\t\\t}\\n\\t\\tif v == 0 {\\n\\t\\t\\t// we need flip once\\n\\t\\t\\tif i+k-1 >= len(nums) {\\n\\t\\t\\t\\t// invalid flip\\n\\t\\t\\t\\treturn math.MaxInt32\\n\\t\\t\\t}\\n\\t\\t\\ttotalFlips++\\n\\t\\t\\tcurrFlips++\\n\\t\\t\\tflipEndIndexes = append(flipEndIndexes, i+k-1)\\n\\t\\t}\\n\\t}\\n\\treturn totalFlips\\n}\\n\\nfunc reverse(A []int) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minKBitFlips(nums []int, k int) int {\\n\\tminFlips1 := lc995Helper(nums, k)\\n\\treverse(nums)\\n\\tminFlips2 := lc995Helper(nums, k)\\n\\tif min(minFlips1, minFlips2) == math.MaxInt32 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn min(minFlips1, minFlips2)\\n}\\n\\nfunc lc995Helper(nums []int, k int) int {\\n\\ttotalFlips, currFlips := 0, 0\\n\\t// flipEndIndexes, inclusive\\n\\tflipEndIndexes := make([]int, 0, len(nums))\\n\\tcurrentIndex := 0\\n\\tfor i, v := range nums {\\n\\t\\tif currFlips > 0 {\\n\\t\\t\\t// if i > flipEndIndexes[currentIndex], we need decrease currFlips by 1\\n\\t\\t\\tif i > flipEndIndexes[currentIndex] {\\n\\t\\t\\t\\tcurrentIndex++\\n\\t\\t\\t\\tcurrFlips--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif currFlips%2 != 0 {\\n\\t\\t\\t// odd flip, 0->1, 1->0\\n\\t\\t\\tv = v ^ 1\\n\\t\\t}\\n\\t\\tif v == 0 {\\n\\t\\t\\t// we need flip once\\n\\t\\t\\tif i+k-1 >= len(nums) {\\n\\t\\t\\t\\t// invalid flip\\n\\t\\t\\t\\treturn math.MaxInt32\\n\\t\\t\\t}\\n\\t\\t\\ttotalFlips++\\n\\t\\t\\tcurrFlips++\\n\\t\\t\\tflipEndIndexes = append(flipEndIndexes, i+k-1)\\n\\t\\t}\\n\\t}\\n\\treturn totalFlips\\n}\\n\\nfunc reverse(A []int) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811873,
                "title": "subtract-in-tricky-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n         int total = 0;\\n         int a[100001] = {0};\\n         int sum = 0;\\n         for(int i = 0;i < nums.size();i++)\\n         {\\n                 sum -= a[i];\\n                 if(nums[i] != (sum%2))\\n                 continue;\\n                 else\\n                 {\\n                     if(i + k > nums.size())\\n                     return -1;\\n                     a[i+k] += 1;\\n                     sum += 1;\\n                     total += 1;\\n                 }\\n         }\\n         return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n         int total = 0;\\n         int a[100001] = {0};\\n         int sum = 0;\\n         for(int i = 0;i < nums.size();i++)\\n         {\\n                 sum -= a[i];\\n                 if(nums[i] != (sum%2))\\n                 continue;\\n                 else\\n                 {\\n                     if(i + k > nums.size())\\n                     return -1;\\n                     a[i+k] += 1;\\n                     sum += 1;\\n                     total += 1;\\n                 }\\n         }\\n         return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791315,
                "title": "greedy-dp",
                "content": "int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int count1 = 0;\\n        \\n        vector<int> dp(n,0);\\n        int ans = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i+k<=n)\\n            {\\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                    {\\n                        count1++;\\n                        ans++;\\n                    }\\n                    dp[i] = count1;\\n                    nums[i] = 1;\\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                    {\\n                        ans++;\\n                        count1++;\\n                    }\\n                    dp[i] = count1;\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n            {\\n                \\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                        return -1;\\n                    \\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                        return -1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int count1 = 0;\\n        \\n        vector<int> dp(n,0);\\n        int ans = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i+k<=n)\\n            {\\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                    {\\n                        count1++;\\n                        ans++;\\n                    }\\n                    dp[i] = count1;\\n                    nums[i] = 1;\\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                    {\\n                        ans++;\\n                        count1++;\\n                    }\\n                    dp[i] = count1;\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n            {\\n                \\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                        return -1;\\n                    \\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                        return -1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1659474,
                "title": "greedy-queue-solution-typescript",
                "content": "\\n```\\nfunction minKBitFlips(nums: number[], k: number): number {\\n    if (nums.length < k) return -1;\\n    \\n    let queue: number[] = [];\\n    \\n    let flips = 0;\\n    \\n    const lastPossibleFlip = nums.length - k;\\n    \\n    for (let i = 0; i < nums.length; i++){\\n        if (queue.length && queue[0] < i) queue.shift();\\n        \\n        if (queue.length % 2 == nums[i]){ // Requires flip\\n            if (i > lastPossibleFlip) return -1;\\n            \\n            flips++;\\n            queue.push(i + k - 1);\\n        }\\n    }\\n    \\n    \\n    return flips;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minKBitFlips(nums: number[], k: number): number {\\n    if (nums.length < k) return -1;\\n    \\n    let queue: number[] = [];\\n    \\n    let flips = 0;\\n    \\n    const lastPossibleFlip = nums.length - k;\\n    \\n    for (let i = 0; i < nums.length; i++){\\n        if (queue.length && queue[0] < i) queue.shift();\\n        \\n        if (queue.length % 2 == nums[i]){ // Requires flip\\n            if (i > lastPossibleFlip) return -1;\\n            \\n            flips++;\\n            queue.push(i + k - 1);\\n        }\\n    }\\n    \\n    \\n    return flips;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568109,
                "title": "short-python",
                "content": "Keep track of indexes you flip, by that count using bisect how many flips of length k cover your current bit and including information about its current value decide whether you need to flip it.\\n\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minKBitFlips(self, nums, k):\\n        n, arr = len(nums), []\\n        for i in range(n):\\n            if (len(arr) - bisect_left(arr, i - k + 1) + nums[i]) % 2 == 0:\\n                arr.append(i)\\n                if i > n - k:\\n                    return -1\\n        return len(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minKBitFlips(self, nums, k):\\n        n, arr = len(nums), []\\n        for i in range(n):\\n            if (len(arr) - bisect_left(arr, i - k + 1) + nums[i]) % 2 == 0:\\n                arr.append(i)\\n                if i > n - k:\\n                    return -1\\n        return len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511201,
                "title": "use-the-length-of-the-queue-to-keep-track-of-number-of-flips",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq = collections.deque()\\n        flips = 0\\n        for i in range(len(nums)):\\n            l = len(dq)\\n            if (nums[i] == 0 and not l & 1) or (nums[i] == 1 and l & 1):\\n                right = i + k - 1\\n                if right < len(nums):\\n                    dq.append(right)\\n                    flips += 1\\n                else:\\n                    return -1\\n            if dq and dq[0] == i:\\n                dq.popleft()\\n        return flips\\n```\\nyou can come to this solution by trying this test case [0,1,0,1,0,1,0,1...]\\nyou will notice that when you flip, all numbers in the range are flipped. when you move to the next index and flip again, all the numbers in the window -1 are flipped again except for the last element which is flipped only once. so you only need to store the right side of flips since everything to the left of that will be the same number of flips which also happens to be the length of the queue. then when you reach the index in which you added the element to the queue, pop it off",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq = collections.deque()\\n        flips = 0\\n        for i in range(len(nums)):\\n            l = len(dq)\\n            if (nums[i] == 0 and not l & 1) or (nums[i] == 1 and l & 1):\\n                right = i + k - 1\\n                if right < len(nums):\\n                    dq.append(right)\\n                    flips += 1\\n                else:\\n                    return -1\\n            if dq and dq[0] == i:\\n                dq.popleft()\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448792,
                "title": "javascript-2-solutions",
                "content": "**1. Queue - Time O(n), Space O(k)**\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let n = nums.length, list = [], flips = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (list.length && list[0] < i)\\n            list.shift();\\n\\n        if (nums[i] === list.length % 2) {\\n            if (i + k > nums.length)\\n                return -1;\\n\\n            list.push(i + k - 1);\\n            flips++;\\n        }\\n    }\\n\\n    return flips;\\n};\\n```\\n**2. Using Queue length alone - Time O(n), SpaceO(1)**\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let n = nums.length, list = 0, flips = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (i >= k && nums[i - k] === 2)\\n            list--;\\n\\n        if (nums[i] === list % 2) {\\n            if (i + k > nums.length)\\n                return -1;\\n            nums[i] = 2;\\n            list++;\\n            flips++;\\n        }\\n    }\\n\\n    return flips;\\n};",
                "solutionTags": [],
                "code": "```\\nvar minKBitFlips = function(nums, k) {\\n    let n = nums.length, list = [], flips = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (list.length && list[0] < i)\\n            list.shift();\\n\\n        if (nums[i] === list.length % 2) {\\n            if (i + k > nums.length)\\n                return -1;\\n\\n            list.push(i + k - 1);\\n            flips++;\\n        }\\n    }\\n\\n    return flips;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1405013,
                "title": "c-simple-queue-implementation-queue",
                "content": "Make a `queue ` that will keep track of the first indices of  `k`-bitflips from left to right.\\nThese first indices of `k`-bitflips must be in the range `[0, nums.size() - k ]`.\\n\\nFor index `i`, if we flipped `n` bits out of  range `[i - k + 1, i - 1]` , the bit at `i` is now `nums[i] + n` modulo 2.\\n\\nIf `nums[i] + n` is even, the bit at index `i` is `0`, so flip `k`-bits starting at index`i`. (i,e `push` `i` to the `queue`.) \\nif  `nums[i] + n` is odd, the bit at index `i` is `1`. So don\\'t` push` `i` to the queue.\\n\\n\\n\\n**Algorithm: **\\n\\n1. if the `front `of the `queue` is more than `k` distance away from index `i`, pop it.\\n2. count the size of the queue. (this determines how many flips were made on the bit at index `i`.)\\n3. if `i` is not one of the very last `k - 1` indices and `nums[i] + q.size()` is an even number, push index `i` to the queue (we flip the bit at index `i`)\\n4. if `i` is one of the very last `k - 1` indices and `nums[i] + q.size()` is an even number, return `-1`.\\n5. Return the total number of `push` operations. (# of flips)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n\\n        int count = 0;\\n \\n        queue<int> q;\\n        for (int i = 0; i < nums.size(); i++) {\\n         \\n            if (!q.empty() && i - q.front() >= k) {\\n                q.pop();\\n            }\\n            \\n            if (i <= nums.size() - k) {\\n\\t\\n                if ((nums[i] + q.size()) % 2 == 0) {\\n                    q.push(i);\\n                    count++;\\n                } \\n                \\n            } else {\\n                if ((nums[i] + q.size()) % 2 != 1) return -1;\\n            }\\n            \\n        }  \\n       \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n\\n        int count = 0;\\n \\n        queue<int> q;\\n        for (int i = 0; i < nums.size(); i++) {\\n         \\n            if (!q.empty() && i - q.front() >= k) {\\n                q.pop();\\n            }\\n            \\n            if (i <= nums.size() - k) {\\n\\t\\n                if ((nums[i] + q.size()) % 2 == 0) {\\n                    q.push(i);\\n                    count++;\\n                } \\n                \\n            } else {\\n                if ((nums[i] + q.size()) % 2 != 1) return -1;\\n            }\\n            \\n        }  \\n       \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301099,
                "title": "moving-from-the-basic-to-the-hard-solution",
                "content": "Like any hard problem, first an initial solution has to be thought up which has to be refined. The HARD part of this problem is in refining this problem for an interview ready solution. \\n\\nOn observing the test cases and with some thinking one can observe that whenever a 0 is encountered, it must be flipped, for the least number of flips. This suggests the greedy approach, iterating over the array and flipping k bits on encountering 0. For an array of size n and window size of k, there are k*(n-k+1) operations possible (considering we actually flip the bits). This solution gives TLE.\\n\\nThe observation which gives the efficient solution is that one does not have to carry out the flips to setup the rest of the array. If a count of all the flips that can affect an index is maintained, the count determines the state of an array.\\n\\nConsider that **making a flip at index i means flipping the bits from i to i+k-1**. \\n\\nThen if 0 is encountered at index i, a flip affects indices upto i+k-1. The same greedy approach is followed but instead of flipping in the case of a zero, a queue is used and on flipping at an index the last index affected by the flip is pushed onto the queue. Flipping is done whenever the number of flips is such that the state of an index is 0. \\n\\nOnce the last index is reached the index is popped from the queue. So, for any index the size of the queue determines the number of flips which have already taken place which involve the bit at that index. Using this the actual state of the flip 0/1 can be determined using the original state which is already present in the array itself. \\n\\nSince a given index can be affected by at most k flips, the queue has a length of at most k. Now, a flip has to be made in this strategy when \\n\\n* The original value is 0 and an even number of flips have taken place so far\\n* The original value is 1 and an odd number of flips have taken place so far\\n\\nIn concise solutions, these are combined into a single condition A[i] == flips%2, although writing them separately is more logical to think about. \\n\\nNote that since flips are removed from the queue when the last index to be affected by the flip is traversed, the only case in which -1 is returned is if the queue is non-empty after all the indices are traversed, i.e. an index beyond the addressible range has been pushed onto the queue, or that a 0 exists at a location where there are less than k bits to flip.\\n\\nFor the O(1) space solution which might be asked, the count of the flips can be updated as in the queue solution, however, instead of using a queue, flip indices are indicated by making the numbers at those positions negative. Then, when the iteration reaches the limit of an old flip, checking whether the beginning of the old flip is negative allows to maintain the count of the flips (subtracting 1 if indeed it is negative). However, a separate count is required only to count the times the flip counter is incremented, for the total k bit flips. (The flip counter itself is used to check only the flips that can affect a particular index, but we need to count every flip.)\\n\\nThe pattern that comes out of learning the solution is that for binary values/states, only a count of switches is sufficient to track the state. The k-bit restriction suggests queue as an effective way of tracking this count.",
                "solutionTags": [],
                "code": "Like any hard problem, first an initial solution has to be thought up which has to be refined. The HARD part of this problem is in refining this problem for an interview ready solution. \\n\\nOn observing the test cases and with some thinking one can observe that whenever a 0 is encountered, it must be flipped, for the least number of flips. This suggests the greedy approach, iterating over the array and flipping k bits on encountering 0. For an array of size n and window size of k, there are k*(n-k+1) operations possible (considering we actually flip the bits). This solution gives TLE.\\n\\nThe observation which gives the efficient solution is that one does not have to carry out the flips to setup the rest of the array. If a count of all the flips that can affect an index is maintained, the count determines the state of an array.\\n\\nConsider that **making a flip at index i means flipping the bits from i to i+k-1**. \\n\\nThen if 0 is encountered at index i, a flip affects indices upto i+k-1. The same greedy approach is followed but instead of flipping in the case of a zero, a queue is used and on flipping at an index the last index affected by the flip is pushed onto the queue. Flipping is done whenever the number of flips is such that the state of an index is 0. \\n\\nOnce the last index is reached the index is popped from the queue. So, for any index the size of the queue determines the number of flips which have already taken place which involve the bit at that index. Using this the actual state of the flip 0/1 can be determined using the original state which is already present in the array itself. \\n\\nSince a given index can be affected by at most k flips, the queue has a length of at most k. Now, a flip has to be made in this strategy when \\n\\n* The original value is 0 and an even number of flips have taken place so far\\n* The original value is 1 and an odd number of flips have taken place so far\\n\\nIn concise solutions, these are combined into a single condition A[i] == flips%2, although writing them separately is more logical to think about. \\n\\nNote that since flips are removed from the queue when the last index to be affected by the flip is traversed, the only case in which -1 is returned is if the queue is non-empty after all the indices are traversed, i.e. an index beyond the addressible range has been pushed onto the queue, or that a 0 exists at a location where there are less than k bits to flip.\\n\\nFor the O(1) space solution which might be asked, the count of the flips can be updated as in the queue solution, however, instead of using a queue, flip indices are indicated by making the numbers at those positions negative. Then, when the iteration reaches the limit of an old flip, checking whether the beginning of the old flip is negative allows to maintain the count of the flips (subtracting 1 if indeed it is negative). However, a separate count is required only to count the times the flip counter is incremented, for the total k bit flips. (The flip counter itself is used to check only the flips that can affect a particular index, but we need to count every flip.)\\n\\nThe pattern that comes out of learning the solution is that for binary values/states, only a count of switches is sufficient to track the state. The k-bit restriction suggests queue as an effective way of tracking this count.",
                "codeTag": "Unknown"
            },
            {
                "id": 1258842,
                "title": "100-solution-simple-solution-clean-cpp-code",
                "content": "```\\nTime Used       : [48ms~64ms]\\nTime            :  O(N)\\nSpace           :  O(K)  \\nAdditional Space:  O(c) //we reuse original vector to save history of flips\\n```\\n\\nThe algorithm:\\nActually, it is quite straightforward. \\n1. We scan from left to right, and cout flippings  for the most recently K bits as \"sum\".\\n2. For each \"bit\", we cout all flippings that will change the value of the current bit. Additional flipping is required as long as nums[i]!=(sum&1) or !(nums[i]-(sum&1)).\\n3. Step 2  should stop at the (N-k+1)-th bit. The tricky part is M=min(k, N-k+1) for small value of N.\\n4. We should check the rest of bits left, as long as that one bit is 0, return -1. Again, the tricky part is M for small value of N.\\n\\n```\\n//C++ code\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int ans, sum=0, N=nums.size(), i=0, flip;\\n        int M=min(k, N-k+1);\\n        for(; i<M; ++i) {\\n            nums[i] = !(nums[i]-(sum&1));\\n            //nums[i]=flip;\\n            sum+=nums[i];\\n        }\\n        ans=sum;\\n        if(N>2*k-1) {\\n            for(; i<N-k+1; ++i) {\\n                sum-=nums[i-k];\\n                nums[i] = !(nums[i]-(sum&1));\\n                //nums[i]=nums[i];\\n                sum+=nums[i];\\n                ans+=nums[i];\\n            }\\n        }\\n        for(; i<k; ++i) {\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        for(; i<N; ++i) {\\n            sum-=nums[i-k];\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTime Used       : [48ms~64ms]\\nTime            :  O(N)\\nSpace           :  O(K)  \\nAdditional Space:  O(c) //we reuse original vector to save history of flips\\n```\n```\\n//C++ code\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int ans, sum=0, N=nums.size(), i=0, flip;\\n        int M=min(k, N-k+1);\\n        for(; i<M; ++i) {\\n            nums[i] = !(nums[i]-(sum&1));\\n            //nums[i]=flip;\\n            sum+=nums[i];\\n        }\\n        ans=sum;\\n        if(N>2*k-1) {\\n            for(; i<N-k+1; ++i) {\\n                sum-=nums[i-k];\\n                nums[i] = !(nums[i]-(sum&1));\\n                //nums[i]=nums[i];\\n                sum+=nums[i];\\n                ans+=nums[i];\\n            }\\n        }\\n        for(; i<k; ++i) {\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        for(; i<N; ++i) {\\n            sum-=nums[i-k];\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219403,
                "title": "c-with-queue-easy-understanding",
                "content": "public class Solution {\\n    public int MinKBitFlips(int[] nums, int k) \\n    {\\n        int result = 0;\\n        Queue<int> qu = new Queue<int>();\\n        \\n        for(int a = 0;a<nums.Length;a++)\\n        {            \\n            while(qu.Count()>0&&qu.Peek()<a)\\n            {\\n                qu.Dequeue();\\n            }\\n            \\n            if((nums[a]+qu.Count())%2==1)\\n            {\\n                continue;\\n            }\\n            if(a>nums.Length-k)\\n            {\\n                return -1;\\n            }\\n            result++;\\n            qu.Enqueue(a+k-1);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinKBitFlips(int[] nums, int k) \\n    {\\n        int result = 0;\\n        Queue<int> qu = new Queue<int>();\\n        \\n        for(int a = 0;a<nums.Length;a++)\\n        {            \\n            while(qu.Count()>0&&qu.Peek()<a)\\n            {\\n                qu.Dequeue();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1217788,
                "title": "scala-solution",
                "content": "```\\ndef minKBitFlips(nums: Array[Int], k: Int): Int = {\\n        val n = nums.length\\n        val isFlipped = Array.ofDim[Int](n)\\n        (0 until n).foldLeft(0/*flipped*/,0/*res*/)((b,a)=>{\\n          var temp = b._1\\n          if(a >= k){temp ^= isFlipped(a - k)}\\n          if(temp == nums(a)){\\n            if(a + k > n){return  -1}\\n            isFlipped(a) = 1\\n            (temp^1, b._2 + 1)\\n          }else (temp,b._2)\\n        })._2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(nums: Array[Int], k: Int): Int = {\\n        val n = nums.length\\n        val isFlipped = Array.ofDim[Int](n)\\n        (0 until n).foldLeft(0/*flipped*/,0/*res*/)((b,a)=>{\\n          var temp = b._1\\n          if(a >= k){temp ^= isFlipped(a - k)}\\n          if(temp == nums(a)){\\n            if(a + k > n){return  -1}\\n            isFlipped(a) = 1\\n            (temp^1, b._2 + 1)\\n          }else (temp,b._2)\\n        })._2\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1193680,
                "title": "c-very-simple-code-no-stack3",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        int ans[60001]={0};\\n        int cnt=0;\\n        if(v[0]==0)\\n        {\\n            cnt++;\\n            ans[0]=1;\\n            ans[k]=-1;\\n        }\\n        for(int i=1;i<=v.size()-k;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n            if(v[i]==0&&ans[i]%2==0)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            else if(v[i]==1&&ans[i]%2)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            \\n        }\\n        for(int j=v.size()-k+1;j<v.size();j++)\\n        {\\n            ans[j]+=ans[j-1];\\n            if(v[j]==0&&ans[j]%2==0)\\n                return -1;\\n            if(v[j]==1&&ans[j]%2)\\n                return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nFeel free to ask in comments.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        int ans[60001]={0};\\n        int cnt=0;\\n        if(v[0]==0)\\n        {\\n            cnt++;\\n            ans[0]=1;\\n            ans[k]=-1;\\n        }\\n        for(int i=1;i<=v.size()-k;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n            if(v[i]==0&&ans[i]%2==0)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            else if(v[i]==1&&ans[i]%2)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            \\n        }\\n        for(int j=v.size()-k+1;j<v.size();j++)\\n        {\\n            ans[j]+=ans[j-1];\\n            if(v[j]==0&&ans[j]%2==0)\\n                return -1;\\n            if(v[j]==1&&ans[j]%2)\\n                return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188034,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        \"\"\"\\n        WLOG, since the bit flip operations are commutative we can assume\\n        that flip_i happens before flip_j when i < j \\n        (flip_i denotes flippings bits i thru i + K - 1)\\n        \"\"\"\\n        N = len(A)\\n        flips = 0\\n        \\n        if not A[0]:\\n            for i in range(K):\\n                A[i] = 1 - A[i]\\n            flips += 1\\n        \\n        diffs = [abs(A[i+1] - A[i]) for i in range(N-1)]\\n        for i in range(N-K):\\n            if diffs[i]:\\n                flips += 1\\n                if i < N - K - 1:\\n                    diffs[i+K] = 1 - diffs[i+K]\\n                \\n        return flips if not any(diffs[N-K:]) else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        \"\"\"\\n        WLOG, since the bit flip operations are commutative we can assume\\n        that flip_i happens before flip_j when i < j \\n        (flip_i denotes flippings bits i thru i + K - 1)\\n        \"\"\"\\n        N = len(A)\\n        flips = 0\\n        \\n        if not A[0]:\\n            for i in range(K):\\n                A[i] = 1 - A[i]\\n            flips += 1\\n        \\n        diffs = [abs(A[i+1] - A[i]) for i in range(N-1)]\\n        for i in range(N-K):\\n            if diffs[i]:\\n                flips += 1\\n                if i < N - K - 1:\\n                    diffs[i+K] = 1 - diffs[i+K]\\n                \\n        return flips if not any(diffs[N-K:]) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159778,
                "title": "javascript-super-easy",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar minKBitFlips = function(A, K) {\\n    let r = 0;\\n    for(let i = 0; i<A.length; i++) {\\n\\t// if we come across 0 we  want to alter it (so we alter also K-1 following values \\n        if(A[i] === 0 && i<A.length - K + 1) {\\n            for(let j = i; j< i + K; j++) {\\n                A[j] = +!A[j];\\n            }\\n            r++;\\n        }\\n\\t//we check if we are left with any 0. If so, then there is no valid combination and we can return 0\\n        if(A[i] === 0) return -1;\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar minKBitFlips = function(A, K) {\\n    let r = 0;\\n    for(let i = 0; i<A.length; i++) {\\n\\t// if we come across 0 we  want to alter it (so we alter also K-1 following values \\n        if(A[i] === 0 && i<A.length - K + 1) {\\n            for(let j = i; j< i + K; j++) {\\n                A[j] = +!A[j];\\n            }\\n            r++;\\n        }\\n\\t//we check if we are left with any 0. If so, then there is no valid combination and we can return 0\\n        if(A[i] === 0) return -1;\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151016,
                "title": "c-simple-solution-using-deque-with-comments-o-n-time-o-k-space",
                "content": "We use a deque to records the indexes where a flip is needed. When evaluating the the situation at i-th position, only the flips that with k -distance have impact.   \\n\\n~~~\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int> &a, int k) {\\n        int ret = 0;\\n        \\n        // holds the indexes at them a flip is needed\\n        deque<int> data;\\n        for (int i = 0; i < a.size(); ++i) {\\n            // phase out the the flips that have no\\n            // impact on i or further\\n            while (data.empty() == false && data.front() <= i - k) {\\n                data.pop_front();\\n            }\\n            \\n            if (i > a.size() - k) { // no flip is allowed (less that k spaces) \\n                if (data.size() % 2 == a[i]) return -1;\\n            } else if (data.size() % 2 == a[i]) {\\n                //  need a flip\\n                data.push_back(i);\\n                ++ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int> &a, int k) {\\n        int ret = 0;\\n        \\n        // holds the indexes at them a flip is needed\\n        deque<int> data;\\n        for (int i = 0; i < a.size(); ++i) {\\n            // phase out the the flips that have no\\n            // impact on i or further\\n            while (data.empty() == false && data.front() <= i - k) {\\n                data.pop_front();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1112206,
                "title": "easy-one",
                "content": "```\\n// pseudo-code\\n//     [----------------------------]\\n//         [-------]\\n//            [--------]\\n//               [---------]\\n              \\n// queue \\n//         check front of queue\\n//             queue pop\\n        \\n//         if queue size%2 and val is not okay\\n//             queue insert\\n//             flip++\\n        \\n        \\n        \\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> flipIndex;\\n        int minFlips=0;\\n        int i;\\n        \\n        for(i=0;i<A.size();i++){\\n            if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n            }\\n            if(A[i]==1&&flipIndex.size()%2==0||A[i]==0&&flipIndex.size()%2==1){\\n                continue;\\n            }\\n            minFlips++;\\n            flipIndex.push(i);    \\n        }\\n        if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n        }\\n        \\n        if(flipIndex.empty()){\\n            return minFlips;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// pseudo-code\\n//     [----------------------------]\\n//         [-------]\\n//            [--------]\\n//               [---------]\\n              \\n// queue \\n//         check front of queue\\n//             queue pop\\n        \\n//         if queue size%2 and val is not okay\\n//             queue insert\\n//             flip++\\n        \\n        \\n        \\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> flipIndex;\\n        int minFlips=0;\\n        int i;\\n        \\n        for(i=0;i<A.size();i++){\\n            if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n            }\\n            if(A[i]==1&&flipIndex.size()%2==0||A[i]==0&&flipIndex.size()%2==1){\\n                continue;\\n            }\\n            minFlips++;\\n            flipIndex.push(i);    \\n        }\\n        if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n        }\\n        \\n        if(flipIndex.empty()){\\n            return minFlips;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072210,
                "title": "go-greedy",
                "content": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    var prefix = make([]int, len(nums) + 1);\\n    var cnt int = 0;\\n    var res int = 0;\\n    \\n    for i := 0; i < len(nums); i++ {\\n        cnt += prefix[i];\\n        num := (nums[i] + (cnt % 2)) % 2;\\n        if num == 0 {\\n            if i + k > len(nums) {return -1;}\\n            cnt++;\\n            res++;\\n            prefix[i + k]--;\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    var prefix = make([]int, len(nums) + 1);\\n    var cnt int = 0;\\n    var res int = 0;\\n    \\n    for i := 0; i < len(nums); i++ {\\n        cnt += prefix[i];\\n        num := (nums[i] + (cnt % 2)) % 2;\\n        if num == 0 {\\n            if i + k > len(nums) {return -1;}\\n            cnt++;\\n            res++;\\n            prefix[i + k]--;\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025072,
                "title": "python-3-sliding-window",
                "content": "```\\ndef minKBitFlips(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        f = [0] * (n + 1)\\n        ans = 0\\n        cur = 0 \\n        for x in range(n - K + 1):\\n            cur += f[x]\\n            if (A[x] + cur) % 2 == 1:\\n                continue\\n            else:\\n                ans += 1\\n                cur += 1\\n                f[x + K] -= 1\\n        for idx in range(x + 1, n):\\n            cur += f[idx]\\n            if (A[idx] + cur) % 2 == 0:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        f = [0] * (n + 1)\\n        ans = 0\\n        cur = 0 \\n        for x in range(n - K + 1):\\n            cur += f[x]\\n            if (A[x] + cur) % 2 == 1:\\n                continue\\n            else:\\n                ans += 1\\n                cur += 1\\n                f[x + K] -= 1\\n        for idx in range(x + 1, n):\\n            cur += f[idx]\\n            if (A[idx] + cur) % 2 == 0:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1023113,
                "title": "c-o-n-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        \\n        int n = A.size();\\n        int flip = 0,cnt = 0;\\n        \\n        for(int i=0;i<=A.size()-k;i++){\\n            if(A[i] > 1){\\n                A[i]-=2;\\n                flip--;\\n            }\\n            if((A[i] ^ flip & 1)) continue;\\n            cnt++;\\n            if(i + k < A.size()){\\n                A[i+k] += 2;\\n            }\\n            ++flip;\\n        }\\n        \\n        for(int i=A.size()-k+1;i<A.size();i++){\\n            if(A[i] > 1){\\n                A[i]-=2;\\n                flip--;\\n            }\\n            if((A[i] ^ flip & 1)) continue;\\n            return -1;\\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        \\n        int n = A.size();\\n        int flip = 0,cnt = 0;\\n        \\n        for(int i=0;i<=A.size()-k;i++){\\n            if(A[i] > 1){\\n                A[i]-=2;\\n                flip--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565102,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n²)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 1566108,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n²)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 1794134,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n²)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 2050720,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n²)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 1856086,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n²)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            }
        ]
    }
]