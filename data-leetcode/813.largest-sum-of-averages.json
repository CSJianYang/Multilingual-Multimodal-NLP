[
    {
        "title": "Largest Triangle Area",
        "question_content": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.\n&nbsp;\nExample 1:\n\nInput: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\nOutput: 2.00000\nExplanation: The five points are shown in the above figure. The red triangle is the largest.\n\nExample 2:\n\nInput: points = [[1,0],[0,0],[0,1]]\nOutput: 0.50000\n\n&nbsp;\nConstraints:\n\n\t3 <= points.length <= 50\n\t-50 <= xi, yi <= 50\n\tAll the given points are unique.",
        "solutions": [
            {
                "id": 122711,
                "title": "c-java-python-solution-with-explanation-and-prove",
                "content": "**Explanaiton**\\nBurete force loop on all combinations of three points and calculate the area of these three points.\\nIf you google \"three pointes triangle area formula\", you can find the answer with the first result in second.\\n\\n**Time complexity**\\n```O(N^3)``` solution, but ```N <= 50```, so it\\'s fast enough.\\nYou may find convex hull first as @weidairpi replies. It help improve to O(M^3 + NlogN) in the best case where M is the number of points on the hull. \\nBut it make this easy problem complex and it stays same complexity in the worst case.\\n\\n**Prove 1**\\nWell, someone complains the situation without any formula.\\nIn fact the formula is not that difficult to find out.\\n\\nFor this case:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523209147.png)\\n\\nWe can calculate the area as follow:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523379988.png)\\n\\n\\nIn the result A,B,C are symmetrical, so it won\\'t matter what order we name it.\\nIn this case, we calculate the total area by addition three triangle.\\nIn the other cases, you may need to use substraction and it\\'s quite the same process.\\n\\n**Prove 2**\\nIf you are familar with vector product. The result is quite obvious.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523380000.png)\\n\\n\\n**C++:**\\n```\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public double largestTriangleArea(int[][] p) {\\n        double res = 0;\\n        for (int[] i: p)\\n            for (int[] j: p)\\n                for (int[] k: p)\\n            res = Math.max(res, 0.5 * Math.abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\\n\\n**1-line Python**\\n```\\ndef largestTriangleArea(self, p):\\n        return max(0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1])\\n            for i, j, k in itertools.combinations(p, 3))\\n```",
                "solutionTags": [],
                "code": "```O(N^3)```\n```N <= 50```\n```\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\n```\\n    public double largestTriangleArea(int[][] p) {\\n        double res = 0;\\n        for (int[] i: p)\\n            for (int[] j: p)\\n                for (int[] k: p)\\n            res = Math.max(res, 0.5 * Math.abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\n```\\ndef largestTriangleArea(self, p):\\n        return max(0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1])\\n            for i, j, k in itertools.combinations(p, 3))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 124010,
                "title": "simple-java-easy-understand",
                "content": "How to pick all combinaitons from an array that consist of 3 points - \\nhttps://www.geeksforgeeks.org/print-all-possible-combinations-of-r-elements-in-a-given-array-of-size-n/\\n\\nHow to calculate the triangle area knowing the coordinates of the 3 points? \\nhttps://www.mathopenref.com/coordtrianglearea.html\\n\\n\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max = 0.0; \\n        for (int i = 0; i < points.length - 2; i++) \\n            for (int j = i + 1; j < points.length - 1; j++) \\n                for (int k = j + 1; k < points.length; k++) \\n                    max = Math.max(max, areaCal(points[i], points[j], points[k])); \\n        return max; \\n    }\\n    \\n    public double areaCal(int[] pt1, int[] pt2, int[] pt3) {\\n        return Math.abs(pt1[0] * (pt2[1] - pt3[1]) + pt2[0] * (pt3[1] - pt1[1]) + pt3[0] * (pt1[1] - pt2[1])) / 2.0; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max = 0.0; \\n        for (int i = 0; i < points.length - 2; i++) \\n            for (int j = i + 1; j < points.length - 1; j++) \\n                for (int k = j + 1; k < points.length; k++) \\n                    max = Math.max(max, areaCal(points[i], points[j], points[k])); \\n        return max; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1585033,
                "title": "python-faster-than-93-simple-maths-with-explanation",
                "content": "I used my highschool determinants formula of area of a triangle\\n if coordinates are given\\n        1/2(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n  Explanation link:    https://www.cuemath.com/geometry/area-of-triangle-in-coordinate-geometry/\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346989,
                "title": "c-brute-force-herone-s-formulae",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\n//812. Largest Triangle Area (Using brute force)\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& points) {\\n        int n=points.size();\\n        double maxArea=0;\\n             double d1,d2,d3,area,s;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n        d1=sqrt((double)pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));    \\n        d2=sqrt((double)pow(points[j][0]-points[k][0],2)+pow(points[j][1]-points[k][1],2));\\n        d3=sqrt((double)pow(points[i][0]-points[k][0],2)+pow(points[i][1]-points[k][1],2));\\n        s=(d1+d2+d3)/2.00000;\\n        area=(double)sqrt(s*(s-d1)*(s-d2)*(s-d3));\\n                    \\n                    if(maxArea<area)\\n                     maxArea=area;   \\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//812. Largest Triangle Area (Using brute force)\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& points) {\\n        int n=points.size();\\n        double maxArea=0;\\n             double d1,d2,d3,area,s;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n        d1=sqrt((double)pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));    \\n        d2=sqrt((double)pow(points[j][0]-points[k][0],2)+pow(points[j][1]-points[k][1],2));\\n        d3=sqrt((double)pow(points[i][0]-points[k][0],2)+pow(points[i][1]-points[k][1],2));\\n        s=(d1+d2+d3)/2.00000;\\n        area=(double)sqrt(s*(s-d1)*(s-d2)*(s-d3));\\n                    \\n                    if(maxArea<area)\\n                     maxArea=area;   \\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182897,
                "title": "easy-java-solution-beats-99-77",
                "content": "Just need to recall a formula to calculate a right trapezoid area (no angles or vectors math).\\n\\nEach triangle\\'s side forms a trapezoid with its projection on to Y=Ymin line:\\n![image](https://assets.leetcode.com/users/kirj/image_1539852429.png)\\nThen the triangle area can be calculated as a sum of 3 trapezoids area formed by the triangle sides:\\n\\nResult area = | A1 + A2 + A3 |, where \\nA1 = (X2 - X1) * ((Y2 - Ymin + Y1 - Ymin) / 2) \\nA2 = (X3 - X2) * ((Y3 - Ymin + Y2 - Ymin) / 2) \\nA3 = (X1 - X3) * ((Y1 - Ymin + Y3 - Ymin) / 2) \\n\\nThe order of the Xi coordinates is important here and it\\'s expected for some Ai to be negative. We deduct Ymin to ensure that the Y part is always positive.\\n\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max = 0;\\n        \\n        for (int i = 0; i < n; ++i) \\n            for (int j = i + 1; j < n; ++j)\\n                for (int k = j + 1; k < n; ++k) {\\n                    double area = area(points, i, j, k);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n        \\n        \\n        return max;\\n    }\\n    \\n    // triangle\\n    double area(int[][] points, int i, int j, int k) {\\n        int[] p1 = points[i];\\n        int[] p2 = points[j];\\n        int[] p3 = points[k];\\n        \\n        double area = 0;\\n        area += area(p1, p2);\\n        area += area(p2, p3);\\n        area += area(p3, p1);\\n        \\n        return Math.abs(area);\\n    }\\n    \\n    // right trapezoid\\n    double area(int[] p1, int[] p2) {\\n        int w = p2[0] - p1[0];\\n        double h = (p1[1] + p2[1] + 200) / 2.0;\\n        return w * h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max = 0;\\n        \\n        for (int i = 0; i < n; ++i) \\n            for (int j = i + 1; j < n; ++j)\\n                for (int k = j + 1; k < n; ++k) {\\n                    double area = area(points, i, j, k);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n        \\n        \\n        return max;\\n    }\\n    \\n    // triangle\\n    double area(int[][] points, int i, int j, int k) {\\n        int[] p1 = points[i];\\n        int[] p2 = points[j];\\n        int[] p3 = points[k];\\n        \\n        double area = 0;\\n        area += area(p1, p2);\\n        area += area(p2, p3);\\n        area += area(p3, p1);\\n        \\n        return Math.abs(area);\\n    }\\n    \\n    // right trapezoid\\n    double area(int[] p1, int[] p2) {\\n        int w = p2[0] - p1[0];\\n        double h = (p1[1] + p2[1] + 200) / 2.0;\\n        return w * h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179046,
                "title": "c",
                "content": "\\u8FD9\\u91CC\\u4F7F\\u7528\\u7684\\u662FGraham\\u626B\\u63CF\\u6CD5\\uFF0C\\u5C06`int[]`\\u8868\\u793A\\u7684\\u70B9\\u5C01\\u88C5\\u6210\\u4E86`Vector3`\\uFF0C\\u5E76\\u5B9E\\u73B0\\u4E86\\u53C9\\u4E58\\u7B49\\u5E38\\u7528\\u65B9\\u6CD5\\u65B9\\u4FBF\\u8BA1\\u7B97\\u3002\\u867D\\u7136\\u66B4\\u529B\\u6CD5\\u53EF\\u4EE5\\u901A\\u8FC7\\uFF0C\\u4F46\\u662F\\u901A\\u8FC7\\u4F18\\u5316\\u53EF\\u4EE5\\u5B66\\u4E60\\u66F4\\u591A\\u65B0\\u7684\\u77E5\\u8BC6\\u548C\\u6280\\u672F\\uFF0C\\u63D0\\u9AD8\\u81EA\\u5DF1\\u89E3\\u51B3\\u95EE\\u9898\\u7684\\u80FD\\u529B\\uFF0C\\u4E0D\\u8981\\u4E3A\\u4E86\\u505A\\u9898\\u800C\\u505A\\u9898\\uFF01\\n```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        double maxArea = -1;\\n        points = Graham(points);\\n        // foreach(var p in resultArray) {\\n        //     Console.WriteLine(\"x:{0}, y:{1}\", p[0], p[1]);\\n        // }\\n        for (int i = 0; i < points.Length; i++) {\\n            for (int j = 0; j < points.Length; j++) {\\n                for (int k = 0; k < points.Length; k++) {\\n                    if (i != j && j != k && i != k) {\\n                        double area = GetTriArea(points[i],points[j],points[k]);\\n                        if (area > maxArea) {\\n                            maxArea = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int[][] Graham(int[][] pointsArray) {\\n        List<Vector3> points = new List<Vector3>(pointsArray.Length);\\n        foreach(var p in pointsArray) {\\n            points.Add(new Vector3(p));\\n        }\\n        List<Vector3> result = new List<Vector3>();\\n        for(int i = 0; i < points.Count; i++)\\n        {\\n            //grab the bottom-right point and move it to the head of the list\\n            if (points[i].z < points[0].z || points[i].z == points[0].z && points[i].x > points[0].x)\\n            {\\n                Vector3 temp = points[i];\\n                points[i] = points[0];\\n                points[0] = temp;\\n            }\\n        }\\n        //\\u6839\\u636E\\u6781\\u89D2\\u7531\\u5C0F\\u5230\\u5927\\u6392\\u5E8F\\n        PolarAngleComparer comparer = new PolarAngleComparer(points[0]);\\n        points.Sort(1, points.Count - 1, comparer);\\n        Stack<Vector3> s = new Stack<Vector3>();\\n        s.Push(points[0]);\\n        s.Push(points[1]);\\n        int index = 2;\\n        while (index < points.Count)\\n        {\\n            Vector3 lastPoint = s.Pop();\\n            Vector3 lastSecondPoint = s.Peek();\\n            s.Push(lastPoint);\\n            Vector3 curPoint = points[index];\\n            Vector3 p1 = lastPoint - lastSecondPoint;\\n            Vector3 p2 = curPoint - lastPoint;\\n            Vector3 cross = Vector3.Cross(p1, p2);\\n            //\\u8FD9\\u91CC\\u4F7F\\u7528\\u7684\\u662F\\u5DE6\\u624B\\u5750\\u6807\\u7CFB\\n            if (cross.y < 0)    //\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Push(curPoint);\\n                index++;\\n            }\\n            else if (cross.y == 0) //\\u540C\\u4E00\\u76F4\\u7EBF\\u4E0A\\uFF0C\\u9009\\u53D6\\u79BB\\u5012\\u6570\\u7B2C\\u4E8C\\u4E2A\\u70B9\\u8F83\\u8FDC\\u7684\\u70B9\\n            {\\n                double dis1 = Vector3.Distance(lastPoint, lastSecondPoint);\\n                double dis2 = Vector3.Distance(curPoint, lastSecondPoint);\\n                if (dis2 > dis1)\\n                {\\n                    s.Pop();\\n                    s.Push(curPoint);\\n                }\\n                index++;\\n            }\\n            else                //\\u4E0D\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Pop();\\n            }\\n        }\\n        while (s.Count > 0)\\n        {\\n            result.Add(s.Pop());\\n        }\\n        int[][] resultArray = new int[result.Count][];\\n        for (int i = 0; i < result.Count; i++) {\\n            resultArray[i] = new int[2]{(int)result[i].x, (int)result[i].z};\\n        }\\n        return resultArray;\\n    }\\n    private double GetTriArea(int[] a, int[] b, int[] c)\\n    {\\n        //\\u53C9\\u4E58\\u8BA1\\u7B97\\u4E09\\u89D2\\u5F62\\u9762\\u79EF\\n        return (0.5 * Math.Abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1]- b[0] * a[1] - c[0] * b[1] - a[0] * c[1]));\\n    }\\n}\\n//\\u5750\\u6807\\u70B9\\u7ED3\\u6784\\u4F53\\u5C01\\u88C5\\npublic struct Vector3 {\\n    public double x;\\n    public double y;\\n    public double z;\\n    public Vector3(double x, double y, double z)\\n    {\\n        this.x = x;\\n        this.y = y;\\n        this.z = z;\\n    }\\n    public Vector3(int[] pointArray)\\n    {\\n        x = pointArray[0];\\n        y = 0;\\n        z = pointArray[1];\\n    }\\n    public static Vector3 zero => new Vector3(0,0,0);\\n    public static Vector3 right => new Vector3(1, 0, 0);\\n    public Vector3 normalized => Normalize(this);\\n    public static Vector3 Cross(Vector3 lhs, Vector3 rhs) \\n    {\\n        return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);\\n    }\\n    public static double Distance(Vector3 a, Vector3 b)\\n    {\\n        Vector3 vector = new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n        return Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);\\n    }\\n    public static double Dot(Vector3 lhs, Vector3 rhs)\\n    {\\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\\n    }\\n    public static Vector3 Normalize(Vector3 value)\\n    {\\n        double num = Magnitude(value);\\n        if (num > 1E-05f)\\n        {\\n            return value / num;\\n        }\\n        return zero;\\n    }\\n    public static double Magnitude(Vector3 a)\\n    {\\n    \\treturn Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\\n    }\\n    public static Vector3 operator +(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a)\\n    {\\n    \\treturn new Vector3(0f - a.x, 0f - a.y, 0f - a.z);\\n    }\\n\\n    public static Vector3 operator *(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator *(float d, Vector3 a)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator /(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x / d, a.y / d, a.z / d);\\n    }\\n}\\n//\\u6781\\u89D2\\u6392\\u5E8F\\u5668\\npublic class PolarAngleComparer : IComparer<Vector3>\\n{\\n    public Vector3 basePoint = Vector3.zero;\\n    public PolarAngleComparer(Vector3 basePoint)\\n    {\\n        this.basePoint = basePoint;\\n    }\\n    public int Compare(Vector3 x, Vector3 y)\\n    {\\n        Vector3 v1 = x - basePoint;\\n        Vector3 v2 = y - basePoint;\\n        double cos1 = Vector3.Dot(v1.normalized, Vector3.right);\\n        double cos2 = Vector3.Dot(v2.normalized, Vector3.right);\\n        return cos1 < cos2 ? 1 : cos1 > cos2 ? -1 : 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        double maxArea = -1;\\n        points = Graham(points);\\n        // foreach(var p in resultArray) {\\n        //     Console.WriteLine(\"x:{0}, y:{1}\", p[0], p[1]);\\n        // }\\n        for (int i = 0; i < points.Length; i++) {\\n            for (int j = 0; j < points.Length; j++) {\\n                for (int k = 0; k < points.Length; k++) {\\n                    if (i != j && j != k && i != k) {\\n                        double area = GetTriArea(points[i],points[j],points[k]);\\n                        if (area > maxArea) {\\n                            maxArea = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int[][] Graham(int[][] pointsArray) {\\n        List<Vector3> points = new List<Vector3>(pointsArray.Length);\\n        foreach(var p in pointsArray) {\\n            points.Add(new Vector3(p));\\n        }\\n        List<Vector3> result = new List<Vector3>();\\n        for(int i = 0; i < points.Count; i++)\\n        {\\n            //grab the bottom-right point and move it to the head of the list\\n            if (points[i].z < points[0].z || points[i].z == points[0].z && points[i].x > points[0].x)\\n            {\\n                Vector3 temp = points[i];\\n                points[i] = points[0];\\n                points[0] = temp;\\n            }\\n        }\\n        //\\u6839\\u636E\\u6781\\u89D2\\u7531\\u5C0F\\u5230\\u5927\\u6392\\u5E8F\\n        PolarAngleComparer comparer = new PolarAngleComparer(points[0]);\\n        points.Sort(1, points.Count - 1, comparer);\\n        Stack<Vector3> s = new Stack<Vector3>();\\n        s.Push(points[0]);\\n        s.Push(points[1]);\\n        int index = 2;\\n        while (index < points.Count)\\n        {\\n            Vector3 lastPoint = s.Pop();\\n            Vector3 lastSecondPoint = s.Peek();\\n            s.Push(lastPoint);\\n            Vector3 curPoint = points[index];\\n            Vector3 p1 = lastPoint - lastSecondPoint;\\n            Vector3 p2 = curPoint - lastPoint;\\n            Vector3 cross = Vector3.Cross(p1, p2);\\n            //\\u8FD9\\u91CC\\u4F7F\\u7528\\u7684\\u662F\\u5DE6\\u624B\\u5750\\u6807\\u7CFB\\n            if (cross.y < 0)    //\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Push(curPoint);\\n                index++;\\n            }\\n            else if (cross.y == 0) //\\u540C\\u4E00\\u76F4\\u7EBF\\u4E0A\\uFF0C\\u9009\\u53D6\\u79BB\\u5012\\u6570\\u7B2C\\u4E8C\\u4E2A\\u70B9\\u8F83\\u8FDC\\u7684\\u70B9\\n            {\\n                double dis1 = Vector3.Distance(lastPoint, lastSecondPoint);\\n                double dis2 = Vector3.Distance(curPoint, lastSecondPoint);\\n                if (dis2 > dis1)\\n                {\\n                    s.Pop();\\n                    s.Push(curPoint);\\n                }\\n                index++;\\n            }\\n            else                //\\u4E0D\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Pop();\\n            }\\n        }\\n        while (s.Count > 0)\\n        {\\n            result.Add(s.Pop());\\n        }\\n        int[][] resultArray = new int[result.Count][];\\n        for (int i = 0; i < result.Count; i++) {\\n            resultArray[i] = new int[2]{(int)result[i].x, (int)result[i].z};\\n        }\\n        return resultArray;\\n    }\\n    private double GetTriArea(int[] a, int[] b, int[] c)\\n    {\\n        //\\u53C9\\u4E58\\u8BA1\\u7B97\\u4E09\\u89D2\\u5F62\\u9762\\u79EF\\n        return (0.5 * Math.Abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1]- b[0] * a[1] - c[0] * b[1] - a[0] * c[1]));\\n    }\\n}\\n//\\u5750\\u6807\\u70B9\\u7ED3\\u6784\\u4F53\\u5C01\\u88C5\\npublic struct Vector3 {\\n    public double x;\\n    public double y;\\n    public double z;\\n    public Vector3(double x, double y, double z)\\n    {\\n        this.x = x;\\n        this.y = y;\\n        this.z = z;\\n    }\\n    public Vector3(int[] pointArray)\\n    {\\n        x = pointArray[0];\\n        y = 0;\\n        z = pointArray[1];\\n    }\\n    public static Vector3 zero => new Vector3(0,0,0);\\n    public static Vector3 right => new Vector3(1, 0, 0);\\n    public Vector3 normalized => Normalize(this);\\n    public static Vector3 Cross(Vector3 lhs, Vector3 rhs) \\n    {\\n        return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);\\n    }\\n    public static double Distance(Vector3 a, Vector3 b)\\n    {\\n        Vector3 vector = new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n        return Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);\\n    }\\n    public static double Dot(Vector3 lhs, Vector3 rhs)\\n    {\\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\\n    }\\n    public static Vector3 Normalize(Vector3 value)\\n    {\\n        double num = Magnitude(value);\\n        if (num > 1E-05f)\\n        {\\n            return value / num;\\n        }\\n        return zero;\\n    }\\n    public static double Magnitude(Vector3 a)\\n    {\\n    \\treturn Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\\n    }\\n    public static Vector3 operator +(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a)\\n    {\\n    \\treturn new Vector3(0f - a.x, 0f - a.y, 0f - a.z);\\n    }\\n\\n    public static Vector3 operator *(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator *(float d, Vector3 a)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator /(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x / d, a.y / d, a.z / d);\\n    }\\n}\\n//\\u6781\\u89D2\\u6392\\u5E8F\\u5668\\npublic class PolarAngleComparer : IComparer<Vector3>\\n{\\n    public Vector3 basePoint = Vector3.zero;\\n    public PolarAngleComparer(Vector3 basePoint)\\n    {\\n        this.basePoint = basePoint;\\n    }\\n    public int Compare(Vector3 x, Vector3 y)\\n    {\\n        Vector3 v1 = x - basePoint;\\n        Vector3 v2 = y - basePoint;\\n        double cos1 = Vector3.Dot(v1.normalized, Vector3.right);\\n        double cos2 = Vector3.Dot(v2.normalized, Vector3.right);\\n        return cos1 < cos2 ? 1 : cos1 > cos2 ? -1 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333629,
                "title": "two-solutions-in-python-3-shoelace-method-and-heron-s-formula",
                "content": "_Shoelace Method:_\\n```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        L, A = len(p), 0\\n        for i in range(L-2):\\n        \\tfor j in range(i+1,L-1):\\n        \\t\\tfor k in range(j+1,L):\\n        \\t\\t\\tR = Area_Shoelace(p[i],p[j],p[k])\\n        \\t\\t\\tA = max(A,R)\\n        return A\\n\\ndef Area_Shoelace(a,b,c):\\n\\treturn abs(a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-(a[0]*c[1]+c[0]*b[1]+b[0]*a[1]))/2\\n\\t\\n\\n```\\n_Heron\\'s Formula:_\\n```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        L, A = len(p), 0\\n        for i in range(L-2):\\n        \\tfor j in range(i+1,L-1):\\n        \\t\\tfor k in range(j+1,L):\\n        \\t\\t\\tR = Area_Heron(p[i],p[j],p[k])\\n        \\t\\t\\tA = max(A,R)\\n        return A\\n\\ndef Area_Heron(r,s,t):\\n\\ta, b, c = math.hypot(r[0]-s[0],r[1]-s[1]), math.hypot(r[0]-t[0],r[1]-t[1]), math.hypot(s[0]-t[0],s[1]-t[1])\\n\\ts = (a + b + c)/2\\n\\treturn (max(0,s*(s-a)*(s-b)*(s-c)))**.5\\n\\n\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        L, A = len(p), 0\\n        for i in range(L-2):\\n        \\tfor j in range(i+1,L-1):\\n        \\t\\tfor k in range(j+1,L):\\n        \\t\\t\\tR = Area_Shoelace(p[i],p[j],p[k])\\n        \\t\\t\\tA = max(A,R)\\n        return A\\n\\ndef Area_Shoelace(a,b,c):\\n\\treturn abs(a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-(a[0]*c[1]+c[0]*b[1]+b[0]*a[1]))/2\\n\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283662,
                "title": "simple-c-solution-using-heron-s-formula",
                "content": "https://www.cuemath.com/herons-formula/\\nRefer the above link to know about Heron\\'s Formula.\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        for(int i=0;i<points.size();++i){\\n           for(int j=i+1;j<points.size();++j){\\n               for(int k=j+1;k<points.size();++k){\\n                   double a=points[i][0];\\n                   double b=points[i][1];\\n                   double c=points[j][0];\\n                   double d=points[j][1];\\n                   double e=points[k][0];\\n                   double f=points[k][1];\\n                   double distance1=sqrt((a-c)*(a-c)+(b-d)*(b-d));\\n                   double distance2=sqrt((a-e)*(a-e)+(b-f)*(b-f));\\n                   double distance3=sqrt((c-e)*(c-e)+(d-f)*(d-f));\\n                   double s=(distance1+distance2+distance3)/2;\\n                   double area=sqrt(s*(s-distance1)*(s-distance2)*(s-distance3));\\n                   ans=max(ans,area);\\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        for(int i=0;i<points.size();++i){\\n           for(int j=i+1;j<points.size();++j){\\n               for(int k=j+1;k<points.size();++k){\\n                   double a=points[i][0];\\n                   double b=points[i][1];\\n                   double c=points[j][0];\\n                   double d=points[j][1];\\n                   double e=points[k][0];\\n                   double f=points[k][1];\\n                   double distance1=sqrt((a-c)*(a-c)+(b-d)*(b-d));\\n                   double distance2=sqrt((a-e)*(a-e)+(b-f)*(b-f));\\n                   double distance3=sqrt((c-e)*(c-e)+(d-f)*(d-f));\\n                   double s=(distance1+distance2+distance3)/2;\\n                   double area=sqrt(s*(s-distance1)*(s-distance2)*(s-distance3));\\n                   ans=max(ans,area);\\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210808,
                "title": "beats-100-of-java-sol-3ms-brute-force-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Calculate area of each data points and return the data points having maximum area.\\n- To Calculate the area of a triangle having vertices as *(x1,y1), (x2,y2) and (x3,y3)* we use the formula:\\n$$S=[x1(y2\\u2212y3)+x2(y3\\u2212y1)+x3(y1\\u2212y2)]/2$$\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\\n        return ans;\\n    }\\n    public static double area(int[] x1, int[] x2, int[] x3)\\n    {\\n        int t1 = x1[0] * ( x2[1] - x3[1]);\\n        int t2 = x2[0] * ( x3[1] - x1[1]);\\n        int t3 = x3[0] * ( x1[1] - x2[1]);\\n        return (double)( t1 + t2 + t3 )/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\\n        return ans;\\n    }\\n    public static double area(int[] x1, int[] x2, int[] x3)\\n    {\\n        int t1 = x1[0] * ( x2[1] - x3[1]);\\n        int t2 = x2[0] * ( x3[1] - x1[1]);\\n        int t3 = x3[0] * ( x1[1] - x2[1]);\\n        return (double)( t1 + t2 + t3 )/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847965,
                "title": "convex-hull-reduction-fast-c",
                "content": "If we are trying to find the largest triangle given some set of points, considering every set of 3 points gives **O(n^3)** triangles to consider.\\nIf we notice that any maximal triangle has points which lie on the convex hull (wrap an elastic band around all the points, the points that touch the elastic are on the convex hull) then we can substantially reduce the size of the problem and hence the overall time complexity by performing an **O(nlog(n))** operation.\\nIn the worst case, we are still **O(n^3)** however in the best case, we only need to consider 1 triangle.\\nSo, while our overall time complexity is the same **O(n^3)** our average performance will be much better than this.\\n\\n```\\ntypedef pair<int, int> pt;\\n#define x first\\n#define y second\\npt operator -(pt a, pt b) {\\n  return pt(a.x - b.x, a.y - b.y);\\n}\\n\\nclass Solution {\\n  int cross(pt a, pt b) { // 2d cross product\\n    return a.x*b.y - a.y*b.x;\\n  }\\n  bool ccw(pt a, pt b, pt c) { // counter clockwise rotation\\n    return cross(b - a, c - a) >= 0;\\n  }\\n  \\n  vector<pt> half_hull(vector<pt>& pts) {\\n    vector<pt> res;\\n    for (int i = 0; i < pts.size() ; i++) {\\n      while (res.size() >= 2 && ccw(pts[i], res[res.size()-1], res[res.size()-2]))\\n        res.pop_back();\\n      res.push_back (pts[i]);\\n    }\\n    return res;\\n  }\\n  \\n  vector<pt> convex_hull(vector<pt>& pts) {\\n    sort (pts.begin(), pts.end());\\n    vector<pt> top = half_hull(pts);\\n    reverse(pts.begin(), pts.end());\\n    vector<pt> bottom = half_hull(pts) ;\\n    top.pop_back() ;\\n    bottom.pop_back();\\n    vector<pt> res(top.begin(), top.end());\\n    res.insert(res.end(), bottom.begin(), bottom.end());\\n    return res;\\n  }\\n \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      int area = -1;\\n      vector<pt> pts;\\n      for (vector<int>& p : points) {\\n        pts.push_back({p[0], p[1]});\\n      }\\n      vector<pt> hull = convex_hull(pts);\\n\\n      for (int i = 0; i < hull.size(); i++) {\\n        for (int j = i + 1; j < hull.size(); j++) {\\n          for (int k = j + 1; k < hull.size(); k++) {\\n            area = max(area, abs(cross(hull[j]-hull[i], hull[k]-hull[i])));\\n          }\\n        }\\n      }\\n      return 0.5*area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef pair<int, int> pt;\\n#define x first\\n#define y second\\npt operator -(pt a, pt b) {\\n  return pt(a.x - b.x, a.y - b.y);\\n}\\n\\nclass Solution {\\n  int cross(pt a, pt b) { // 2d cross product\\n    return a.x*b.y - a.y*b.x;\\n  }\\n  bool ccw(pt a, pt b, pt c) { // counter clockwise rotation\\n    return cross(b - a, c - a) >= 0;\\n  }\\n  \\n  vector<pt> half_hull(vector<pt>& pts) {\\n    vector<pt> res;\\n    for (int i = 0; i < pts.size() ; i++) {\\n      while (res.size() >= 2 && ccw(pts[i], res[res.size()-1], res[res.size()-2]))\\n        res.pop_back();\\n      res.push_back (pts[i]);\\n    }\\n    return res;\\n  }\\n  \\n  vector<pt> convex_hull(vector<pt>& pts) {\\n    sort (pts.begin(), pts.end());\\n    vector<pt> top = half_hull(pts);\\n    reverse(pts.begin(), pts.end());\\n    vector<pt> bottom = half_hull(pts) ;\\n    top.pop_back() ;\\n    bottom.pop_back();\\n    vector<pt> res(top.begin(), top.end());\\n    res.insert(res.end(), bottom.begin(), bottom.end());\\n    return res;\\n  }\\n \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      int area = -1;\\n      vector<pt> pts;\\n      for (vector<int>& p : points) {\\n        pts.push_back({p[0], p[1]});\\n      }\\n      vector<pt> hull = convex_hull(pts);\\n\\n      for (int i = 0; i < hull.size(); i++) {\\n        for (int j = i + 1; j < hull.size(); j++) {\\n          for (int k = j + 1; k < hull.size(); k++) {\\n            area = max(area, abs(cross(hull[j]-hull[i], hull[k]-hull[i])));\\n          }\\n        }\\n      }\\n      return 0.5*area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918415,
                "title": "0ms-solution-2-different-solutions-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach)\\n```\\n\\n# (Approach 1) : 10 ms\\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) \\n    {\\n        double area=0;\\n        for(int[] A:points)\\n        {\\n            for(int[] B:points)\\n            {\\n                for(int[] C:points)\\n                {\\n                    area=Math.max(area,0.5*calcArea(A,B,C));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n    public double calcArea(int[] A,int[] B,int[] C)\\n    {\\n        int ABx=B[0]-A[0];\\n        int ACy=C[1]-A[1];\\n        int ABy=B[1]-A[1];\\n        int ACx=C[0]-A[0];\\n        return Math.abs(ABx*ACy-ABy*ACx);\\n    }\\n}\\n```\\n# (Approach 2) : 0 ms\\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) //fastest approach\\n    {\\n        int n = points.length;\\n        double max =0;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }\\n        return max;\\n    }\\n\\n    public double area(int[] a, int[] b)\\n    {\\n        int l = b[0]-a[0];\\n        double h = (a[1]+b[1]+200)/2.0;\\n        return l*h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach)\\n```\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) \\n    {\\n        double area=0;\\n        for(int[] A:points)\\n        {\\n            for(int[] B:points)\\n            {\\n                for(int[] C:points)\\n                {\\n                    area=Math.max(area,0.5*calcArea(A,B,C));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n    public double calcArea(int[] A,int[] B,int[] C)\\n    {\\n        int ABx=B[0]-A[0];\\n        int ACy=C[1]-A[1];\\n        int ABy=B[1]-A[1];\\n        int ACx=C[0]-A[0];\\n        return Math.abs(ABx*ACy-ABy*ACx);\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) //fastest approach\\n    {\\n        int n = points.length;\\n        double max =0;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }\\n        return max;\\n    }\\n\\n    public double area(int[] a, int[] b)\\n    {\\n        int l = b[0]-a[0];\\n        double h = (a[1]+b[1]+200)/2.0;\\n        return l*h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258864,
                "title": "python-triangle-area",
                "content": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        res = 0\\n        for i in range(len(points)):\\n            x1, y1 = points[i]\\n            for j in range(i+1, len(points)):\\n                x2, y2 = points[j]\\n                for k in range(j+1, len(points)):\\n                    x3, y3 = points[k]\\n                    res = max(res, abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        res = 0\\n        for i in range(len(points)):\\n            x1, y1 = points[i]\\n            for j in range(i+1, len(points)):\\n                x2, y2 = points[j]\\n                for k in range(j+1, len(points)):\\n                    x3, y3 = points[k]\\n                    res = max(res, abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 122859,
                "title": "python-another-convex-hull-solution-44ms-to-reduce-the-search-space",
                "content": "```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        return self.largestTriangeAreaInConvexHull(self.convex_hull(points))\\n        \\n        \\n        \\n        \\n    def largestTriangeAreaInConvexHull(self, points):\\n        \\n        max_area = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    new_area = abs(0.5 * (points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1]\\n                   - points[i][0] * points[k][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1]))\\n                    max_area= max(max_area, new_area)\\n        return max_area\\n    \\n    \\n    def convex_hull(self, points):\\n        hull = []\\n        points = sorted(points,key=lambda l:l[1])\\n        ref_point= points[0]\\n        angle_points = []\\n        for p in points[1:]:\\n            angle = self.angle(ref_point, p)\\n            if angle < 0:\\n                angle = math.pi*2.0 + angle\\n            angle_points.append( [angle, p])\\n        \\n        \\n        angle_points.sort()\\n        hull.append(ref_point)\\n        hull.append(angle_points[0][1])\\n\\n        for angle_point in angle_points[1:]:\\n            top = hull.pop()\\n            while len(hull) > 0 and self.ccw(hull[-1], top, angle_point[1]) < 0: #it is not <= because we want to keep all points in the convex hull, even if the are in a line\\n                top = hull.pop()\\n                \\n            hull.append(top)\\n            hull.append(angle_point[1])\\n\\n        return hull\\n    \\n    def angle(self, reference, point):\\n        v1_x = point[0]-reference[0]\\n        v1_y = point[1] - reference[1]\\n        return math.atan2(v1_y, v1_x)\\n        \\n    def ccw(self, a, b, c):\\n        area2 = (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])\\n        if area2 < 0:\\n            return -1 #clockwise\\n        if area2 >0 :\\n            return 1 #counter clock wise\\n        return 0 #linear\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        return self.largestTriangeAreaInConvexHull(self.convex_hull(points))\\n        \\n        \\n        \\n        \\n    def largestTriangeAreaInConvexHull(self, points):\\n        \\n        max_area = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    new_area = abs(0.5 * (points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1]\\n                   - points[i][0] * points[k][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1]))\\n                    max_area= max(max_area, new_area)\\n        return max_area\\n    \\n    \\n    def convex_hull(self, points):\\n        hull = []\\n        points = sorted(points,key=lambda l:l[1])\\n        ref_point= points[0]\\n        angle_points = []\\n        for p in points[1:]:\\n            angle = self.angle(ref_point, p)\\n            if angle < 0:\\n                angle = math.pi*2.0 + angle\\n            angle_points.append( [angle, p])\\n        \\n        \\n        angle_points.sort()\\n        hull.append(ref_point)\\n        hull.append(angle_points[0][1])\\n\\n        for angle_point in angle_points[1:]:\\n            top = hull.pop()\\n            while len(hull) > 0 and self.ccw(hull[-1], top, angle_point[1]) < 0: #it is not <= because we want to keep all points in the convex hull, even if the are in a line\\n                top = hull.pop()\\n                \\n            hull.append(top)\\n            hull.append(angle_point[1])\\n\\n        return hull\\n    \\n    def angle(self, reference, point):\\n        v1_x = point[0]-reference[0]\\n        v1_y = point[1] - reference[1]\\n        return math.atan2(v1_y, v1_x)\\n        \\n    def ccw(self, a, b, c):\\n        area2 = (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])\\n        if area2 < 0:\\n            return -1 #clockwise\\n        if area2 >0 :\\n            return 1 #counter clock wise\\n        return 0 #linear\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605382,
                "title": "javascript-non-bruteforce-solution-dobkin-snyder-jarvis-march",
                "content": "**Complexity**\\n- **Space**\\n  - Jarvis March (Gift Wrapping Algorithm)\\n    - In all cases, the space complexity is `O(H)` where `H` is the size of the hull.\\n    - worst/average case: `H=N -> O(N)`; all the points are on the hull.\\n    - best case: `H=3 -> O(3) == O(1)`; the hull is a triangle.\\n\\n  - Dobkin & Snyder, Largest Triangle\\n    - worst/best/average case: `O(1)`; we allocate a fixed amount of space that doesn\\'t change relative to the size of the input.\\n\\n  - Combined\\n    - worst/average case: `O(JARVIS + DOBKIN_SNYDER) == O(N + 1) == O(N)`.\\n    - best case: `O(JARVIS + DOBKIN_SNYDER) == O(1 + 1) == O(1)`.\\n\\n- **Time**\\n  - Jarvis March (Gift Wrapping Algorithm)\\n    - In all cases, the time complexity is `O(H * N)` where `H` is the number of points on the hull.\\n    - worst/average case: `H=N -> O(N^2)`; all the points are on the hull.\\n    - best case: `H=3 -> O(3N) == O(N)`; the hull is a triangle.\\n\\n  - Dobkin & Snyder (Gift Wrapping Algorithm)\\n    - worst/average case: `O(N)`; `a`, `b`, and `c` each visit `N-2` points.\\n    - best case: `O(1)`; the largest triangle is formed by the first three points of the hull.\\n\\n  - Combined\\n    - worst/average case: `O(JARVIS + DOBKIN_SNYDER) == O(N^2 + N) == O(N^2)`.\\n    - best case: `O(JARVIS + DOBKIN_SNYDER) == O(N + 1) == O(N)`.\\n\\n```\\n// Heron\\'s Formula for the area of an arbitrary triangle\\n// https://en.wikipedia.org/wiki/Heron%27s_formula\\nlet areaOfTriangle = function(p1, p2, p3) {\\n  const a = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);\\n  const b = Math.sqrt((p3.x - p1.x)**2 + (p3.y - p1.y)**2);\\n  const c = Math.sqrt((p3.x - p2.x)**2 + (p3.y - p2.y)**2);\\n  \\n  // The \\'semi-perimeter\\'; ie. half the perimeter.\\n  const s = (a + b + c) / 2;\\n\\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c));\\n}\\n\\n// Gift-Wrapping Algorithm (Jarvis March) for computing the hull of a set of points.\\n// https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\\nlet computeHull = function(p) {\\n  const h = [];\\n  \\n  let leftMostPoint = p.reduce((acc, cur) => acc.x < cur.x ? acc : cur);\\n  \\n  let a = leftMostPoint;\\n  do {\\n    h.push(a);\\n    \\n    // The idea is to get any point other than `a`.\\n    let c = p[(p.indexOf(a) + 1) % p.length];\\n    for(const b of p) {\\n      if(b === a || b === c) continue;\\n      \\n      // Probably the least-intuitive part of this whole algorithm. Check the wiki article for a visual illustration.\\n      if(c.turnsRightRelativeTo(a, b) || (c.collinearWith(a, b) && b.lengthFrom(a) > c.lengthFrom(a))) {\\n        c = b;\\n      }\\n    }\\n    \\n    a = c;\\n  } while(a !== leftMostPoint);\\n  \\n  return h;\\n}\\n\\nlet crossProduct = function(p1, p2) {\\n  return p1.x * p2.y - p2.x * p1.y;\\n}\\n\\nlet Point = function([x, y]){\\n  this.x = x;\\n  this.y = y;\\n}\\n\\n// Assuming a line of three points, with p1 -> p2 -> p3, does p3 make a right turn relative to p1?\\nPoint.prototype.turnsRightRelativeTo = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is less than 0, `a` is counter-clockwise to `b`. When `a` is counter-clockwise to `b` that means this line makes a right turn.\\n  return crossProduct(a, b) < 0;\\n}\\n\\nPoint.prototype.collinearWith = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is equal to 0, `a` is collinear (on the same line as) `b`.\\n  return crossProduct(a, b) === 0;\\n}\\n\\nPoint.prototype.lengthFrom = function(p) {\\n  return Math.sqrt((this.x - p.x)**2 + (this.y - p.y)**2);\\n}\\n\\nlet toPoint = ([x, y]) => new Point([x, y]);\\n\\nlet largestTriangleArea = p => {\\n  // Convert the data to `Point` objects and compute the hull.\\n  const h = computeHull(p.map(toPoint));\\n  const area = (a, b, c) => areaOfTriangle(h[a], h[b], h[c]);\\n\\n  // Dobkin & Snyder\\'s largest-triangle algorithm.\\n  // https://arxiv.org/pdf/1705.11035.pdf (Algorithm 1, Page 4).\\n  let a = 0;\\n  let b = 1;\\n  let c = 2;\\n  let max = area(a, b, c);\\n\\n  for(; a < h.length; a++) {\\n    let cur = area(a, b, c);\\n    let cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n    let bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    while((cNext && cNext >= cur) || (bNext && bNext >= cur)) {\\n      if((cNext && cNext >= cur)) {\\n        c++;\\n      } else if((bNext && bNext >= cur)) {\\n        b++;\\n      }\\n      \\n      cur = area(a, b, c);\\n      cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n      bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    }\\n    \\n    max = Math.max(max, area(a, b, c));\\n  }\\n\\n  return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Heron\\'s Formula for the area of an arbitrary triangle\\n// https://en.wikipedia.org/wiki/Heron%27s_formula\\nlet areaOfTriangle = function(p1, p2, p3) {\\n  const a = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);\\n  const b = Math.sqrt((p3.x - p1.x)**2 + (p3.y - p1.y)**2);\\n  const c = Math.sqrt((p3.x - p2.x)**2 + (p3.y - p2.y)**2);\\n  \\n  // The \\'semi-perimeter\\'; ie. half the perimeter.\\n  const s = (a + b + c) / 2;\\n\\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c));\\n}\\n\\n// Gift-Wrapping Algorithm (Jarvis March) for computing the hull of a set of points.\\n// https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\\nlet computeHull = function(p) {\\n  const h = [];\\n  \\n  let leftMostPoint = p.reduce((acc, cur) => acc.x < cur.x ? acc : cur);\\n  \\n  let a = leftMostPoint;\\n  do {\\n    h.push(a);\\n    \\n    // The idea is to get any point other than `a`.\\n    let c = p[(p.indexOf(a) + 1) % p.length];\\n    for(const b of p) {\\n      if(b === a || b === c) continue;\\n      \\n      // Probably the least-intuitive part of this whole algorithm. Check the wiki article for a visual illustration.\\n      if(c.turnsRightRelativeTo(a, b) || (c.collinearWith(a, b) && b.lengthFrom(a) > c.lengthFrom(a))) {\\n        c = b;\\n      }\\n    }\\n    \\n    a = c;\\n  } while(a !== leftMostPoint);\\n  \\n  return h;\\n}\\n\\nlet crossProduct = function(p1, p2) {\\n  return p1.x * p2.y - p2.x * p1.y;\\n}\\n\\nlet Point = function([x, y]){\\n  this.x = x;\\n  this.y = y;\\n}\\n\\n// Assuming a line of three points, with p1 -> p2 -> p3, does p3 make a right turn relative to p1?\\nPoint.prototype.turnsRightRelativeTo = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is less than 0, `a` is counter-clockwise to `b`. When `a` is counter-clockwise to `b` that means this line makes a right turn.\\n  return crossProduct(a, b) < 0;\\n}\\n\\nPoint.prototype.collinearWith = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is equal to 0, `a` is collinear (on the same line as) `b`.\\n  return crossProduct(a, b) === 0;\\n}\\n\\nPoint.prototype.lengthFrom = function(p) {\\n  return Math.sqrt((this.x - p.x)**2 + (this.y - p.y)**2);\\n}\\n\\nlet toPoint = ([x, y]) => new Point([x, y]);\\n\\nlet largestTriangleArea = p => {\\n  // Convert the data to `Point` objects and compute the hull.\\n  const h = computeHull(p.map(toPoint));\\n  const area = (a, b, c) => areaOfTriangle(h[a], h[b], h[c]);\\n\\n  // Dobkin & Snyder\\'s largest-triangle algorithm.\\n  // https://arxiv.org/pdf/1705.11035.pdf (Algorithm 1, Page 4).\\n  let a = 0;\\n  let b = 1;\\n  let c = 2;\\n  let max = area(a, b, c);\\n\\n  for(; a < h.length; a++) {\\n    let cur = area(a, b, c);\\n    let cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n    let bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    while((cNext && cNext >= cur) || (bNext && bNext >= cur)) {\\n      if((cNext && cNext >= cur)) {\\n        c++;\\n      } else if((bNext && bNext >= cur)) {\\n        b++;\\n      }\\n      \\n      cur = area(a, b, c);\\n      cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n      bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    }\\n    \\n    max = Math.max(max, area(a, b, c));\\n  }\\n\\n  return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158780,
                "title": "c-812-largest-triangle-area",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans = 0; \\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i+1; j < points.size(); ++j) {\\n                for (int k = j+1; k < points.size(); ++k ){\\n                    double a = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)), \\n                    b = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2)), \\n                    c = sqrt(pow(points[k][0] - points[i][0], 2) + pow(points[k][1] - points[i][1], 2)), \\n                    s = (a + b + c)/2; \\n                    ans = max(ans, sqrt(s*(s-a)*(s-b)*(s-c)));\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans = 0; \\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i+1; j < points.size(); ++j) {\\n                for (int k = j+1; k < points.size(); ++k ){\\n                    double a = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)), \\n                    b = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2)), \\n                    c = sqrt(pow(points[k][0] - points[i][0], 2) + pow(points[k][1] - points[i][1], 2)), \\n                    s = (a + b + c)/2; \\n                    ans = max(ans, sqrt(s*(s-a)*(s-b)*(s-c)));\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700009,
                "title": "java-brute-force-using-function-mathematical-formula",
                "content": "### **Please Upvote** :D\\nArea of a triangle **```ABC```** with 3 given points **```A(x1, y1), B(x2, y2),```** and **```C(x3, y3)```** is:\\n**```(\\u0394ABC) = (1/2)|x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|```**\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```ABC```\n```A(x1, y1), B(x2, y2),```\n```C(x3, y3)```\n```(\\u0394ABC) = (1/2)|x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|```\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650043,
                "title": "python-solution-99-faster",
                "content": "Using the coordinate geometry area of triangle formula:\\nhttps://www.brainkart.com/article/Area-of-a-Triangle_39390/\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        area = 0\\n        \\n        for i in range(len(points)-2):\\n            x1,y1 = points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2 = points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3 = points[k]\\n                    curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if (curr_area > area):\\n                        area = curr_area\\n            \\n        return area\\n\\nUpvote if you liked the solution!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Using the coordinate geometry area of triangle formula:\\nhttps://www.brainkart.com/article/Area-of-a-Triangle_39390/\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        area = 0\\n        \\n        for i in range(len(points)-2):\\n            x1,y1 = points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2 = points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3 = points[k]\\n                    curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if (curr_area > area):\\n                        area = curr_area\\n            \\n        return area\\n\\nUpvote if you liked the solution!",
                "codeTag": "Java"
            },
            {
                "id": 1257766,
                "title": "faster-than-98-00-of-python3",
                "content": "```\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        def triangle_area(p1,p2,p3):\\n            area = abs(((p1[0] -p2[0])*(p1[1] -p3[1])) - ((p1[0] - p3[0])*(p1[1] - p2[1]))) *.5\\n            return area\\n        max_area =0\\n        for i, j, k in combinations(points,3):\\n            if max_area < triangle_area(i,j,k):\\n                max_area = triangle_area(i,j,k)\\n        return max_area\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        def triangle_area(p1,p2,p3):\\n            area = abs(((p1[0] -p2[0])*(p1[1] -p3[1])) - ((p1[0] - p3[0])*(p1[1] - p2[1]))) *.5\\n            return area\\n        max_area =0\\n        for i, j, k in combinations(points,3):\\n            if max_area < triangle_area(i,j,k):\\n                max_area = triangle_area(i,j,k)\\n        return max_area\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1007970,
                "title": "easy-clear-solution-python",
                "content": "```\\nclass Solution:\\n    \\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        res=0\\n        n=len(p)\\n        r,l=0,0\\n        for i in range (1,n-1):\\n            for r in range(0,i):\\n                for l in range(i+1,n):\\n                    newArea=(p[i][0]*p[r][1] + p[r][0]*p[l][1] +p[l][0]*p[i][1] - p[i][0]*p[l][1] - p[r][0]*p[i][1] - p[l][0]*p[r][1] )/2\\n                    newArea=abs(newArea)\\n                    print(newArea)\\n                    if newArea>res:\\n                        res=newArea\\n        return res           \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        res=0\\n        n=len(p)\\n        r,l=0,0\\n        for i in range (1,n-1):\\n            for r in range(0,i):\\n                for l in range(i+1,n):\\n                    newArea=(p[i][0]*p[r][1] + p[r][0]*p[l][1] +p[l][0]*p[i][1] - p[i][0]*p[l][1] - p[r][0]*p[i][1] - p[l][0]*p[r][1] )/2\\n                    newArea=abs(newArea)\\n                    print(newArea)\\n                    if newArea>res:\\n                        res=newArea\\n        return res           \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979217,
                "title": "johnoyegbite-simple-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def area_with_3points(self, three_points: List[List[int]]) -> float:\\n        \"\"\"\\n        If you care about the proof which is trivial, see link below.\\n        Link: https://mathinstructor.net/2012/08/how-to-find-area-of-triangle-given-three-vertices/\\n        y-axis |\\n               |           (x1, y1)\\n               |           /       \\\\\\n               |          /         \\\\\\n               |         /           \\\\\\n               |   (x2, y2)___________(x3, y3)\\n               |\\n               |__________________________________> x-axis\\n        \"\"\"\\n        x1, y1 = three_points[0]\\n        x2, y2 = three_points[1]\\n        x3, y3 = three_points[2]\\n        return abs((1/2) * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n    \\n        # How to remember this formular? \\n        # Pick your coordinate starting from x1 and move anticlockwise.\\n        # Example Pick -> x1 with y2 before y3 => x1 * (y2 - y3)\\n        #              -> x2 with y3 before y1 => x2 * (y3 - y1)\\n        #              -> x3 with y1 before y2 => x3 * (y1 - y2)\\n        # REMEMBER!!! (Anticlockwise movement)\\n        \\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest_area = 0\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    three_points = [points[i], points[j], points[k]]\\n                    curr_area = self.area_with_3points(three_points)\\n                    largest_area = max(largest_area, curr_area)\\n        return largest_area\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def area_with_3points(self, three_points: List[List[int]]) -> float:\\n        \"\"\"\\n        If you care about the proof which is trivial, see link below.\\n        Link: https://mathinstructor.net/2012/08/how-to-find-area-of-triangle-given-three-vertices/\\n        y-axis |\\n               |           (x1, y1)\\n               |           /       \\\\\\n               |          /         \\\\\\n               |         /           \\\\\\n               |   (x2, y2)___________(x3, y3)\\n               |\\n               |__________________________________> x-axis\\n        \"\"\"\\n        x1, y1 = three_points[0]\\n        x2, y2 = three_points[1]\\n        x3, y3 = three_points[2]\\n        return abs((1/2) * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n    \\n        # How to remember this formular? \\n        # Pick your coordinate starting from x1 and move anticlockwise.\\n        # Example Pick -> x1 with y2 before y3 => x1 * (y2 - y3)\\n        #              -> x2 with y3 before y1 => x2 * (y3 - y1)\\n        #              -> x3 with y1 before y2 => x3 * (y1 - y2)\\n        # REMEMBER!!! (Anticlockwise movement)\\n        \\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest_area = 0\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    three_points = [points[i], points[j], points[k]]\\n                    curr_area = self.area_with_3points(three_points)\\n                    largest_area = max(largest_area, curr_area)\\n        return largest_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494444,
                "title": "javascript-solution",
                "content": "```\\nvar largestTriangleArea = function(points) {\\n    const n = points.length;\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            for (k = j + 1; k < n; k++) {\\n                const area = calcArea(points[i], points[j], points[k]);\\n                maxArea = Math.max(maxArea, area);\\n            }\\n        }\\n    }\\n\\n    return maxArea;\\n};\\n\\n\\nfunction calcArea(coordA, coordB, coordC){\\n    const [xCoordA, yCoordA] = coordA;\\n    const [xCoordB, yCoordB] = coordB;\\n    const [xCoordC, yCoordC] = coordC;\\n    \\n    const sideA = xCoordA * (yCoordB - yCoordC);\\n    const sideB = xCoordB * (yCoordC - yCoordA);\\n    const sideC = xCoordC * (yCoordA - yCoordB);\\n    \\n    return Math.abs((sideA + sideB + sideC) / 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTriangleArea = function(points) {\\n    const n = points.length;\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            for (k = j + 1; k < n; k++) {\\n                const area = calcArea(points[i], points[j], points[k]);\\n                maxArea = Math.max(maxArea, area);\\n            }\\n        }\\n    }\\n\\n    return maxArea;\\n};\\n\\n\\nfunction calcArea(coordA, coordB, coordC){\\n    const [xCoordA, yCoordA] = coordA;\\n    const [xCoordB, yCoordB] = coordB;\\n    const [xCoordC, yCoordC] = coordC;\\n    \\n    const sideA = xCoordA * (yCoordB - yCoordC);\\n    const sideB = xCoordB * (yCoordC - yCoordA);\\n    const sideC = xCoordC * (yCoordA - yCoordB);\\n    \\n    return Math.abs((sideA + sideB + sideC) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238048,
                "title": "c-heron-s-formula",
                "content": "```\\ndouble getDis(int* pointA, int* pointB)\\n{\\n    return(sqrt(pow(pointA[0] - pointB[0], 2) + pow(pointA[1] - pointB[1], 2)));\\n}\\n\\ndouble getArea(int* pointA, int* pointB, int* pointC)\\n{\\n    double a, b, c, s;\\n    a = getDis(pointA, pointB);\\n    b = getDis(pointB, pointC);\\n    c = getDis(pointA, pointC);\\n    s = (a+b+c)/2;\\n    \\n    return(sqrt(s*(s-a)*(s-b)*(s-c)));\\n}\\n\\ndouble largestTriangleArea(int** points, int pointsRowSize, int *pointsColSizes) {\\n    double area, ans = 0;\\n    for(int i = 0; i < pointsRowSize - 2; i++)\\n    {\\n        for(int j = i+1; j < pointsRowSize -1; j++)\\n        {\\n            for(int k = j+1; k < pointsRowSize; k++)\\n            {\\n                area = getArea(points[i], points[j], points[k]);\\n                //printf(\"%f\\\\n\", area);\\n                if(area > ans) ans = area;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble getDis(int* pointA, int* pointB)\\n{\\n    return(sqrt(pow(pointA[0] - pointB[0], 2) + pow(pointA[1] - pointB[1], 2)));\\n}\\n\\ndouble getArea(int* pointA, int* pointB, int* pointC)\\n{\\n    double a, b, c, s;\\n    a = getDis(pointA, pointB);\\n    b = getDis(pointB, pointC);\\n    c = getDis(pointA, pointC);\\n    s = (a+b+c)/2;\\n    \\n    return(sqrt(s*(s-a)*(s-b)*(s-c)));\\n}\\n\\ndouble largestTriangleArea(int** points, int pointsRowSize, int *pointsColSizes) {\\n    double area, ans = 0;\\n    for(int i = 0; i < pointsRowSize - 2; i++)\\n    {\\n        for(int j = i+1; j < pointsRowSize -1; j++)\\n        {\\n            for(int k = j+1; k < pointsRowSize; k++)\\n            {\\n                area = getArea(points[i], points[j], points[k]);\\n                //printf(\"%f\\\\n\", area);\\n                if(area > ans) ans = area;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122737,
                "title": "python-simple-brute-force-solution",
                "content": "```\\ndef largestTriangleArea(self, points):\\n        N = len(points)\\n        ma = 0\\n        def calArea(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        for i in range(N-2):\\n            for j in range(i+1, N-1):\\n                for k in range(j+1, N):\\n                    ma = max(ma, calArea(points[i][0],points[i][1],points[j][0],points[j][1],points[k][0],points[k][1]))\\n        return ma\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\ndef largestTriangleArea(self, points):\\n        N = len(points)\\n        ma = 0\\n        def calArea(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        for i in range(N-2):\\n            for j in range(i+1, N-1):\\n                for k in range(j+1, N):\\n                    ma = max(ma, calArea(points[i][0],points[i][1],points[j][0],points[j][1],points[k][0],points[k][1]))\\n        return ma\\n\\t\\t\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 122721,
                "title": "short-straight-forward-c-solution",
                "content": "Math basics reference https://en.wikipedia.org/wiki/Triangle#Using_coordinates\\n```\\ndouble largestTriangleArea(vector<vector<int>>& points) {\\n    double res = 0;\\n    for (auto &i : points)\\n    for (auto &j : points)\\n    for (auto &k : points)\\n        res = max(res, fabs(0.5 * (i[0] * j[1] + j[0] * k[1] + k[0] * i[1]\\n                   - i[0] * k[1] - j[0] * i[1] - k[0] * j[1])));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestTriangleArea(vector<vector<int>>& points) {\\n    double res = 0;\\n    for (auto &i : points)\\n    for (auto &j : points)\\n    for (auto &k : points)\\n        res = max(res, fabs(0.5 * (i[0] * j[1] + j[0] * k[1] + k[0] * i[1]\\n                   - i[0] * k[1] - j[0] * i[1] - k[0] * j[1])));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692633,
                "title": "math-c-faster-easy-to-understand",
                "content": "* ***Apply Maths Of Triangle***\\n\\n* ***Time Complexity :- O(N * N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584913,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2353530,
                "title": "java-simple-math",
                "content": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    ans = Math.max(ans,0.5*Math.abs(points[i][0]*(points[j][1] - points[k][1]) + points[j][0]*( points[k][1] - points[i][1]) + points[k][0]*(points[i][1] - points[j][1])));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    ans = Math.max(ans,0.5*Math.abs(points[i][0]*(points[j][1] - points[k][1]) + points[j][0]*( points[k][1] - points[i][1]) + points[k][0]*(points[i][1] - points[j][1])));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2347730,
                "title": "o-n-3-80-t-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n    public double largestTriangleArea(int[][] p) {\\n        int l = p.length;\\n        double max = 0;\\n        for (int i = 0; i < l - 2; i++) {\\n            for (int j = i + 1; j < l - 1; j++) {\\n                for (int k = j + 1; k < l; k++) {\\n                    max = Math.max(max, 0.5 * Math.abs(\\n                                    p[i][0] * (p[j][1] - p[k][1]) +\\n                                    p[j][0] * (p[k][1] - p[i][1]) +\\n                                    p[k][0] * (p[i][1] - p[j][1])\\n                    ));\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965827,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n    int n = points.length;\\n    double max =0;\\n    \\n    for(int i =0; i<n; i++)\\n        for(int j =i+1; j<n; j++)\\n            for(int k =j+1; k<n; k++)\\n            {\\n                double area =0;\\n                int[] a=points[i];\\n                int[] b=points[j];\\n                int[] c=points[k];\\n                area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                if(area>max)\\n                    max=area;\\n            }\\n    return max;\\n\\t}\\n\\n    public double area(int[] a, int[] b)\\n\\t{\\n    int l = b[0]-a[0];\\n    double h = (a[1]+b[1]+200)/2.0;\\n    return l*h;\\n\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n    int n = points.length;\\n    double max =0;\\n    \\n    for(int i =0; i<n; i++)\\n        for(int j =i+1; j<n; j++)\\n            for(int k =j+1; k<n; k++)\\n            {\\n                double area =0;\\n                int[] a=points[i];\\n                int[] b=points[j];\\n                int[] c=points[k];\\n                area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                if(area>max)\\n                    max=area;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1757043,
                "title": "heron-s-formula-brute-force",
                "content": "So acc to class 9 maths we can calculate area of triangle as follows:\\ns=a+b+c/2\\narea=root(s*(s-a)*(s-b)*(s-c))\\nhere a,b,c are the lengths of different sides\\n\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    double length(vector<int>&a,vector<int>&b)\\n    {\\n        return pow((b[1]-a[1])*(b[1]-a[1])+(b[0]-a[0])*(b[0]-a[0]),0.5);\\n    }\\n    double area(vector<int>&a,vector<int>&b,vector<int>&c){\\n\\n        double x=length(a,b);\\n        double y=length(b,c);\\n        double z=length(a,c);\\n        \\n        double s=(double)(x+y+z)/(double)2;\\n        return pow(s*(s-x)*(s-y)*(s-z),0.5);\\n        \\n        \\n    \\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n     \\n        double maxi=0;\\n        \\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double m=area(points[i],points[j],points[k]);\\n                    if(maxi<m)\\n                        maxi=m;\\n                }\\n            }\\n                \\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    double length(vector<int>&a,vector<int>&b)\\n    {\\n        return pow((b[1]-a[1])*(b[1]-a[1])+(b[0]-a[0])*(b[0]-a[0]),0.5);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1648159,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // The following function calculates the area of the triangle having three vertices as f,s, and t\\n    double area(vector<int>&f,vector<int>&s,vector<int>&t) {\\n        double p=(double)(f[0]*s[1]+s[0]*t[1]+t[0]*f[1]);\\n        double d=(double)(f[1]*s[0]+s[1]*t[0]+t[1]*f[0]);\\n        return 0.5*abs(p-d);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        // Generate all possible combinations of 3 points and calculate the area and take their maximum\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) {\\n                    ans=max(ans,area(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // The following function calculates the area of the triangle having three vertices as f,s, and t\\n    double area(vector<int>&f,vector<int>&s,vector<int>&t) {\\n        double p=(double)(f[0]*s[1]+s[0]*t[1]+t[0]*f[1]);\\n        double d=(double)(f[1]*s[0]+s[1]*t[0]+t[1]*f[0]);\\n        return 0.5*abs(p-d);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        // Generate all possible combinations of 3 points and calculate the area and take their maximum\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) {\\n                    ans=max(ans,area(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370840,
                "title": "java-solution",
                "content": "class Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max =0;\\n        \\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }\\n        return max;\\n    }\\n    \\n    public double area(int[] a, int[] b)\\n    {\\n        int l = b[0]-a[0];\\n        double h = (a[1]+b[1]+200)/2.0;\\n        return l*h;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max =0;\\n        \\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1352571,
                "title": "easy-python-solution-99-40",
                "content": "Runtime: 88 ms, faster than 99.40% of Python3 online submissions for Largest Triangle Area.\\nMemory Usage: 14.2 MB, less than 84.94% of Python3 online submissions for Largest Triangle Area.\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        area = 0\\n        for i in range(len(points)-2):\\n            x1,y1=points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > area :\\n                        area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    \\n        return area",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 88 ms, faster than 99.40% of Python3 online submissions for Largest Triangle Area.\\nMemory Usage: 14.2 MB, less than 84.94% of Python3 online submissions for Largest Triangle Area.\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        area = 0\\n        for i in range(len(points)-2):\\n            x1,y1=points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > area :\\n                        area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    \\n        return area",
                "codeTag": "Java"
            },
            {
                "id": 949819,
                "title": "ruby-combinations-map-by-the-formula-select-max",
                "content": "##### Leetcode: 812. Largest Triangle Area.\\n\\nGet all combination of tree elements of the input array, calculate an area of an every triangle by the formula, select maximum value. https://www.mathopenref.com/coordtrianglearea.html url that stores the formula.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 812. Largest Triangle Area.\\n# https://leetcode.com/problems/largest-triangle-area/\\n# Runtime: 136 ms, faster than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# Memory Usage: 210.5 MB, less than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef largest_triangle_area(points)\\n   points.combination(3)\\n    .map{|((ax,ay),(bx,by),(cx,cy))| ((ax*(by-cy)+bx*(cy-ay)+cx*(ay-by)).fdiv(2)).abs}.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 812. Largest Triangle Area.\\n# https://leetcode.com/problems/largest-triangle-area/\\n# Runtime: 136 ms, faster than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# Memory Usage: 210.5 MB, less than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef largest_triangle_area(points)\\n   points.combination(3)\\n    .map{|((ax,ay),(bx,by),(cx,cy))| ((ax*(by-cy)+bx*(cy-ay)+cx*(ay-by)).fdiv(2)).abs}.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550125,
                "title": "o-n-3-best-solution",
                "content": "## area of triangle = 1/2|x1(y2-y3) - x2(y1-y3) + x3(y1-y2)|\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans=0;\\n        for(int i=0;i<p.size()-2;i++){\\n            for(int j=i+1;j<p.size()-1;j++){\\n                for(int k=j+1;k<p.size();k++){\\n        int x1=p[i][0];\\n        int x2=p[j][0];\\n        int x3=p[k][0];\\n        int y1=p[i][1];\\n        int y2=p[j][1];\\n        int y3=p[k][1];\\n    ans = max(ans,0.5*(abs(x1*(y2-y3) - x2*(y1-y3) + x3*(y1-y2)))) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans=0;\\n        for(int i=0;i<p.size()-2;i++){\\n            for(int j=i+1;j<p.size()-1;j++){\\n                for(int k=j+1;k<p.size();k++){\\n        int x1=p[i][0];\\n        int x2=p[j][0];\\n        int x3=p[k][0];\\n        int y1=p[i][1];\\n        int y2=p[j][1];\\n        int y3=p[k][1];\\n    ans = max(ans,0.5*(abs(x1*(y2-y3) - x2*(y1-y3) + x3*(y1-y2)))) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357755,
                "title": "python-brute-force-solution-simple-math-proof",
                "content": "![image](https://assets.leetcode.com/users/magi003769/image_1565699964.png)\\n\\n1. Set our 3 points are respectively: `(x1, y1)`, `(x2,y2)` and `(x3,y3)`. The method is to calculate distance between one point and the line determined by the other two. Here we use `(x3,y3)` to form the (x0,y0) in formula and the other two points to determine parameter A, B and C in line equation: Ax + By + C = 0\\n![image](https://assets.leetcode.com/users/magi003769/image_1565698434.png)\\n\\n2. Using formula ![image](https://assets.leetcode.com/users/magi003769/image_1565699047.png), we express A, B and C with `(x1, y1)` and `(x2,y2)`: `A = (y2 - y1)`, `B = (x1 - x2)` and `C = x2y1 - x1y2`.\\n![image](https://assets.leetcode.com/users/magi003769/image_1565699860.png)\\n\\n3. Set the distance described above as `h` and the distance between `(x1, y1)` and `(x2,y2)` as `d`. The area `S` of triangle  can be obtained as `1/2 * h * d`. Fortunately, `d^2 = A^2 + B^2` which can eliminate the denominator in distance formula.\\n\\n\\n4. Finally, we obtain the area as `S = 1/2 * |Ax3 + By3 + C|`. If we unfold this expression, it is exactly what we have in code `0.5 * abs(i[0]*k[1] + j[0]*i[1] + k[0]*j[1] - i[0]*j[1] - j[0]*k[1] - k[0]*i[1])`.\\n\\n```python\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        max_s = 0\\n        for i, j, k in itertools.combinations(points, 3):\\n            max_s = max(max_s, 0.5 * abs(i[0]*k[1] + j[0]*i[1] + k[0]*j[1] - i[0]*j[1] - j[0]*k[1] - k[0]*i[1]))\\n        return max_s\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        max_s = 0\\n        for i, j, k in itertools.combinations(points, 3):\\n            max_s = max(max_s, 0.5 * abs(i[0]*k[1] + j[0]*i[1] + k[0]*j[1] - i[0]*j[1] - j[0]*k[1] - k[0]*i[1]))\\n        return max_s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233989,
                "title": "javascript-brute-force",
                "content": "```js\\nvar largestTriangleArea = function(points) {\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = 1; j < points.length; j++) {\\n            for (let k = 2; k < points.length; k++) {\\n                if (i !== j && i !== k && j !== k) {\\n                maxArea = Math.max(area(points[i], points[j], points[k]), maxArea);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return maxArea;\\n};\\n\\nvar area = function([x1, y1], [x2, y2], [x3, y3]) {\\n    return Math.abs(((x2 - x1)*(y3 - y1)) - ((x3 - x1)*(y2 - y1))) / 2;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar largestTriangleArea = function(points) {\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = 1; j < points.length; j++) {\\n            for (let k = 2; k < points.length; k++) {\\n                if (i !== j && i !== k && j !== k) {\\n                maxArea = Math.max(area(points[i], points[j], points[k]), maxArea);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return maxArea;\\n};\\n\\nvar area = function([x1, y1], [x2, y2], [x3, y3]) {\\n    return Math.abs(((x2 - x1)*(y3 - y1)) - ((x3 - x1)*(y2 - y1))) / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032908,
                "title": "best-java-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static double helper(int arr1[], int arr2[], int arr3[]){\\n        double x1 = (double)arr1[0];\\n        double y1 = (double)arr1[1];\\n\\n        double x2 = (double)arr2[0];\\n        double y2 = (double)arr2[1];\\n\\n        double x3 = (double)arr3[0];\\n        double y3 = (double)arr3[1];\\n\\n        return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)))/2;\\n    }\\n    public double largestTriangleArea(int[][] arr) {\\n        \\n\\n        double ans = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    ans = Math.max(ans,helper(arr[i],arr[j],arr[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static double helper(int arr1[], int arr2[], int arr3[]){\\n        double x1 = (double)arr1[0];\\n        double y1 = (double)arr1[1];\\n\\n        double x2 = (double)arr2[0];\\n        double y2 = (double)arr2[1];\\n\\n        double x3 = (double)arr3[0];\\n        double y3 = (double)arr3[1];\\n\\n        return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)))/2;\\n    }\\n    public double largestTriangleArea(int[][] arr) {\\n        \\n\\n        double ans = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    ans = Math.max(ans,helper(arr[i],arr[j],arr[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794039,
                "title": "only-one-line-on-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n    \\n        return max(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) for [x1,y1], [x2,y2], [x3,y3] in combinations(points, 3))\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n    \\n        return max(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) for [x1,y1], [x2,y2], [x3,y3] in combinations(points, 3))\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658762,
                "title": "best-case-o-n-log-n-beats-100-spatial-algorithms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider the points as a cluster. Some points lie towards the \"outside\", and most on the \"inside\" of the cluster. One could draw a convex polyhedra by connecting the \"outside\" points such that all the other points like inside the convex polyedra. This polyhedra is called the convex hull. \\nThe key idea is that the largest triangle will be made by 3 of the points that make up the convex hull. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe family of algorithms that- given an array of points, return the set of points that make up the convex hull, are known as \"[Gift Wrapping Algorithms](https://medium.com/@indemfeld/gift-wrapping-algorithms-graham-scan-b24ca814e403)\".\\n\\nI used the algorithm discussed in the article- Graham Scan; Actually I copy pasted most of the code from this Geeks for Geeks [link](https://www.geeksforgeeks.org/convex-hull-using-graham-scan/). \\n\\nThe algorithm outputs the set of points that make up the convex hull in O(NlogN) time. After, we use the brute force to find the largest triangle from among the points that make up the convex hull.\\n\\n# Complexity\\n**Time complexity:** Best case $O($N$log$N$)$. Worst Case: $O($N$^3)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The best case is when the convex hull of the input points is a triangle. In such a case, the graham scan algorithm will output only 3 points and thus the brute force loops only run once. Thus, the time complexity will be $O($N$)+O($N$log$N$)+ O(1)+O(1) = O($N$log$N$)$.\\n- The worst case is when the convex hull is a $n-$dimensional convex polyhedra made up by all of the $n$ input points. In this case the Graham scan does not filter out any points. The complexity will then be $O($N$)+O($N$log$N$)+O($N$)+O($N$^3) = O($N$^3)$.\\n\\nMost case, however, lie in between these extreme- where graham scan will filter out a large percentage of the points and thus performing significantly better. Here time complexity will be $O($N$log$N$) + O($M$^3)$, where N is number of input points and M is number of points that make up the convex hull.  \\n\\n**Space complexity:** $O($M$)$ where M is number of points that make up the convex hull.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nActually one could reduce it to constant space complexity but to clearly separate the convex hull part, I decided against that. \\n\\n# Code\\n```\\nfrom functools import cmp_to_key\\n\\n# A utility function to return square of distance\\n# between p1 and p2\\ndef distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n# To find orientation of ordered triplet (p, q, r).\\n# The function returns following values\\n# 0 --> p, q and r are collinear\\n# 1 --> Clockwise\\n# 2 --> Counterclockwise\\ndef orientation(p, q, r):\\n    val= ((q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]))\\n    if val == 0:\\n        return 0  # collinear\\n    elif val > 0:\\n        return 1  # clock wise\\n    else:\\n        return 2  # counterclock wise\\n\\nclass Solution(object):\\n    # A function used by cmp_to_key function to sort an array of\\n    # points with respect to the first point\\n    def compare(self, p1, p2):\\n        # Find orientation\\n        o = orientation(self.p0, p1, p2)\\n        if o == 0:\\n            if distSq(self.p0, p2) >= distSq(self.p0, p1):\\n                return -1\\n            else:\\n                return 1\\n        elif o == 2:\\n            return -1\\n        else:\\n            return 1\\n\\n    # Returns convex hull of a set of n points.\\n    def convexHull(self, points, n):\\n        # Find the bottommost point\\n        ymin = points[0][1]\\n        minIdx = 0\\n        for i in range(1, n):\\n            y = points[i][1] \\n            # Pick the bottom-most or choose the left\\n            # most point in case of tie\\n            if ((y < ymin) or (ymin == y and points[i][0] < points[minIdx][0])):\\n                ymin = points[i][1]\\n                min = i\\n \\n        # Place the bottom-most point at first position\\n        points[0], points[minIdx] = points[minIdx], points[0]\\n \\n        # Sort n-1 points with respect to the first point.\\n        # A point p1 comes before p2 in sorted output if p2\\n        # has larger polar angle (in counterclockwise\\n        # direction) than p1\\n        self.p0 = points[0]\\n        points = sorted(points, key=cmp_to_key(self.compare))\\n \\n        # If two or more points make same angle with p0,\\n        # Remove all but the one that is farthest from p0\\n        # Remember that, in above sorting, our criteria was\\n        # to keep the farthest point at the end when more than\\n        # one points have same angle.\\n        m = 1  # Initialize size of modified array\\n        for i in range(1, n):\\n            # Keep removing i while angle of i and i+1 is same\\n            # with respect to p0\\n            while ((i<n-1) and (orientation(self.p0,points[i],points[i+1])==0)):\\n                i += 1\\n            points[m] = points[i]\\n            m += 1  # Update size of modified array\\n \\n        # If modified array of points has less than 3 points,\\n        # convex hull is not possible\\n        if m < 3:\\n            return []\\n \\n        # Create an empty stack and push first three points to it.\\n        S = [points[0],points[1],points[2]]\\n \\n        # Process remaining n-3 points\\n        for i in range(3, m):\\n            # Keep removing top while the angle formed by\\n            # points next-to-top, top, and points[i] makes a non-left turn\\n            while (len(S)>1) and (orientation(S[-2],S[-1],points[i])!=2):\\n                S.pop()\\n            S.append(points[i])\\n        return S\\n\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        # Area of triangle between three points: \\n        # ( x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) ) / 2\\n\\n        n = len(points)\\n        S = self.convexHull(points,n)\\n        n = len(S)\\n        if n<3:\\n            return 0\\n            \\n        area = 0\\n        for a in range(n-2):\\n            x1,y1 = S[a]\\n            for b in range(a+1,n-1):\\n                x2,y2 = S[b]\\n                for c in range(b+1,n):\\n                    x3,y3 = S[c]\\n                    areaT = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n                    area = max (area, areaT)\\n        return round(float(area)/2,5)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom functools import cmp_to_key\\n\\n# A utility function to return square of distance\\n# between p1 and p2\\ndef distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n# To find orientation of ordered triplet (p, q, r).\\n# The function returns following values\\n# 0 --> p, q and r are collinear\\n# 1 --> Clockwise\\n# 2 --> Counterclockwise\\ndef orientation(p, q, r):\\n    val= ((q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]))\\n    if val == 0:\\n        return 0  # collinear\\n    elif val > 0:\\n        return 1  # clock wise\\n    else:\\n        return 2  # counterclock wise\\n\\nclass Solution(object):\\n    # A function used by cmp_to_key function to sort an array of\\n    # points with respect to the first point\\n    def compare(self, p1, p2):\\n        # Find orientation\\n        o = orientation(self.p0, p1, p2)\\n        if o == 0:\\n            if distSq(self.p0, p2) >= distSq(self.p0, p1):\\n                return -1\\n            else:\\n                return 1\\n        elif o == 2:\\n            return -1\\n        else:\\n            return 1\\n\\n    # Returns convex hull of a set of n points.\\n    def convexHull(self, points, n):\\n        # Find the bottommost point\\n        ymin = points[0][1]\\n        minIdx = 0\\n        for i in range(1, n):\\n            y = points[i][1] \\n            # Pick the bottom-most or choose the left\\n            # most point in case of tie\\n            if ((y < ymin) or (ymin == y and points[i][0] < points[minIdx][0])):\\n                ymin = points[i][1]\\n                min = i\\n \\n        # Place the bottom-most point at first position\\n        points[0], points[minIdx] = points[minIdx], points[0]\\n \\n        # Sort n-1 points with respect to the first point.\\n        # A point p1 comes before p2 in sorted output if p2\\n        # has larger polar angle (in counterclockwise\\n        # direction) than p1\\n        self.p0 = points[0]\\n        points = sorted(points, key=cmp_to_key(self.compare))\\n \\n        # If two or more points make same angle with p0,\\n        # Remove all but the one that is farthest from p0\\n        # Remember that, in above sorting, our criteria was\\n        # to keep the farthest point at the end when more than\\n        # one points have same angle.\\n        m = 1  # Initialize size of modified array\\n        for i in range(1, n):\\n            # Keep removing i while angle of i and i+1 is same\\n            # with respect to p0\\n            while ((i<n-1) and (orientation(self.p0,points[i],points[i+1])==0)):\\n                i += 1\\n            points[m] = points[i]\\n            m += 1  # Update size of modified array\\n \\n        # If modified array of points has less than 3 points,\\n        # convex hull is not possible\\n        if m < 3:\\n            return []\\n \\n        # Create an empty stack and push first three points to it.\\n        S = [points[0],points[1],points[2]]\\n \\n        # Process remaining n-3 points\\n        for i in range(3, m):\\n            # Keep removing top while the angle formed by\\n            # points next-to-top, top, and points[i] makes a non-left turn\\n            while (len(S)>1) and (orientation(S[-2],S[-1],points[i])!=2):\\n                S.pop()\\n            S.append(points[i])\\n        return S\\n\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        # Area of triangle between three points: \\n        # ( x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) ) / 2\\n\\n        n = len(points)\\n        S = self.convexHull(points,n)\\n        n = len(S)\\n        if n<3:\\n            return 0\\n            \\n        area = 0\\n        for a in range(n-2):\\n            x1,y1 = S[a]\\n            for b in range(a+1,n-1):\\n                x2,y2 = S[b]\\n                for c in range(b+1,n):\\n                    x3,y3 = S[c]\\n                    areaT = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n                    area = max (area, areaT)\\n        return round(float(area)/2,5)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477719,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: list[list[int]]) -> float:\\n        return max(\\n            abs(getVector(a, b, c)) / 2\\n            for a, b, c in combinations(getBoundary(points), 3)\\n        )\\ndef getBoundary(points):\\n    points = [(a, b) for a, b in points]\\n    points.sort(key=lambda x: (x[0], x[1]))\\n\\n    upper = []\\n    lower = []\\n\\n    for point in points:\\n\\n        while len(lower) >= 2 and getVector(lower[-2], lower[-1], point) < 0:\\n            lower.pop()\\n        lower.append(point)\\n\\n        while len(upper) >= 2 and getVector(upper[-2], upper[-1], point) > 0:\\n            upper.pop()\\n        upper.append(point)\\n\\n    return list(set(upper + lower))\\n\\ndef getVector(a, b, c):\\n    return (b[0] - a[0]) * (b[1] - c[1]) - (b[1] - a[1]) * (b[0] - c[0])\\n```\\n\\n```Java []\\nclass Solution {\\n    double maxArea = Integer.MIN_VALUE;\\n    int[] idxList = new int[3];\\n    int n, k;\\n\\n    public double largestTriangleArea(int[][] points) {\\n        if(points == null) return 0;\\n        n = points.length;\\n        k = 3;\\n        dfs(points, 0, 0);\\n        return maxArea;\\n    }\\n    public void dfs(int[][] points, int pre, int idx){\\n        if(idx >= k){\\n            maxArea = Math.max(getArea(points), maxArea);\\n            return;\\n        }\\n        for(int i = pre + 1; i <= n; i ++){\\n            idxList[idx] = i - 1;\\n            dfs(points, i, idx + 1);  \\n        }\\n    }\\n    public double getArea(int[][] points){\\n        return Math.abs(0.5 * (points[idxList[0]][0] * (points[idxList[1]][1] - points[idxList[2]][1]) +\\n                        points[idxList[1]][0] * (points[idxList[2]][1] - points[idxList[0]][1]) +\\n                        points[idxList[2]][0] * (points[idxList[0]][1] - points[idxList[1]][1])));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: list[list[int]]) -> float:\\n        return max(\\n            abs(getVector(a, b, c)) / 2\\n            for a, b, c in combinations(getBoundary(points), 3)\\n        )\\ndef getBoundary(points):\\n    points = [(a, b) for a, b in points]\\n    points.sort(key=lambda x: (x[0], x[1]))\\n\\n    upper = []\\n    lower = []\\n\\n    for point in points:\\n\\n        while len(lower) >= 2 and getVector(lower[-2], lower[-1], point) < 0:\\n            lower.pop()\\n        lower.append(point)\\n\\n        while len(upper) >= 2 and getVector(upper[-2], upper[-1], point) > 0:\\n            upper.pop()\\n        upper.append(point)\\n\\n    return list(set(upper + lower))\\n\\ndef getVector(a, b, c):\\n    return (b[0] - a[0]) * (b[1] - c[1]) - (b[1] - a[1]) * (b[0] - c[0])\\n```\n```Java []\\nclass Solution {\\n    double maxArea = Integer.MIN_VALUE;\\n    int[] idxList = new int[3];\\n    int n, k;\\n\\n    public double largestTriangleArea(int[][] points) {\\n        if(points == null) return 0;\\n        n = points.length;\\n        k = 3;\\n        dfs(points, 0, 0);\\n        return maxArea;\\n    }\\n    public void dfs(int[][] points, int pre, int idx){\\n        if(idx >= k){\\n            maxArea = Math.max(getArea(points), maxArea);\\n            return;\\n        }\\n        for(int i = pre + 1; i <= n; i ++){\\n            idxList[idx] = i - 1;\\n            dfs(points, i, idx + 1);  \\n        }\\n    }\\n    public double getArea(int[][] points){\\n        return Math.abs(0.5 * (points[idxList[0]][0] * (points[idxList[1]][1] - points[idxList[2]][1]) +\\n                        points[idxList[1]][0] * (points[idxList[2]][1] - points[idxList[0]][1]) +\\n                        points[idxList[2]][0] * (points[idxList[0]][1] - points[idxList[1]][1])));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405260,
                "title": "javascript-100-o-n-3-time-o-1-space-brute-force",
                "content": "![image.png](https://assets.leetcode.com/users/images/61c84a94-a4e7-4592-908d-7760aab176d6_1681226967.606129.png)\\n\\n# Approach\\nBrute force solution using the following formula:\\n\\n$$|a[0](b[1]-c[1]) + b[0](c[1]-a[1]) + c[0](a[1]-b[1])| / 2$$\\n\\n```\\nfunction largestTriangleArea(points) {\\n    let result = 0;\\n\\n    for (let i = 0; i in points; i++) {\\n        for (let j = i + 1; j in points; j++) {\\n            for (let k = j + 1; k in points; k++) {\\n                const area = getArea(\\n                    points[i],\\n                    points[j],\\n                    points[k],\\n                );\\n\\n                result = Math.max(result, area);\\n            }\\n        }\\n    }\\n\\n    return result;    \\n};\\n\\nfunction getArea(a, b, c) {\\n    return Math.abs(a[0] * (b[1] - c[1]) +\\n                    b[0] * (c[1] - a[1]) +\\n                    c[0] * (a[1] - b[1])) / 2;\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nfunction largestTriangleArea(points) {\\n    let result = 0;\\n\\n    for (let i = 0; i in points; i++) {\\n        for (let j = i + 1; j in points; j++) {\\n            for (let k = j + 1; k in points; k++) {\\n                const area = getArea(\\n                    points[i],\\n                    points[j],\\n                    points[k],\\n                );\\n\\n                result = Math.max(result, area);\\n            }\\n        }\\n    }\\n\\n    return result;    \\n};\\n\\nfunction getArea(a, b, c) {\\n    return Math.abs(a[0] * (b[1] - c[1]) +\\n                    b[0] * (c[1] - a[1]) +\\n                    c[0] * (a[1] - b[1])) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706764,
                "title": "loop-over-all-points-and-use-determinant",
                "content": "```\\nclass Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * \\n                      abs(+ i[0] * j[1] \\n                          + j[0] * k[1]\\n                          + k[0] * i[1]\\n                          - j[0] * i[1] \\n                          - k[0] * j[1] \\n                          - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * \\n                      abs(+ i[0] * j[1] \\n                          + j[0] * k[1]\\n                          + k[0] * i[1]\\n                          - j[0] * i[1] \\n                          - k[0] * j[1] \\n                          - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580416,
                "title": "c-first-comes-in-mind-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580405,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\n      \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n       for(int i=0;i<points.size();i++)\\n       {\\n           for(int j=i+1;j<points.size();j++)\\n           {\\n               for(int k=j+1;k<points.size();k++)\\n               {\\n                   double x1=points[i][0];\\n                   double y1=points[i][1];\\n                   double x2=points[j][0];\\n                   double y2=points[j][1];\\n                   double x3=points[k][0];\\n                   double y3=points[k][1];\\n                   double area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                   maxi=max(area,maxi);\\n               }\\n           }\\n       }\\n        return maxi;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n      \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n       for(int i=0;i<points.size();i++)\\n       {\\n           for(int j=i+1;j<points.size();j++)\\n           {\\n               for(int k=j+1;k<points.size();k++)\\n               {\\n                   double x1=points[i][0];\\n                   double y1=points[i][1];\\n                   double x2=points[j][0];\\n                   double y2=points[j][1];\\n                   double x3=points[k][0];\\n                   double y3=points[k][1];\\n                   double area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                   maxi=max(area,maxi);\\n               }\\n           }\\n       }\\n        return maxi;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299824,
                "title": "python-3-brute-force-solution-98-50",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxA = 0\\n        for p1, p2, p3 in combinations(points, 3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            A=(1/2) * abs(x1*(y2 - y3) + x2*(y3 - y1)+ x3*(y1 - y2))\\n            if A > maxA: maxA = A\\n        return maxA\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxA = 0\\n        for p1, p2, p3 in combinations(points, 3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            A=(1/2) * abs(x1*(y2 - y3) + x2*(y3 - y1)+ x3*(y1 - y2))\\n            if A > maxA: maxA = A\\n        return maxA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151115,
                "title": "golang-solution-brute-force-using-heron-s-formula",
                "content": "Time: **O(N^3)**\\nSpace: **O(1)**\\n\\n```golang\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\n    // Heron\\'s formula\\n    // triangle\\'s lengths a, b, c\\n    // S = sqrt((a+b+c) * (a+b-c) * (a+c-b) * (b+c-a)) / 4\\n    md := make(map[int]float64)\\n    \\n    var res float64 = 0\\n    for i := 0; i < len(points); i++ {\\n        for j := i + 1; j < len(points); j++ {\\n            mask := (1<<i)|(1<<j)\\n            x := md[mask]\\n            if x == 0 {\\n                x = distance(points[i], points[j])\\n                md[mask] = x\\n            }\\n            for k := j + 1; k < len(points); k++ {\\n                mask = (1<<i)|(1<<k)\\n                y := md[mask]\\n                if y == 0 {\\n                    y = distance(points[i], points[k])\\n                    md[mask] = y\\n                }\\n                mask = (1<<j)|(1<<k)\\n                z := md[mask]\\n                if z == 0 {\\n                    z = distance(points[j], points[k])\\n                    md[mask] = z\\n                }\\n                \\n                if x + y < z || x + z < y || y + z < x {\\n                    continue\\n                }\\n                \\n                if v := (x+y+z)*(x+y-z)*(x+z-y)*(y+z-x); v > res {\\n                    res = v\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(res) / 4.0\\n}\\n\\nfunc distance(p1 []int, p2 []int) float64 {\\n    x := p1[0] - p2[0]\\n    y := p1[1] - p2[1]\\n    return math.Sqrt(float64(x*x + y*y))\\n}\\n```\\n\\nAnother way to caculate triangle area when you only get 3 points\\'s position: https://www.mathopenref.com/coordtrianglearea.html\\n`S = |Ax(By \\u2212 Cy) + Bx(Cy \\u2212 Ay) + Cx(Ay \\u2212 By)| / 2`\\n\\nwhen 3 points on one line, S = 0\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\n    // Heron\\'s formula\\n    // triangle\\'s lengths a, b, c\\n    // S = sqrt((a+b+c) * (a+b-c) * (a+c-b) * (b+c-a)) / 4\\n    md := make(map[int]float64)\\n    \\n    var res float64 = 0\\n    for i := 0; i < len(points); i++ {\\n        for j := i + 1; j < len(points); j++ {\\n            mask := (1<<i)|(1<<j)\\n            x := md[mask]\\n            if x == 0 {\\n                x = distance(points[i], points[j])\\n                md[mask] = x\\n            }\\n            for k := j + 1; k < len(points); k++ {\\n                mask = (1<<i)|(1<<k)\\n                y := md[mask]\\n                if y == 0 {\\n                    y = distance(points[i], points[k])\\n                    md[mask] = y\\n                }\\n                mask = (1<<j)|(1<<k)\\n                z := md[mask]\\n                if z == 0 {\\n                    z = distance(points[j], points[k])\\n                    md[mask] = z\\n                }\\n                \\n                if x + y < z || x + z < y || y + z < x {\\n                    continue\\n                }\\n                \\n                if v := (x+y+z)*(x+y-z)*(x+z-y)*(y+z-x); v > res {\\n                    res = v\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(res) / 4.0\\n}\\n\\nfunc distance(p1 []int, p2 []int) float64 {\\n    x := p1[0] - p2[0]\\n    y := p1[1] - p2[1]\\n    return math.Sqrt(float64(x*x + y*y))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2046105,
                "title": "o-n-2-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        int len = points.size();\\n        vector<vector<double>> chart(len,vector<double>(len,0)); // store the length between two points\\n        for (int i=0;i<len-1;i++)\\n            for (int j=i+1;j<len;j++)\\n                chart[i][j] = sqrt(pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));\\n        for (int i=0;i<len-2;i++)\\n            for (int j=i+1;j<len-1;j++)\\n                for (int k=j+1;k<len;k++)\\n                {\\n                    double p=(chart[i][j] + chart[i][k] + chart[j][k])/2;\\n                    ans = max(ans,sqrt(p*(p-chart[i][j])*(p-chart[i][k])*(p-chart[j][k])));\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        int len = points.size();\\n        vector<vector<double>> chart(len,vector<double>(len,0)); // store the length between two points\\n        for (int i=0;i<len-1;i++)\\n            for (int j=i+1;j<len;j++)\\n                chart[i][j] = sqrt(pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));\\n        for (int i=0;i<len-2;i++)\\n            for (int j=i+1;j<len-1;j++)\\n                for (int k=j+1;k<len;k++)\\n                {\\n                    double p=(chart[i][j] + chart[i][k] + chart[j][k])/2;\\n                    ans = max(ans,sqrt(p*(p-chart[i][j])*(p-chart[i][k])*(p-chart[j][k])));\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038867,
                "title": "java-math",
                "content": "```\\nclass Solution {\\n    /**\\n     * Time Complexity: O(n^3) {@code n} is the length of {@prams points}\\n     * Space Complexity: O(1)\\n     * @topic Largest Triangle Area\\n     * @author ArtistS\\n     * @param points\\n     * @return\\n     */\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double ret = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\\n        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * Time Complexity: O(n^3) {@code n} is the length of {@prams points}\\n     * Space Complexity: O(1)\\n     * @topic Largest Triangle Area\\n     * @author ArtistS\\n     * @param points\\n     * @return\\n     */\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double ret = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\\n        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890947,
                "title": "largest-triangle-area-solution-java",
                "content": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double largestArea = 0;\\n        int length = points.length;\\n        for (int i = 0; i < length; i++) {\\n            int[] point1 = points[i];\\n            for (int j = i + 1; j < length; j++) {\\n                int[] point2 = points[j];\\n                for (int k = j + 1; k < length; k++) {\\n                    int[] point3 = points[k];\\n                    if (sameLine(point1, point2, point3))\\n                        continue;\\n                    double area = getArea(point1, point2, point3);\\n                    largestArea = Math.max(largestArea, area);\\n                }\\n            }\\n        }\\n        return largestArea;\\n    }\\n\\n    public boolean sameLine(int[] point1, int[] point2, int[] point3) {\\n        int delta1X = point2[0] - point1[0], delta1Y = point2[1] - point1[1];\\n        int delta2X = point3[0] - point2[0], delta2Y = point3[1] - point2[1];\\n        return delta1X * delta2Y == delta2X * delta1Y;\\n    }\\n\\n    public double getArea(int[] point1, int[] point2, int[] point3) {\\n        double side1 = getDistance(point1, point2);\\n        double side2 = getDistance(point2, point3);\\n        double side3 = getDistance(point3, point1);\\n        double halfPerimeter = (side1 + side2 + side3) / 2;\\n        double area = Math.sqrt(halfPerimeter * (halfPerimeter - side1) * (halfPerimeter - side2) * (halfPerimeter - side3));\\n        return area;\\n    }\\n\\n    public double getDistance(int[] point1, int[] point2) {\\n        return Math.sqrt(((double) point2[0] - (double) point1[0]) * ((double) point2[0] - (double) point1[0]) + ((double) point2[1] - (double) point1[1]) * ((double) point2[1] - (double) point1[1]));\\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double largestArea = 0;\\n        int length = points.length;\\n        for (int i = 0; i < length; i++) {\\n            int[] point1 = points[i];\\n            for (int j = i + 1; j < length; j++) {\\n                int[] point2 = points[j];\\n                for (int k = j + 1; k < length; k++) {\\n                    int[] point3 = points[k];\\n                    if (sameLine(point1, point2, point3))\\n                        continue;\\n                    double area = getArea(point1, point2, point3);\\n                    largestArea = Math.max(largestArea, area);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1827111,
                "title": "very-easy-code-for-beginner-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double distance(vector<int> &p1, vector<int> &p2){\\n        int d1 = abs(p2[0]-p1[0]), d2 = abs(p2[1]-p1[1]);\\n        d1 *= d1, d2 *= d2;\\n        return sqrt(d1+d2);\\n    }\\n    \\n    double area(double s, double a, double b, double c){\\n        double prod = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(prod);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans = 0.0;\\n        double a=0, b=0, c=0;\\n        int n = p.size();\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                a = distance(p[i], p[j]);\\n                for(int k=j+1; k<n; k++){\\n                    b = distance(p[i], p[k]);\\n                    c = distance(p[j], p[k]);\\n                    double s = (a+b+c)/2.0;\\n                    ans = max(ans, area(s, a, b, c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double distance(vector<int> &p1, vector<int> &p2){\\n        int d1 = abs(p2[0]-p1[0]), d2 = abs(p2[1]-p1[1]);\\n        d1 *= d1, d2 *= d2;\\n        return sqrt(d1+d2);\\n    }\\n    \\n    double area(double s, double a, double b, double c){\\n        double prod = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(prod);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans = 0.0;\\n        double a=0, b=0, c=0;\\n        int n = p.size();\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                a = distance(p[i], p[j]);\\n                for(int k=j+1; k<n; k++){\\n                    b = distance(p[i], p[k]);\\n                    c = distance(p[j], p[k]);\\n                    double s = (a+b+c)/2.0;\\n                    ans = max(ans, area(s, a, b, c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692057,
                "title": "python-concise-solution-using-combinations-multi-unpacking-faster-and-less-memory-than-90",
                "content": "The formula being used for the area here is based on making 3 trapezoids using the x-axis as the base and triangles vertices as the end points.  Split the triangle, to make two trapezoids including its area, then subtract the area of the trapezoid between the triangle and the axis. \\n   The formula has been simplified here to remove terms to cancel out.\\n\\n```python\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        max_area = 0\\n        for [x1, y1], [x2, y2], [x3, y3] in combinations(points, 3):\\n            area = 0.5 * abs(y1 * (x2 - x3) + y2 * (x3 - x1) + y3 * (x1 - x2))\\n            if area > max_area: max_area = area\\n        \\n        return max_area     \\n```\\n\\n![image](https://assets.leetcode.com/users/images/a7b37783-b8be-4acf-81ef-f59293bce02b_1642263009.0722857.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        max_area = 0\\n        for [x1, y1], [x2, y2], [x3, y3] in combinations(points, 3):\\n            area = 0.5 * abs(y1 * (x2 - x3) + y2 * (x3 - x1) + y3 * (x1 - x2))\\n            if area > max_area: max_area = area\\n        \\n        return max_area     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597637,
                "title": "rust-triangular-code-solution",
                "content": "```\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n        let mut s = f64::MIN;\\n        for (i, p1) in points.iter().enumerate() {\\n            for (j, p2) in points[i + 1..].iter().enumerate() {\\n                for p3 in points[j + 1..].iter() {\\n                    if let [x1, y1] = p1[..] {\\n                        if let [x2, y2] = p2[..] {\\n                            if let [x3, y3] = p3[..] {\\n                                s = s.max(\\n                                    0.5 * ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)).abs()\\n                                        as f64,\\n                                );\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n        let mut s = f64::MIN;\\n        for (i, p1) in points.iter().enumerate() {\\n            for (j, p2) in points[i + 1..].iter().enumerate() {\\n                for p3 in points[j + 1..].iter() {\\n                    if let [x1, y1] = p1[..] {\\n                        if let [x2, y2] = p2[..] {\\n                            if let [x3, y3] = p3[..] {\\n                                s = s.max(\\n                                    0.5 * ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)).abs()\\n                                        as f64,\\n                                );\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557937,
                "title": "simple-way-in-python-with-permutation",
                "content": "```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = float(\\'-inf\\')\\n        list_3p = itertools.permutations(points,3)\\n        for p1, p2, p3 in list_3p:\\n            area = max(area, 0.5*abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1])))\\n            \\n        return area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = float(\\'-inf\\')\\n        list_3p = itertools.permutations(points,3)\\n        for p1, p2, p3 in list_3p:\\n            area = max(area, 0.5*abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1])))\\n            \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530214,
                "title": "c-simple-code",
                "content": "class Solution {\\npublic:\\n    \\n    double Area(vector<int> A, vector<int> B, vector<int> C)\\n    {\\n         return (double)abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1]))/2;\\n    }\\n    \\n    \\n    double largestTriangleArea(vector<vector<int>>& points) \\n\\t{\\n        int n = points.size();\\n        double maxarea = INT_MIN;\\n        for(int i=0 ; i<n-2 ; ++i){\\n            for(int j=i ; j<n-1 ; ++j){\\n                for(int k=j ; k<n ; ++k){\\n                    maxarea = max(maxarea, Area(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        \\n        return maxarea;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    double Area(vector<int> A, vector<int> B, vector<int> C)\\n    {\\n         return (double)abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1]))/2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1280268,
                "title": "python-3",
                "content": "from itertools import combinations\\nclass Solution:\\n    \\n\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxArea=0       \\n\\t\\t\\t\\n        def Area(a,b,c):\\n            return 0.5*abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))\\n\\t\\t\\t\\t\\t\\n        return max(map(lambda x: Area(*x),combinations(points,3)))",
                "solutionTags": [],
                "code": "from itertools import combinations\\nclass Solution:\\n    \\n\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxArea=0       \\n\\t\\t\\t\\n        def Area(a,b,c):\\n            return 0.5*abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))\\n\\t\\t\\t\\t\\t\\n        return max(map(lambda x: Area(*x),combinations(points,3)))",
                "codeTag": "Java"
            },
            {
                "id": 1254653,
                "title": "c-4ms",
                "content": "```C++\\nclass Solution {\\npublic:\\n  double largestTriangleArea(std::vector<std::vector<int>>& points) {\\n    double max_area = std::numeric_limits<double>::min();\\n    for (int i = 0; i < points.size(); ++i) {\\n      for (int j = i + 1; j < points.size(); ++j) {\\n        for (int k = j + 1; k < points.size(); ++k) {\\n          double m = areaOfTriangle(points[i], points[j], points[k]);\\n          if (m > max_area) {\\n            max_area = m;\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n\\n  double areaOfTriangle(const std::vector<int> &a, const std::vector<int> &b,\\n                        const std::vector<int> &c) {\\n    return .5 * std::abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) +\\n                         c[0] * (a[1] - b[1]));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n  double largestTriangleArea(std::vector<std::vector<int>>& points) {\\n    double max_area = std::numeric_limits<double>::min();\\n    for (int i = 0; i < points.size(); ++i) {\\n      for (int j = i + 1; j < points.size(); ++j) {\\n        for (int k = j + 1; k < points.size(); ++k) {\\n          double m = areaOfTriangle(points[i], points[j], points[k]);\\n          if (m > max_area) {\\n            max_area = m;\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n\\n  double areaOfTriangle(const std::vector<int> &a, const std::vector<int> &b,\\n                        const std::vector<int> &c) {\\n    return .5 * std::abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) +\\n                         c[0] * (a[1] - b[1]));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254376,
                "title": "java-brute-force-calculation-area-with-explanation",
                "content": "Since the points.length < 50, maybe we can use a O(n^3) solution pass.\\nUsing the vector product formula.\\nthree points: (x1, y1), (x2, y2), (x3, y3), \\n`area = Math.abs((x1 -x2) * (y1 - y3) - (x1 - x3) * (x1 - x2)) / 2`\\nbrute-force can pass.\\n\\n```java\\n// AC: Runtime: 4 ms, faster than 83.33% of Java online submissions for Largest Triangle Area.\\n// Memory Usage: 36.5 MB, less than 87.14% of Java online submissions for Largest Triangle Area.\\n// thought: using the vector product formula: (x1, y1), (x2, y2), (x3, y3), \\n//       area = Math.abs((x1 -x2) * (y1 - y3) - (x1 - x3) * (x1 - x2)) / 2\\n// T:O(n^3), S:O(1)\\n//\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int size = points.length;\\n        double ret = 0;\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size - 1; j++) {\\n                int x = points[i][0] - points[j][0];\\n                int y = points[i][1] - points[j][1];\\n                for (int k = j + 1; k < size; k++) {\\n                    int x1 = points[i][0] - points[k][0];\\n                    int y1 = points[i][1] - points[k][1];\\n                    double area = Math.abs(x * y1 - y * x1) / (2 * 1.000000);\\n                    if (area > ret) {\\n                        ret = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 4 ms, faster than 83.33% of Java online submissions for Largest Triangle Area.\\n// Memory Usage: 36.5 MB, less than 87.14% of Java online submissions for Largest Triangle Area.\\n// thought: using the vector product formula: (x1, y1), (x2, y2), (x3, y3), \\n//       area = Math.abs((x1 -x2) * (y1 - y3) - (x1 - x3) * (x1 - x2)) / 2\\n// T:O(n^3), S:O(1)\\n//\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int size = points.length;\\n        double ret = 0;\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size - 1; j++) {\\n                int x = points[i][0] - points[j][0];\\n                int y = points[i][1] - points[j][1];\\n                for (int k = j + 1; k < size; k++) {\\n                    int x1 = points[i][0] - points[k][0];\\n                    int y1 = points[i][1] - points[k][1];\\n                    double area = Math.abs(x * y1 - y * x1) / (2 * 1.000000);\\n                    if (area > ret) {\\n                        ret = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239538,
                "title": "python-triangle-areas-based-on-combinations-itertools-recursive-iterative",
                "content": "I used 4 different approaches to generate all combinations, the itertools.combinations() is by far the fastest method among all. All have O(n^3) time complexity and O(n) space complexity due to stack (recursive or iterative) usage except using triple loops which has O(1) space complexity.\\n\\nI personally think that the hardest part of this problem is to derive the triangle area formula on the spot, because I do not remember such a long formula with so many details.\\n\\nNote that math.sqrt(x) raised Math Domain Error when x<0 , which is possible in our Heron\\'s formula calculation due to floating point epsilon rounding errors. Used numpy.sqrt(x) which returns numpy.nan when x<0.\\n\\nNote that max(iter, * , default) returns nan if first argument is math.nan or numpy.nan because 1st arg is considered the max seen so far value which is compared against all subsequent values in iter. any number compares to nan returns False.\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def triple_loops():\\n            for i in range(len(points)-2):\\n                # BUG 4: range(i,len(points)-1)\\n                for j in range(i+1,len(points)-1):\\n                    for k in range(j+1,len(points)):\\n                        yield [points[i],points[j],points[k]]\\n                        \\n        def comb_recr(idx,res):\\n            if len(res)==3:\\n                yield res\\n                return  # critical. return is needed, otherwise, inf loop\\n            elif idx==len(points):\\n                return\\n            # BUG 1. off yb 1\\uFF1Acomb(idx,res) \\n            # BUG 2. forgot that comb() returns a iterator, more specifically a generator, so simply comb(idx+1,res) won\\'t do it\\n            for i in comb_recr(idx+1,res):\\n                yield i\\n            for j in comb_recr(idx+1,res+[points[idx]]):\\n                yield j\\n                        \\n        def comb_iter():\\n            stack=[[0,0]] if points else  []\\n            res=[]\\n            # My first attempt was to use a forward=True flag to indicate whether we are advancing or backtracking to current top element of the stack. This will not work as we need more info than a bool\\n            # we basically visit each element three times, 1st time is to go forward without selecting current, 2nd time is backtracked and forward with current selected, thrid is backtracked again and clean up, so these 3 status can not be represented using a bool var. If a bool can do the trick, then there is actually no need for it because we can safely pop the current top before pushing its successor, knowning that when we backtrack to current, the only thing we do is to pop it, we can do the popping before appending its successor.\\n            while stack:\\n                stack[-1][1]+=1\\n                i,s=stack[-1]\\n                if len(points)==i:\\n                        stack.pop()\\n                elif s==1: #first time , do not select current elem\\n                    stack.append([i+1,0])\\n                elif s==2: #second time, backtracked, select current elem and forward\\n                    res.append(points[i]) \\n                    if len(res)==3:\\n                        yield res\\n                    else:\\n                        stack.append([i+1,0])\\n                else: #s==3 , backtracked, done with current elem\\n                    stack.pop()\\n                    res.pop()\\n            \\n        maxarea=area=0\\n        #for p in comb_recr(0,[]): # performance 14%\\n        #for p in comb_iter(): #performance 26%\\n        for p in triple_loops(): #performance 45%\\n        #for p in itertools.combinations(points,3): # performance 84%\\n            (xa,ya),(xb,yb),(xc,yc)=p # xa,ya is a better name than ax,ay\\n            #use shoelace formula with abs() works\\n            #area=abs((xa*yb+xb*yc+xc*ya-xa*yc-xb*ya-xc*yb)/2)  # abs()needed because the relative position of A,B,C are unknown and negative value is likely ,eg if point b is to the right of line AC\\n            # BUG 3. sort does not work (xa,ya),(xb,yb),(xc,yc)=(p:=sorted(p,key=lambda e:(e[1],-e[0]),reverse=True) ), there are too many cases that ordering 3 points to yield only positive numbers could be difficult\\n            #alt. way is to use Heron\\'s formula\\n            import numpy as np\\n            def getlen(xa,ya,xb,yb):\\n                return np.sqrt((xa-xb)**2+(ya-yb)**2)\\n            def heron(a,b,c):\\n                s=1/2*sum([a,b,c])   # sum(iter,*,start=intONly) only , not sum(*iter), start can not be str, use \\'\\'.join(seq) for str\\n                t=s*(s-a)*(s-b)*(s-c)\\n                if t<0: # [[-19, -3], [-21, -4], [23, 18]] then t=-3.670178492160762e-11 <sys.float_info.epsilon\\n                        print(\\'float epsilon in Python\\',sys.float_info.epsilon)\\n                        print(\\'value found:\\',t, \\'for :\\',p)\\n                        #raise ValueError(t)\\n                        #t=0  #if we use math.sqrt, we need to set any t<0 to 0 to avoid Math Domain Error\\n                return np.sqrt(t) # if use math.sqrt(t) for t=-3.670178492160762e-11 will cause Math Domain Error\\n            area=heron(getlen(xa,ya,xb,yb),getlen(xa,ya,xc,yc),getlen(xb,yb,xc,yc))\\n            maxarea=max(maxarea,area)  #max(0,np.nan)==0, max(np.nan,0)==nan ! if first arg is nan, the max() returns nan; if nan appears in nth arg, it is ignored. https://stackoverflow.com/questions/47788361/why-does-max-sometimes-return-nan-and-sometimes-ignores-it\\n        return maxarea\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def triple_loops():\\n            for i in range(len(points)-2):\\n                # BUG 4: range(i,len(points)-1)\\n                for j in range(i+1,len(points)-1):\\n                    for k in range(j+1,len(points)):\\n                        yield [points[i],points[j],points[k]]\\n                        \\n        def comb_recr(idx,res):\\n            if len(res)==3:\\n                yield res\\n                return  # critical. return is needed, otherwise, inf loop\\n            elif idx==len(points):\\n                return\\n            # BUG 1. off yb 1\\uFF1Acomb(idx,res) \\n            # BUG 2. forgot that comb() returns a iterator, more specifically a generator, so simply comb(idx+1,res) won\\'t do it\\n            for i in comb_recr(idx+1,res):\\n                yield i\\n            for j in comb_recr(idx+1,res+[points[idx]]):\\n                yield j\\n                        \\n        def comb_iter():\\n            stack=[[0,0]] if points else  []\\n            res=[]\\n            # My first attempt was to use a forward=True flag to indicate whether we are advancing or backtracking to current top element of the stack. This will not work as we need more info than a bool\\n            # we basically visit each element three times, 1st time is to go forward without selecting current, 2nd time is backtracked and forward with current selected, thrid is backtracked again and clean up, so these 3 status can not be represented using a bool var. If a bool can do the trick, then there is actually no need for it because we can safely pop the current top before pushing its successor, knowning that when we backtrack to current, the only thing we do is to pop it, we can do the popping before appending its successor.\\n            while stack:\\n                stack[-1][1]+=1\\n                i,s=stack[-1]\\n                if len(points)==i:\\n                        stack.pop()\\n                elif s==1: #first time , do not select current elem\\n                    stack.append([i+1,0])\\n                elif s==2: #second time, backtracked, select current elem and forward\\n                    res.append(points[i]) \\n                    if len(res)==3:\\n                        yield res\\n                    else:\\n                        stack.append([i+1,0])\\n                else: #s==3 , backtracked, done with current elem\\n                    stack.pop()\\n                    res.pop()\\n            \\n        maxarea=area=0\\n        #for p in comb_recr(0,[]): # performance 14%\\n        #for p in comb_iter(): #performance 26%\\n        for p in triple_loops(): #performance 45%\\n        #for p in itertools.combinations(points,3): # performance 84%\\n            (xa,ya),(xb,yb),(xc,yc)=p # xa,ya is a better name than ax,ay\\n            #use shoelace formula with abs() works\\n            #area=abs((xa*yb+xb*yc+xc*ya-xa*yc-xb*ya-xc*yb)/2)  # abs()needed because the relative position of A,B,C are unknown and negative value is likely ,eg if point b is to the right of line AC\\n            # BUG 3. sort does not work (xa,ya),(xb,yb),(xc,yc)=(p:=sorted(p,key=lambda e:(e[1],-e[0]),reverse=True) ), there are too many cases that ordering 3 points to yield only positive numbers could be difficult\\n            #alt. way is to use Heron\\'s formula\\n            import numpy as np\\n            def getlen(xa,ya,xb,yb):\\n                return np.sqrt((xa-xb)**2+(ya-yb)**2)\\n            def heron(a,b,c):\\n                s=1/2*sum([a,b,c])   # sum(iter,*,start=intONly) only , not sum(*iter), start can not be str, use \\'\\'.join(seq) for str\\n                t=s*(s-a)*(s-b)*(s-c)\\n                if t<0: # [[-19, -3], [-21, -4], [23, 18]] then t=-3.670178492160762e-11 <sys.float_info.epsilon\\n                        print(\\'float epsilon in Python\\',sys.float_info.epsilon)\\n                        print(\\'value found:\\',t, \\'for :\\',p)\\n                        #raise ValueError(t)\\n                        #t=0  #if we use math.sqrt, we need to set any t<0 to 0 to avoid Math Domain Error\\n                return np.sqrt(t) # if use math.sqrt(t) for t=-3.670178492160762e-11 will cause Math Domain Error\\n            area=heron(getlen(xa,ya,xb,yb),getlen(xa,ya,xc,yc),getlen(xb,yb,xc,yc))\\n            maxarea=max(maxarea,area)  #max(0,np.nan)==0, max(np.nan,0)==nan ! if first arg is nan, the max() returns nan; if nan appears in nth arg, it is ignored. https://stackoverflow.com/questions/47788361/why-does-max-sometimes-return-nan-and-sometimes-ignores-it\\n        return maxarea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224082,
                "title": "simple-determinant-solution-java",
                "content": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max=0;\\n        int n=points.length;\\n        for(int fp=0;fp<n-2;fp++){\\n            for(int sp=fp+1;sp<n-1;sp++){\\n                for(int tp=sp+1;tp<n;tp++){\\n                    double area=calc(points[fp],points[sp],points[tp]);\\n                    max=Math.max(max,area);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public double calc(int[]a,int[]b,int[]c){\\n        double t=(a[0]*(b[1]-c[1])-b[0]*(a[1]-c[1])+c[0]*(a[1]-b[1]))/2.0;\\n        return t > 0 ? t : -t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max=0;\\n        int n=points.length;\\n        for(int fp=0;fp<n-2;fp++){\\n            for(int sp=fp+1;sp<n-1;sp++){\\n                for(int tp=sp+1;tp<n;tp++){\\n                    double area=calc(points[fp],points[sp],points[tp]);\\n                    max=Math.max(max,area);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public double calc(int[]a,int[]b,int[]c){\\n        double t=(a[0]*(b[1]-c[1])-b[0]*(a[1]-c[1])+c[0]*(a[1]-b[1]))/2.0;\\n        return t > 0 ? t : -t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146805,
                "title": "php",
                "content": "$count = count($points);\\n        $max = 0;\\n        for ($i = 0; $i < $count; $i++) {\\n            for ($j = $i + 1; $j < $count; $j++) {\\n                for ($k = $j + 1; $k < $count; $k++) {\\n                    $s = 0.5 * abs(($points[$j][0] - $points[$i][0]) * ($points[$k][1] - $points[$i][1]) - ($points[$k][0] - $points[$i][0]) * ($points[$j][1] - $points[$i][1]));\\n                    if ($s > $max) {\\n                        $max =  $s;\\n                    }\\n                }\\n            }\\n        }\\n        return $max;",
                "solutionTags": [],
                "code": "$count = count($points);\\n        $max = 0;\\n        for ($i = 0; $i < $count; $i++) {\\n            for ($j = $i + 1; $j < $count; $j++) {\\n                for ($k = $j + 1; $k < $count; $k++) {\\n                    $s = 0.5 * abs(($points[$j][0] - $points[$i][0]) * ($points[$k][1] - $points[$i][1]) - ($points[$k][0] - $points[$i][0]) * ($points[$j][1] - $points[$i][1]));\\n                    if ($s > $max) {\\n                        $max =  $s;\\n                    }\\n                }\\n            }\\n        }\\n        return $max;",
                "codeTag": "Unknown"
            },
            {
                "id": 1055253,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int N = points.size();\\n        double ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = i+1; j < N; ++j) {\\n                for (int k = j+1; k < N; ++k) {\\n                    ans = max(ans, area(points[i], points[j], points[k]));\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    double area(vector<int> P, vector<int> Q, vector<int> R) {\\n        return 0.5 * abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]\\n                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int N = points.size();\\n        double ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = i+1; j < N; ++j) {\\n                for (int k = j+1; k < N; ++k) {\\n                    ans = max(ans, area(points[i], points[j], points[k]));\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    double area(vector<int> P, vector<int> Q, vector<int> R) {\\n        return 0.5 * abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]\\n                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040805,
                "title": "surprisingly-fast-100",
                "content": "```\\nclass Solution {\\n    double area(vector<int>& p1, vector<int>& p2, vector<int>& p3)\\n    {\\n        return abs((p1[0] * (p2[1]-p3[1]) + p2[0] * (p3[1]-p1[1]) + p3[0] * (p1[1]-p2[1])) / 2.0);\\n    }\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max_area = 0.0;\\n        for (auto point1 = points.begin(); point1 != points.end(); point1++)\\n            for (auto point2 = next(point1); point2 != points.end(); point2++)\\n                for (auto point3 = next(point2); point3 != points.end(); point3++)\\n                    max_area = max(max_area, area(*point1, *point2, *point3));\\n        return max_area;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    double area(vector<int>& p1, vector<int>& p2, vector<int>& p3)\\n    {\\n        return abs((p1[0] * (p2[1]-p3[1]) + p2[0] * (p3[1]-p1[1]) + p3[0] * (p1[1]-p2[1])) / 2.0);\\n    }\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max_area = 0.0;\\n        for (auto point1 = points.begin(); point1 != points.end(); point1++)\\n            for (auto point2 = next(point1); point2 != points.end(); point2++)\\n                for (auto point3 = next(point2); point3 != points.end(); point3++)\\n                    max_area = max(max_area, area(*point1, *point2, *point3));\\n        return max_area;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863701,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    double area(vector<int> p1,vector<int> p2,vector<int> p3){\\n        double a=sqrt((p2[1]-p1[1])*(p2[1]-p1[1])+(p2[0]-p1[0])*(p2[0]-p1[0]));\\n        double b=sqrt((p3[1]-p1[1])*(p3[1]-p1[1])+(p3[0]-p1[0])*(p3[0]-p1[0]));\\n        double c=sqrt((p3[1]-p2[1])*(p3[1]-p2[1])+(p3[0]-p2[0])*(p3[0]-p2[0]));\\n        double s=(a+b+c)/2;\\n        return sqrt(s*(s-b)*(s-c)*(s-a));\\n        \\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=INT_MIN;\\n        for(int i=0;i<points.size();i++)\\n            for(int j=0;j<points.size();j++)\\n                for(int k=0;k<points.size();k++)\\n                {\\n                    double a=area(points[i],points[j],points[k]);\\n                    if(a>max)\\n                        max=a;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double area(vector<int> p1,vector<int> p2,vector<int> p3){\\n        double a=sqrt((p2[1]-p1[1])*(p2[1]-p1[1])+(p2[0]-p1[0])*(p2[0]-p1[0]));\\n        double b=sqrt((p3[1]-p1[1])*(p3[1]-p1[1])+(p3[0]-p1[0])*(p3[0]-p1[0]));\\n        double c=sqrt((p3[1]-p2[1])*(p3[1]-p2[1])+(p3[0]-p2[0])*(p3[0]-p2[0]));\\n        double s=(a+b+c)/2;\\n        return sqrt(s*(s-b)*(s-c)*(s-a));\\n        \\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=INT_MIN;\\n        for(int i=0;i<points.size();i++)\\n            for(int j=0;j<points.size();j++)\\n                for(int k=0;k<points.size();k++)\\n                {\\n                    double a=area(points[i],points[j],points[k]);\\n                    if(a>max)\\n                        max=a;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749640,
                "title": "java-solution-using-hero-rule-in-math",
                "content": "```\\n double max=0;\\n        \\n        for(int x=0;x<points.length-2;x++)\\n        for(int j=0;j<points.length;j++){\\n        for(int i=0;i<points.length;i++){\\n            if(i==j)continue;\\n            if(Area(points[x],points[j],points[i])>max)\\n                max=Area(points[x],points[j],points[i]);\\n           // System.out.print(Area(points[x],points[j],points[i])+\"  \");\\n        }\\n        }\\n       // (Area(points[0],points[1],points[2]));\\n        return max;\\n    }\\n    double Area(int p1[],int p2[],int []p3){\\n        double l1=Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\\n        double l2=Math.sqrt((p2[0]-p3[0])*(p2[0]-p3[0]) + (p2[1]-p3[1])*(p2[1]-p3[1]));\\n        double l3=Math.sqrt((p3[0]-p1[0])*(p3[0]-p1[0]) + (p3[1]-p1[1])*(p3[1]-p1[1]));\\n        \\n        double Halfofpremiter=(l1+l2+l3)/2;\\n        // calaculating Area of rectangle using Hero rule.\\n        return Math.sqrt(Halfofpremiter*(Halfofpremiter-l1)*(Halfofpremiter-l2)*(Halfofpremiter-l3));\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n double max=0;\\n        \\n        for(int x=0;x<points.length-2;x++)\\n        for(int j=0;j<points.length;j++){\\n        for(int i=0;i<points.length;i++){\\n            if(i==j)continue;\\n            if(Area(points[x],points[j],points[i])>max)\\n                max=Area(points[x],points[j],points[i]);\\n           // System.out.print(Area(points[x],points[j],points[i])+\"  \");\\n        }\\n        }\\n       // (Area(points[0],points[1],points[2]));\\n        return max;\\n    }\\n    double Area(int p1[],int p2[],int []p3){\\n        double l1=Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\\n        double l2=Math.sqrt((p2[0]-p3[0])*(p2[0]-p3[0]) + (p2[1]-p3[1])*(p2[1]-p3[1]));\\n        double l3=Math.sqrt((p3[0]-p1[0])*(p3[0]-p1[0]) + (p3[1]-p1[1])*(p3[1]-p1[1]));\\n        \\n        double Halfofpremiter=(l1+l2+l3)/2;\\n        // calaculating Area of rectangle using Hero rule.\\n        return Math.sqrt(Halfofpremiter*(Halfofpremiter-l1)*(Halfofpremiter-l2)*(Halfofpremiter-l3));\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 736658,
                "title": "c-herons-formula-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double side(vector<int> a, vector<int> b){\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return sqrt(x * x + y * y);\\n    }\\n    \\n    double A(double a, double b, double c){\\n        double s = (a + b + c) / 2.0;\\n        double area = sqrt(s * (s - a) * (s - b) * (s - c));\\n        return area;\\n    }\\n    \\n    bool isValid(double a, double b, double c){\\n        return (a + b > c && a + c > b && b + c > a);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int i = 0;i<points.size();i++){\\n            for(int j = i + 1;j<points.size();j++){\\n                for(int k = j + 1;k<points.size();k++){\\n                    double a = side(points[i], points[j]);\\n                    double b = side(points[j], points[k]);\\n                    double c = side(points[i], points[k]);\\n                    \\n                    if(isValid(a, b, c)){\\n                        double area = A(a, b, c);\\n\\n                        result = max(area, result);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double side(vector<int> a, vector<int> b){\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return sqrt(x * x + y * y);\\n    }\\n    \\n    double A(double a, double b, double c){\\n        double s = (a + b + c) / 2.0;\\n        double area = sqrt(s * (s - a) * (s - b) * (s - c));\\n        return area;\\n    }\\n    \\n    bool isValid(double a, double b, double c){\\n        return (a + b > c && a + c > b && b + c > a);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int i = 0;i<points.size();i++){\\n            for(int j = i + 1;j<points.size();j++){\\n                for(int k = j + 1;k<points.size();k++){\\n                    double a = side(points[i], points[j]);\\n                    double b = side(points[j], points[k]);\\n                    double c = side(points[i], points[k]);\\n                    \\n                    if(isValid(a, b, c)){\\n                        double area = A(a, b, c);\\n\\n                        result = max(area, result);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584112,
                "title": "c-clean-solution",
                "content": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var n = points.Length;\\n        var max = 0.0;\\n        for (var i = 0; i < n; i++) {\\n            for (var j = i + 1; j < n; j++) {\\n                for (var k = j + 1; k < n; k++) {\\n                    var area = Area(points[i], points[j], points[k]);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    double Area(int[] p0, int[] p1, int[] p2) {\\n        var v1x = p1[0] - p0[0];\\n        var v1y = p1[1] - p0[1];\\n        var v2x = p2[0] - p0[0];\\n        var v2y = p2[1] - p0[1];\\n        return Math.Abs(v1x * v2y - v1y * v2x) / 2.0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var n = points.Length;\\n        var max = 0.0;\\n        for (var i = 0; i < n; i++) {\\n            for (var j = i + 1; j < n; j++) {\\n                for (var k = j + 1; k < n; k++) {\\n                    var area = Area(points[i], points[j], points[k]);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    double Area(int[] p0, int[] p1, int[] p2) {\\n        var v1x = p1[0] - p0[0];\\n        var v1y = p1[1] - p0[1];\\n        var v2x = p2[0] - p0[0];\\n        var v2y = p2[1] - p0[1];\\n        return Math.Abs(v1x * v2y - v1y * v2x) / 2.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525638,
                "title": "python-3-2-simple-solutions",
                "content": "```\\n## Solution 1\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use itertools.combinations to save code amount\\n# S=(1/2)*(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n        def f(p1, p2, p3):\\n            (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(f(a, b, c) for a, b, c in itertools.combinations(points, 3))\\n\\n## Solution 2\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use formula and don\\'t forget to use absolute value\\n        res = 0\\n        N = len(points)\\n        for i in range(N - 2):\\n            for j in range(i + 1, N - 1):\\n                for k in range(i + 2, N):\\n                    (x1, y1), (x2, y2), (x3, y3) = points[i], points[j], points[k]\\n                    res = max(res, 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n## Solution 1\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use itertools.combinations to save code amount\\n# S=(1/2)*(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n        def f(p1, p2, p3):\\n            (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(f(a, b, c) for a, b, c in itertools.combinations(points, 3))\\n\\n## Solution 2\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use formula and don\\'t forget to use absolute value\\n        res = 0\\n        N = len(points)\\n        for i in range(N - 2):\\n            for j in range(i + 1, N - 1):\\n                for k in range(i + 2, N):\\n                    (x1, y1), (x2, y2), (x3, y3) = points[i], points[j], points[k]\\n                    res = max(res, 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505207,
                "title": "c-ugly-task-all-about-knowing-formula-or-proving-formula",
                "content": "Inspired by post [[C++/Java/Python] Solution with Explanation and Prove](https://leetcode.com/problems/largest-triangle-area/discuss/122711/C%2B%2BJavaPython-Solution-with-Explanation-and-Prove)\\n\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double area = 0;\\n        for (int i = 0; i < p.size() - 2; i++)\\n            for (int j = i + 1; j < p.size() - 1; j++)\\n                for (int k = j + 1; k < p.size(); k++)\\n                    area = max(area, 0.5 * abs(\\n                        p[i][0] * p[j][1] + p[j][0] * p[k][1] + p[k][0] * p[i][1] -\\n                        p[i][0] * p[k][1] - p[j][0] * p[i][1] - p[k][0] * p[j][1]\\n                    ));\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double area = 0;\\n        for (int i = 0; i < p.size() - 2; i++)\\n            for (int j = i + 1; j < p.size() - 1; j++)\\n                for (int k = j + 1; k < p.size(); k++)\\n                    area = max(area, 0.5 * abs(\\n                        p[i][0] * p[j][1] + p[j][0] * p[k][1] + p[k][0] * p[i][1] -\\n                        p[i][0] * p[k][1] - p[j][0] * p[i][1] - p[k][0] * p[j][1]\\n                    ));\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476143,
                "title": "my-swift-brute-force-solution-beats-100-runtime-and-memory",
                "content": "My Swift brute force solution beats 100% runtime and memory\\n\\n![image](https://assets.leetcode.com/users/yamironov/image_1578666188.png)\\n\\n```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        let c = points.count\\n        var result: Double = 0.0\\n        for i in 0...(c - 3) {\\n            for j in (i + 1)...(c - 2) {\\n                for k in (j + 1)...(c - 1) {\\n                    let s: Double = Double(abs((points[j][0] - points[i][0]) * (points[k][1] - points[i][1]) - (points[k][0] - points[i][0]) * (points[j][1] - points[i][1]))) / 2\\n                    if s > result { result = s }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        let c = points.count\\n        var result: Double = 0.0\\n        for i in 0...(c - 3) {\\n            for j in (i + 1)...(c - 2) {\\n                for k in (j + 1)...(c - 1) {\\n                    let s: Double = Double(abs((points[j][0] - points[i][0]) * (points[k][1] - points[i][1]) - (points[k][0] - points[i][0]) * (points[j][1] - points[i][1]))) / 2\\n                    if s > result { result = s }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426250,
                "title": "c-beats-98-88-time-100-space",
                "content": "basically, it is a math problem rather than a programming problem. It uses below formula to get size of triangle through 3 vertexes:\\nS=(1/2)*abs(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n \\n        double max = 0;\\n        for(int i=0; i<points.size()-2; i++)\\n            for(int j=i+1; j<points.size()-1; j++)\\n                for(int k=j+1; k<points.size(); k++)\\n                {\\n                    //S=(1/2)*abs(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n                    double cur = 0.5*abs(points[i][0]*points[j][1]+points[j][0]*points[k][1]+\\n                                        points[k][0]*points[i][1]-points[i][0]*points[k][1]-\\n                                        points[j][0]*points[i][1]-points[k][0]*points[j][1]);\\n                    if(cur > max)\\n                        max = cur;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n \\n        double max = 0;\\n        for(int i=0; i<points.size()-2; i++)\\n            for(int j=i+1; j<points.size()-1; j++)\\n                for(int k=j+1; k<points.size(); k++)\\n                {\\n                    //S=(1/2)*abs(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n                    double cur = 0.5*abs(points[i][0]*points[j][1]+points[j][0]*points[k][1]+\\n                                        points[k][0]*points[i][1]-points[i][0]*points[k][1]-\\n                                        points[j][0]*points[i][1]-points[k][0]*points[j][1]);\\n                    if(cur > max)\\n                        max = cur;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409313,
                "title": "easy-understandable-concise-code-beats-95",
                "content": "\\tdef LTA(m, n, o):\\n\\t\\tar = abs(((m[0]-o[0])*(n[1]-m[1])) - ((m[0] - n[0])*(o[1] - m[1])))\\n\\t\\treturn 0.5*ar\\n\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tmaxarea = 0\\n\\t\\t\\tfor i in range(len(points)-2):\\n\\t\\t\\t\\tfor j in range(i+1, len(points)-1):\\n\\t\\t\\t\\t\\tfor k in range(j+1, len(points)):\\n\\t\\t\\t\\t\\t\\tarea = LTA(points[i], points[j], points[k])\\n\\t\\t\\t\\t\\t\\tif area>maxarea:\\n\\t\\t\\t\\t\\t\\t\\tmaxarea = area\\n\\t\\t\\treturn maxarea\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef LTA(m, n, o):\\n\\t\\tar = abs(((m[0]-o[0])*(n[1]-m[1])) - ((m[0] - n[0])*(o[1] - m[1])))\\n\\t\\treturn 0.5*ar\\n\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tmaxarea = 0\\n\\t\\t\\tfor i in range(len(points)-2):\\n\\t\\t\\t\\tfor j in range(i+1, len(points)-1):\\n\\t\\t\\t\\t\\tfor k in range(j+1, len(points)):\\n\\t\\t\\t\\t\\t\\tarea = LTA(points[i], points[j], points[k])\\n\\t\\t\\t\\t\\t\\tif area>maxarea:\\n\\t\\t\\t\\t\\t\\t\\tmaxarea = area\\n\\t\\t\\treturn maxarea\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 280808,
                "title": "python-short-and-sweet-brute-force-heron-s-formula",
                "content": "```\\n\\nimport itertools\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def d(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**.5\\n        \\n        def area(a,b,c):\\n            p=.5*(d(a,b)+d(a,c)+d(b,c))\\n            sq=p*(p-d(a,b))*(p-d(a,c))*(p-d(b,c))\\n            return 0 if sq<0 else sq**.5\\n        \\n        ans=0\\n        for a,b,c in itertools.combinations(points,3):\\n            ans=max(ans,area(a,b,c))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nimport itertools\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def d(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**.5\\n        \\n        def area(a,b,c):\\n            p=.5*(d(a,b)+d(a,c)+d(b,c))\\n            sq=p*(p-d(a,b))*(p-d(a,c))*(p-d(b,c))\\n            return 0 if sq<0 else sq**.5\\n        \\n        ans=0\\n        for a,b,c in itertools.combinations(points,3):\\n            ans=max(ans,area(a,b,c))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274503,
                "title": "fast-c-solution",
                "content": "\\n```\\n   double largestTriangleArea(vector<vector<int>>& points) {\\n        auto det = [&](int i, int j) {\\n            return points[i][0] * points[j][1] -\\n                   points[j][0] * points[i][1];     \\n        };\\n            \\n        // double of the max area.\\n        int area = 0;\\n        int n = points.size();\\n        for (int i = 0; i < n - 2; ++i) {\\n            for (int j = i + 1; j < n - 1; ++j) {\\n                for (int k = j + 1; k < n; ++k) {\\n                    // Determinant formula:\\n                    // https://people.richland.edu/james/lecture/m116/matrices/applications.html\\n                    int t = det(j, k) - det(i, k) + det(i, j);\\n                    area = max(area, max(-t, t));\\n                }\\n            }\\n        }\\n        \\n        // only do division in the end.\\n        return area / 2.0f;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   double largestTriangleArea(vector<vector<int>>& points) {\\n        auto det = [&](int i, int j) {\\n            return points[i][0] * points[j][1] -\\n                   points[j][0] * points[i][1];     \\n        };\\n            \\n        // double of the max area.\\n        int area = 0;\\n        int n = points.size();\\n        for (int i = 0; i < n - 2; ++i) {\\n            for (int j = i + 1; j < n - 1; ++j) {\\n                for (int k = j + 1; k < n; ++k) {\\n                    // Determinant formula:\\n                    // https://people.richland.edu/james/lecture/m116/matrices/applications.html\\n                    int t = det(j, k) - det(i, k) + det(i, j);\\n                    area = max(area, max(-t, t));\\n                }\\n            }\\n        }\\n        \\n        // only do division in the end.\\n        return area / 2.0f;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247182,
                "title": "brute-force-outer-product-8-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    double area(vector<int>& a, vector<int>&b, vector<int>& c) {\\n        return abs((double)((a[0]-b[0])*(a[1]-c[1])-(a[1]-b[1])*(a[0]-c[0]))/2.0);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int size = points.size();\\n        double tmpArea = 0, output = 0;\\n        for (int i = 0; i < size; ++i) \\n            for (int j = i+1; j < size; ++j) \\n                for (int k = j+1; k < size; ++k) {\\n                    tmpArea = area(points[i],points[j],points[k]);\\n                    if (tmpArea > output)\\n                        output = tmpArea;\\n                }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double area(vector<int>& a, vector<int>&b, vector<int>& c) {\\n        return abs((double)((a[0]-b[0])*(a[1]-c[1])-(a[1]-b[1])*(a[0]-c[0]))/2.0);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int size = points.size();\\n        double tmpArea = 0, output = 0;\\n        for (int i = 0; i < size; ++i) \\n            for (int j = i+1; j < size; ++j) \\n                for (int k = j+1; k < size; ++k) {\\n                    tmpArea = area(points[i],points[j],points[k]);\\n                    if (tmpArea > output)\\n                        output = tmpArea;\\n                }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134351,
                "title": "kotlin-o-n-3-solution",
                "content": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        var maxArea = 0.0\\n        for (i in 0 until points.size) {\\n            for (j in i + 1 until points.size) {\\n                for (k in j + 1 until points.size) {\\n                    maxArea = Math.max(maxArea, area(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return maxArea\\n    }\\n\\n    private fun area(a: IntArray, b: IntArray, c: IntArray): Double {\\n        return 0.5 * Math.abs((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        var maxArea = 0.0\\n        for (i in 0 until points.size) {\\n            for (j in i + 1 until points.size) {\\n                for (k in j + 1 until points.size) {\\n                    maxArea = Math.max(maxArea, area(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return maxArea\\n    }\\n\\n    private fun area(a: IntArray, b: IntArray, c: IntArray): Double {\\n        return 0.5 * Math.abs((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123555,
                "title": "c-simple-9ms-solution-without-complex-formulas",
                "content": "```\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double res=0.0;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) res=max(res, cal(points[i], points[j], points[k]));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    double cal(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        double base=sqrt((a[1]-b[1])*(a[1]-b[1])+(a[0]-b[0])*(a[0]-b[0]));\\n        double A=(a[1]-c[1])*(a[1]-c[1])+(a[0]-c[0])*(a[0]-c[0]);\\n        double B=(c[1]-b[1])*(c[1]-b[1])+(c[0]-b[0])*(c[0]-b[0]);\\n        double temp=base/2-(A-B)/(2*base);\\n        double height=sqrt(B-temp*temp);\\n        return base*height/2;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double res=0.0;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) res=max(res, cal(points[i], points[j], points[k]));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    double cal(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        double base=sqrt((a[1]-b[1])*(a[1]-b[1])+(a[0]-b[0])*(a[0]-b[0]));\\n        double A=(a[1]-c[1])*(a[1]-c[1])+(a[0]-c[0])*(a[0]-c[0]);\\n        double B=(c[1]-b[1])*(c[1]-b[1])+(c[0]-b[0])*(c[0]-b[0]);\\n        double temp=base/2-(A-B)/(2*base);\\n        double height=sqrt(B-temp*temp);\\n        return base*height/2;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4088862,
                "title": "triple-loop-to-find-the-biggest-triangle",
                "content": "# Intuition\\nThe problem requires finding the largest possible area of a triangle formed by three points from the given set of points. A brute-force approach is used to iterate through all possible combinations of three points and calculate the area of each triangle formed by them. The maximum area found among all triangles is the result.\\n\\n# Approach\\n1. Initialize a variable `res` to store the maximum area, initially set to 0.\\n2. Use three nested loops to iterate through all possible combinations of three points from the given array `points`.\\n3. For each combination of three points (i, j, k), calculate the area of the triangle formed by these points using the formula for the area of a triangle given its vertices.\\n4. Update the `res` variable with the maximum of its current value and the area calculated in step 3.\\n5. After all combinations have been checked, `res` will contain the maximum area of a triangle formed by any three points in the array.\\n6. Return the value of `res` as the result.\\n\\n# Complexity\\n- Time complexity: O(n^3) where n is the number of points in the input array. This is because we have three nested loops to generate all combinations of three points.\\n- Space complexity: O(1) as we are using a constant amount of extra space regardless of the input size.\\n\\n\\n# Code\\n```\\nfunction largestTriangleArea(points: number[][]): number {\\n    let res = 0;\\n\\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            for (let k = j + 1; k < points.length; k++) {\\n                const area = 0.5 * Math.abs(\\n                    points[i][0] * (points[j][1] - points[k][1]) +\\n                    points[j][0] * (points[k][1] - points[i][1]) +\\n                    points[k][0] * (points[i][1] - points[j][1])\\n                );\\n\\n                res = Math.max(res, area);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestTriangleArea(points: number[][]): number {\\n    let res = 0;\\n\\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            for (let k = j + 1; k < points.length; k++) {\\n                const area = 0.5 * Math.abs(\\n                    points[i][0] * (points[j][1] - points[k][1]) +\\n                    points[j][0] * (points[k][1] - points[i][1]) +\\n                    points[k][0] * (points[i][1] - points[j][1])\\n                );\\n\\n                res = Math.max(res, area);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061297,
                "title": "just-the-heron-s-formula-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double distance(vector<int>& p1, vector<int>& p2){\\n        double d1=abs(p1[0]-p2[0]);\\n        double d2=abs(p1[1]-p2[1]);\\n        d1*=d1;\\n        d2*=d2;\\n        return sqrt(d1+d2);\\n    }\\n    double area(double a, double b, double c){\\n        double s=(a+b+c)/2.0;\\n        return sqrt(s*(s-a)*(s-b)*(s-c));\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0.0;\\n        double a=0,b=0,c=0;\\n        int n=points.size();\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                a=distance(points[i],points[j]);\\n                for(int k=j+1;k<n;k++){\\n                    b=distance(points[j],points[k]);\\n                    c=distance(points[i],points[k]);\\n                    ans=max(ans,area(a,b,c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double distance(vector<int>& p1, vector<int>& p2){\\n        double d1=abs(p1[0]-p2[0]);\\n        double d2=abs(p1[1]-p2[1]);\\n        d1*=d1;\\n        d2*=d2;\\n        return sqrt(d1+d2);\\n    }\\n    double area(double a, double b, double c){\\n        double s=(a+b+c)/2.0;\\n        return sqrt(s*(s-a)*(s-b)*(s-c));\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0.0;\\n        double a=0,b=0,c=0;\\n        int n=points.size();\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                a=distance(points[i],points[j]);\\n                for(int k=j+1;k<n;k++){\\n                    b=distance(points[j],points[k]);\\n                    c=distance(points[i],points[k]);\\n                    ans=max(ans,area(a,b,c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058296,
                "title": "simple-with-unit-tests",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \"\"\"\\n        Calculate the surface of the largest triangle from 3 points on 2-D plain from the list.\\n\\n        Triangle size is height/2 * b. Height is perpendicular to on the b side and touches the vertex.\\n        There is a formula for triangle from coordinates also called determinant: `A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|`\\n\\n        The simplest solution is iterating over all combinations with time complexity of O(N**3).\\n        There are more complex solutions involving Gift Wrapping Algorithms.\\n\\n        >>> Solution().largestTriangleArea([[0,0],[0,1],[1,0],[0,2],[2,0]])\\n        2.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0],[0,1]])\\n        0.5\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0]])\\n        0.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0], [0,0]])\\n        0.0\\n\\n        \"\"\"\\n\\n        if len(points) < 3:\\n            return 0.0\\n\\n        max_area = 0.0\\n        for (x1, y1) in points:\\n            for (x2, y2) in points:\\n                for (x3, y3) in points:\\n                    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\\n                    if area > max_area:\\n                        max_area = area\\n\\n        return max_area\\n\\n\\n```\\n\\n\\n## Follow me for more software and machine learning at https://vaclavkosar.com/",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \"\"\"\\n        Calculate the surface of the largest triangle from 3 points on 2-D plain from the list.\\n\\n        Triangle size is height/2 * b. Height is perpendicular to on the b side and touches the vertex.\\n        There is a formula for triangle from coordinates also called determinant: `A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|`\\n\\n        The simplest solution is iterating over all combinations with time complexity of O(N**3).\\n        There are more complex solutions involving Gift Wrapping Algorithms.\\n\\n        >>> Solution().largestTriangleArea([[0,0],[0,1],[1,0],[0,2],[2,0]])\\n        2.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0],[0,1]])\\n        0.5\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0]])\\n        0.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0], [0,0]])\\n        0.0\\n\\n        \"\"\"\\n\\n        if len(points) < 3:\\n            return 0.0\\n\\n        max_area = 0.0\\n        for (x1, y1) in points:\\n            for (x2, y2) in points:\\n                for (x3, y3) in points:\\n                    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\\n                    if area > max_area:\\n                        max_area = area\\n\\n        return max_area\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047307,
                "title": "shoelace",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\ndouble calculateArea(double x1, double y1, double x2, double y2, double x3, double y3) {\\n    return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\\n}\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      double res = 0;\\n      int n = points.size();\\n      for (int i = 0; i < n-2; ++i) {\\n        for (int j = i+1; j < n-1; ++j) {\\n          for (int k = j+1; k < n; ++k) {\\n            vector<int> p1 = points[i];\\n            vector<int> p2 = points[j];\\n            vector<int> p3 = points[k];\\n            double area = calculateArea(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\\n            res = max(res,area);\\n          }\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\ndouble calculateArea(double x1, double y1, double x2, double y2, double x3, double y3) {\\n    return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\\n}\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      double res = 0;\\n      int n = points.size();\\n      for (int i = 0; i < n-2; ++i) {\\n        for (int j = i+1; j < n-1; ++j) {\\n          for (int k = j+1; k < n; ++k) {\\n            vector<int> p1 = points[i];\\n            vector<int> p2 = points[j];\\n            vector<int> p3 = points[k];\\n            double area = calculateArea(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\\n            res = max(res,area);\\n          }\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032967,
                "title": "excellent-solution-very-quick-and-takes-up-very-little-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def calc_area(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        \\n        max_area = 0\\n        n = len(points)\\n        \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    curr_area = calc_area(x1, y1, x2, y2, x3, y3)\\n                    max_area = max(max_area, curr_area)\\n        \\n        return max_area\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def calc_area(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        \\n        max_area = 0\\n        n = len(points)\\n        \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    curr_area = calc_area(x1, y1, x2, y2, x3, y3)\\n                    max_area = max(max_area, curr_area)\\n        \\n        return max_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012074,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\n\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992307,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964680,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\n O(n^3)\\n- Space complexity:\\n O(1)\\n# Code\\n```\\nclass Solution {\\n    double calculateTriangleArea(List<List<int>> points, int i, int j, int k) {\\n    return 0.5 * (points[i][0] * (points[j][1] - points[k][1]) +\\n        points[j][0] * (points[k][1] - points[i][1]) +\\n        points[k][0] * (points[i][1] - points[j][1])).abs();\\n  }\\n\\n  double largestTriangleArea(List<List<int>> points) {\\n    double maxArea = 0.0;\\n    int n = points.length;\\n\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          double area = calculateTriangleArea(points, i, j, k);\\n          maxArea = max(maxArea, area);\\n        }\\n      }\\n    }\\n\\n    return maxArea;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n    double calculateTriangleArea(List<List<int>> points, int i, int j, int k) {\\n    return 0.5 * (points[i][0] * (points[j][1] - points[k][1]) +\\n        points[j][0] * (points[k][1] - points[i][1]) +\\n        points[k][0] * (points[i][1] - points[j][1])).abs();\\n  }\\n\\n  double largestTriangleArea(List<List<int>> points) {\\n    double maxArea = 0.0;\\n    int n = points.length;\\n\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          double area = calculateTriangleArea(points, i, j, k);\\n          maxArea = max(maxArea, area);\\n        }\\n      }\\n    }\\n\\n    return maxArea;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954482,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886601,
                "title": "java-math-formula",
                "content": "# Intuition\\n**Area = (1/2) (x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2))**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864092,
                "title": "easy-solution-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a simple Brute Force question using a simple Mathematical formula for finding the Area.\\nFormula used : `Area = ((1.0/2) * abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^3)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double Area = 0;\\n        double Maxi = -1;\\n        for(int i=0;i<points.size()-2;i++) {\\n            for(int j=i+1;j<points.size()-1;j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    // A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|\\n                    int i1 = points[i][0];\\n                    int j1 = points[i][1];\\n                    int i2 = points[j][0];\\n                    int j2 = points[j][1];\\n                    int i3 = points[k][0];\\n                    int j3 = points[k][1];\\n                    \\n                    Area = ((1.0/2) * abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    // Area = ((1/2)* abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    Maxi = max(Maxi,Area);\\n                }\\n            }\\n        }       \\n        return Maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double Area = 0;\\n        double Maxi = -1;\\n        for(int i=0;i<points.size()-2;i++) {\\n            for(int j=i+1;j<points.size()-1;j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    // A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|\\n                    int i1 = points[i][0];\\n                    int j1 = points[i][1];\\n                    int i2 = points[j][0];\\n                    int j2 = points[j][1];\\n                    int i3 = points[k][0];\\n                    int j3 = points[k][1];\\n                    \\n                    Area = ((1.0/2) * abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    // Area = ((1/2)* abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    Maxi = max(Maxi,Area);\\n                }\\n            }\\n        }       \\n        return Maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853712,
                "title": "c-solution",
                "content": "```\\ndouble largestTriangleArea(vector<vector<int>>& p) {\\n\\tdouble res = DBL_MIN;\\n\\tfor (int i = 0; i < p.size(); i++)\\n\\t\\tfor (int j = i + 1; j < p.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k < p.size(); k++) {\\n\\t\\t\\t\\tdouble area = 0.5 * abs(p[i][0] * (p[j][1] - p[k][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[j][0] * (p[k][1] - p[i][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[k][0] * (p[i][1] - p[j][1]));\\n\\t\\t\\t\\tres = max(res, area);\\n\\t\\t\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ndouble largestTriangleArea(vector<vector<int>>& p) {\\n\\tdouble res = DBL_MIN;\\n\\tfor (int i = 0; i < p.size(); i++)\\n\\t\\tfor (int j = i + 1; j < p.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k < p.size(); k++) {\\n\\t\\t\\t\\tdouble area = 0.5 * abs(p[i][0] * (p[j][1] - p[k][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[j][0] * (p[k][1] - p[i][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[k][0] * (p[i][1] - p[j][1]));\\n\\t\\t\\t\\tres = max(res, area);\\n\\t\\t\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847518,
                "title": "kp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def find(points):\\n            a = points[0]\\n            b = points[1]\\n            c = points[2]\\n            x1, y1 = a[0], a[1]\\n            x2, y2 = b[0], b[1]\\n            x3, y3 = c[0], c[1]\\n            pre_area = x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)\\n            final_area = 0.5*abs(pre_area)\\n            return final_area\\n        if len(points)==3:\\n            return find(points)\\n        else:\\n            a = list(combinations(points, 3))\\n            c = []\\n            for i in a:\\n                c.append(find(i))\\n            return max(c)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def find(points):\\n            a = points[0]\\n            b = points[1]\\n            c = points[2]\\n            x1, y1 = a[0], a[1]\\n            x2, y2 = b[0], b[1]\\n            x3, y3 = c[0], c[1]\\n            pre_area = x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)\\n            final_area = 0.5*abs(pre_area)\\n            return final_area\\n        if len(points)==3:\\n            return find(points)\\n        else:\\n            a = list(combinations(points, 3))\\n            c = []\\n            for i in a:\\n                c.append(find(i))\\n            return max(c)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841640,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1,len(points)):\\n                for k in range(j+1,len(points)):\\n                    one = ((points[j][0]-points[i][0])**2+(points[j][1]-points[i][1])**2)**0.5\\n                    two = ((points[k][0]-points[i][0])**2+(points[k][1]-points[i][1])**2)**0.5\\n                    three = ((points[k][0]-points[j][0])**2+(points[k][1]-points[j][1])**2)**0.5\\n                    s = (one+two+three)/2\\n                    largest = max((s*(round(s-one, 8))*(round(s-two, 8))*(round(s-three, 8)))**0.5, largest)\\n        \\n        return largest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1,len(points)):\\n                for k in range(j+1,len(points)):\\n                    one = ((points[j][0]-points[i][0])**2+(points[j][1]-points[i][1])**2)**0.5\\n                    two = ((points[k][0]-points[i][0])**2+(points[k][1]-points[i][1])**2)**0.5\\n                    three = ((points[k][0]-points[j][0])**2+(points[k][1]-points[j][1])**2)**0.5\\n                    s = (one+two+three)/2\\n                    largest = max((s*(round(s-one, 8))*(round(s-two, 8))*(round(s-three, 8)))**0.5, largest)\\n        \\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824181,
                "title": "simple-c-solution-using-heron-s-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double hammingDistance(vector<int> x1, vector<int> x2) {\\n        double sq = pow((x1[0]-x2[0]), 2)+pow((x1[1]- x2[1]), 2);\\n        return sqrt(sq);\\n    }\\n    double getArea(vector<int> p0, vector<int> p1, vector<int> p2){\\n        double a = hammingDistance(p0, p1);\\n        double b = hammingDistance(p1, p2);\\n        double c = hammingDistance(p2, p0);\\n        double s = (a+b+c)/2;\\n        double sq = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(sq);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<int> res;\\n        double area = 0;\\n        int m = points.size();\\n        \\n        for(int i=0;i<m-2;i++){\\n            \\n            for(int j=i+1;j<m-1;j++){\\n                \\n                for(int k=j+1;k<m;k++){\\n                    \\n                    double finalArea = getArea(points[i], points[j], points[k]);\\n                    if(finalArea>area)\\n                        area=finalArea;\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/f1e70f93-6634-4144-87cf-d02ad247260a_1690467810.4240024.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double hammingDistance(vector<int> x1, vector<int> x2) {\\n        double sq = pow((x1[0]-x2[0]), 2)+pow((x1[1]- x2[1]), 2);\\n        return sqrt(sq);\\n    }\\n    double getArea(vector<int> p0, vector<int> p1, vector<int> p2){\\n        double a = hammingDistance(p0, p1);\\n        double b = hammingDistance(p1, p2);\\n        double c = hammingDistance(p2, p0);\\n        double s = (a+b+c)/2;\\n        double sq = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(sq);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<int> res;\\n        double area = 0;\\n        int m = points.size();\\n        \\n        for(int i=0;i<m-2;i++){\\n            \\n            for(int j=i+1;j<m-1;j++){\\n                \\n                for(int k=j+1;k<m;k++){\\n                    \\n                    double finalArea = getArea(points[i], points[j], points[k]);\\n                    if(finalArea>area)\\n                        area=finalArea;\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750383,
                "title": "simple-mathematics-brute-force",
                "content": "```\\ndouble findArea(double a, double b, double c) \\n   {  \\n    if (a < 0 || b < 0 || c < 0 || \\n       (a + b <= c) || a + c <= b || \\n                       b + c <= a) {\\n        return 0.0;\\n    }\\n    double s = (a + b + c) / 2; \\n    return sqrt(s * (s - a) * \\n                    (s - b) * (s - c)); \\n    }\\n    double func(int x1,int y1,int x2,int y2)\\n    {\\n        double a=(x1-x2)*(x1-x2);\\n        double b=(y1-y2)*(y1-y2);\\n        \\n        return sqrt(a+b);\\n    }\\n    double solve(vector<int>&a,vector<int>&b,vector<int>&c)\\n    {   \\n        double x=func(a[0],a[1],b[0],b[1]);\\n        double y=func(c[0],c[1],b[0],b[1]);\\n        double z=func(a[0],a[1],c[0],c[1]);\\n        return findArea(x,y,z);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points)\\n    {   \\n        double ans=0.0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    ans=max(ans,solve(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndouble findArea(double a, double b, double c) \\n   {  \\n    if (a < 0 || b < 0 || c < 0 || \\n       (a + b <= c) || a + c <= b || \\n                       b + c <= a) {\\n        return 0.0;\\n    }\\n    double s = (a + b + c) / 2; \\n    return sqrt(s * (s - a) * \\n                    (s - b) * (s - c)); \\n    }\\n    double func(int x1,int y1,int x2,int y2)\\n    {\\n        double a=(x1-x2)*(x1-x2);\\n        double b=(y1-y2)*(y1-y2);\\n        \\n        return sqrt(a+b);\\n    }\\n    double solve(vector<int>&a,vector<int>&b,vector<int>&c)\\n    {   \\n        double x=func(a[0],a[1],b[0],b[1]);\\n        double y=func(c[0],c[1],b[0],b[1]);\\n        double z=func(a[0],a[1],c[0],c[1]);\\n        return findArea(x,y,z);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points)\\n    {   \\n        double ans=0.0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    ans=max(ans,solve(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702727,
                "title": "largest-triangle-area-js-clear-solution",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    result = 0\\n\\n    for (a of points)\\n        for (b of points)\\n            for (c of points) {\\n                x1 = a[0]\\n                x2 = b[0]\\n                x3 = c[0]\\n                y1 = a[1]\\n                y2 = b[1]\\n                y3 = c[1]\\n                area = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))/2                \\n                result = Math.max(area, result)\\n            }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    result = 0\\n\\n    for (a of points)\\n        for (b of points)\\n            for (c of points) {\\n                x1 = a[0]\\n                x2 = b[0]\\n                x3 = c[0]\\n                y1 = a[1]\\n                y2 = b[1]\\n                y3 = c[1]\\n                area = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))/2                \\n                result = Math.max(area, result)\\n            }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668671,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def largestTriangleArea(points: Array[Array[Int]]): Double = {\\n      def area(p1: Array[Int], p2: Array[Int], p3: Array[Int]): Double =\\n        math.abs((p1(0)*p2(1) + p2(0)*p3(1) + p3(0)*p1(1) - p1(0)*p3(1) - p2(0)*p1(1) - p3(0)*p2(1))/2.0)\\n\\n      (for {\\n        i <- points.indices\\n        j <- i+1 until points.length\\n        k <- j+1 until points.length\\n      } yield area(points(i), points(j), points(k))).max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def largestTriangleArea(points: Array[Array[Int]]): Double = {\\n      def area(p1: Array[Int], p2: Array[Int], p3: Array[Int]): Double =\\n        math.abs((p1(0)*p2(1) + p2(0)*p3(1) + p3(0)*p1(1) - p1(0)*p3(1) - p2(0)*p1(1) - p3(0)*p2(1))/2.0)\\n\\n      (for {\\n        i <- points.indices\\n        j <- i+1 until points.length\\n        k <- j+1 until points.length\\n      } yield area(points(i), points(j), points(k))).max\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3602149,
                "title": "simple-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst youhave to select 3 coordinates from the list,\\nAfter That The formula of area of triangle formula in coordinate geometry is: A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|\\nApply it You will win. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n            area = 0\\n    \\n            for i in range(len(points)-2):\\n                x1,y1 = points[i]\\n                for j in range(i+1,len(points)-1):\\n                    x2,y2 = points[j]\\n                    for k in range(j+1,len(points)):\\n                        x3,y3 = points[k]\\n                        curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                        if (curr_area > area):\\n                            area = curr_area\\n        \\n            return area\\n```\\nIf you Like \\nPlz Up vote :)))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n            area = 0\\n    \\n            for i in range(len(points)-2):\\n                x1,y1 = points[i]\\n                for j in range(i+1,len(points)-1):\\n                    x2,y2 = points[j]\\n                    for k in range(j+1,len(points)):\\n                        x3,y3 = points[k]\\n                        curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                        if (curr_area > area):\\n                            area = curr_area\\n        \\n            return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601315,
                "title": "java-faster-than-95-bits-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public double calculateArea(int i,int j,int k,int[][] points){\\n        int x1=points[i][0];\\n        int x2=points[j][0];\\n        int x3=points[k][0];\\n        int y1=points[i][1];\\n        int y2=points[j][1];\\n        int y3=points[k][1];\\n\\n        double ans;\\n        ans=Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))*0.5);\\n        return ans;\\n    }\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double ans=0;\\n        for(int i=0;i<points.length;i++){\\n            for(int j=i+1;j<=points.length;j++){\\n                for(int k=j+1;k<points.length;k++){\\n                    double area=calculateArea(i,j,k,points);\\n                    ans=Math.max(ans,area);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double calculateArea(int i,int j,int k,int[][] points){\\n        int x1=points[i][0];\\n        int x2=points[j][0];\\n        int x3=points[k][0];\\n        int y1=points[i][1];\\n        int y2=points[j][1];\\n        int y3=points[k][1];\\n\\n        double ans;\\n        ans=Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))*0.5);\\n        return ans;\\n    }\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double ans=0;\\n        for(int i=0;i<points.length;i++){\\n            for(int j=i+1;j<=points.length;j++){\\n                for(int k=j+1;k<points.length;k++){\\n                    double area=calculateArea(i,j,k,points);\\n                    ans=Math.max(ans,area);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557653,
                "title": "java-brute-force",
                "content": "# Intuition\\nInitialize a variable maxArea to keep track of the maximum triangle area found. Initially, set it to 0.\\n\\nIterate over the array of points using three nested loops. The outer loop selects the first point, the middle loop selects the second point, and the inner loop selects the third point.\\n\\nFor each combination of three points, calculate the area of the triangle formed by these points using the calculateArea method.\\n\\nUpdate the maxArea if the calculated area is greater than the current maximum.\\n\\nAfter checking all possible combinations, return the maxArea as the result.\\n\\nThe calculateArea method implements the shoelace formula, also known as the formula for the area of a triangle given three points. It takes three points as input and calculates the area using the absolute value of the sum of the products of the coordinates of the points.\\n\\n# Complexity\\n- Time complexity:\\n\\no(n)cube\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n\\n       double maxArea = 0.0;\\n        int n = points.length;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p1 = points[i];\\n                    int[] p2 = points[j];\\n                    int[] p3 = points[k];\\n\\n                    double area = calculateArea(p1, p2, p3);\\n                    maxArea = Math.max(maxArea, area);\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n        \\n    }\\n      static double calculateArea(int[] p1, int[] p2, int[] p3) {\\n        double area = 0.5 * Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n        );\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n\\n       double maxArea = 0.0;\\n        int n = points.length;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p1 = points[i];\\n                    int[] p2 = points[j];\\n                    int[] p3 = points[k];\\n\\n                    double area = calculateArea(p1, p2, p3);\\n                    maxArea = Math.max(maxArea, area);\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n        \\n    }\\n      static double calculateArea(int[] p1, int[] p2, int[] p3) {\\n        double area = 0.5 * Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n        );\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538681,
                "title": "sumit",
                "content": "# Intuition\\neassy approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        n=len(points)\\n        h=[]\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    h.append(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))))\\n\\n        \\n            \\n        h.sort(reverse=True)\\n        return(h[0])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        n=len(points)\\n        h=[]\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    h.append(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))))\\n\\n        \\n            \\n        h.sort(reverse=True)\\n        return(h[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519913,
                "title": "python-one-liner",
                "content": "# Intuition\\nUse formula for the area of triangle when 3 points are given.\\nJust check every tripplet and take the max.\\n$$\\nArea = 1/2[x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)]\\n$$\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        return max(abs(p[i][0]*(p[j][1]-p[k][1])+p[j][0]*(p[k][1]-p[i][1])+p[k][0]*(p[i][1]-p[j][1]))for i in range(len(p)-2) for j in range(i+1,len(p)-1)for k in range(j+1,len(p)))/2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        return max(abs(p[i][0]*(p[j][1]-p[k][1])+p[j][0]*(p[k][1]-p[i][1])+p[k][0]*(p[i][1]-p[j][1]))for i in range(len(p)-2) for j in range(i+1,len(p)-1)for k in range(j+1,len(p)))/2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475593,
                "title": "simple-javascript-solution",
                "content": "Please Upvote My Solution. Thankyou \\uD83D\\uDE0A\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0;\\n    for(let i of points) {\\n        for(let j of points){\\n            for(let k of points) {\\n                area = Math.max(area , Math.abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n            }\\n        }\\n    }\\n    return area;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0;\\n    for(let i of points) {\\n        for(let j of points){\\n            for(let k of points) {\\n                area = Math.max(area , Math.abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n            }\\n        }\\n    }\\n    return area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430757,
                "title": "better-3-line-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430754,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404863,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0\\n    const len = points.length;\\n    for (let i=0; i<len; i++) {\\n      [a1, b1] = points[i];\\n      for (let j = i+1; j<len; j++){\\n        [a2, b2] = points[j];\\n        for (let k = j+1; k<len; k++) {\\n          [a3, b3] = points[k];\\n          let value = Math.abs(0.5*(a1*(b2-b3)+a2*(b3-b1)+a3*(b1-b2)))\\n          if (value >area) area = value; \\n        }\\n      }\\n    }\\n    return area;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0\\n    const len = points.length;\\n    for (let i=0; i<len; i++) {\\n      [a1, b1] = points[i];\\n      for (let j = i+1; j<len; j++){\\n        [a2, b2] = points[j];\\n        for (let k = j+1; k<len; k++) {\\n          [a3, b3] = points[k];\\n          let value = Math.abs(0.5*(a1*(b2-b3)+a2*(b3-b1)+a3*(b1-b2)))\\n          if (value >area) area = value; \\n        }\\n      }\\n    }\\n    return area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404579,
                "title": "beat-93percent-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying heroines formula of mathematics by taking 3 points at a time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398151,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396586,
                "title": "java-simple-solution-brutefroce-geometry",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    maxArea = Math.max(\\n                            maxArea,\\n                            Math.abs(area(points[i], points[j], points[k])));\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n\\n    public static double area(int[] x1, int[] x2, int[] x3) {\\n        int t1 = x1[0] * (x2[1] - x3[1]);\\n        int t2 = x2[0] * (x3[1] - x1[1]);\\n        int t3 = x3[0] * (x1[1] - x2[1]);\\n\\n        return (t1 + t2 + t3) / 2.;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    maxArea = Math.max(\\n                            maxArea,\\n                            Math.abs(area(points[i], points[j], points[k])));\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n\\n    public static double area(int[] x1, int[] x2, int[] x3) {\\n        int t1 = x1[0] * (x2[1] - x3[1]);\\n        int t2 = x2[0] * (x3[1] - x1[1]);\\n        int t3 = x3[0] * (x1[1] - x2[1]);\\n\\n        return (t1 + t2 + t3) / 2.;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393583,
                "title": "c-short-code-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    using Point = std::vector<int32_t>;\\n\\n    double triangleArea(Point const& p0, Point const& p1, Point const& p2) {\\n        return 0.5 * std::abs((p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]));\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int32_t i = 0; i < points.size(); i++) {\\n            for(int32_t j = i + 1; j < points.size(); j++) {\\n                for(int32_t k = j + 1; k < points.size(); k++) {\\n                    double area = triangleArea(points[i], points[j], points[k]);\\n                    result = std::max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using Point = std::vector<int32_t>;\\n\\n    double triangleArea(Point const& p0, Point const& p1, Point const& p2) {\\n        return 0.5 * std::abs((p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]));\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int32_t i = 0; i < points.size(); i++) {\\n            for(int32_t j = i + 1; j < points.size(); j++) {\\n                for(int32_t k = j + 1; k < points.size(); k++) {\\n                    double area = triangleArea(points[i], points[j], points[k]);\\n                    result = std::max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380846,
                "title": "go-brute-force-o-n-3-please-let-me-know-if-you-find-faster-way-to-do-that",
                "content": "I fill like it is not optimal way, but it works. Let me know of you find better way to do that.\\n\\n# Code\\n```\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\tMAX := func(v1, v2 float64) float64 {\\n\\t\\tif v1 > v2 {\\n\\t\\t\\treturn v1\\n\\t\\t}\\n\\t\\treturn v2\\n\\t}\\n\\n\\tvar result float64\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif i == k || j == k {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// s = 1/2 (X2 * X1)(Y3-Y1) - (X3-X1)(Y2-Y1)\\n\\t\\t\\t\\tx1 := float64(points[i][0])\\n\\t\\t\\t\\ty1 := float64(points[i][1])\\n\\n\\t\\t\\t\\tx2 := float64(points[j][0])\\n\\t\\t\\t\\ty2 := float64(points[j][1])\\n\\n\\t\\t\\t\\tx3 := float64(points[k][0])\\n\\t\\t\\t\\ty3 := float64(points[k][1])\\n\\n\\t\\t\\t\\tresult = MAX(result, 0.5*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\tMAX := func(v1, v2 float64) float64 {\\n\\t\\tif v1 > v2 {\\n\\t\\t\\treturn v1\\n\\t\\t}\\n\\t\\treturn v2\\n\\t}\\n\\n\\tvar result float64\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif i == k || j == k {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// s = 1/2 (X2 * X1)(Y3-Y1) - (X3-X1)(Y2-Y1)\\n\\t\\t\\t\\tx1 := float64(points[i][0])\\n\\t\\t\\t\\ty1 := float64(points[i][1])\\n\\n\\t\\t\\t\\tx2 := float64(points[j][0])\\n\\t\\t\\t\\ty2 := float64(points[j][1])\\n\\n\\t\\t\\t\\tx3 := float64(points[k][0])\\n\\t\\t\\t\\ty3 := float64(points[k][1])\\n\\n\\t\\t\\t\\tresult = MAX(result, 0.5*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3361483,
                "title": "java-easy-and-fastest",
                "content": "\\tclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0.0;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i+1; j < points.length; j++) {\\n                for (int k = j+1; k < points.length; k++) {\\n                    double area = getTriangleArea(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, area);\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n    \\n    private double getTriangleArea(int[] p1, int[] p2, int[] p3) {\\n        return 0.5 * Math.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]));\\n    }\\n}\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math"
                ],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0.0;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i+1; j < points.length; j++) {\\n                for (int k = j+1; k < points.length; k++) {\\n                    double area = getTriangleArea(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, area);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3352507,
                "title": "largest-triangle-area-problem-c",
                "content": "\\n\\n# Approach\\nThis is a C++ code that calculates the largest possible area of a triangle using the coordinates of given points. The function largestTriangleArea takes a 2D vector points as input, where each element is a 2D vector representing the (x, y) coordinates of a point on a plane.\\n\\nThe code uses a brute-force approach to calculate the area of all possible triangles that can be formed using the given points. It does this by iterating through all possible combinations of three points and calculating the area of the triangle formed by them using the formula for the area of a triangle:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328508,
                "title": "3-nested-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ar=0\\n        for i in range(0,len(points)-2):\\n            x1,y1=points[i]\\n            for j in range (i,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > ar:\\n                        ar=abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        return ar\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ar=0\\n        for i in range(0,len(points)-2):\\n            x1,y1=points[i]\\n            for j in range (i,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > ar:\\n                        ar=abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        return ar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274960,
                "title": "code-for-find-the-maximum-area-of-the-triangle",
                "content": "# Code for find Maximum area of the triangle.\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3225804,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188955,
                "title": "math-approach",
                "content": "# Intuition\\nTake all points one by one and calculate the area of each triangle.\\n\\n# Approach\\nTake variable to store area.\\nIterate on all points and apply area formula.\\nNext compare area by max function and find max area.\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(int i = 0 ; i < points.size() ; i++)\\n        {\\n            for(int j = i + 1 ; j < points.size() ; j++)\\n            {\\n                for(int k = j + 1 ; k < points.size() ; k++)\\n                {\\n                    area = max(area , abs(0.5 * (points[i][0] * (points[j][1] - points[k][1]) + points[j][0] * (points[k][1] - points[i][1]) + points[k][0] * (points[i][1] - points[j][1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```*Italic*\\n---\\n\\n```javascript []\\nconsole.log(\\'Hello world!\\')\\n```javascript []\\n```\\n```\\nconsole.log(\\'Hello world!\\')\\n```javascript []\\n> ``$$[[console.log(\\'Hello world!\\')]()]()$$``\\n![Screenshot 2023-01-24 093700.png](https://assets.leetcode.com/users/images/978ea4d6-3655-4e90-9dc7-75f4605f0edb_1676462373.1911116.png)\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n```\\n```\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(int i = 0 ; i < points.size() ; i++)\\n        {\\n            for(int j = i + 1 ; j < points.size() ; j++)\\n            {\\n                for(int k = j + 1 ; k < points.size() ; k++)\\n                {\\n                    area = max(area , abs(0.5 * (points[i][0] * (points[j][1] - points[k][1]) + points[j][0] * (points[k][1] - points[i][1]) + points[k][0] * (points[i][1] - points[j][1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```\n```javascript []\\nconsole.log(\\'Hello world!\\')\\n```\n```\\n```\n```javascript []\\n> ``$$[[console.log(\\'Hello world!\\')]()]()$$``\\n![Screenshot 2023-01-24 093700.png](https://assets.leetcode.com/users/images/978ea4d6-3655-4e90-9dc7-75f4605f0edb_1676462373.1911116.png)\\n```\n```python []\\nprint(\\'Hello world!\\')\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n```\n```python []\\nprint(\\'Hello world!\\')\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188881,
                "title": "math-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188838,
                "title": "python-beats-92-with-explanation",
                "content": "# Intuition\\nAs there are at most 50 point, a brute force search should work. Given a triplet of points (x_1,y_1), (x_2,y_2) and (x_3,y_3), the area of the triangle with vertices these 3 points is \\n\\nA = 2^(-1)|x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|.\\n# Approach\\nWe run a brute force approach using the above formula and updating the answer if we find a larger area \\n\\n# Complexity\\n- Time complexity:\\nWe consider all the triples so we get O(n^3)\\n\\n- Space complexity:\\nO(1) as we keep track only of the largest area. \\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        ans  = 0\\n\\n        n = len(points)\\n\\n        for i in range(n):\\n            x_1,y_1 = points[i]\\n            for j in range(i+1,n):\\n                x_2,y_2 = points[j]\\n                for k in range(j+1,n):\\n                    x_3,y_3 = points[k]\\n\\n                    area0 = abs((x_1*(y_2-y_3) + x_2*(y_3-y_1) + x_3*(y_1-y_2))/2)\\n\\n                    if area0>= ans:\\n                        ans = area0\\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        ans  = 0\\n\\n        n = len(points)\\n\\n        for i in range(n):\\n            x_1,y_1 = points[i]\\n            for j in range(i+1,n):\\n                x_2,y_2 = points[j]\\n                for k in range(j+1,n):\\n                    x_3,y_3 = points[k]\\n\\n                    area0 = abs((x_1*(y_2-y_3) + x_2*(y_3-y_1) + x_3*(y_1-y_2))/2)\\n\\n                    if area0>= ans:\\n                        ans = area0\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161130,
                "title": "python-easy-solutions-3-for",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        area = 0\\n\\n        for i in points:\\n            for j in points:\\n                for k in points:\\n                    if i!=j and i!=k and j!=k:\\n                        r = ( (i[0]*j[1]) + (j[0]*k[1]) + (k[0]*i[1])) - ((i[0]*k[1]) + (k[0]*j[1]) + (j[0]*i[1]) )\\n                        r=r/2\\n                        if r>area:\\n                            area=r\\n        \\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        area = 0\\n\\n        for i in points:\\n            for j in points:\\n                for k in points:\\n                    if i!=j and i!=k and j!=k:\\n                        r = ( (i[0]*j[1]) + (j[0]*k[1]) + (k[0]*i[1])) - ((i[0]*k[1]) + (k[0]*j[1]) + (j[0]*i[1]) )\\n                        r=r/2\\n                        if r>area:\\n                            area=r\\n        \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149786,
                "title": "easy-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120108,
                "title": "easy-c-solution-using-array-math-geometry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solve this question using using Array + Math  + Geometry.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple we have check the area of every 3 point combination and return the maximum area and we have given cordination of geometry so we have apply the formula of the triangle area with 3 coordinates\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity: O(N^3), where N is the length of points(Array).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity: O(1) Constant Space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity: O(N^3), where N is the length of points(Array).\\n    Space Complexity: O(1) Constant Space.\\n                        \\n    Solved Using Array + Math + Geometry;\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size();\\n        double areaOfLargestTriangle = INT_MIN;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    double area = abs((1/2.0)*(points[i][0]*(points[j][1]-points[k][1]) + \\n                    points[j][0]*(points[k][1]-points[i][1]) + points[k][0]*(points[i][1]-points[j][1])));\\n                    areaOfLargestTriangle = max(areaOfLargestTriangle, area);\\n                }\\n            }\\n        }\\n        return areaOfLargestTriangle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity: O(N^3), where N is the length of points(Array).\\n    Space Complexity: O(1) Constant Space.\\n                        \\n    Solved Using Array + Math + Geometry;\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size();\\n        double areaOfLargestTriangle = INT_MIN;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    double area = abs((1/2.0)*(points[i][0]*(points[j][1]-points[k][1]) + \\n                    points[j][0]*(points[k][1]-points[i][1]) + points[k][0]*(points[i][1]-points[j][1])));\\n                    areaOfLargestTriangle = max(areaOfLargestTriangle, area);\\n                }\\n            }\\n        }\\n        return areaOfLargestTriangle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117700,
                "title": "clean-solution",
                "content": "# Intuition\\nWe have to use three for loops here and complexity will be $$O(n^3)$$.\\n\\n# Approach\\nWe iterate through all points combination and take the max area. \\nTriangle area is calculated using the three points formulae.\\n\\n$$1/2 [x1 (y2 \\u2013 y3 ) + x2 (y3 \\u2013 y1 ) + x3(y1 \\u2013 y2)]$$\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double maxa=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double x1=points[i][0],y1=points[i][1];\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                double x2=points[j][0],y2=points[j][1];\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    double x3=points[k][0],y3=points[k][1];\\n                    maxa=max(maxa, 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                }\\n            }\\n        }\\n        return maxa;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double maxa=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double x1=points[i][0],y1=points[i][1];\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                double x2=points[j][0],y2=points[j][1];\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    double x3=points[k][0],y3=points[k][1];\\n                    maxa=max(maxa, 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                }\\n            }\\n        }\\n        return maxa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113567,
                "title": "simple-solution-brute-force-without-using-square-root-and-floating-point-variables",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size(), x1, y1, x2, y2, x3, y3, area, max_area = 0;\\n        for(int i = 0; i < n; i++) {\\n            x1 = points[i][0], y1 = points[i][1];\\n            for(int j = 0; j < n; j++) {\\n                x2 = points[j][0], y2 = points[j][1];\\n                for(int k = 0; k < n; k++) {\\n                    x3 = points[k][0], y3 = points[k][1];\\n                    area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\\n                    max_area = max(abs(area), max_area);\\n                }\\n            }\\n        }\\n        return 0.5 * double(max_area);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size(), x1, y1, x2, y2, x3, y3, area, max_area = 0;\\n        for(int i = 0; i < n; i++) {\\n            x1 = points[i][0], y1 = points[i][1];\\n            for(int j = 0; j < n; j++) {\\n                x2 = points[j][0], y2 = points[j][1];\\n                for(int k = 0; k < n; k++) {\\n                    x3 = points[k][0], y3 = points[k][1];\\n                    area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\\n                    max_area = max(abs(area), max_area);\\n                }\\n            }\\n        }\\n        return 0.5 * double(max_area);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107761,
                "title": "easy-c-solution-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n   class Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                     \\n                     double x1=points[i][0];\\n                     double y1=points[i][1];\\n                     double x2=points[j][0];\\n                     double y2=points[j][1];\\n                     double x3=points[k][0];\\n                     double y3=points[k][1];\\n\\n                     double area=0.5 * (abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                    maxi=max(area,maxi);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};  \\n\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                     \\n                     double x1=points[i][0];\\n                     double y1=points[i][1];\\n                     double x2=points[j][0];\\n                     double y2=points[j][1];\\n                     double x3=points[k][0];\\n                     double y3=points[k][1];\\n\\n                     double area=0.5 * (abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                    maxi=max(area,maxi);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3091654,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0;\\n        for (auto i = 0; i < points.size() - 2; ++i) {\\n            for (auto j = i + 1; j < points.size() - 1; ++j) {\\n                for (auto k = j + 1; k < points.size(); ++k) {\\n                    auto ij = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\\n                    auto ik = sqrt(pow(points[i][0] - points[k][0], 2) + pow(points[i][1] - points[k][1], 2));\\n                    auto jk = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2));\\n                    if (ij < ik + jk && ik < ij + jk && jk < ij + ik) {\\n                        auto s = (ij + ik + jk) / 2;\\n                        result = max(result, sqrt(s * (s - ij) * (s - ik) * (s - jk)));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0;\\n        for (auto i = 0; i < points.size() - 2; ++i) {\\n            for (auto j = i + 1; j < points.size() - 1; ++j) {\\n                for (auto k = j + 1; k < points.size(); ++k) {\\n                    auto ij = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\\n                    auto ik = sqrt(pow(points[i][0] - points[k][0], 2) + pow(points[i][1] - points[k][1], 2));\\n                    auto jk = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2));\\n                    if (ij < ik + jk && ik < ij + jk && jk < ij + ik) {\\n                        auto s = (ij + ik + jk) / 2;\\n                        result = max(result, sqrt(s * (s - ij) * (s - ik) * (s - jk)));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071226,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        \\n        double ans = 0.0d;\\n\\n        for(int i=0; i<points.length-2; i++){\\n            for(int j=i+1; j<points.length-1; j++){\\n                for(int k=j+1; k<points.length; k++){\\n\\n                    double x1 = points[i][0]; double y1 = points[i][1];\\n                    double x2 = points[j][0]; double y2 = points[j][1];\\n                    double x3 = points[k][0]; double y3 = points[k][1];\\n\\n                    double area = Math.abs( (x1*(y2-y3)) + (x2*(y3-y1)) + (x3*(y1-y2)) ) / 2;\\n                    ans = Math.max(ans,area);\\n                    \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        \\n        double ans = 0.0d;\\n\\n        for(int i=0; i<points.length-2; i++){\\n            for(int j=i+1; j<points.length-1; j++){\\n                for(int k=j+1; k<points.length; k++){\\n\\n                    double x1 = points[i][0]; double y1 = points[i][1];\\n                    double x2 = points[j][0]; double y2 = points[j][1];\\n                    double x3 = points[k][0]; double y3 = points[k][1];\\n\\n                    double area = Math.abs( (x1*(y2-y3)) + (x2*(y3-y1)) + (x3*(y1-y2)) ) / 2;\\n                    ans = Math.max(ans,area);\\n                    \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060722,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double result = 0;\\n        for (int x = 0; x < points.length; x++) {\\n            for (int y = x + 1; y < points.length; y++) {\\n                for (int z = y + 1; z < points.length; z++) {\\n                    double area = Math.abs((points[x][0] * points[y][1] +\\n                                            points[y][0] * points[z][1] +\\n                                            points[z][0] * points[x][1]) - \\n                            \\n                                            (points[x][1] * points[y][0] + \\n                                            points[y][1] * points[z][0] +\\n                                            points[z][1] * points[x][0])) / (double) 2;\\n                    result = Math.max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double result = 0;\\n        for (int x = 0; x < points.length; x++) {\\n            for (int y = x + 1; y < points.length; y++) {\\n                for (int z = y + 1; z < points.length; z++) {\\n                    double area = Math.abs((points[x][0] * points[y][1] +\\n                                            points[y][0] * points[z][1] +\\n                                            points[z][0] * points[x][1]) - \\n                            \\n                                            (points[x][1] * points[y][0] + \\n                                            points[y][1] * points[z][0] +\\n                                            points[z][1] * points[x][0])) / (double) 2;\\n                    result = Math.max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060398,
                "title": "python-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the largest area of a triangle that can be formed using a given list of points.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem by using the shoelace formula to calculate the area of each triangle that can be formed using 3 points from the list of points. The shoelace formula is a mathematical formula that can be used to calculate the area of a polygon by summing the product of the coordinates of the vertices of the polygon.\\n\\nWe can use the itertools.combinations function to generate all possible combinations of 3 points from the list of points. We can then use the shoelace formula to calculate the area of each triangle and keep track of the largest area.\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area(a, b, c):\\n            return 0.5 * abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1] - a[1] * b[0] - b[1] * c[0] - c[1] * a[0])\\n        return max(area(*triangle) for triangle in itertools.combinations(points, 3))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area(a, b, c):\\n            return 0.5 * abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1] - a[1] * b[0] - b[1] * c[0] - c[1] * a[0])\\n        return max(area(*triangle) for triangle in itertools.combinations(points, 3))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053691,
                "title": "basic-area-of-triangle-formula",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = 0.0\\n\\n        def calc_area(p1, p2, p3):\\n            return abs(0.5*( p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]) ))\\n\\n        for i in range(0,len(points)-2):\\n            for j in range(i+1, len(points)-1):\\n                for k in range(j+1, len(points)):\\n                    area = max(area, calc_area(points[i], points[j], points[k]))\\n\\n        print(area)\\n        return area\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = 0.0\\n\\n        def calc_area(p1, p2, p3):\\n            return abs(0.5*( p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]) ))\\n\\n        for i in range(0,len(points)-2):\\n            for j in range(i+1, len(points)-1):\\n                for k in range(j+1, len(points)):\\n                    area = max(area, calc_area(points[i], points[j], points[k]))\\n\\n        print(area)\\n        return area\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030146,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        val n = points.size\\n        var max = 0.0\\n        for (i in 0..n-3) {\\n            for (j in i+1..n-2) {\\n                for (k in j+1..n-1) {\\n                    max = maxOf(max, calArea(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return max\\n    }\\n\\n    private fun calArea(p1: IntArray, p2: IntArray, p3: IntArray): Double {\\n        return Math.abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1]))/2.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        val n = points.size\\n        var max = 0.0\\n        for (i in 0..n-3) {\\n            for (j in i+1..n-2) {\\n                for (k in j+1..n-1) {\\n                    max = maxOf(max, calArea(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return max\\n    }\\n\\n    private fun calArea(p1: IntArray, p2: IntArray, p3: IntArray): Double {\\n        return Math.abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1]))/2.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009209,
                "title": "c-area-of-triangle-math-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was to obviously look for methods to find the area of triangle using geometry \\nSo, i found three methods to go around the solution and chose the one suitable for me\\n\\nIf you want to read and look at the methods\\n\\n[Methods To Find area of triangle using math](https://byjus.com/maths/area-triangle-coordinate-geometry/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn above link you will be able to find 3 methods to solve this specific problem and i went with the method 3, so you can take a look at that method before reading the approach\\n\\nNow we need 3 pair of points in minimum to create a triangle in the cartesian plane, \\n\\n1) so we create three for loop so we can take 3 pair of points from the given points vector. now because we need three pair minimum and in cartesian plane no pair can be repeated we take a gap of 1 pair between each thats why we take  <i < points.size()-2 >, <j < points.size()-1> and <i < points.size()>\\n\\n2) now we pass these pair of points to 3 different vector named <pointX> , <pointY> and <pointZ>, so that we can access the individual index of each pair\\n\\n3) then we use are Method 3 formula to find the area and save it to temp\\n\\n4) using max function we compare <maxArea> and <temp> and check for max value , we do this till be have found the maximum area and finally return it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n3 for loop used for nesting so time complexity will be O(N^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nno extra space used so space complexity will be O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        float maxArea=0.0;\\n        for(int i=0;i<points.size()-2;i++)\\n        {\\n            for(int j=i+1;j<points.size()-1;j++)\\n            {\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    vector <int> pointX =points[i];\\n                    vector <int> pointY=points[j];\\n                    vector <int> pointZ=points[k];\\n                    float tempArea=0;\\n                    tempArea = 0.5*abs(pointX[0]*(pointY[1]-pointZ[1])+pointY[0]*(pointZ[1]-pointX[1])+pointZ[0]*(pointX[1]-pointY[1]));\\n                    maxArea = max(tempArea,maxArea);\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        float maxArea=0.0;\\n        for(int i=0;i<points.size()-2;i++)\\n        {\\n            for(int j=i+1;j<points.size()-1;j++)\\n            {\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    vector <int> pointX =points[i];\\n                    vector <int> pointY=points[j];\\n                    vector <int> pointZ=points[k];\\n                    float tempArea=0;\\n                    tempArea = 0.5*abs(pointX[0]*(pointY[1]-pointZ[1])+pointY[0]*(pointZ[1]-pointX[1])+pointZ[0]*(pointX[1]-pointY[1]));\\n                    maxArea = max(tempArea,maxArea);\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007770,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        \\n        func area(_ x: [Double], _ y: [Double], _ z: [Double]) -> Double {\\n            \\n            let a = ((x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1])).squareRoot()\\n            let b = ((z[0] - y[0]) * (z[0] - y[0]) + (z[1] - y[1]) * (z[1] - y[1])).squareRoot()\\n            let c = ((z[0] - x[0]) * (z[0] - x[0]) + (z[1] - x[1]) * (z[1] - x[1])).squareRoot()\\n            \\n            let s = (a + b + c) / 2\\n            \\n            return (s * (s - a) * (s - b) * (s - c)).squareRoot()\\n        }\\n        \\n        let p = points.map { $0.map(Double.init) }\\n        \\n        var res = 0.0\\n        \\n        for i in 0..<p.count {\\n            for j in 0..<p.count where j != i {\\n                for l in 0..<p.count where l != i && l != j {\\n                    res = max(res, area(p[i], p[j], p[l]))\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        \\n        func area(_ x: [Double], _ y: [Double], _ z: [Double]) -> Double {\\n            \\n            let a = ((x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1])).squareRoot()\\n            let b = ((z[0] - y[0]) * (z[0] - y[0]) + (z[1] - y[1]) * (z[1] - y[1])).squareRoot()\\n            let c = ((z[0] - x[0]) * (z[0] - x[0]) + (z[1] - x[1]) * (z[1] - x[1])).squareRoot()\\n            \\n            let s = (a + b + c) / 2\\n            \\n            return (s * (s - a) * (s - b) * (s - c)).squareRoot()\\n        }\\n        \\n        let p = points.map { $0.map(Double.init) }\\n        \\n        var res = 0.0\\n        \\n        for i in 0..<p.count {\\n            for j in 0..<p.count where j != i {\\n                for l in 0..<p.count where l != i && l != j {\\n                    res = max(res, area(p[i], p[j], p[l]))\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947888,
                "title": "very-inefficient-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEz, just calculate the area of all the triangles formed and return the largest value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBRUTE FORCE! the area calculation with 3 $for$ loops, one for each point. Get the formula for area of a triangle in cartesian coordinates from your high school math textbook.\\n\\n# Complexity\\n- Time complexity: _Extremely_ inefficient O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ans = 0\\n        for x in range(len(points)):\\n            for y in range(1, len(points)):\\n                for z in range(2, len(points)):\\n                    ans = max(ans, \\n                    abs(1/2 * (points[x][0]* (points[y][1] - points[z][1]) + points[y][0] * \\n                    (points[z][1] - points[x][1]) + points[z][0] * (points[x][1] - points[y][1]))))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ans = 0\\n        for x in range(len(points)):\\n            for y in range(1, len(points)):\\n                for z in range(2, len(points)):\\n                    ans = max(ans, \\n                    abs(1/2 * (points[x][0]* (points[y][1] - points[z][1]) + points[y][0] * \\n                    (points[z][1] - points[x][1]) + points[z][0] * (points[x][1] - points[y][1]))))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947437,
                "title": "99-faster-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int len=points.length;\\n        double ar=Integer.MIN_VALUE;\\n        for(int i=0;i<len-2;i++)\\n        {\\n            for(int j=i+1;j<len-1;j++)\\n            {\\n                for(int k=j+1;k<len;k++)\\n\\n{\\n    ar=Math.max(ar,area(points[i],points[j],points[k]));\\n}            }\\n        }\\n        return ar;\\n    }\\npublic double area(int[] a,int[] b,int[] c)\\n{\\n    return Math.abs(((a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-a[0]*c[1]-b[0]*a[1]-c[0]*b[1])*1.0)/2.0);\\n}\\n    \\n        \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int len=points.length;\\n        double ar=Integer.MIN_VALUE;\\n        for(int i=0;i<len-2;i++)\\n        {\\n            for(int j=i+1;j<len-1;j++)\\n            {\\n                for(int k=j+1;k<len;k++)\\n\\n{\\n    ar=Math.max(ar,area(points[i],points[j],points[k]));\\n}            }\\n        }\\n        return ar;\\n    }\\npublic double area(int[] a,int[] b,int[] c)\\n{\\n    return Math.abs(((a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-a[0]*c[1]-b[0]*a[1]-c[0]*b[1])*1.0)/2.0);\\n}\\n    \\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939234,
                "title": "python3-concise-solution-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933195,
                "title": "simple-solution-using-basic-math-formulae-100ms",
                "content": "# Intuition\\nThis question seems easy at first when you think you have to use formulae of finding area of a triangle but becomes tricky when you realise it area of a triangle using coordinates not length sides etc.\\nso formulae here would be |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|and not(1/2*base*height) or if you try solving it using s = (a + b + c)/2\\n\\u221A[s \\xD7 (s \\u2013 a) \\xD7 (s \\u2013 b) \\xD7 (s \\u2013 c)] then the calculation becomes a little lengthier. Hence simple approach is to use |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)| formulae all you need to do is get the coordinates of the triangle ad put in the formulae.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area_cal(corr1, corr2, corr3):\\n            (x1, y1), (x2, y2), (x3, y3) = corr1, corr2, corr3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(area_cal(corr1, corr2, corr3) for corr1, corr2, corr3 in itertools.combinations(points, 3))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area_cal(corr1, corr2, corr3):\\n            (x1, y1), (x2, y2), (x3, y3) = corr1, corr2, corr3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(area_cal(corr1, corr2, corr3) for corr1, corr2, corr3 in itertools.combinations(points, 3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864041,
                "title": "c-easy-pure-math-formula-nothing-special",
                "content": "# Code\\n```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var s = -1.0;\\n        for(int i=0;i<points.Length-2;i++){\\n            for(int j=i+1;j<points.Length-1;j++){\\n                for(int k=j+1;k<points.Length;k++){\\n                    var currentArea = GetArea(new int[][]{points[i], points[j], points[k]});\\n                    if(s < currentArea){\\n                        s = currentArea;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n\\n    private double GetArea(int[][] point){\\n        var a = Math.Sqrt(Math.Pow(point[0][0] - point[1][0], 2) + Math.Pow(point[0][1] - point[1][1], 2));\\n        var b = Math.Sqrt(Math.Pow(point[1][0] - point[2][0], 2) + Math.Pow(point[1][1] - point[2][1], 2));\\n        var c = Math.Sqrt(Math.Pow(point[2][0] - point[0][0], 2) + Math.Pow(point[2][1] - point[0][1], 2));\\n        var avg = (a+b+c)/2;\\n        var s = Math.Sqrt(avg*(avg-a)*(avg-b)*(avg-c));\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var s = -1.0;\\n        for(int i=0;i<points.Length-2;i++){\\n            for(int j=i+1;j<points.Length-1;j++){\\n                for(int k=j+1;k<points.Length;k++){\\n                    var currentArea = GetArea(new int[][]{points[i], points[j], points[k]});\\n                    if(s < currentArea){\\n                        s = currentArea;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n\\n    private double GetArea(int[][] point){\\n        var a = Math.Sqrt(Math.Pow(point[0][0] - point[1][0], 2) + Math.Pow(point[0][1] - point[1][1], 2));\\n        var b = Math.Sqrt(Math.Pow(point[1][0] - point[2][0], 2) + Math.Pow(point[1][1] - point[2][1], 2));\\n        var c = Math.Sqrt(Math.Pow(point[2][0] - point[0][0], 2) + Math.Pow(point[2][1] - point[0][1], 2));\\n        var avg = (a+b+c)/2;\\n        var s = Math.Sqrt(avg*(avg-a)*(avg-b)*(avg-c));\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847374,
                "title": "c",
                "content": "```\\ndouble largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n    double max = 0;\\n\\n    for(int i = 0; i < pointsSize-2; i++){\\n        for(int j = i+1; j < pointsSize-1; j++){\\n            for(int k = j+1; k < pointsSize; k++){\\n                   int x1 = points[i][0], y1 = points[i][1];\\n                   int x2 = points[j][0], y2 = points[j][1];\\n                   int x3 = points[k][0], y3 = points[k][1];\\n                   double area = fabs(0.5 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));\\n                   max = fmax(max, area);\\n            }\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n    double max = 0;\\n\\n    for(int i = 0; i < pointsSize-2; i++){\\n        for(int j = i+1; j < pointsSize-1; j++){\\n            for(int k = j+1; k < pointsSize; k++){\\n                   int x1 = points[i][0], y1 = points[i][1];\\n                   int x2 = points[j][0], y2 = points[j][1];\\n                   int x3 = points[k][0], y3 = points[k][1];\\n                   double area = fabs(0.5 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));\\n                   max = fmax(max, area);\\n            }\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2845874,
                "title": "python-simple-fromula-based",
                "content": "This is a brute force based approach where we iterate over all three sets of points and find the maximum area of traingles formed by all these sets of points.\\n**Time Complexity: O(n^3)\\nSpace Complexity: O(1)**\\n\\nArea of a triangle when three points of its vertices are given, is represented in matrix form as:\\n```\\nArea= (1/2)*abs(determinant(\\n[x1,y1,1],\\n[x2,y2,1],\\n[x3,y3,1]))\\n```\\nThis is expanded and used in a function as shown below\\n```\\ndef area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n```\\nThe complete solution is\\n```\\nclass Solution:\\n    def area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        maxarea=0\\n        for i in range(len(p)-2):\\n            for j in range(i+1,len(p)-1):\\n                for k in range(j+1,len(p)):\\n                    maxarea=max(maxarea,self.area(p[i][0],p[i][1],p[j][0],p[j][1],p[k][0],p[k][1]))\\n        return maxarea\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nArea= (1/2)*abs(determinant(\\n[x1,y1,1],\\n[x2,y2,1],\\n[x3,y3,1]))\\n```\n```\\ndef area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n```\n```\\nclass Solution:\\n    def area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        maxarea=0\\n        for i in range(len(p)-2):\\n            for j in range(i+1,len(p)-1):\\n                for k in range(j+1,len(p)):\\n                    maxarea=max(maxarea,self.area(p[i][0],p[i][1],p[j][0],p[j][1],p[k][0],p[k][1]))\\n        return maxarea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844274,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double ans=0.0;\\n        int i=0;\\n        while(i<points.size())\\n        {\\n          int j=i+1;\\n          while(j<points.size())\\n          {\\n            int k=j+1;\\n            while(k<points.size())\\n            {\\n               //x1(y2-y3)\\n               double a=points[i][0]*(points[j][1]-points[k][1]);\\n               //x2(y3-y1)\\n               double b=points[j][0]*(points[k][1]-points[i][1]);\\n               //x3(y1-y2)\\n               double c=points[k][0]*(points[i][1]-points[j][1]);\\n               double x=0.5;\\n               long double area=(x)*(abs(a+b+c));\\n               if(area>ans)\\n               ans=area;\\n              //  cout<<\"area: \"<<area<<endl;\\n              //  v.push_back(area);\\n               k++;\\n            }\\n            j++;\\n          }\\n          i++;\\n        }\\n        //we cant use this below function as this max and min function is for int data types only.\\n        //int max=*max_element(v.begin(),v.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double ans=0.0;\\n        int i=0;\\n        while(i<points.size())\\n        {\\n          int j=i+1;\\n          while(j<points.size())\\n          {\\n            int k=j+1;\\n            while(k<points.size())\\n            {\\n               //x1(y2-y3)\\n               double a=points[i][0]*(points[j][1]-points[k][1]);\\n               //x2(y3-y1)\\n               double b=points[j][0]*(points[k][1]-points[i][1]);\\n               //x3(y1-y2)\\n               double c=points[k][0]*(points[i][1]-points[j][1]);\\n               double x=0.5;\\n               long double area=(x)*(abs(a+b+c));\\n               if(area>ans)\\n               ans=area;\\n              //  cout<<\"area: \"<<area<<endl;\\n              //  v.push_back(area);\\n               k++;\\n            }\\n            j++;\\n          }\\n          i++;\\n        }\\n        //we cant use this below function as this max and min function is for int data types only.\\n        //int max=*max_element(v.begin(),v.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2842832,
                "title": "optimized-brute-force-approach-10ms-89-7-5mb-90-c",
                "content": "1. Use formula to calculate triangle area given 3 points.\\n2. For each loop-shell, store the pointer to data of the specific point to reduce repeated access to vector.\\n3. Use integer operations all the time, store area result with 2x (so you don\\'t need to x0.5 and can keep using integer). Only need to do x0.5 for return.\\n4. Do not use function calls.\\n5. Area could be negative but you don\\'t need to use abs(), just negate the value if it is negative.\\n```\\nclass Solution {\\n    // Given the 3 points, calculate triangle area using formula:\\n    // area = 1/2 * abs[x1(y2-y3)+x2(y3-y1)+x3(y1-y2)]\\n    // Reference: https://www.cuemath.com/geometry/area-of-triangle-in-coordinate-geometry/\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int maxArea;\\n        int i, j, k, n;\\n        int *p0, *p1, *p2;\\n        int area;\\n        \\n        n = points.size();\\n        maxArea = 0;\\n        // Full search, need n*(n-1)*(n-2)/6 operations.\\n        for (i=0;i<n-2;i++) {\\n            p0 = points[i].data();\\n            for (j=i+1;j<n-1;j++) {\\n                p1 = points[j].data();\\n                for (k=j+1;k<n;k++) {\\n                    p2 = points[k].data();\\n                    area = p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]);\\n                    if (area < 0)\\n                        area = -area;\\n                    if (area > maxArea) {\\n                        maxArea = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (double) maxArea * 0.5;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    // Given the 3 points, calculate triangle area using formula:\\n    // area = 1/2 * abs[x1(y2-y3)+x2(y3-y1)+x3(y1-y2)]\\n    // Reference: https://www.cuemath.com/geometry/area-of-triangle-in-coordinate-geometry/\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int maxArea;\\n        int i, j, k, n;\\n        int *p0, *p1, *p2;\\n        int area;\\n        \\n        n = points.size();\\n        maxArea = 0;\\n        // Full search, need n*(n-1)*(n-2)/6 operations.\\n        for (i=0;i<n-2;i++) {\\n            p0 = points[i].data();\\n            for (j=i+1;j<n-1;j++) {\\n                p1 = points[j].data();\\n                for (k=j+1;k<n;k++) {\\n                    p2 = points[k].data();\\n                    area = p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]);\\n                    if (area < 0)\\n                        area = -area;\\n                    if (area > maxArea) {\\n                        maxArea = area;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2829991,
                "title": "easy-c-solution-faster-than-58",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n         int l = p.size();\\n    double mx = 0;\\n    for (int i = 0; i < l - 2; i++) {\\n        for (int j = i + 1; j < l - 1; j++) {\\n            for (int k = j + 1; k < l; k++) {\\n                mx = max(mx, 0.5 * abs(\\n                                p[i][0] * (p[j][1] - p[k][1]) +\\n                                p[j][0] * (p[k][1] - p[i][1]) +\\n                                p[k][0] * (p[i][1] - p[j][1])\\n                ));\\n            }\\n        }\\n    }\\n    return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n         int l = p.size();\\n    double mx = 0;\\n    for (int i = 0; i < l - 2; i++) {\\n        for (int j = i + 1; j < l - 1; j++) {\\n            for (int k = j + 1; k < l; k++) {\\n                mx = max(mx, 0.5 * abs(\\n                                p[i][0] * (p[j][1] - p[k][1]) +\\n                                p[j][0] * (p[k][1] - p[i][1]) +\\n                                p[k][0] * (p[i][1] - p[j][1])\\n                ));\\n            }\\n        }\\n    }\\n    return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801630,
                "title": "rust-not-so-fast-but-easy-to-understand",
                "content": "\\n}\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n\\t\\n\\t\\tfn find_area(a: Vec<i32>, b: Vec<i32>, c:Vec<i32>) ->f64{\\n\\t\\t\\tlet sum = a[0]*(b[1]-c[1]) + b[0] * (c[1]-a[1]) + c[0] * (a[1] - b[1]);\\n\\t\\t\\tlet sum = sum as f64 / 2.;\\n\\n\\t\\t\\tsum\\n        let mut highest = 0 as f64;\\n        for a in 0..points.len()-2{\\n            for b in 1+a..points.len()-1{\\n                for c in 1+b..points.len(){\\n                    let mut after = find_area(points[a].to_vec(), points[b].to_vec(), points[c].to_vec()).abs();\\n                    let out = f64::trunc(after  * 100000.0) / 100000.0;\\n                    if out > highest{\\n                        highest = out;\\n                    }\\n                }\\n            }\\n        }\\n        highest\\n    }\\n}",
                "solutionTags": [],
                "code": "\\n}\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n\\t\\n\\t\\tfn find_area(a: Vec<i32>, b: Vec<i32>, c:Vec<i32>) ->f64{\\n\\t\\t\\tlet sum = a[0]*(b[1]-c[1]) + b[0] * (c[1]-a[1]) + c[0] * (a[1] - b[1]);\\n\\t\\t\\tlet sum = sum as f64 / 2.;\\n\\n\\t\\t\\tsum\\n        let mut highest = 0 as f64;\\n        for a in 0..points.len()-2{\\n            for b in 1+a..points.len()-1{\\n                for c in 1+b..points.len(){\\n                    let mut after = find_area(points[a].to_vec(), points[b].to_vec(), points[c].to_vec()).abs();\\n                    let out = f64::trunc(after  * 100000.0) / 100000.0;\\n                    if out > highest{\\n                        highest = out;\\n                    }\\n                }\\n            }\\n        }\\n        highest\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2783108,
                "title": "python-clean-and-simple-solution",
                "content": "```\\nfrom itertools import combinations\\n\\nPoint = tuple[int, int]\\nTriangle = tuple[Point, Point, Point]\\n\\n\\nclass Solution:\\n\\n    def largestTriangleArea(self, points: list[Point]) -> float:\\n        \"\"\"\\n        @posted Solution: https://leetcode.com/problems/largest-triangle-area/discuss/2783108/Python-oror-Clean-and-Simple-Solution\\n        :param points:\\n        :return:\\n        \"\"\"\\n        # return max(self.area1(p) for p in combinations(points, 3))\\n        return max(self.area2(p) for p in combinations(points, 3))\\n\\n    @staticmethod\\n    def area2(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        (x1, y1), (x2, y2), (x3, y3) = p\\n\\n        return abs(\\n            x1 * (y2 - y3) +\\n            x2 * (y3 - y1) +\\n            x3 * (y1 - y2)\\n        ) / 2\\n\\n    @staticmethod\\n    def area1(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        #         x[i]  * (y[(i + 1) % 3]    -   y[(i + 2) % 3])\\n        a = sum(p[i][0] * (p[(i + 1) % 3][1] - p[(i + 2) % 3][1]) for i in range(3))\\n        return abs(a) / 2\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom itertools import combinations\\n\\nPoint = tuple[int, int]\\nTriangle = tuple[Point, Point, Point]\\n\\n\\nclass Solution:\\n\\n    def largestTriangleArea(self, points: list[Point]) -> float:\\n        \"\"\"\\n        @posted Solution: https://leetcode.com/problems/largest-triangle-area/discuss/2783108/Python-oror-Clean-and-Simple-Solution\\n        :param points:\\n        :return:\\n        \"\"\"\\n        # return max(self.area1(p) for p in combinations(points, 3))\\n        return max(self.area2(p) for p in combinations(points, 3))\\n\\n    @staticmethod\\n    def area2(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        (x1, y1), (x2, y2), (x3, y3) = p\\n\\n        return abs(\\n            x1 * (y2 - y3) +\\n            x2 * (y3 - y1) +\\n            x3 * (y1 - y2)\\n        ) / 2\\n\\n    @staticmethod\\n    def area1(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        #         x[i]  * (y[(i + 1) % 3]    -   y[(i + 2) % 3])\\n        a = sum(p[i][0] * (p[(i + 1) % 3][1] - p[(i + 2) % 3][1]) for i in range(3))\\n        return abs(a) / 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767886,
                "title": "c-o-n-3-solution-approach-explained-with-equations",
                "content": "# Intuition\\nThe intuition behind solving this problem is to check the knowledge of basic geometry. We will be given some co-ordinates. And we need to make a triangle that has larger area. Just leave the `larger` portion for now. If we have any 3 co-ordinate what do we do to form a triangle? \\n - Draw lines between all 3 co-ordinates.\\n - Calculate side length of all 3 lines.\\n - Then apply Heron\\'s formula (https://www.mathopenref.com/heronsformula.html) to find out the area. \\n\\nRight?\\nHere we will do the same thing. By drawing lines, here we will calculate the distance among the co-ordinates. To calculate the distance between any two co-ordinate, we will use - $$sqrt{( (x_1-x_2)^2 + (y_1-y_2))^2}$$ formula.\\n\\nAfter having length of all three sides, we will use **Heron\\'s** formula which is - \\n$$s * (s-a) * (s-b) *(s-c)$$ where $$a, b, c = Length \\\\space of \\\\space sides$$ and $$ s = (a+b+c)\\\\div 2$$.\\n\\n# Approach\\n- We will run 3 nested loops which will denote selection of any three co-ordinates.\\n- Draw lines between those three co-ordinates which means calculate distance between any two points using abovementioned rule.\\n- Apply **Heron\\'s** formula to calculate area mentioned above.\\n- Calculate max among areas.\\n- Return the Max Area.\\n\\n# Complexity\\n- Time complexity: $$O(n*n*n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double get_distance(int x1, int y1, int x2, int y2){\\n        double x_dist = (x1 * 1.0) - (x2 * 1.0);\\n        x_dist *= x_dist;\\n        double y_dist = (y1 * 1.0) - (y2 * 1.0);\\n        y_dist *= y_dist;\\n        double dist = sqrt(x_dist + y_dist);\\n        return dist;\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<double>distance;\\n        int n = points.size();\\n        double ans_area = 0.0, side_a, side_b, side_c, sum, area;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    side_a = get_distance(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                    side_b = get_distance(points[i][0], points[i][1], points[k][0], points[k][1]);\\n                    side_c = get_distance(points[j][0], points[j][1], points[k][0], points[k][1]);\\n                    sum = (side_a + side_b + side_c)/2.0;\\n                    side_a = sum - side_a;\\n                    side_b = sum - side_b;\\n                    side_c = sum - side_c;\\n                    area = sqrt(sum * side_a * side_b * side_c);\\n                    ans_area = max(ans_area, area);\\n                }\\n            }\\n        }\\n        return ans_area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double get_distance(int x1, int y1, int x2, int y2){\\n        double x_dist = (x1 * 1.0) - (x2 * 1.0);\\n        x_dist *= x_dist;\\n        double y_dist = (y1 * 1.0) - (y2 * 1.0);\\n        y_dist *= y_dist;\\n        double dist = sqrt(x_dist + y_dist);\\n        return dist;\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<double>distance;\\n        int n = points.size();\\n        double ans_area = 0.0, side_a, side_b, side_c, sum, area;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    side_a = get_distance(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                    side_b = get_distance(points[i][0], points[i][1], points[k][0], points[k][1]);\\n                    side_c = get_distance(points[j][0], points[j][1], points[k][0], points[k][1]);\\n                    sum = (side_a + side_b + side_c)/2.0;\\n                    side_a = sum - side_a;\\n                    side_b = sum - side_b;\\n                    side_c = sum - side_c;\\n                    area = sqrt(sum * side_a * side_b * side_c);\\n                    ans_area = max(ans_area, area);\\n                }\\n            }\\n        }\\n        return ans_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735179,
                "title": "go-brute-force",
                "content": "```\\nfunc largestTriangleArea(points [][]int) float64 {\\n    area := 0.0\\n    l := len(points)\\n    \\n    for  p1 := 0; p1 < l; p1++ {\\n        for p2 := p1 + 1; p2 < l; p2++ {\\n            for p3 := p2 + 1; p3 < l; p3++ {\\n                    area = math.Max(area, getArea(points[p1], points[p2], points[p3]))\\n                }\\n            }\\n        }\\n    \\n    return area\\n}\\n\\nfunc getArea(p1, p2, p3 []int) float64 {\\n        return math.Abs(float64(p2[0] - p1[0]) * float64(p3[1] - p1[1]) - \\n                        float64(0.5) * float64(p2[0] - p1[0]) * float64(p2[1] - p1[1]) - \\n                       float64(0.5) * float64(p3[0] - p1[0]) * float64(p3[1] - p1[1]) -\\n                       float64(0.5) * float64(p2[0] - p3[0]) * float64(p3[1] - p2[1]))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestTriangleArea(points [][]int) float64 {\\n    area := 0.0\\n    l := len(points)\\n    \\n    for  p1 := 0; p1 < l; p1++ {\\n        for p2 := p1 + 1; p2 < l; p2++ {\\n            for p3 := p2 + 1; p3 < l; p3++ {\\n                    area = math.Max(area, getArea(points[p1], points[p2], points[p3]))\\n                }\\n            }\\n        }\\n    \\n    return area\\n}\\n\\nfunc getArea(p1, p2, p3 []int) float64 {\\n        return math.Abs(float64(p2[0] - p1[0]) * float64(p3[1] - p1[1]) - \\n                        float64(0.5) * float64(p2[0] - p1[0]) * float64(p2[1] - p1[1]) - \\n                       float64(0.5) * float64(p3[0] - p1[0]) * float64(p3[1] - p1[1]) -\\n                       float64(0.5) * float64(p2[0] - p3[0]) * float64(p3[1] - p2[1]))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714619,
                "title": "easy-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    inline double triangleSquare(int x1, int y1, int x2, int y2, int x3, int y3)\\n    {\\n        return 0.5 * abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1));\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double square = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i; j < points.size(); j++)\\n            {\\n                for(int k = j; k < points.size(); k++)\\n                {\\n                    double s = triangleSquare(points[i][0], points[i][1], points[j][0], points[j][1],\\n                                              points[k][0], points[k][1]);\\n                    if(square < s)\\n                    {\\n                        square = s;\\n                    }\\n                }\\n            }\\n        }\\n        return square;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    inline double triangleSquare(int x1, int y1, int x2, int y2, int x3, int y3)\\n    {\\n        return 0.5 * abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1));\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double square = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i; j < points.size(); j++)\\n            {\\n                for(int k = j; k < points.size(); k++)\\n                {\\n                    double s = triangleSquare(points[i][0], points[i][1], points[j][0], points[j][1],\\n                                              points[k][0], points[k][1]);\\n                    if(square < s)\\n                    {\\n                        square = s;\\n                    }\\n                }\\n            }\\n        }\\n        return square;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707027,
                "title": "js-please-help-with-my-js-code-failed-two-test-case",
                "content": "i have passed 55 test case out of 57 with the below code , please help with this code about the other tw test case\\n\\n```\\nvar largestTriangleArea = function(points) {\\n    let pos = []\\n    let side_arr = []\\n    let arr = []\\n    \\n    \\n    for(let i = 0; i<points.length-2; i++){\\n        for(let j = i+1; j<points.length; j++){\\n            for(let k= j+1; k<points.length; k++){\\n                pos.push([points[i],points[j],points[k]])\\n            }\\n        }\\n    }\\n    \\n    for(let i=0; i<pos.length; i++){\\n         let a = Math.sqrt( ((pos[i][0][0]-pos[i][1][0])**2) + ((pos[i][0][1]-pos[i][1][1])**2) )\\n         let b = Math.sqrt( ((pos[i][1][0]-pos[i][2][0])**2) + ((pos[i][1][1]-pos[i][2][1])**2) )\\n         let c = Math.sqrt( ((pos[i][0][0]-pos[i][2][0])**2) + ((pos[i][0][1]-pos[i][2][1])**2) )\\n         \\n        side_arr.push([a,b,c])                           \\n    }\\n    \\n    for(let i=0; i<side_arr.length; i++){\\n        let p = (side_arr[i][0] + side_arr[i][1] + side_arr[i][2])/2\\n        let area = Math.sqrt( p*(p-side_arr[i][0])*(p-side_arr[i][1])*(p-side_arr[i][2]) )\\n        arr.push(area)\\n    }\\n    \\n    let ans = arr.sort((a,b)=>b-a)\\n    \\n    return ans[0]\\n\\t\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar largestTriangleArea = function(points) {\\n    let pos = []\\n    let side_arr = []\\n    let arr = []\\n    \\n    \\n    for(let i = 0; i<points.length-2; i++){\\n        for(let j = i+1; j<points.length; j++){\\n            for(let k= j+1; k<points.length; k++){\\n                pos.push([points[i],points[j],points[k]])\\n            }\\n        }\\n    }\\n    \\n    for(let i=0; i<pos.length; i++){\\n         let a = Math.sqrt( ((pos[i][0][0]-pos[i][1][0])**2) + ((pos[i][0][1]-pos[i][1][1])**2) )\\n         let b = Math.sqrt( ((pos[i][1][0]-pos[i][2][0])**2) + ((pos[i][1][1]-pos[i][2][1])**2) )\\n         let c = Math.sqrt( ((pos[i][0][0]-pos[i][2][0])**2) + ((pos[i][0][1]-pos[i][2][1])**2) )\\n         \\n        side_arr.push([a,b,c])                           \\n    }\\n    \\n    for(let i=0; i<side_arr.length; i++){\\n        let p = (side_arr[i][0] + side_arr[i][1] + side_arr[i][2])/2\\n        let area = Math.sqrt( p*(p-side_arr[i][0])*(p-side_arr[i][1])*(p-side_arr[i][2]) )\\n        arr.push(area)\\n    }\\n    \\n    let ans = arr.sort((a,b)=>b-a)\\n    \\n    return ans[0]\\n\\t\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704241,
                "title": "python-using-3-loop",
                "content": "\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        # base theory: Ax(By-Cy)+Bx(Cy-Ay)+Cx(Ay-By)\\n        def triangle(A,B,C):\\n            return abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1])) / 2\\n        largestArea = 0\\n        length = len(points)\\n        for i in range(length):  \\n            for j in range(i+1, length):\\n                for k in range(j+1, length):\\n                    largestArea = max(largestArea, triangle(points[i],points[j],points[k]))\\n        return largestArea",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        # base theory: Ax(By-Cy)+Bx(Cy-Ay)+Cx(Ay-By)\\n        def triangle(A,B,C):\\n            return abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1])) / 2\\n        largestArea = 0\\n        length = len(points)\\n        for i in range(length):  \\n            for j in range(i+1, length):\\n                for k in range(j+1, length):\\n                    largestArea = max(largestArea, triangle(points[i],points[j],points[k]))\\n        return largestArea",
                "codeTag": "Python3"
            },
            {
                "id": 2696584,
                "title": "python-straightforward-solution-faster-than-6-time-o-n-3-space-o-1",
                "content": "\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tnum_points = len(points)\\n\\t\\t\\tres = 0\\n\\n\\t\\t\\tlengths_list = list()\\n\\t\\t\\tfor i in range(num_points-2): \\n\\t\\t\\t\\tfor j in range(i+1, num_points-1): \\n\\t\\t\\t\\t\\tfor k in range(j+1, num_points): \\n\\t\\t\\t\\t\\t\\txi, yi = points[i]\\n\\t\\t\\t\\t\\t\\txj, yj = points[j]\\n\\t\\t\\t\\t\\t\\txk, yk = points[k]\\n\\t\\t\\t\\t\\t\\tside_a = ((xi - xj)**2 + (yi - yj)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_b = ((xi - xk)**2 + (yi - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_c = ((xj - xk)**2 + (yj - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tshort_side = min(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tlong_side = max(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tmid_side = (side_a+side_b+side_c)-short_side-long_side                                     \\n\\t\\t\\t\\t\\t\\tif short_side+mid_side>long_side:\\n\\t\\t\\t\\t\\t\\t\\tp = (side_a+side_b+side_c)/2\\n\\t\\t\\t\\t\\t\\t\\t# print(p, side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\t\\tcurr_area = (p*(p-side_a)*(p-side_b)*(p-side_c))**0.5\\n\\t\\t\\t\\t\\t\\t\\tif res<curr_area:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = curr_area\\n\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tnum_points = len(points)\\n\\t\\t\\tres = 0\\n\\n\\t\\t\\tlengths_list = list()\\n\\t\\t\\tfor i in range(num_points-2): \\n\\t\\t\\t\\tfor j in range(i+1, num_points-1): \\n\\t\\t\\t\\t\\tfor k in range(j+1, num_points): \\n\\t\\t\\t\\t\\t\\txi, yi = points[i]\\n\\t\\t\\t\\t\\t\\txj, yj = points[j]\\n\\t\\t\\t\\t\\t\\txk, yk = points[k]\\n\\t\\t\\t\\t\\t\\tside_a = ((xi - xj)**2 + (yi - yj)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_b = ((xi - xk)**2 + (yi - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_c = ((xj - xk)**2 + (yj - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tshort_side = min(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tlong_side = max(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tmid_side = (side_a+side_b+side_c)-short_side-long_side                                     \\n\\t\\t\\t\\t\\t\\tif short_side+mid_side>long_side:\\n\\t\\t\\t\\t\\t\\t\\tp = (side_a+side_b+side_c)/2\\n\\t\\t\\t\\t\\t\\t\\t# print(p, side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\t\\tcurr_area = (p*(p-side_a)*(p-side_b)*(p-side_c))**0.5\\n\\t\\t\\t\\t\\t\\t\\tif res<curr_area:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = curr_area\\n\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2696109,
                "title": "c-1-liner-math",
                "content": "The general idea is to try all combinations of 3 points, compute the area, then pick the largest computed value.\\n\\nRather than useing nested `for` loops, we use nested `Max` expressions.\\n\\nThe formula for computing thea area of a triangle is not something that most people are going to have memorized, so we look it up. The more common approach uses an absolute value, however because we are trying all points in all positions, we do not need to do this. We could have used array slicing to avoid trying all points in all positions, but it doesn\\'t affect the overall runtime of `O(n ^ 3)`\\n\\n```cs\\npublic double LargestTriangleArea(int[][] P) =>\\n    P.Max(a => P.Max(b => P.Max(c =>\\n        a[0] * b[1] + b[0] * c[1] + c[0] * a[1] -\\n        a[1] * b[0] - b[1] * c[0] - c[1] * a[0]\\n    ))) / 2D;\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [
                    "Math"
                ],
                "code": "```cs\\npublic double LargestTriangleArea(int[][] P) =>\\n    P.Max(a => P.Max(b => P.Max(c =>\\n        a[0] * b[1] + b[0] * c[1] + c[0] * a[1] -\\n        a[1] * b[0] - b[1] * c[0] - c[1] * a[0]\\n    ))) / 2D;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564791,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1565978,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1571906,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1571957,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 2068494,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 2012738,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1783232,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Sum of Averages",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. You can partition the array into <strong>at most</strong> <code>k</code> non-empty adjacent subarrays. The <strong>score</strong> of a partition is the sum of the averages of each subarray.</p>\n\n<p>Note that the partition must use every integer in <code>nums</code>, and that the score is not necessarily an integer.</p>\n\n<p>Return <em>the maximum <strong>score</strong> you can achieve of all the possible partitions</em>. Answers within <code>10<sup>-6</sup></code> of the actual answer will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9,1,2,3,9], k = 3\n<strong>Output:</strong> 20.00000\n<strong>Explanation:</strong> \nThe best choice is to partition nums into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned nums into [9, 1], [2], [3, 9], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 4\n<strong>Output:</strong> 20.50000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 126280,
                "title": "naive-detailed-step-by-step-approach-from-recursive-to-dp-o-n-solution",
                "content": "All the below methods share same logic:\\n1. Recursive Approach - Find recurrence equation\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        return h(A, K, sum, A.length, 0);\\n    }\\n    \\n    public double h(int[] A, int k, int[] sum, int len, int s) {\\n        if (k == 1) return ((double)(sum[len-1] - sum[s] + A[s]) / (len-s));\\n        double num = 0;\\n        for (int i = s; i + k <= len ; i++) {\\n            num = Math.max(num, ((double) (sum[i] - sum[s] + A[s]) / (i - s + 1)) + h(A, k-1, sum, len, i+1));\\n        }\\n        return num;\\n    }\\n}\\n```\\n2. Recursion + Top-Bottom Memoralization  - Seperate moving pieces\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        double[][] dp = new double[A.length][K+1];\\n        return h(A, K, sum, dp, A.length, 0);\\n    }\\n    \\n    public double h(int[] A, int k, int[] sum, double[][] dp, int len, int s) {\\n        if (dp[s][k] != 0) return dp[s][k];\\n        if (k == 1){\\n            dp[s][k] = ((double)(sum[len-1] - sum[s] + A[s]) / (len-s));\\n            return dp[s][k];\\n        }\\n        for (int i = s; i + k <= len ; i++) {\\n            dp[s][k] = Math.max(dp[s][k], ((double) (sum[i] - sum[s] + A[s]) / (i - s + 1)) + h(A, k-1, sum, dp, len, i+1));\\n        }\\n        return dp[s][k];\\n    }\\n}\\n```\\n3. Bottom-UP DP approach O(N ^ 3) Run Time and O(N ^ 2) space - This is crucial step. Recognise base case for Approach-2 and make sure you evolve from that base case to your result.\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        double[][] dp = new double[A.length][K+1];\\n        \\n        for (int groups = 1; groups <= K; groups++) {\\n            for (int s = 0; s + groups <= A.length; s++) {\\n                if (groups == 1) {\\n                    dp[s][groups] = ((double)(sum[A.length-1] - sum[s] + A[s]) / (A.length-s));\\n                    continue;\\n                }\\n                for (int e = s; e + groups <= A.length; e++) {\\n                    dp[s][groups] = Math.max(dp[s][groups], (dp[e+1][groups-1] + (double) (sum[e] - sum[s] + A[s]) / (e - s + 1)));\\n                }\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n}\\n```\\n4. Bottom-UP DP approach O(N ^ 3) Run Time and O(N) space - Check if can reduce Space complexity.\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        double[] dp = new double[A.length];\\n        \\n        for (int groups = 1; groups <= K; groups++) {\\n            for (int s = 0; s + groups <= A.length; s++) {\\n                if (groups == 1) {\\n                    dp[s] = ((double)(sum[A.length-1] - sum[s] + A[s]) / (A.length-s));\\n                    continue;\\n                }\\n                for (int e = s; e + groups <= A.length; e++) {\\n                    dp[s] = Math.max(dp[s], (dp[e+1] + (double) (sum[e] - sum[s] + A[s]) / (e - s + 1)));\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        return h(A, K, sum, A.length, 0);\\n    }\\n    \\n    public double h(int[] A, int k, int[] sum, int len, int s) {\\n        if (k == 1) return ((double)(sum[len-1] - sum[s] + A[s]) / (len-s));\\n        double num = 0;\\n        for (int i = s; i + k <= len ; i++) {\\n            num = Math.max(num, ((double) (sum[i] - sum[s] + A[s]) / (i - s + 1)) + h(A, k-1, sum, len, i+1));\\n        }\\n        return num;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        double[][] dp = new double[A.length][K+1];\\n        return h(A, K, sum, dp, A.length, 0);\\n    }\\n    \\n    public double h(int[] A, int k, int[] sum, double[][] dp, int len, int s) {\\n        if (dp[s][k] != 0) return dp[s][k];\\n        if (k == 1){\\n            dp[s][k] = ((double)(sum[len-1] - sum[s] + A[s]) / (len-s));\\n            return dp[s][k];\\n        }\\n        for (int i = s; i + k <= len ; i++) {\\n            dp[s][k] = Math.max(dp[s][k], ((double) (sum[i] - sum[s] + A[s]) / (i - s + 1)) + h(A, k-1, sum, dp, len, i+1));\\n        }\\n        return dp[s][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        double[][] dp = new double[A.length][K+1];\\n        \\n        for (int groups = 1; groups <= K; groups++) {\\n            for (int s = 0; s + groups <= A.length; s++) {\\n                if (groups == 1) {\\n                    dp[s][groups] = ((double)(sum[A.length-1] - sum[s] + A[s]) / (A.length-s));\\n                    continue;\\n                }\\n                for (int e = s; e + groups <= A.length; e++) {\\n                    dp[s][groups] = Math.max(dp[s][groups], (dp[e+1][groups-1] + (double) (sum[e] - sum[s] + A[s]) / (e - s + 1)));\\n                }\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum = new int[A.length];\\n        for (int i = 0;i < A.length; i++) sum[i] = A[i] + (i > 0 ? sum[i-1] : 0); \\n        double[] dp = new double[A.length];\\n        \\n        for (int groups = 1; groups <= K; groups++) {\\n            for (int s = 0; s + groups <= A.length; s++) {\\n                if (groups == 1) {\\n                    dp[s] = ((double)(sum[A.length-1] - sum[s] + A[s]) / (A.length-s));\\n                    continue;\\n                }\\n                for (int e = s; e + groups <= A.length; e++) {\\n                    dp[s] = Math.max(dp[s], (dp[e+1] + (double) (sum[e] - sum[s] + A[s]) / (e - s + 1)));\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122739,
                "title": "c-java-python-easy-understood-solution-with-explanation",
                "content": "```search``` return the result for ```n``` first numbers to ```k``` groups.\\nIt\\'s top-down solution and it keeps all process to memory.\\nSo it\\'s like a DP solution while DP is bottom-up.\\nI took suggestion from @MonnaGotIt and added a prunting: ```if (n < k) return 0;```\\n\\nTime complexity: ```O(KN^2)```\\n\\nC++:\\n```\\n    double memo[200][200];\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        memset(memo, 0, sizeof(memo));\\n        int N = A.size();\\n        double cur = 0;\\n        for (int i = 0; i < N; ++i) {\\n            cur += A[i];\\n            memo[i + 1][1] = cur / (i + 1);\\n        }\\n        return search(N, K, A);\\n    }\\n\\n    double search(int n, int k, vector<int>& A) {\\n        if (memo[n][k] > 0) return memo[n][k];\\n        if (n < k) return 0; // 14ms to 10ms\\n        double cur = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            cur += A[i];\\n            memo[n][k] = max(memo[n][k], search(i, k - 1, A) + cur / (n - i));\\n        }\\n        return memo[n][k];\\n    }\\n```\\nJava:\\n```\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int N = A.length;\\n        double[][] memo = new double[N+1][N+1];\\n        double cur = 0;\\n        for (int i = 0; i < N; ++i) {\\n            cur += A[i];\\n            memo[i + 1][1] = cur / (i + 1);\\n        }\\n        return search(N, K, A, memo);\\n    }\\n\\n    public double search(int n, int k, int[] A, double[][] memo) {\\n        if (memo[n][k] > 0) return memo[n][k];\\n        if (n < k) return 0;\\n        double cur = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            cur += A[i];\\n            memo[n][k] = Math.max(memo[n][k], search(i, k - 1, A, memo) + cur / (n - i));\\n        }\\n        return memo[n][k];\\n    }\\n```\\n\\nPython\\n```\\n    def largestSumOfAverages(self, A, K):\\n        memo = {}\\n        def search(n, k):\\n            if (n, k) in memo: return memo[n, k]\\n            if n < k: return 0\\n            if k == 1:\\n                memo[n, k] = sum(A[:n]) / float(n)\\n                return memo[n, k]\\n            cur, memo[n, k] = 0, 0\\n            for i in range(n - 1, 0, -1):\\n                cur += A[i]\\n                memo[n, k] = max(memo[n, k], search(i, k - 1) + cur / float(n - i))\\n            return memo[n, k]\\n        return search(len(A), K)\\n\\n",
                "solutionTags": [],
                "code": "```search```\n```n```\n```k```\n```if (n < k) return 0;```\n```O(KN^2)```\n```\\n    double memo[200][200];\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        memset(memo, 0, sizeof(memo));\\n        int N = A.size();\\n        double cur = 0;\\n        for (int i = 0; i < N; ++i) {\\n            cur += A[i];\\n            memo[i + 1][1] = cur / (i + 1);\\n        }\\n        return search(N, K, A);\\n    }\\n\\n    double search(int n, int k, vector<int>& A) {\\n        if (memo[n][k] > 0) return memo[n][k];\\n        if (n < k) return 0; // 14ms to 10ms\\n        double cur = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            cur += A[i];\\n            memo[n][k] = max(memo[n][k], search(i, k - 1, A) + cur / (n - i));\\n        }\\n        return memo[n][k];\\n    }\\n```\n```\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int N = A.length;\\n        double[][] memo = new double[N+1][N+1];\\n        double cur = 0;\\n        for (int i = 0; i < N; ++i) {\\n            cur += A[i];\\n            memo[i + 1][1] = cur / (i + 1);\\n        }\\n        return search(N, K, A, memo);\\n    }\\n\\n    public double search(int n, int k, int[] A, double[][] memo) {\\n        if (memo[n][k] > 0) return memo[n][k];\\n        if (n < k) return 0;\\n        double cur = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            cur += A[i];\\n            memo[n][k] = Math.max(memo[n][k], search(i, k - 1, A, memo) + cur / (n - i));\\n        }\\n        return memo[n][k];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122775,
                "title": "java-bottom-up-dp-with-explanation",
                "content": "Let `f[i][j]`be the largest sum of averages for first `i + 1` numbers`(A[0], A[1], ... , A[i])` to`j`groups. `f[i][j]` consists of two parts: first `j-1` groups\\' averages and the last group\\' s average. Considering the last group, its last number must be `A[i]` and its first number can be  from `A[0]` to `A[i]`. Suppose the last group starts from `A[p+1]`, we can easily get the average form `A[p+1]` to `A[i]`.  The sum of first  `j-1` groups\\'  average is `f[p][j-1]` which we have got before. So now we can write the DP equation:\\n` f[i][j] = max {f[p][j-1] + (A[p+1] + A[p+2] + ... + A[i]) / (i - p)}, p = 0,1,...,i-1`\\n\\n```java\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        if (K == 0 || A.length == 0) {\\n            return 0;\\n        }\\n        int l = A.length;\\n        double[][] f = new double[l][K + 1];\\n        double[] s = new double[l + 1];\\n        for (int i = 1; i <= l; i++) {\\n            s[i] = s[i - 1] + A[i - 1];\\n            f[i - 1][1] =  s[i] / i;\\n        }\\n        for (int j = 2; j <= K; j++) {\\n            for (int i = 0; i < l; i++) {\\n                double max = Double.MIN_VALUE;\\n                for (int p = 0; p < i; p++) {\\n                    double sum = f[p][j - 1] + (s[i + 1] - s[p + 1]) / (i - p);\\n                    max = Double.max(sum, max);\\n                }\\n                f[i][j] = max;\\n            }\\n        }\\n        return f[l - 1][K];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        if (K == 0 || A.length == 0) {\\n            return 0;\\n        }\\n        int l = A.length;\\n        double[][] f = new double[l][K + 1];\\n        double[] s = new double[l + 1];\\n        for (int i = 1; i <= l; i++) {\\n            s[i] = s[i - 1] + A[i - 1];\\n            f[i - 1][1] =  s[i] / i;\\n        }\\n        for (int j = 2; j <= K; j++) {\\n            for (int i = 0; i < l; i++) {\\n                double max = Double.MIN_VALUE;\\n                for (int p = 0; p < i; p++) {\\n                    double sum = f[p][j - 1] + (s[i + 1] - s[p + 1]) / (i - p);\\n                    max = Double.max(sum, max);\\n                }\\n                f[i][j] = max;\\n            }\\n        }\\n        return f[l - 1][K];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126003,
                "title": "c-dp-simple-solution-use-o-n-k-space-and-o-k-n-2-time-with-detailed-explanation",
                "content": "First, we should compute the sum array, which will be helpful when we compute mean value of subarray.\\nJust like, if we want to compute mean of subarray A[i] ~ A[j], we can use sum[j + 1] - sum[i] / (j + 1 - i).(There we use sum[i] represent the front i\\'s element of A\\'s sum).\\nThen we simply judge the special case,if K <= 1, we just compute the overall mean, if K >= n, we just return total sum as every single element be a subarray.\\nThen, we start to construct the dp vector.\\ndp[i][1] represent the largest sum of averages of front i\\'s element in A when K = 1, namely the mean of subarray A[0] ~A[i - 1].\\ndp[i][k] = max(dp[i][k], dp[j][k - 1] + 1.0 * (sum[i] - sum[j]) / (i - j)) means we split the k subarray to k -1 subarray in A[0] ~A[j - 1] and one more subarray from A[j] ~A[i - 1], use the sum we already computed, we can get this subarray\\'s mean easily.\\nFinally, we got the answer dp[n][K], so the total time complexity is O(K*n^2), and the total space complexity is O(n * K).\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<int> sum(n + 1, 0);\\n        for(int i = 0; i < n; ++i){\\n        \\tsum[i + 1] = sum[i] + A[i];\\n        }\\n        if(K <= 1){\\n        \\treturn (1.0 * sum[n]) / n;\\n        }\\n        if(K >= n){\\n        \\treturn sum[n];\\n        }\\n        vector<vector<double>> dp(n + 1, vector<double>(K + 1, 0.0));\\n        for(int i = 1; i <= n; ++i){\\n        \\tdp[i][1] = (1.0 * sum[i]) / i;\\n        }\\n        for(int k = 2; k <= K; ++k){\\n        \\tfor(int i = k; i <= n; ++i){\\n        \\t\\tfor(int j = i - 1; j >= k - 1; --j){\\n        \\t\\t\\tdp[i][k] = max(dp[i][k], dp[j][k - 1] + 1.0 * (sum[i] - sum[j]) / (i - j));\\n        \\t\\t}\\n        \\t\\t\\n        \\t}\\n        }\\n        return dp[n][K];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<int> sum(n + 1, 0);\\n        for(int i = 0; i < n; ++i){\\n        \\tsum[i + 1] = sum[i] + A[i];\\n        }\\n        if(K <= 1){\\n        \\treturn (1.0 * sum[n]) / n;\\n        }\\n        if(K >= n){\\n        \\treturn sum[n];\\n        }\\n        vector<vector<double>> dp(n + 1, vector<double>(K + 1, 0.0));\\n        for(int i = 1; i <= n; ++i){\\n        \\tdp[i][1] = (1.0 * sum[i]) / i;\\n        }\\n        for(int k = 2; k <= K; ++k){\\n        \\tfor(int i = k; i <= n; ++i){\\n        \\t\\tfor(int j = i - 1; j >= k - 1; --j){\\n        \\t\\t\\tdp[i][k] = max(dp[i][k], dp[j][k - 1] + 1.0 * (sum[i] - sum[j]) / (i - j));\\n        \\t\\t}\\n        \\t\\t\\n        \\t}\\n        }\\n        return dp[n][K];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475907,
                "title": "simple-bottom-up-and-top-down-dp-only-5-lines-with-detail-explanation-python3",
                "content": "How to define state is important to solve DP problems. For this problem,\\ndp[0][k] means from 0 to N-1 inclusively we have at most k groups .\\nd[i][k] means from index i of array A to N-1 inclusively we have at most k groups.\\nMore detail can be found from the comments of the bottom up approach.\\nBottom up solution with explanation\\n```\\nRuntime: 340 ms, faster than 43.48% of Python3 online submissions for Largest Sum of Averages.\\nMemory Usage: 13.1 MB, less than 100.00% of Python3 online submissions for Largest Sum of Averages.\\n```\\n```python\\nclass Solution:\\n    def largestSumOfAverages(self, a: List[int], k: int) -> float:\\n        cusum = list(itertools.accumulate([0]+a))\\n        N=len(a)\\n        #dp[0][k] means from 0 to N-1 inclusively we have at most k groups\\n        # dp[0][k] = maximum of below cases\\n        #average(a[:1])+dp[1][k-1] from 1 to N-1 inclusively we have at most k-1 groups\\n        #average(a[:2])+dp[2][k-1] from 2 to N-1 inclusively we have at most k-1 groups\\n        #...\\n        #average(a[:N-1])+dp[N-1][k-1] from N-1 to N-1 inclusively we have at most k-1 groups\\n        # dp[1][k-1] from 1 to N-1 inclusively we have at most k-1 groups\\n        # average(a[1:2])+dp[2][k-2]\\n        # average(a[1:3])+dp[3][k-2]\\n        # ...\\n        # average(a[1:N-1])+dp[N-1][k-2]\\n        # until now, the solution can be clear. We should maintain a 2D dp table\\n        # dp[i][k] it means maximum average sum \\n        #     from index i to N-1 inclusively, we have at most k groups\\n        # we can do it bottom up or top down\\n        # we can use cusum to speed up the average operation.\\n        dp = [[0]*(k+1) for i in range(len(a))]\\n        # the very bottom case will be k is 1, it means we only have one group from i to N-1 inclusively\\n        for at_most_group in range(1, k+1):\\n            for begin_i in range(N):\\n                if at_most_group == 1:\\n                    dp[begin_i][at_most_group] = (cusum[-1]-cusum[begin_i])/(N-begin_i)\\n                else:\\n                    this_res = []\\n                    for j in range(begin_i, N):\\n                        # we divide at_most_group to 1+(at_most_group-1)\\n                        # (at_most_group-1) is already caculated. \\n                        # for eaxmple, dp[3][2] means \\n                        # we are dividing list a from index 3 to N-1 into at most 2 groups\\n                        # if we pick up index 3 to 4 as first group, then we still need dp[5][1]\\n                        # dp[5][1] means we begin from index 5, we need at most 1 group.\\n                        # dp[5][1] is already caculated as k is from smaller to larger.\\n                        first_group_ave = (cusum[j+1]-cusum[begin_i])/(j-begin_i+1)\\n                        if j+1<N:\\n                            this_res.append(first_group_ave+dp[j+1][at_most_group-1])\\n                        else:\\n                            this_res.append(first_group_ave)\\n                    dp[begin_i][at_most_group] = max(this_res)\\n        # final result will be begin at 0 and at most it has k groups.\\n        return dp[0][k]\\n```\\n\\nWe can also have a top down approach based on similar idea.\\n\\n```\\nRuntime: 104 ms, faster than 98.84% of Python3 online submissions for Largest Sum of Averages.\\nMemory Usage: 13.6 MB, less than 100.00% of Python3 online submissions for Largest Sum of Averages.\\n```\\n\\n\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def largestSumOfAverages(self, a: List[int], k: int) -> float:\\n        cusum = list(itertools.accumulate([0]+a))\\n        @lru_cache(None)\\n        def dp(i, k):\\n            #if i>=len(a):return 0\\n            if k == 1:return (cusum[-1]-cusum[i])/(len(a)-i)\\n            return max((cusum[j+1]-cusum[i])/(j-i+1) + dp(j+1, k-1) for j in range(i, len(a)-k+1))\\n        \\n        return dp(0, k)\\n```\\n\\nFrom the analysis process of bottom up, we can see the complexity of this algorithm is \\nnumber of states O(nk)  by number of operation for each state. Each state, we are get the maximum from about n values, so the complexity for each state of O(n).\\nThe final time complexity will be O(kn^2)\\nReference \\nhttps://leetcode.com/problems/largest-sum-of-averages/discuss/122704/Simple-python-solution",
                "solutionTags": [],
                "code": "```\\nRuntime: 340 ms, faster than 43.48% of Python3 online submissions for Largest Sum of Averages.\\nMemory Usage: 13.1 MB, less than 100.00% of Python3 online submissions for Largest Sum of Averages.\\n```\n```python\\nclass Solution:\\n    def largestSumOfAverages(self, a: List[int], k: int) -> float:\\n        cusum = list(itertools.accumulate([0]+a))\\n        N=len(a)\\n        #dp[0][k] means from 0 to N-1 inclusively we have at most k groups\\n        # dp[0][k] = maximum of below cases\\n        #average(a[:1])+dp[1][k-1] from 1 to N-1 inclusively we have at most k-1 groups\\n        #average(a[:2])+dp[2][k-1] from 2 to N-1 inclusively we have at most k-1 groups\\n        #...\\n        #average(a[:N-1])+dp[N-1][k-1] from N-1 to N-1 inclusively we have at most k-1 groups\\n        # dp[1][k-1] from 1 to N-1 inclusively we have at most k-1 groups\\n        # average(a[1:2])+dp[2][k-2]\\n        # average(a[1:3])+dp[3][k-2]\\n        # ...\\n        # average(a[1:N-1])+dp[N-1][k-2]\\n        # until now, the solution can be clear. We should maintain a 2D dp table\\n        # dp[i][k] it means maximum average sum \\n        #     from index i to N-1 inclusively, we have at most k groups\\n        # we can do it bottom up or top down\\n        # we can use cusum to speed up the average operation.\\n        dp = [[0]*(k+1) for i in range(len(a))]\\n        # the very bottom case will be k is 1, it means we only have one group from i to N-1 inclusively\\n        for at_most_group in range(1, k+1):\\n            for begin_i in range(N):\\n                if at_most_group == 1:\\n                    dp[begin_i][at_most_group] = (cusum[-1]-cusum[begin_i])/(N-begin_i)\\n                else:\\n                    this_res = []\\n                    for j in range(begin_i, N):\\n                        # we divide at_most_group to 1+(at_most_group-1)\\n                        # (at_most_group-1) is already caculated. \\n                        # for eaxmple, dp[3][2] means \\n                        # we are dividing list a from index 3 to N-1 into at most 2 groups\\n                        # if we pick up index 3 to 4 as first group, then we still need dp[5][1]\\n                        # dp[5][1] means we begin from index 5, we need at most 1 group.\\n                        # dp[5][1] is already caculated as k is from smaller to larger.\\n                        first_group_ave = (cusum[j+1]-cusum[begin_i])/(j-begin_i+1)\\n                        if j+1<N:\\n                            this_res.append(first_group_ave+dp[j+1][at_most_group-1])\\n                        else:\\n                            this_res.append(first_group_ave)\\n                    dp[begin_i][at_most_group] = max(this_res)\\n        # final result will be begin at 0 and at most it has k groups.\\n        return dp[0][k]\\n```\n```\\nRuntime: 104 ms, faster than 98.84% of Python3 online submissions for Largest Sum of Averages.\\nMemory Usage: 13.6 MB, less than 100.00% of Python3 online submissions for Largest Sum of Averages.\\n```\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def largestSumOfAverages(self, a: List[int], k: int) -> float:\\n        cusum = list(itertools.accumulate([0]+a))\\n        @lru_cache(None)\\n        def dp(i, k):\\n            #if i>=len(a):return 0\\n            if k == 1:return (cusum[-1]-cusum[i])/(len(a)-i)\\n            return max((cusum[j+1]-cusum[i])/(j-i+1) + dp(j+1, k-1) for j in range(i, len(a)-k+1))\\n        \\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561245,
                "title": "top-down-bottom-up-with-detail-explanation",
                "content": "I know that there are many posts with good solutions already written for this problem (I\\'d recommend to check them all), however, it took me a good amount of time to come up with a  bottom-up solution. In this post, I\\'ll try to explain how I came up with a top-down solution and then transformed it to bottom-up.\\n\\nTop-down\\n\\n![image](https://assets.leetcode.com/users/dmgcodevil/image_1585874428.png)\\n\\nif K = 0 we simply return 0, if it equals 1 we calculate average in `A` starting from `i`, if we already found a solution for `(i,K)` we return it from the `memo`, otherwise, we try to extend `i` by adding more elements in the current group, recurse on `j+1` and `K-1` .  `j+1` - because an element at index `j` is already used in the current group `[i:j]`, `K-1` comes from the fact that we already calculating a value for the current group, i.e. `A[i:j]`\\n\\nUpper bound `N-K (inclusive)` or `N-K+1 (exclusive)` comes from the following observation: \\n\\n```\\nN=5 K=1, max elements in one group is 5\\nN=5 K=2, max elements in one group is 4\\nN=5 K=3, max elements in one group is 3\\nN=5 K=4, max elements in one group is 2\\nN=5 K=5, max elements in one group is 1\\n```\\n\\nNow it\\'s a straight forward to write a code for this solution.\\n\\n```java\\n    public static double largestSumOfAverages(int[] A, int K) {\\n        double[][] cache = new double[A.length][K + 1];\\n        return topDown(0, A, K, cache);\\n    }\\n\\n    static double topDown(int i, int[] A, int K, double[][] memo) {\\n        if (K <= 0 || i >= A.length) return 0;\\n        if (memo[i][K] != 0) return memo[i][K];\\n        if (K == 1) return avg(i, A);\\n\\n        double sum = 0;\\n        int max_group_size = A.length - K; // max elements in the group for the given K\\n        for (int j = i; j <= max_group_size; j++) {\\n            sum += A[j];\\n            memo[i][K] = Math.max(memo[i][K], sum / (j - i + 1) + topDown(j + 1, A, K - 1, memo));\\n        }\\n        return memo[i][K];\\n    }\\n    \\n\\t// helper functions. please use pre-sum\\n    static double avg(int start, int[] A, int end) {\\n        double sum = 0;\\n        for (int i = start; i <= end; i++) sum += A[i];\\n        return sum / (end - start + 1);\\n    }\\n\\n    static double avg(int start, int[] A) {\\n        return avg(start, A, A.length - 1);\\n    }\\n    \\n```\\n\\ntop-down (essentially `DFS` ) is an intuitive approach used to solve DP problems and I usually prefer it than iterative bottom-up. Finding a solution using a bottom-up approach might be very challenging or even impossible for some problems, however, it\\'s good for practicing.  There is no general rule that can be used to transform top-down to bottom-up, but there are few basic steps you can begin with. A  DP problem can be represented as directed acyclic graph (DAG) where vertices represent states and edges are functions that transform one state to another. Our goal is to define the initial states and a function that transforms S to S\\' where both states are optimal. It\\'s similar to topological sort. What would be a state for our problem? It\\'s `S(j,K)` for `A[i:j]`, i.e. `dp[j][k]` contains the maximum average sum (answer) for `K` groups and `[i:j]` elements. `S(j,1)` is our initial states, where `j = [0 ... N-1] ` and `K=1`  Let\\'s consider the following example: \\n\\nA=[1,2,3],K=2\\n\\nCalculate initial states for K=1\\n\\nf(S(0,1)) -> avg(A[0:0])->  1.0\\nf(S(1,1)) -> avg(A[0:1]) -> 1.5\\nf(S(2,1)) -> avg(A[0:2]) -> 2.0\\n\\nWhat would be the next state ? It\\'s `S(1,2)`.  Becuase we calculated all possble states for `K=1` and `j < N` . Solving the problem for `S(1,2)`  is equvalent to solving the problem for `A=[1,2], K=2`  with the optimal answer = `3.0` (we start from index `1` because solving the problem for `K > len(A[0:j])` makes no sense).   How can we reuse the results we have previously calculated? we already have the optimal solutiuon for `K =1` and `i=0` , hence we can calculate a new satate by using the following formula: `dp[i][k - 1] + avg(A[i + 1:j]) for all i < j; j<N; k<=K` , i.e. : `dp[0][1] + avg(A[1:1]) = 1.0 + 2.0 = 3.0.`. What is the next state ? It\\'s `S(2,2), j=2, k=2`: \\n\\nfor i=0 :  dp[2][2] = max(dp[2][2],  dp[0][1] + avg(A[1:2]) = 1.0 + 2.5 = 3.5 ); dp[2][2] = 3.5\\nfor i =1 : dp[2][2] = max(dp[2][2],  dp[1][1] + avg(A[2,2]) = 1.5 + 3.0 ) dp[2][2] = 4.5\\n\\n\\n\\nWe repeat the same algorithm for `2 ... K`. The final answer will be `dp[N-1][K]`:\\n\\n\\n```java\\n        if (K == 0 || A.length == 0) return 0;\\n        int N = A.length;\\n        double[][] dp = new double[N][K + 1];\\n        double sum = 0;\\n        for (int i = 0; i < N; i++) {\\n            sum += A[i];\\n            dp[i][1] = sum / (i + 1);\\n        }\\n \\n        for (int k = 2; k <= K; k++) {\\n            for (int j = k - 1; j < N; j++) {\\n                for (int i = 0; i < j; i++) {\\n                    dp[j][k] = Math.max(dp[j][k], dp[i][k - 1] + avg(i + 1, A, j));\\n                }\\n            }\\n        }\\n        return dp[N - 1][K];\\n```\\n\\n\\nAgain, use `pre-sum` instead of `avg`.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nN=5 K=1, max elements in one group is 5\\nN=5 K=2, max elements in one group is 4\\nN=5 K=3, max elements in one group is 3\\nN=5 K=4, max elements in one group is 2\\nN=5 K=5, max elements in one group is 1\\n```\n```java\\n    public static double largestSumOfAverages(int[] A, int K) {\\n        double[][] cache = new double[A.length][K + 1];\\n        return topDown(0, A, K, cache);\\n    }\\n\\n    static double topDown(int i, int[] A, int K, double[][] memo) {\\n        if (K <= 0 || i >= A.length) return 0;\\n        if (memo[i][K] != 0) return memo[i][K];\\n        if (K == 1) return avg(i, A);\\n\\n        double sum = 0;\\n        int max_group_size = A.length - K; // max elements in the group for the given K\\n        for (int j = i; j <= max_group_size; j++) {\\n            sum += A[j];\\n            memo[i][K] = Math.max(memo[i][K], sum / (j - i + 1) + topDown(j + 1, A, K - 1, memo));\\n        }\\n        return memo[i][K];\\n    }\\n    \\n\\t// helper functions. please use pre-sum\\n    static double avg(int start, int[] A, int end) {\\n        double sum = 0;\\n        for (int i = start; i <= end; i++) sum += A[i];\\n        return sum / (end - start + 1);\\n    }\\n\\n    static double avg(int start, int[] A) {\\n        return avg(start, A, A.length - 1);\\n    }\\n    \\n```\n```java\\n        if (K == 0 || A.length == 0) return 0;\\n        int N = A.length;\\n        double[][] dp = new double[N][K + 1];\\n        double sum = 0;\\n        for (int i = 0; i < N; i++) {\\n            sum += A[i];\\n            dp[i][1] = sum / (i + 1);\\n        }\\n \\n        for (int k = 2; k <= K; k++) {\\n            for (int j = k - 1; j < N; j++) {\\n                for (int i = 0; i < j; i++) {\\n                    dp[j][k] = Math.max(dp[j][k], dp[i][k - 1] + avg(i + 1, A, j));\\n                }\\n            }\\n        }\\n        return dp[N - 1][K];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122752,
                "title": "c-dp",
                "content": "    double largestSumOfAverages(vector<int>& A, int K) {\\n        if(A.empty() || K == 0)\\n            return 0;\\n        vector<vector<double>> dp(K+1,vector<double>(A.size(),0));\\n        vector<int> sum;\\n        sum.push_back(A[0]);\\n        for(int i = 1; i < A.size(); i++)\\n            sum.push_back(A[i] + sum.back());\\n        \\n        for(int k = 1; k <= K; k++){\\n            for(int i = k-1; i < A.size(); i++){\\n                if(k == 1)\\n                    dp[k][i] = double(sum[i])/(i+1);\\n                else{\\n                    for(int j = k-2 ; j < i; j++){\\n                        dp[k][i] = max(dp[k-1][j] + double(sum[i] - sum[j]) / (i - j),dp[k][i]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[K][A.size()-1];\\n    }",
                "solutionTags": [],
                "code": "    double largestSumOfAverages(vector<int>& A, int K) {\\n        if(A.empty() || K == 0)\\n            return 0;\\n        vector<vector<double>> dp(K+1,vector<double>(A.size(),0));\\n        vector<int> sum;\\n        sum.push_back(A[0]);\\n        for(int i = 1; i < A.size(); i++)\\n            sum.push_back(A[i] + sum.back());\\n        \\n        for(int k = 1; k <= K; k++){\\n            for(int i = k-1; i < A.size(); i++){\\n                if(k == 1)\\n                    dp[k][i] = double(sum[i])/(i+1);\\n                else{\\n                    for(int j = k-2 ; j < i; j++){\\n                        dp[k][i] = max(dp[k-1][j] + double(sum[i] - sum[j]) / (i - j),dp[k][i]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[K][A.size()-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 125872,
                "title": "python-dp-solution",
                "content": "\\n    def largestSumOfAverages(self, A, K):\\n        \\n        dp=[[0 for j in range(K)] for i in A]\\n        \\n         \\n        for j in range(len(A)):\\n            for i in range(K): \\n                if i==0:\\n                    dp[j][i]=sum(A[:j+1])/len(A[:j+1])\\n                else:\\n                    if len(A[:j+1])<i+1:\\n                        break\\n                    for k in range(j):\\n                        \\n                        dp[j][i]=max(dp[k][i-1]+sum(A[k+1:j+1])/len(A[k+1:j+1]),dp[j][i])\\n                        \\n    \\n        return dp[-1][-1]",
                "solutionTags": [],
                "code": "\\n    def largestSumOfAverages(self, A, K):\\n        \\n        dp=[[0 for j in range(K)] for i in A]\\n        \\n         \\n        for j in range(len(A)):\\n            for i in range(K): \\n                if i==0:\\n                    dp[j][i]=sum(A[:j+1])/len(A[:j+1])\\n                else:\\n                    if len(A[:j+1])<i+1:\\n                        break\\n                    for k in range(j):\\n                        \\n                        dp[j][i]=max(dp[k][i-1]+sum(A[k+1:j+1])/len(A[k+1:j+1]),dp[j][i])\\n                        \\n    \\n        return dp[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 2986326,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double dfs(vector<vector<double>>& dp, vector<int>& nums, int k, int i) {\\n        // reached all elements\\n        if (i >= nums.size()) return 0;\\n        // cannot further partition\\n        if (k == 0) return INT_MIN;\\n        // the result has been calculated before\\n        if (dp[i][k] != -1) return dp[i][k];\\n        double mx = INT_MIN, sum = 0;\\n        for (int j = i; j < nums.size(); j++) {\\n            // sum from nums[i .. j]\\n            sum += nums[j];\\n            // current partition + the best result starting from the next index\\n            mx = max(mx, sum / (j - i + 1) + dfs(dp, nums, k - 1, j + 1));\\n        }\\n        // memorise the result\\n        return dp[i][k] = mx;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        // The best score partitioning A[i:] into at most K parts\\n        vector<vector<double>> dp(n, vector<double>(k + 1, -1));\\n        // starting from index 0\\n        return dfs(dp, nums, k, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double dfs(vector<vector<double>>& dp, vector<int>& nums, int k, int i) {\\n        // reached all elements\\n        if (i >= nums.size()) return 0;\\n        // cannot further partition\\n        if (k == 0) return INT_MIN;\\n        // the result has been calculated before\\n        if (dp[i][k] != -1) return dp[i][k];\\n        double mx = INT_MIN, sum = 0;\\n        for (int j = i; j < nums.size(); j++) {\\n            // sum from nums[i .. j]\\n            sum += nums[j];\\n            // current partition + the best result starting from the next index\\n            mx = max(mx, sum / (j - i + 1) + dfs(dp, nums, k - 1, j + 1));\\n        }\\n        // memorise the result\\n        return dp[i][k] = mx;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        // The best score partitioning A[i:] into at most K parts\\n        vector<vector<double>> dp(n, vector<double>(k + 1, -1));\\n        // starting from index 0\\n        return dfs(dp, nums, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127181,
                "title": "c-4-lines-6-ms-dfs-memo",
                "content": "Like other solutions, with the goal to make it fast and compact. The recursive function splits the array at increasing ```i``` indexes, calculates the average for the newly formed group, and calls itself to calculate the largest sum for the remaining ```K - 1``` groups (DFS).\\n\\nWe use memoization to avoid processing the same groups repeatedly. The function output depends on two inputs  - the number of groups and position, so we need two-dimension array ```m``` to store results for all input combinations.\\n\\nNote that when ```K == 1```,  we just accumulate the sum untill we reach the end of the vector (``` i == A.size() - 1```). \\n```\\ndouble m[101][101] = {};\\ndouble largestSumOfAverages(vector<int>& A, int K, int p = 0) {\\n  if (p >= A.size() || m[K][p] > 0) return m[K][p];\\n  for (double i = p, sum = 0; i <= A.size() - K; ++i) {\\n      sum += A[i];\\n      if (K == 1 && i < A.size() - 1) continue;\\n      m[K][p] = max(m[K][p], sum / (i - p + 1) + largestSumOfAverages(A, K - 1, i + 1));\\n  }\\n  return m[K][p];\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```K - 1```\n```m```\n```K == 1```\n``` i == A.size() - 1```\n```\\ndouble m[101][101] = {};\\ndouble largestSumOfAverages(vector<int>& A, int K, int p = 0) {\\n  if (p >= A.size() || m[K][p] > 0) return m[K][p];\\n  for (double i = p, sum = 0; i <= A.size() - K; ++i) {\\n      sum += A[i];\\n      if (K == 1 && i < A.size() - 1) continue;\\n      m[K][p] = max(m[K][p], sum / (i - p + 1) + largestSumOfAverages(A, K - 1, i + 1));\\n  }\\n  return m[K][p];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160161,
                "title": "c-dp-recursive-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector < vector <double> > dp;\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        dp=vector<vector<double>>(n,vector<double>(K+1,-1));\\n        return helper(A,0,K);      \\n    }\\n    double helper(vector<int>& a,int idx,int k)\\n    {\\n        if(idx >= a.size()) return 0;\\n        if(!k) return INT_MIN;\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        double ans = INT_MIN;\\n        double sum = 0;\\n        for(int i = idx;i<a.size();i++)\\n        {\\n            sum = sum+a[i];\\n            ans = max(sum/(i-idx+1) + helper(a,i+1,k-1),ans);\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n};\\n```\\nQueries? Feel free to ask!\\nHappy Coding : )",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector < vector <double> > dp;\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        dp=vector<vector<double>>(n,vector<double>(K+1,-1));\\n        return helper(A,0,K);      \\n    }\\n    double helper(vector<int>& a,int idx,int k)\\n    {\\n        if(idx >= a.size()) return 0;\\n        if(!k) return INT_MIN;\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        double ans = INT_MIN;\\n        double sum = 0;\\n        for(int i = idx;i<a.size();i++)\\n        {\\n            sum = sum+a[i];\\n            ans = max(sum/(i-idx+1) + helper(a,i+1,k-1),ans);\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354479,
                "title": "dp-recursion-java-with-explanation-of-subproblems",
                "content": "This problem is about is tricky because of at most `k` splits, and getting `averages` for each split. The way I think about these array problems that ask to split the array or partition the array is to actually split the array in as many ways as possible. I will enumerate through all possible partitions and save the result in a DP. This might not be the most performant solution, but it has been reliable for me to solve the problem myself without looking at the solution first.\\n\\nExamining the below code, we start the recursion off with the two ranges of `start=0` `end=nums.length`. Our very first recursive call will attempt to split the `nums` array at every index. This is why we have a loop in the recursive function. Each recursive step is actually trying to build the BEST partition starting at `index=start`. Our recursive call within the loop gives us the BEST partition total sum of the partitions AFTER `index=start`.\\n\\nIn essence, we are trying to build the best partition at the curent index and asking the recursion to give us the best partition sums later on. This is the optimal substructure of this problem. \\n\\nThe state transfer equation decrements `k-1` and increments `start+1`. We decrement `k` because each call to `divide` means we are making a split. That means we are using a unit of `k`. The later subproblems that will find us the best partition sum after our current index will have `k-1` partitions to work with. We increment `i` because that is how we are saying we are making the next split.\\n\\n```\\nclass Solution {\\n  public double largestSumOfAverages(int[] nums, int k) {\\n    int n = nums.length;\\n    Double[][] dp = new Double[n][k];\\n    return divide(nums, 0, n, k-1, dp);\\n  }\\n  \\n  public double divide(int[] nums, int start, int end, int k, Double[][] dp) {\\n    if(start >= end) return 0;\\n    if(dp[start][k] != null) return dp[start][k];\\n    if(k == 0) {\\n      double lastPartitionSum = 0;\\n      for(int j = start; j < end; j++) {\\n        lastPartitionSum += nums[j];\\n      }\\n      return lastPartitionSum / (end - start);\\n    }\\n    \\n    double max = 0;\\n    for(int i = start+1; i < end; i++) { // try to split at every single index > start\\n      double res = divide(nums, i, end, k-1, dp);\\n      \\n      double currPartitionSum = 0;\\n      for(int j = start; j < i; j++) { // get the average of the partition we just tried to make\\n        currPartitionSum += nums[j];\\n      }\\n      double avg = currPartitionSum / (i - start); \\n      max = Math.max(res + avg, max); // optimal substructure, find the best partition at each index\\n    }\\n    dp[start][k] = max;\\n    return max;    \\n  }\\n}\\n```\\n\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  public double largestSumOfAverages(int[] nums, int k) {\\n    int n = nums.length;\\n    Double[][] dp = new Double[n][k];\\n    return divide(nums, 0, n, k-1, dp);\\n  }\\n  \\n  public double divide(int[] nums, int start, int end, int k, Double[][] dp) {\\n    if(start >= end) return 0;\\n    if(dp[start][k] != null) return dp[start][k];\\n    if(k == 0) {\\n      double lastPartitionSum = 0;\\n      for(int j = start; j < end; j++) {\\n        lastPartitionSum += nums[j];\\n      }\\n      return lastPartitionSum / (end - start);\\n    }\\n    \\n    double max = 0;\\n    for(int i = start+1; i < end; i++) { // try to split at every single index > start\\n      double res = divide(nums, i, end, k-1, dp);\\n      \\n      double currPartitionSum = 0;\\n      for(int j = start; j < i; j++) { // get the average of the partition we just tried to make\\n        currPartitionSum += nums[j];\\n      }\\n      double avg = currPartitionSum / (i - start); \\n      max = Math.max(res + avg, max); // optimal substructure, find the best partition at each index\\n    }\\n    dp[start][k] = max;\\n    return max;    \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112119,
                "title": "a-very-comprehensible-little-piece-of-recursion-and-memo-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int k) {\\n        \\n        vector <vector <double>> t(A.size() + 1, vector <double>(A.size() + 1, -1.00));\\n        \\n        double ans = solve(A, k, 0, t);\\n        \\n        return ans;\\n    }\\n    \\n    double solve(vector <int>& A, int k, int start, vector <vector <double>>& t)\\n    {\\n        if(k <= 0)       // Base condition\\n            return 0;  \\n        \\n        if(t[k][start] != -1.00)\\n            return t[k][start];   // Memo\\n        \\n        double res = 0.00;\\n        double sum = 0.00;\\n        \\n        for(int i = start; i < A.size(); i++)    // Different indices that we can break at.\\n        {\\n            sum += A[i];  // Sum till the particular index\\n            \\n            if(k != 1 || i == A.size() - 1) // Now this is a bit tricky part--\\n\\t\\t\\t//In here the code splits the array with the help of start and i but the splitting does not take place when k = 1, \\n\\t\\t\\t//because there cannot be anymore distributions, the whole array has to be considered if k == 1.\\n\\t\\t\\t//if you still didnt get it, try doing a dry run on k = 1 and A = {10, 1}.\\n\\t\\t\\t// Try first with this if condition and then without.\\n                res = max(res, sum / (i - start + 1) + solve(A, k - 1, i + 1, t)); // recursive call\\n        }\\n        \\n        return t[k][start] = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int k) {\\n        \\n        vector <vector <double>> t(A.size() + 1, vector <double>(A.size() + 1, -1.00));\\n        \\n        double ans = solve(A, k, 0, t);\\n        \\n        return ans;\\n    }\\n    \\n    double solve(vector <int>& A, int k, int start, vector <vector <double>>& t)\\n    {\\n        if(k <= 0)       // Base condition\\n            return 0;  \\n        \\n        if(t[k][start] != -1.00)\\n            return t[k][start];   // Memo\\n        \\n        double res = 0.00;\\n        double sum = 0.00;\\n        \\n        for(int i = start; i < A.size(); i++)    // Different indices that we can break at.\\n        {\\n            sum += A[i];  // Sum till the particular index\\n            \\n            if(k != 1 || i == A.size() - 1) // Now this is a bit tricky part--\\n\\t\\t\\t//In here the code splits the array with the help of start and i but the splitting does not take place when k = 1, \\n\\t\\t\\t//because there cannot be anymore distributions, the whole array has to be considered if k == 1.\\n\\t\\t\\t//if you still didnt get it, try doing a dry run on k = 1 and A = {10, 1}.\\n\\t\\t\\t// Try first with this if condition and then without.\\n                res = max(res, sum / (i - start + 1) + solve(A, k - 1, i + 1, t)); // recursive call\\n        }\\n        \\n        return t[k][start] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122704,
                "title": "simple-python-solution",
                "content": "```\\n    def largestSumOfAverages(self, a, k):\\n        def rec(st, k):\\n            if (st, k) in cache:\\n                return cache[(st, k)]\\n            if k == 1:\\n                cache[(st, k)] = sum(a[st:])/(len(a)-st)\\n                return cache[(st, k)]\\n            total = 0\\n            res = -math.inf\\n            for i in range(st, len(a)-k+1):\\n                total += a[i]\\n                res = max(res, (total/(i-st+1)) + rec(i+1, k-1))\\n            cache[(st, k)] = res\\n            return cache[(st, k)]\\n        cache = {}\\n        return rec(0, k)\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestSumOfAverages(self, a, k):\\n        def rec(st, k):\\n            if (st, k) in cache:\\n                return cache[(st, k)]\\n            if k == 1:\\n                cache[(st, k)] = sum(a[st:])/(len(a)-st)\\n                return cache[(st, k)]\\n            total = 0\\n            res = -math.inf\\n            for i in range(st, len(a)-k+1):\\n                total += a[i]\\n                res = max(res, (total/(i-st+1)) + rec(i+1, k-1))\\n            cache[(st, k)] = res\\n            return cache[(st, k)]\\n        cache = {}\\n        return rec(0, k)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 206267,
                "title": "my-self-explained-java-solution-with-dp-no-recursion-needed",
                "content": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        // dp[i][j] is the max average sum (MAS) of the array of length j (the subarray of A, starting from 0), with i partitions\\n        double[][] dp = new double[K + 1][A.length + 1]; \\n        double sum = 0.0;\\n        for (int j = 1; j <= A.length; j++) { // calculate the initial state, the MAS of 1 partition for each subarray\\n            sum += A[j - 1];\\n            dp[1][j] = sum / j;\\n        }\\n        for (int i = 2; i <= K; i++) { // itearate from 2 partitions\\n            for (int j = 1; j <= A.length; j++) {\\n                // for each dp[i][j], it can be dp[i - 1][k] + the average of (A[k, ..., j - 1])\\n                // then we iterate k from j - 1 to 0, and get max dp[i][j]\\n                sum = 0;\\n                for (int k = j - 1; k >= 0; k--) {\\n                    sum += A[k];\\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + sum / (j - k));\\n                }\\n            }\\n        }\\n        return dp[K][A.length];\\n    }\\n}\\n```\\nTime Complexity: O(KN^2)\\nSpace Complexity: O(KN), can be reduced to O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        // dp[i][j] is the max average sum (MAS) of the array of length j (the subarray of A, starting from 0), with i partitions\\n        double[][] dp = new double[K + 1][A.length + 1]; \\n        double sum = 0.0;\\n        for (int j = 1; j <= A.length; j++) { // calculate the initial state, the MAS of 1 partition for each subarray\\n            sum += A[j - 1];\\n            dp[1][j] = sum / j;\\n        }\\n        for (int i = 2; i <= K; i++) { // itearate from 2 partitions\\n            for (int j = 1; j <= A.length; j++) {\\n                // for each dp[i][j], it can be dp[i - 1][k] + the average of (A[k, ..., j - 1])\\n                // then we iterate k from j - 1 to 0, and get max dp[i][j]\\n                sum = 0;\\n                for (int k = j - 1; k >= 0; k--) {\\n                    sum += A[k];\\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + sum / (j - k));\\n                }\\n            }\\n        }\\n        return dp[K][A.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916679,
                "title": "dfs-dp-progression-with-explanation-o-kn-2-o-kn",
                "content": "In this problem, we are trying to find the combination of `k` groups that has the largest sum of averages.  DFS is a great tool to accomplish this as it allows us to look at all possible combinations.  We can think of an instance of a recursive call as a possible state of the problem, and each of the recursive calls as actions we can take to move to another state.\\n```\\ndef dfs(A, k):\\n\\tif not A:\\n\\t\\treturn 0\\n\\tif k == 1:\\n\\t\\treturn mean(A)\\n\\tlargest = 0\\n\\tfor i in range(1, len(A)):\\n\\t\\tcurr = mean(A[:i]) + dfs(A[i:], k - 1)\\n\\t\\tlargest = max(largest, curr)\\n\\treturn largest\\nreturn dfs(A, K)\\n```\\nLet\\'s take a look at what the DFS tree would look like.\\n![image](https://assets.leetcode.com/users/images/5e526e12-5b1b-4ffe-9315-cc8c71dd3585_1604082202.0873997.png)\\nwhere `m(...)` signifies the mean of those elements.  Notice this isn\\'t the entire DFS tree, but it should give you an idea of how the recursion works.  This DFS will solve the problem, but takes far too long and times out.  Why is that?  Notice that at the second level, we have `m(a) + m(b, c) + [d]` and `m(a, b) + m(c) + [d]`.  Both of these instances have taken the same amount of steps, and are about to make recursive calls to `dfs([d], k - 2))`.  These have the same exact state, and thus will result in the same answer.  Our implementation of DFS does not recognize this, and will take time to recalculate it anyways.  This is where the DP solution comes in.\\n\\nInstead of solving this problem from the top down `(k -> k - 1 -> ... -> 0)`, let\\'s instead build the solution from the ground up , saving the result at each step.\\n```\\ndef dp(A, K):\\n\\tdp = [[0] * len(A) for _ in range(K)]\\n\\tfor j in range(len(A)):\\n\\t\\tdp[0][j] = mean(A[:j + 1])\\n\\tfor k in range(1, K):\\n\\t\\tfor j in range(k, len(A)):\\n\\t\\t\\tfor i in range(j):\\n\\t\\t\\t\\tdp[k][j] = max(dp[k][j], dp[k - 1][i] + mean(A[i + 1:j + 1]))\\n\\treturn dp[-1][-1]\\nreturn dp(A, K)\\n```\\nNotice the recursive relation is exactly the same as the DFS approach.  For a given array, we iterate through all combinations of groupings, and keep the largest result.  We do not spend time recalculating combinations, and instead just reference the calculation that was already made.  \\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(A, k):\\n\\tif not A:\\n\\t\\treturn 0\\n\\tif k == 1:\\n\\t\\treturn mean(A)\\n\\tlargest = 0\\n\\tfor i in range(1, len(A)):\\n\\t\\tcurr = mean(A[:i]) + dfs(A[i:], k - 1)\\n\\t\\tlargest = max(largest, curr)\\n\\treturn largest\\nreturn dfs(A, K)\\n```\n```\\ndef dp(A, K):\\n\\tdp = [[0] * len(A) for _ in range(K)]\\n\\tfor j in range(len(A)):\\n\\t\\tdp[0][j] = mean(A[:j + 1])\\n\\tfor k in range(1, K):\\n\\t\\tfor j in range(k, len(A)):\\n\\t\\t\\tfor i in range(j):\\n\\t\\t\\t\\tdp[k][j] = max(dp[k][j], dp[k - 1][i] + mean(A[i + 1:j + 1]))\\n\\treturn dp[-1][-1]\\nreturn dp(A, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 166374,
                "title": "python-172-ms-bottom-up-dp",
                "content": "I have a very slow solution.I found this in the Accepted Solutions Runtime Distribution. \\n\\ndp[k][i] is the maximum sum of averages when the first i numbers are divided into k groups.\\n```\\ndp[k][i] = max(dp[k][i], dp[k-1][j] + (sums[i]-sums[j])/(i-j))\\n```\\ndp[first i numbers divided into k groups] = max (dp [first j numbers divided into k - 1 groups] + sums (A[j+1:i] )/ len( A[j+1:i])     for j in range(k-1, i).\\nO(K* N^2) Time, O(NK) space\\n```\\n      N = len(A)\\n        dp = [[0 for i in range(N)] for j in range(K)]\\n        sums = [0] * N\\n        \\n        sums[0] = A[0]\\n        dp[0][0] = A[0]\\n        for i in range(1,N):\\n            sums[i] = sums[i-1] + A[i]\\n            dp[0][i] = sums[i]/(i+1)\\n        \\n        for k in range(1,K):\\n            for i in range(k,N):\\n                maxj = 0\\n                for j in range(k-1,i):\\n                    tmp = dp[k-1][j] + (sums[i]-sums[j])/(i-j)\\n                    if tmp > maxj:\\n                        maxj = tmp\\n                dp[k][i] = maxj\\n        return dp[K-1][N-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndp[k][i] = max(dp[k][i], dp[k-1][j] + (sums[i]-sums[j])/(i-j))\\n```\n```\\n      N = len(A)\\n        dp = [[0 for i in range(N)] for j in range(K)]\\n        sums = [0] * N\\n        \\n        sums[0] = A[0]\\n        dp[0][0] = A[0]\\n        for i in range(1,N):\\n            sums[i] = sums[i-1] + A[i]\\n            dp[0][i] = sums[i]/(i+1)\\n        \\n        for k in range(1,K):\\n            for i in range(k,N):\\n                maxj = 0\\n                for j in range(k-1,i):\\n                    tmp = dp[k-1][j] + (sums[i]-sums[j])/(i-j)\\n                    if tmp > maxj:\\n                        maxj = tmp\\n                dp[k][i] = maxj\\n        return dp[K-1][N-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122751,
                "title": "java-dfs-memorization-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int len = A.length;\\n        double[] sum = new double[len];\\n\\t\\t\\t\\t\\n        sum[0] = A[0];\\n        for(int i = 1;i < len;i++)  sum[i] += sum[i - 1] + A[i];\\n        \\n        return backTrack(A, len, sum, 0, K, new double[len][K + 1]);\\n    }\\n    public double backTrack(int[] A, int len, double[] sum, int index, int K, double[][] dp){\\n        if(K == 1)              return (sum[len - 1] - sum[index] + A[index]) / (len - index);\\n        if(dp[index][K] != 0)   return dp[index][K];\\n        \\n        for(int i = index;i <= len - K;i++){\\n            dp[index][K] = Math.max(dp[index][K], (((sum[i] - sum[index] + A[index]) * 1.0) / (i - index + 1)) + backTrack(A, len, sum, i + 1, K - 1, dp));\\n        }\\n        \\n        return dp[index][K];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int len = A.length;\\n        double[] sum = new double[len];\\n\\t\\t\\t\\t\\n        sum[0] = A[0];\\n        for(int i = 1;i < len;i++)  sum[i] += sum[i - 1] + A[i];\\n        \\n        return backTrack(A, len, sum, 0, K, new double[len][K + 1]);\\n    }\\n    public double backTrack(int[] A, int len, double[] sum, int index, int K, double[][] dp){\\n        if(K == 1)              return (sum[len - 1] - sum[index] + A[index]) / (len - index);\\n        if(dp[index][K] != 0)   return dp[index][K];\\n        \\n        for(int i = index;i <= len - K;i++){\\n            dp[index][K] = Math.max(dp[index][K], (((sum[i] - sum[index] + A[index]) * 1.0) / (i - index + 1)) + backTrack(A, len, sum, i + 1, K - 1, dp));\\n        }\\n        \\n        return dp[index][K];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047862,
                "title": "c-solution-using-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[110][110];\\n    double find(vector<int>&nums,int index,int k)\\n    {\\n        if(index>=nums.size()||k<0)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return INT_MIN/2;\\n        }\\n        if(dp[index][k]!=0)\\n        {\\n            return dp[index][k];\\n        }\\n        double sum=0;\\n        double ans=0;\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            ans=max(ans,sum/(i-index+1)+find(nums,i+1,k-1));\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        memset(dp,0,sizeof(dp));\\n        return find(nums,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[110][110];\\n    double find(vector<int>&nums,int index,int k)\\n    {\\n        if(index>=nums.size()||k<0)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return INT_MIN/2;\\n        }\\n        if(dp[index][k]!=0)\\n        {\\n            return dp[index][k];\\n        }\\n        double sum=0;\\n        double ans=0;\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            ans=max(ans,sum/(i-index+1)+find(nums,i+1,k-1));\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        memset(dp,0,sizeof(dp));\\n        return find(nums,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603025,
                "title": "python3-6-lines-prefix-recursion-t-m-100-00-11",
                "content": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        pref = list(accumulate(nums, initial = 0))\\n\\n        @lru_cache(None)\\n        def dp(i,j,k):\\n\\n            if k==1: return (pref[j+1]-pref[i])/(j-i+1)\\n\\n            else: return max([dp(j+1-n,j,1) + \\n                     dp(i,j-n,k-1) for n in range(1, j-i+3-k)])\\n\\n        return dp(0, len(nums)-1, k) \\n```\\n_\\n\\n_\\n[https://leetcode.com/submissions/detail/804821530/](http://)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        pref = list(accumulate(nums, initial = 0))\\n\\n        @lru_cache(None)\\n        def dp(i,j,k):\\n\\n            if k==1: return (pref[j+1]-pref[i])/(j-i+1)\\n\\n            else: return max([dp(j+1-n,j,1) + \\n                     dp(i,j-n,k-1) for n in range(1, j-i+3-k)])\\n\\n        return dp(0, len(nums)-1, k) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334998,
                "title": "java-intuitive-straightforward-topdown",
                "content": "Thanks for dopping-by...\\n\\nPls upvote if it\\'s useful to you... thanks :-)\\n\\n\\n\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return largestSumOfAveragesHelper(nums,k,0,new Double[nums.length][k+1]);\\n    }\\n    \\n    private double largestSumOfAveragesHelper(int[] nums, int k, int index, Double[][] memo) {\\n        //Base\\n        if(index == nums.length)\\n            return 0;\\n        if(memo[index][k] != null)\\n            return memo[index][k];\\n        \\n        int sum=0;\\n        if(k == 1) { //last recursion level... cover all remaining numbers for avg calculation\\n            for(int i=index; i<nums.length; i++) {\\n                sum += nums[i];\\n            }\\n            return memo[index][k] = sum*1.0/(nums.length-index);\\n        }\\n        \\n        int count=0;\\n        double max=0;\\n        double currAvg=0;\\n        for(int i=index; i<nums.length; i++) { //find avg for all combinations recursively & capture the max\\n            sum += nums[i];\\n            count++;\\n            currAvg=sum*1.0/count;\\n            max=Math.max(max,currAvg+largestSumOfAveragesHelper(nums,k-1,i+1,memo));\\n        }\\n        return memo[index][k] = max;\\n    }\\n}\\n```\\n\\nNote: Runtime can be reduced by taking extra space & precalculating prefix sum...\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return largestSumOfAveragesHelper(nums,k,0,new Double[nums.length][k+1]);\\n    }\\n    \\n    private double largestSumOfAveragesHelper(int[] nums, int k, int index, Double[][] memo) {\\n        //Base\\n        if(index == nums.length)\\n            return 0;\\n        if(memo[index][k] != null)\\n            return memo[index][k];\\n        \\n        int sum=0;\\n        if(k == 1) { //last recursion level... cover all remaining numbers for avg calculation\\n            for(int i=index; i<nums.length; i++) {\\n                sum += nums[i];\\n            }\\n            return memo[index][k] = sum*1.0/(nums.length-index);\\n        }\\n        \\n        int count=0;\\n        double max=0;\\n        double currAvg=0;\\n        for(int i=index; i<nums.length; i++) { //find avg for all combinations recursively & capture the max\\n            sum += nums[i];\\n            count++;\\n            currAvg=sum*1.0/count;\\n            max=Math.max(max,currAvg+largestSumOfAveragesHelper(nums,k-1,i+1,memo));\\n        }\\n        return memo[index][k] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272553,
                "title": "c-dfs-memoisation",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>pre;\\n    double dfs(int curr,int k,vector<int>&nums,vector<vector<double>>&dp){\\n        if(curr==n && k!=0) return 0;\\n        if(k==0){\\n            return curr!=0? (double)(pre[n-1]-pre[curr-1])/(n-curr): (double)(pre[n-1])/n;\\n        }\\n        if(dp[curr][k]!=-1) return dp[curr][k];\\n        double ans=0,sum=0;\\n        for(int i=curr;i<n-k;i++){\\n            sum+=nums[i];\\n            ans= max(ans,(double)sum/(i+1-curr)+dfs(i+1,k-1,nums,dp));\\n        }\\n        return dp[curr][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        n=nums.size();\\n        pre=nums;\\n        for(int i=1;i<n;i++) pre[i]+=pre[i-1];\\n        vector<vector<double>>dp(n,vector<double>(k,-1));\\n        return dfs(0,k-1,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>pre;\\n    double dfs(int curr,int k,vector<int>&nums,vector<vector<double>>&dp){\\n        if(curr==n && k!=0) return 0;\\n        if(k==0){\\n            return curr!=0? (double)(pre[n-1]-pre[curr-1])/(n-curr): (double)(pre[n-1])/n;\\n        }\\n        if(dp[curr][k]!=-1) return dp[curr][k];\\n        double ans=0,sum=0;\\n        for(int i=curr;i<n-k;i++){\\n            sum+=nums[i];\\n            ans= max(ans,(double)sum/(i+1-curr)+dfs(i+1,k-1,nums,dp));\\n        }\\n        return dp[curr][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        n=nums.size();\\n        pre=nums;\\n        for(int i=1;i<n;i++) pre[i]+=pre[i-1];\\n        vector<vector<double>>dp(n,vector<double>(k,-1));\\n        return dfs(0,k-1,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470024,
                "title": "c-modi-s-algorithm-simple-dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    \\n    double f(vector<int>& arr, int k, int n) {\\n        if(n==0) return 0;\\n        if(k<=0) return INT_MAX;\\n        if(dp[n-1][k] != -1) return dp[n-1][k];\\n        double res = 0;\\n        double curr = 0;\\n        for(int i = n-1; i>=0 ; i--) {\\n            curr += arr[i];\\n            double prev = f(arr,k-1,i);\\n            if(prev == INT_MAX) continue;\\n            res = max(res, prev + (curr/(n-i)));\\n        }\\n        dp[n-1][k] = res;\\n        return res;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        for(int i=0; i<=n; i++) {\\n            for(int j=0; j<=n; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        double res = f(arr,k,n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    \\n    double f(vector<int>& arr, int k, int n) {\\n        if(n==0) return 0;\\n        if(k<=0) return INT_MAX;\\n        if(dp[n-1][k] != -1) return dp[n-1][k];\\n        double res = 0;\\n        double curr = 0;\\n        for(int i = n-1; i>=0 ; i--) {\\n            curr += arr[i];\\n            double prev = f(arr,k-1,i);\\n            if(prev == INT_MAX) continue;\\n            res = max(res, prev + (curr/(n-i)));\\n        }\\n        dp[n-1][k] = res;\\n        return res;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        for(int i=0; i<=n; i++) {\\n            for(int j=0; j<=n; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        double res = f(arr,k,n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701277,
                "title": "cpp-sol-with-comments-to-help",
                "content": "Runtime: 20 ms, faster than 54.73% of C++ online submissions for Largest Sum of Averages.\\nMemory Usage: 13.7 MB, less than 9.29% of C++ online submissions for Largest Sum of Averages.\\n```\\n    class Solution {\\n    double helper(vector<vector<double>> &dp,vector<double>& presum,  int index, int k, int n){\\n        if(index >= n)return 0.0;//base case (we dont check whether k is zero or not because we need not need exact k parts it can be less than k)\\n        if(k == 0 ) return INT_MIN;//invalid cases as the remaining will other group and increase groups  > k \\n        if(dp[index][k] != 0) return dp[index][k];\\n        double ans  = 0.0;\\n        for(int i = index; i < n; i++){ \\n            //including Aindex..Ai in one group and calling helper for rest \\n            double temp = helper(dp, presum, i + 1, k-1 , n) + (presum[i] - presum[index-1]) / (double)(i - index + 1);\\n            // store maximum possible of all i in index to i\\n            ans = max(ans, temp);\\n        }\\n        dp[index][k] = ans;\\n        return ans;\\n        \\n    }\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        vector<vector<double>> dp(105, vector<double>( 105, 0));\\n        vector<double> presum;\\n        presum.push_back(0);\\n        // presum to keep average from i to j handy\\n        for(int i = 1; i <= A.size(); i++){\\n            presum.push_back(presum[i-1] + A[i-1]);\\n        }\\n        return helper(dp,presum,1,K,presum.size());\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    double helper(vector<vector<double>> &dp,vector<double>& presum,  int index, int k, int n){\\n        if(index >= n)return 0.0;//base case (we dont check whether k is zero or not because we need not need exact k parts it can be less than k)\\n        if(k == 0 ) return INT_MIN;//invalid cases as the remaining will other group and increase groups  > k \\n        if(dp[index][k] != 0) return dp[index][k];\\n        double ans  = 0.0;\\n        for(int i = index; i < n; i++){ \\n            //including Aindex..Ai in one group and calling helper for rest \\n            double temp = helper(dp, presum, i + 1, k-1 , n) + (presum[i] - presum[index-1]) / (double)(i - index + 1);\\n            // store maximum possible of all i in index to i\\n            ans = max(ans, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 561145,
                "title": "java-dp-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        //f[i][j] \\u524Di\\u4E2A\\u5206\\u6210j\\u7EC4\\u7684\\u6700\\u5927\\u548C\\n        double[][] f = new double[A.length][K + 1];\\n        int s = 0;\\n        for(int i = 0; i < A.length; ++i) {\\n            s += A[i];\\n            f[i][1] = s * 1.0 / (i + 1);\\n        }\\n        \\n        for(int i = 0; i < A.length; ++i) {\\n            for(int j = 2; j <= K; ++j) {\\n                if (j > i + 1) {\\n                    break;\\n                } else {\\n                    f[i][j] = -1;\\n                    int sum = A[i];\\n                    for(int k = i - 1; k >= j - 2; --k) {\\n                        f[i][j] = Math.max(f[i][j], f[k][j - 1] + sum * 1.0 / (i - k));\\n                        sum += A[k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return f[A.length - 1][K];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        //f[i][j] \\u524Di\\u4E2A\\u5206\\u6210j\\u7EC4\\u7684\\u6700\\u5927\\u548C\\n        double[][] f = new double[A.length][K + 1];\\n        int s = 0;\\n        for(int i = 0; i < A.length; ++i) {\\n            s += A[i];\\n            f[i][1] = s * 1.0 / (i + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 130685,
                "title": "java-clear-code-using-dfs-memorization-with-explanations",
                "content": "State Transfer :\\nlargest sum of averages from *start* =  \\n\\t**max**( averages of the current partition which starts at *start*  **+**  largest sum of averages which starts at *tail* + 1 )\\n```\\n        for (int tail = start; tail + K - 1 < A.length; tail++) {\\n            num = Math.max(num, ((double) (cumulativeSum[tail] - cumulativeSum[start] + A[start]) / (tail + 1 - start)) + largestSumofAveragesFrom(A, K - 1, tail + 1, cumulativeSum, memo));\\n        }\\n```\\nDuring the recursion, \\n* K minus by 1 each time, until K == 1, i.e., it is the last partition.\\n* *tail* represents the possible last element index of the current partition which starts at *start*\\n\\n```\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] cumulativeSum = new int[A.length];\\n        cumulativeSum[0] = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            cumulativeSum[i] = cumulativeSum[i - 1] + A[i];\\n        }\\n        double[][] memo = new double[A.length][K + 1];\\n        return largestSumofAveragesFrom(A, K, 0, cumulativeSum, memo);\\n    }\\n  \\n    private double largestSumofAveragesFrom(int[] A, int K, int start, int[] cumulativeSum, double[][] memo) {\\n        if (memo[start][K] != 0) {\\n            return memo[start][K];\\n        }\\n        if (K == 1) {\\n            memo[start][1] = ((double)(cumulativeSum[A.length - 1] - cumulativeSum[start]  + A[start]) / (A.length - start));\\n            return memo[start][1];\\n        }\\n        double num = 0;\\n        for (int tail = start; tail + K - 1 < A.length; tail++) {\\n            num = Math.max(num, ((double)(cumulativeSum[tail] - cumulativeSum[start]  + A[start]) / (tail + 1 - start)) + largestSumofAveragesFrom(A, K - 1, tail + 1, cumulativeSum, memo));\\n        }\\n        memo[start][K] = num;\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        for (int tail = start; tail + K - 1 < A.length; tail++) {\\n            num = Math.max(num, ((double) (cumulativeSum[tail] - cumulativeSum[start] + A[start]) / (tail + 1 - start)) + largestSumofAveragesFrom(A, K - 1, tail + 1, cumulativeSum, memo));\\n        }\\n```\n```\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] cumulativeSum = new int[A.length];\\n        cumulativeSum[0] = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            cumulativeSum[i] = cumulativeSum[i - 1] + A[i];\\n        }\\n        double[][] memo = new double[A.length][K + 1];\\n        return largestSumofAveragesFrom(A, K, 0, cumulativeSum, memo);\\n    }\\n  \\n    private double largestSumofAveragesFrom(int[] A, int K, int start, int[] cumulativeSum, double[][] memo) {\\n        if (memo[start][K] != 0) {\\n            return memo[start][K];\\n        }\\n        if (K == 1) {\\n            memo[start][1] = ((double)(cumulativeSum[A.length - 1] - cumulativeSum[start]  + A[start]) / (A.length - start));\\n            return memo[start][1];\\n        }\\n        double num = 0;\\n        for (int tail = start; tail + K - 1 < A.length; tail++) {\\n            num = Math.max(num, ((double)(cumulativeSum[tail] - cumulativeSum[start]  + A[start]) / (tail + 1 - start)) + largestSumofAveragesFrom(A, K - 1, tail + 1, cumulativeSum, memo));\\n        }\\n        memo[start][K] = num;\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894450,
                "title": "largest-sum-of-averages-leetcode-recursive-dynamic-programming-approach-solution",
                "content": "# Intuition\\npartition the array recursively searching for the max sum of averages as mentioned above by partitioning the array into k subarrays recursively by reducing the value of k and incrementing index to next index.\\n\\n# Approach\\nsolved using recursion then applied memoization to reduce tle using dynamic programming approach using the intuitive recursion method\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n // this is the recursion solution which gives tle\\n    // double f(int ind,vector<int>&nums,int k)\\n    // {\\n    //     if(ind>=nums.size()) return 0;\\n    //     if( k==0) return INT_MIN;\\n    //     int len=0;\\n    //     double sum=0;\\n    //     double mxs=INT_MIN;\\n    //     double m=0;\\n    //     for(int j=ind;j<nums.size();j++)\\n    //     {\\n    //         len++;\\n    //         sum+=nums[j];\\n    //         m=sum/len;\\n    //         mxs=max(mxs,m+f(j+1,nums,k-1));\\n    //         cout<<mxs<<\" \";\\n\\n    //     }\\n    //     return mxs;\\n    // }\\n\\n     double f(int ind,vector<int>&nums,int k,vector<vector<double>>&dp)\\n    {\\n        if(ind>=nums.size()) return 0;\\n        if( k==0) return INT_MIN;\\n        \\n        if(dp[ind][k]!=0) return dp[ind][k];\\n\\n        int len=0;\\n        double sum=0;\\n        double mxs=INT_MIN;\\n        double m=0;\\n        for(int j=ind;j<nums.size();j++)\\n        {\\n            len++;\\n            sum+=nums[j];\\n            m=sum/len;\\n            mxs=max(mxs,m+f(j+1,nums,k-1,dp));\\n            cout<<mxs<<\" \";\\n\\n        }\\n        return dp[ind][k]=mxs;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>> dp(nums.size()+1,vector<double>(nums.size()+1,0));\\n        // memset(dp,0,sizeof(dp));\\n        return f(0,nums,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // this is the recursion solution which gives tle\\n    // double f(int ind,vector<int>&nums,int k)\\n    // {\\n    //     if(ind>=nums.size()) return 0;\\n    //     if( k==0) return INT_MIN;\\n    //     int len=0;\\n    //     double sum=0;\\n    //     double mxs=INT_MIN;\\n    //     double m=0;\\n    //     for(int j=ind;j<nums.size();j++)\\n    //     {\\n    //         len++;\\n    //         sum+=nums[j];\\n    //         m=sum/len;\\n    //         mxs=max(mxs,m+f(j+1,nums,k-1));\\n    //         cout<<mxs<<\" \";\\n\\n    //     }\\n    //     return mxs;\\n    // }\\n\\n     double f(int ind,vector<int>&nums,int k,vector<vector<double>>&dp)\\n    {\\n        if(ind>=nums.size()) return 0;\\n        if( k==0) return INT_MIN;\\n        \\n        if(dp[ind][k]!=0) return dp[ind][k];\\n\\n        int len=0;\\n        double sum=0;\\n        double mxs=INT_MIN;\\n        double m=0;\\n        for(int j=ind;j<nums.size();j++)\\n        {\\n            len++;\\n            sum+=nums[j];\\n            m=sum/len;\\n            mxs=max(mxs,m+f(j+1,nums,k-1,dp));\\n            cout<<mxs<<\" \";\\n\\n        }\\n        return dp[ind][k]=mxs;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>> dp(nums.size()+1,vector<double>(nums.size()+1,0));\\n        // memset(dp,0,sizeof(dp));\\n        return f(0,nums,k,dp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3150931,
                "title": "recursion-memoization-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    map<pair<int,int>,double> m;\\n    double f(int i, vector<int> &nums, int k)\\n    {\\n        int n=nums.size();\\n        if(i!=n && k==0) return INT_MIN;\\n        if(i==n || k<=0) return 0;\\n        if(m.find({i,k})!=m.end()) return m[{i,k}];\\n        double sum=0, count=0, ans=0;\\n        for(int x=i; x<=n-k; x++)\\n        {\\n            count++;\\n            sum+=nums[x];\\n            ans=max(ans,sum/count+f(x+1,nums,k-1));\\n        }\\n        return m[{i,k}]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        double mx=0;\\n        for(int x=1; x<=k; x++)\\n        {\\n            mx=max(mx,f(0,nums,x));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    map<pair<int,int>,double> m;\\n    double f(int i, vector<int> &nums, int k)\\n    {\\n        int n=nums.size();\\n        if(i!=n && k==0) return INT_MIN;\\n        if(i==n || k<=0) return 0;\\n        if(m.find({i,k})!=m.end()) return m[{i,k}];\\n        double sum=0, count=0, ans=0;\\n        for(int x=i; x<=n-k; x++)\\n        {\\n            count++;\\n            sum+=nums[x];\\n            ans=max(ans,sum/count+f(x+1,nums,k-1));\\n        }\\n        return m[{i,k}]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        double mx=0;\\n        for(int x=1; x<=k; x++)\\n        {\\n            mx=max(mx,f(0,nums,x));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015816,
                "title": "java-tle-to-top-down-bottom-up-dp",
                "content": "Top-Down DP should be more intuitive, but before that, here is the try-all recursive version that got **TLE**. \\nI didn\\'t check the constraint carefully and figure it is just a medium, so :(\\n\\n```Java\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(0, 0, k, nums); // Time Limit Exceeded\\n    }\\n\\n    private double solve(int i, double score, int lvl, int[] nums){\\n        if (lvl == 0)\\n            return i == nums.length? score : 0;\\n\\n        double ans = 0, cur = 0;\\n        for (int j = i; j <= nums.length - lvl; j++){\\n            cur += nums[j];\\n            ans = Math.max(ans, solve(j + 1, score + cur/(j-i+1), lvl - 1, nums));\\n        }\\n\\n        return ans;\\n    }\\n```\\nBut, it is an easy fix, because we can memo based on level (depth) and the current index.\\nLet `memo[i][lvl]` be the best result from index `i ... n - 1` in array nums with `lvl` depth (`k-lvl` partitions).\\nWe also have to re-arrange the formula a bit becaues we **cannot** memo on the score from index `0 ... i-1`.\\n\\n**5ms Java AC**\\n\\n```Java\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(0, k, nums, new double[nums.length][k+1]);\\n    }\\n\\n    private double solve(int i, int lvl, int[] nums, double[][] memo){\\n        if (lvl == 0)\\n            return i == nums.length? 0 : -10000000;\\n        if (memo[i][lvl] > 0)\\n            return memo[i][lvl];\\n\\n        double ans = 0, cur = 0;\\n        for (int j = i; j <= nums.length - lvl; j++){\\n            cur += nums[j];\\n            ans = Math.max(ans, cur/(j-i+1) + solve(j + 1, lvl - 1, nums, memo));\\n        }\\n\\n        return memo[i][lvl] = ans;\\n    }\\n```\\n\\nNow let\\'s rewrite it as bottom-up DP. \\nHere is the basic idea:\\n- For each partition and for each subarray ending at `j` starting at 0, we try to create a new partition that starts at `j-k` and ends at `j`, where `j >= k > 0` .\\n\\n- Base case is there is no partition, so it is prefix sum average for each subarray ending at `j` and starting at 0.\\n\\n- It is always better to create a new partition, than to not create one.\\n\\n**20ms Java AC**\\n```Java\\n    public double largestSumOfAverages(int[] nums, int p) {\\n        double[] dp = new double[nums.length];\\n        for (int i = 0; i < p; i++){ // p stands for \"num of partition\"\\n            double[] next = new double[nums.length];\\n            double sum = 0;\\n            for (int j = 0; j < nums.length; j++){\\n                sum += nums[j];\\n                if (i == 0){ // base case\\n                    next[j] = sum/(j+1);\\n                }\\n                for (int k = j; k > 0 && i > 0; k--){ // only enter this loop when there is a partition (not base case)\\n                    sum = k == j? nums[k] : sum+nums[k]; // reset sum if it is a new loop\\n                    next[j] = Math.max(next[j], sum/(j-k+1)+dp[k-1]);\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[nums.length - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(0, 0, k, nums); // Time Limit Exceeded\\n    }\\n\\n    private double solve(int i, double score, int lvl, int[] nums){\\n        if (lvl == 0)\\n            return i == nums.length? score : 0;\\n\\n        double ans = 0, cur = 0;\\n        for (int j = i; j <= nums.length - lvl; j++){\\n            cur += nums[j];\\n            ans = Math.max(ans, solve(j + 1, score + cur/(j-i+1), lvl - 1, nums));\\n        }\\n\\n        return ans;\\n    }\\n```\n```Java\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(0, k, nums, new double[nums.length][k+1]);\\n    }\\n\\n    private double solve(int i, int lvl, int[] nums, double[][] memo){\\n        if (lvl == 0)\\n            return i == nums.length? 0 : -10000000;\\n        if (memo[i][lvl] > 0)\\n            return memo[i][lvl];\\n\\n        double ans = 0, cur = 0;\\n        for (int j = i; j <= nums.length - lvl; j++){\\n            cur += nums[j];\\n            ans = Math.max(ans, cur/(j-i+1) + solve(j + 1, lvl - 1, nums, memo));\\n        }\\n\\n        return memo[i][lvl] = ans;\\n    }\\n```\n```Java\\n    public double largestSumOfAverages(int[] nums, int p) {\\n        double[] dp = new double[nums.length];\\n        for (int i = 0; i < p; i++){ // p stands for \"num of partition\"\\n            double[] next = new double[nums.length];\\n            double sum = 0;\\n            for (int j = 0; j < nums.length; j++){\\n                sum += nums[j];\\n                if (i == 0){ // base case\\n                    next[j] = sum/(j+1);\\n                }\\n                for (int k = j; k > 0 && i > 0; k--){ // only enter this loop when there is a partition (not base case)\\n                    sum = k == j? nums[k] : sum+nums[k]; // reset sum if it is a new loop\\n                    next[j] = Math.max(next[j], sum/(j-k+1)+dp[k-1]);\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[nums.length - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512421,
                "title": "java-dp-n-k-top-down-pref-sum",
                "content": "```\\nclass Solution {\\n    double[][] dp;\\n    int k;\\n    int[] a;\\n    long[] prefSum;\\n    int n;\\n    double dfs(int i, int p)\\n    {\\n        if(i==n)\\n        {\\n            return 0;\\n        }\\n        if(p==k)\\n        {\\n            return -10000;\\n        }\\n        if(dp[i][p]==0)\\n        {\\n            for(int j=i+1; j<=n; j++)\\n            {\\n                double avg=prefSum[j]-prefSum[i];\\n                avg/=j-i;\\n                dp[i][p]=Math.max(dp[i][p], avg+dfs(j, p+1));\\n            }   \\n        }\\n        return dp[i][p];\\n    }\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        n=nums.length;\\n        dp=new double[n][k];\\n        this.k=k;\\n        a=nums;\\n        prefSum=new long[n+1];\\n        for(int i=1; i<=n; i++)\\n        {\\n            prefSum[i]=prefSum[i-1]+a[i-1];\\n        }\\n        double ans=0;\\n        ans=dfs(0, 0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double[][] dp;\\n    int k;\\n    int[] a;\\n    long[] prefSum;\\n    int n;\\n    double dfs(int i, int p)\\n    {\\n        if(i==n)\\n        {\\n            return 0;\\n        }\\n        if(p==k)\\n        {\\n            return -10000;\\n        }\\n        if(dp[i][p]==0)\\n        {\\n            for(int j=i+1; j<=n; j++)\\n            {\\n                double avg=prefSum[j]-prefSum[i];\\n                avg/=j-i;\\n                dp[i][p]=Math.max(dp[i][p], avg+dfs(j, p+1));\\n            }   \\n        }\\n        return dp[i][p];\\n    }\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        n=nums.length;\\n        dp=new double[n][k];\\n        this.k=k;\\n        a=nums;\\n        prefSum=new long[n+1];\\n        for(int i=1; i<=n; i++)\\n        {\\n            prefSum[i]=prefSum[i-1]+a[i-1];\\n        }\\n        double ans=0;\\n        ans=dfs(0, 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507150,
                "title": "c-dp-memoization-prefix-sum-faster-than-95",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>prefix;\\n    double dp[101][101];\\n    double solve(int i,int k,vector<int>&nums){\\n        if(i<0) return 0;\\n        if(k==1){\\n            double sum=prefix[i]/(double)(i+1);\\n            return sum;\\n        } \\n        if(dp[i][k]!=0) return dp[i][k];\\n        double ans=0;\\n        for(int j=i;j>=0;j--){\\n            if(j+1<k) break;\\n            double sum=prefix[i]-((j-1>=0) ? prefix[j-1] : 0);\\n            sum=sum/(double)(i-j+1);\\n            sum+=solve(j-1,k-1,nums);\\n            ans=max(ans,sum);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        prefix.resize(nums.size());\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            prefix[i]=nums[i]+prefix[i-1];\\n        memset(dp,0,sizeof(dp));\\n        return solve(nums.size()-1,k,nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>prefix;\\n    double dp[101][101];\\n    double solve(int i,int k,vector<int>&nums){\\n        if(i<0) return 0;\\n        if(k==1){\\n            double sum=prefix[i]/(double)(i+1);\\n            return sum;\\n        } \\n        if(dp[i][k]!=0) return dp[i][k];\\n        double ans=0;\\n        for(int j=i;j>=0;j--){\\n            if(j+1<k) break;\\n            double sum=prefix[i]-((j-1>=0) ? prefix[j-1] : 0);\\n            sum=sum/(double)(i-j+1);\\n            sum+=solve(j-1,k-1,nums);\\n            ans=max(ans,sum);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        prefix.resize(nums.size());\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            prefix[i]=nums[i]+prefix[i-1];\\n        memset(dp,0,sizeof(dp));\\n        return solve(nums.size()-1,k,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415997,
                "title": "c-24ms-simple-dp-with-explanation",
                "content": "First we will take out prefix sum array.\\n\\nNow , we will be using DP with states `dp[position][k] -> Till current position what will be the maximum sum of averages for current value of k`  \\n\\nNow get some idea about this. If we want a solution for a particular value of `k` , then we will have to find what is the maximum answer till previous position for the value of `k-1`.\\n\\n`For e.g. take positon : 3. Then we can have value of k from 1 to 3. Let\\'s say we want to find dp[3][2]. That means we should have the maximum solution till previous position for the k = 1 (i.e. dp[1][1] , dp[2][1])`. \\nSo the idea is for each value of `k` at each `position` , you have to take `max(dp[j][k-1] + remaining_elements_average)` for each `k-2 <= j < position` **(i.e. maximum solution for k-1 using previous set of elements + the average of remaining elements)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int seg) {\\n        int n = nums.size();\\n        \\n        vector<int> prefix(n , 0);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++) prefix[i] = prefix[i-1] + nums[i];\\n        \\n        vector<vector<double>> dp(n+1 , vector<double>(n+1 , 0.0));\\n        dp[0][1] = (double)nums[0];\\n        \\n        for(int pos=1; pos<n; pos++) {\\n            \\n            //for k=1\\n            dp[pos][1] = (double)(prefix[pos]) / (double)(pos+1);\\n            \\n            for(int k=2; k<=pos+1; k++) {\\n                \\n                //average for each j from k-2 to pos-1\\n                for(int j=k-2; j<pos; j++) {\\n                    double avg = (double)(prefix[pos] - prefix[j]) / (double)(pos-j);\\n                    dp[pos][k] = max(dp[pos][k] , avg + dp[j][k-1]);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        double ans = 0.0;\\n        for(int k=1; k<=seg; k++) ans = max(ans , dp[n-1][k]);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**Please Upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int seg) {\\n        int n = nums.size();\\n        \\n        vector<int> prefix(n , 0);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++) prefix[i] = prefix[i-1] + nums[i];\\n        \\n        vector<vector<double>> dp(n+1 , vector<double>(n+1 , 0.0));\\n        dp[0][1] = (double)nums[0];\\n        \\n        for(int pos=1; pos<n; pos++) {\\n            \\n            //for k=1\\n            dp[pos][1] = (double)(prefix[pos]) / (double)(pos+1);\\n            \\n            for(int k=2; k<=pos+1; k++) {\\n                \\n                //average for each j from k-2 to pos-1\\n                for(int j=k-2; j<pos; j++) {\\n                    double avg = (double)(prefix[pos] - prefix[j]) / (double)(pos-j);\\n                    dp[pos][k] = max(dp[pos][k] , avg + dp[j][k-1]);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        double ans = 0.0;\\n        for(int k=1; k<=seg; k++) ans = max(ans , dp[n-1][k]);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014380,
                "title": "trivial-mcm-dp-cpp",
                "content": "```\\nclass Solution {\\n    map<pair<int,int>,double> dp;\\npublic:\\n    double cal(int i,int n,int k,vector<int>&a){\\n        if(k==1){\\n            if(i==n) return 0.0;\\n            double s = 0;\\n            int len = 0 ;\\n            while(i<n) {\\n                len++;\\n                s += a[i++];\\n            }\\n            return s/len;\\n        }\\n        double s = 0 , len = 0;\\n        if(dp.find({i,k})!=dp.end()) return dp[{i,k}];\\n        double &ans = dp[{i,k}];\\n        ans = 0.0;\\n        for(int l = i;l<n;l++){\\n            s += a[l];\\n            len++;\\n            ans = max(ans , s/len + cal(l+1,n,k-1,a));\\n        }\\n        return ans;\\n    }\\n    double largestSumOfAverages(vector<int>& a, int k) {\\n        int n= a.size();\\n        return cal(0,n,k,a);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<pair<int,int>,double> dp;\\npublic:\\n    double cal(int i,int n,int k,vector<int>&a){\\n        if(k==1){\\n            if(i==n) return 0.0;\\n            double s = 0;\\n            int len = 0 ;\\n            while(i<n) {\\n                len++;\\n                s += a[i++];\\n            }\\n            return s/len;\\n        }\\n        double s = 0 , len = 0;\\n        if(dp.find({i,k})!=dp.end()) return dp[{i,k}];\\n        double &ans = dp[{i,k}];\\n        ans = 0.0;\\n        for(int l = i;l<n;l++){\\n            s += a[l];\\n            len++;\\n            ans = max(ans , s/len + cal(l+1,n,k-1,a));\\n        }\\n        return ans;\\n    }\\n    double largestSumOfAverages(vector<int>& a, int k) {\\n        int n= a.size();\\n        return cal(0,n,k,a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999597,
                "title": "dp-beginner-explanation-best-explaination",
                "content": "**Question Explaination**\\n\\nWe are given an array A and a variable K . We can divide the array into **atmost** K groups such that the sum of averages of all groups is maximum possible.\\n\\n**Basics**\\n\\n* if  ``` K >= length(A) ``` \\n        ``` return sum(A)```\\n\\t\\n\\t**Why ?** Because lets say we take each element as a group then sum of averages becomes the sum of all the elements in the array which gives us the maximum possible answer.\\n\\t\\n*  if ``` K = 1``` :  ```return  sum(A\\')/length(A\\')``` \\n    where A\\' is elements of array A from i th index to the end of the array. One group means the        entire array itself.\\n\\t\\n* Prefix Sums :\\n  Lets define prefix[i] as the sum of elements in the array from starting to ith index in array(ith index included) . The sum between two indices i and j (both included) is   :     \\n  ```prefix[j] - prefix[i-1]```\\n  \\n  **Approach** :\\n  \\n  * Lets define a function ```f(i,k)```  which gives the maximum score attainable from ith index to len(A)-1 by forming atmost k groups.\\n  * lets say we take any jth index between ```[i,len(A)-1]``` . We form a group from i to j-1 so our problem reduces in finding ```f(j,k-1)```\\n  *  To caluclate average in between i to j-1:\\n          ```(prefix[j-1] - prefix[i-1]) / ( (j-1) - i + 1)  ```\\n\\t\\t Number of elements between a and b both included is b-a+1 if b>a.\\t \\n  * if we take all the elemenst between i to len(A)-1 as a single group then the score average simply becomes :\\n   ```(prefix[n-1] - prefix[i-1]) / ((n-1) - i +1)```\\n   \\n   **Pseudo Code**\\n   \\n   Computing ```f(i,k)```\\n    ```\\n\\tBase cases\\n\\tans = 0\\n\\tfor i =0 to len(A)-1\\n\\t    for j = 0 to i\\n\\t\\t     ans = max(ans , f(j,k-1) + (prefix[j-1] - prefix[i-1]) / ( (j-1) - i + 1) )\\n\\t  ans = max(ans , (prefix[n-1] - prefix[i-1]) / ((n-1) - i +1))\\n\\t  \\n\\treturn ans\\n\\t```\\n\\t\\n\\t\\n\\t**CODE C++**\\n```\\t\\n\\tclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int len = A.size();\\n        double prefix[len+1];\\n        prefix[0] = A[0];\\n        for(int i = 1;i<len;i++)\\n        {\\n            prefix[i] = prefix[i-1] + A[i];\\n        }\\n        double dp[len+1][K+1];\\n        for(int i = 0;i<len;i++)\\n            dp[i][1] = prefix[i]/(i+1);\\n        for(int k = 2;k<=K;k++)\\n        {\\n            for(int i = 0;i<len;i++)\\n            {\\n                for(int j = 0;j<i;j++)\\n                {\\n                    dp[i][k] = max(dp[j][k-1]+(prefix[i]-prefix[j])/(i-j) , max(dp[i][k],prefix[i]/(i+1)));\\n                }\\n            }\\n        }\\n        return dp[len-1][K];\\n    }\\n};\\n\\t\\n```\\t\\n\\t\\n\\t\\t    \\n\\t\\n\\n  \\n  \\n  \\n  \\n  \\n\\t\\n\\t",
                "solutionTags": [],
                "code": "``` K >= length(A) ```\n``` return sum(A)```\n``` K = 1```\n```return  sum(A\\')/length(A\\')```\n```prefix[j] - prefix[i-1]```\n```f(i,k)```\n```[i,len(A)-1]```\n```f(j,k-1)```\n```(prefix[j-1] - prefix[i-1]) / ( (j-1) - i + 1)  ```\n```(prefix[n-1] - prefix[i-1]) / ((n-1) - i +1)```\n```f(i,k)```\n```\\n\\tBase cases\\n\\tans = 0\\n\\tfor i =0 to len(A)-1\\n\\t    for j = 0 to i\\n\\t\\t     ans = max(ans , f(j,k-1) + (prefix[j-1] - prefix[i-1]) / ( (j-1) - i + 1) )\\n\\t  ans = max(ans , (prefix[n-1] - prefix[i-1]) / ((n-1) - i +1))\\n\\t  \\n\\treturn ans\\n\\t```\n```\\t\\n\\tclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int len = A.size();\\n        double prefix[len+1];\\n        prefix[0] = A[0];\\n        for(int i = 1;i<len;i++)\\n        {\\n            prefix[i] = prefix[i-1] + A[i];\\n        }\\n        double dp[len+1][K+1];\\n        for(int i = 0;i<len;i++)\\n            dp[i][1] = prefix[i]/(i+1);\\n        for(int k = 2;k<=K;k++)\\n        {\\n            for(int i = 0;i<len;i++)\\n            {\\n                for(int j = 0;j<i;j++)\\n                {\\n                    dp[i][k] = max(dp[j][k-1]+(prefix[i]-prefix[j])/(i-j) , max(dp[i][k],prefix[i]/(i+1)));\\n                }\\n            }\\n        }\\n        return dp[len-1][K];\\n    }\\n};\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906321,
                "title": "dp-bottom-up-clear-plan",
                "content": "## Code:\\n\\t\\t\\t\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        #=============================== helper: prefix sum =============================\\n        pref = [0]  # sum(A[a:b]) == pref[b]-pref[a]\\n        summ = 0\\n        for x in A:\\n            summ += x\\n            pref.append(summ) \\n                      \\n        def Sum(a,b):\\n            return pref[b]-pref[a]\\n        \\n        #=============================== Main: dp =====================================\\n        dp = [[0 for j in range(K+1)] for i in range(len(A))]\\n        \\n        for i in range(len(A)):\\n            dp[i][1] = Sum(0,i+1) / (i+1)\\n       \\n        for k in range(2,K+1):           # 2,3\\n            for i in range(k-1,len(A)):  # 1,2,3,4;              2,3,4\\n                for j in range(k-2,i):   # 0;0,1;0,1,2;0,1,2,3;   0,1;0,1,2;0,1,2,3;\\n                    dp[i][k] = max(dp[i][k], dp[j][k-1]+Sum(j+1,i+1)/(i-j))\\n    \\n        return dp[-1][-1]\\n```\\t\\t\\n\\n## My plan:\\n\\n\\n        1.dp subproblems branches:\\n            [9,1,2,3,9]  3\\n            \\n            [9,1,2,3]  2                      [9,1,2] 2                          [9,1]  2\\n            \\n            [9,1,2] 1  [9,1] 1 [9] 1          [9,1] 1  [9]   1                   [9] 1 \\n        \\n        2.dp definition:\\n            dp[i][k] :=  using A[0],A[1],...,A[i],  divide them into k groups, what\\'s the highest score.\\n        \\n        3.what to return:\\n            dp[len(A)-1][K],  OR: dp[-1][-1], if define the nested list properly.\\n            \\n        4.dp equations:\\n          4.1 main:  \\n            dp[i][k] = max(dp[j][k-1]) + sum(A[j+1:i+1]) / ((i+1)-(j+1))     j = (k-1)-1,...,i-1  =  [k-2,i)\\n              \\n              #carefully follow the definition to make sure index +1 -1 is correct.\\n              #  i >= k-1 , because A[0],A[1],...,A[i] should have at least k numbers.   i+1 >= k\\n            \\n          4.2 boundary:\\n            dp[i][1] = sum(A[:i+1]) / (i+1)\\n            dp[i][0] = 0\\n\\n## Upvote if helpful\\n### Thanks",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        #=============================== helper: prefix sum =============================\\n        pref = [0]  # sum(A[a:b]) == pref[b]-pref[a]\\n        summ = 0\\n        for x in A:\\n            summ += x\\n            pref.append(summ) \\n                      \\n        def Sum(a,b):\\n            return pref[b]-pref[a]\\n        \\n        #=============================== Main: dp =====================================\\n        dp = [[0 for j in range(K+1)] for i in range(len(A))]\\n        \\n        for i in range(len(A)):\\n            dp[i][1] = Sum(0,i+1) / (i+1)\\n       \\n        for k in range(2,K+1):           # 2,3\\n            for i in range(k-1,len(A)):  # 1,2,3,4;              2,3,4\\n                for j in range(k-2,i):   # 0;0,1;0,1,2;0,1,2,3;   0,1;0,1,2;0,1,2,3;\\n                    dp[i][k] = max(dp[i][k], dp[j][k-1]+Sum(j+1,i+1)/(i-j))\\n    \\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829762,
                "title": "c-easy-simple-and-short-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K)\\n    {\\n        int n = A.size();\\n        vector<vector<double>> dp(K, vector<double>(n, 0.0));\\n        \\n        double now = 0.0;\\n        for(int i = 0; i<n; i++){now += (double)A[i]; dp[0][i] = now/(i+1);}\\n        \\n        for(int i = 1; i<K; i++)\\n            for(int j = i; j<n; j++)\\n            {\\n                dp[i][j] = dp[i-1][j-1] + (double)A[j];\\n                \\n                double now = (double)A[j];\\n                \\n                for(int k = j-1; k>=i; k--)\\n                {\\n                    now += (double)A[k];\\n                    dp[i][j] = max(dp[i][j], dp[i-1][k-1] + (now/(j-k+1)));\\n                }\\n            }\\n        \\n        return dp[K-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K)\\n    {\\n        int n = A.size();\\n        vector<vector<double>> dp(K, vector<double>(n, 0.0));\\n        \\n        double now = 0.0;\\n        for(int i = 0; i<n; i++){now += (double)A[i]; dp[0][i] = now/(i+1);}\\n        \\n        for(int i = 1; i<K; i++)\\n            for(int j = i; j<n; j++)\\n            {\\n                dp[i][j] = dp[i-1][j-1] + (double)A[j];\\n                \\n                double now = (double)A[j];\\n                \\n                for(int k = j-1; k>=i; k--)\\n                {\\n                    now += (double)A[k];\\n                    dp[i][j] = max(dp[i][j], dp[i-1][k-1] + (now/(j-k+1)));\\n                }\\n            }\\n        \\n        return dp[K-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798597,
                "title": "c-memoization",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n=A.size();\\n        vector<vector<double>> dp(n, vector<double>(K+1, -1));\\n        return helper(A, 0, A.size(), K, dp);\\n        \\n    }\\n    \\n    double helper(vector<int> &A, int l, int n, int k, vector<vector<double>> &dp)\\n    {\\n        \\n        if(l == n)\\n            return 0;\\n        \\n        if(dp[l][k] != -1)\\n            return dp[l][k];\\n        \\n        double sum = 0, res = 0;\\n        if(k==1 )\\n        {\\n            for(int i=l; i<n; i++)\\n                sum += A[i];\\n            return sum/(n-l);\\n        }\\n    \\n        double avg, temp;\\n        for(int i=l; i<n; i++)\\n        {\\n            sum += A[i];\\n            avg = sum/(i-l+1);\\n            temp = avg + helper(A, i+1, n, k-1, dp);\\n            res = max(res, temp);\\n        }\\n        return  dp[l][k] = res;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n=A.size();\\n        vector<vector<double>> dp(n, vector<double>(K+1, -1));\\n        return helper(A, 0, A.size(), K, dp);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 784485,
                "title": "javascript-solution-dynamic-programming-solution",
                "content": "The way that I comprehended this problem was thinking of having `K` groups as equivalent to having `K-1` dividers and figuring out the placement of each one to get the maximum average. If we know the best placement of the first divider from index 0 to 1, 0 to 2, ..., and 0 to n - 1, then we could use this information to figure out the best placement of the second divider from index 0 to 1, 0 to 2, ..., 0 to n - 1. This gives us the structure for our `dp`. We will also create prefixSum `sum` to quickly compute the average of the sums in intervals `[i, j]`.\\n<br>\\n\\n```\\nvar largestSumOfAverages = function (A, K) {\\n    const N = A.length;\\n        \\n    const sums = new Array(N); // the prefix sum\\n    sums[0] = A[0]; // initialize the first sum\\n    \\n    for (let i = 1; i < N; i++) {\\n        sums[i] = sums[i - 1] + A[i]; // sums[i] equals the previous sum + A[i]\\n    }\\n    \\n    const dp = Array.from(Array(K), () => Array(N).fill(0)); // Create a 2-D dp array of size K by N.\\n    dp[0][0] = A[0];\\n    \\n    // initialize the condition when we have 0 dividers\\n    for (let i = 1; i < N; i++) {\\n        dp[0][i] = sums[i] / (i + 1);\\n    }\\n\\n    for (let k = 1; k < K; k++) { // k = the # of dividers we currently have. It is represented as the row of the dp array\\n        for (let i = k; i < N; i++) { // i = index of the array A. We want to figure out the best position to place the divider for A[0...i].\\n            \\n            for (let j = 0; j < i; j++) { // j represents the placement of the divider\\n                const avgBefore = dp[k - 1][j]; // The best avg. we could have from interval [0, j] when we had 1 less divider than current.\\n                const avgAfter = (sums[i] - sums[j]) / (i - j); // The avg. of the sums after the placement of the divider (j + 1) up to i.\\n                \\n                dp[k][i] = Math.max(dp[k][i], avgBefore + avgAfter);\\n            }\\n        }\\n    }\\n\\n    return dp[K - 1][N - 1];\\n};\\n```\\n\\nIf you noticed from the code above, we are starting every `i` at `k`. Also, we are only using the previous row information for each iteration of `k`. We can optimize for space and use a 1D array. We would iterate from the back to prevent overcounting. Everything else is pretty much the same.\\n\\n```\\nvar largestSumOfAverages = function (A, K) {\\n    const N = A.length;\\n        \\n    const sums = new Array(N);\\n    sums[0] = A[0];\\n    \\n    for (let i = 1; i < N; i++) {\\n        sums[i] = sums[i - 1] + A[i];\\n    }\\n    \\n    const dp = new Array(N).fill(0); // Just a 1D array.\\n    dp[0] = A[0];\\n    \\n   \\n    for (let i = 1; i < N; i++) {\\n        dp[i] = sums[i] / (i + 1);\\n    }\\n\\n    for (let k = 1; k < K; k++) {\\n        for (let i = N - 1; i >= k; i--) { // We iterate from the back to avoid overcounting. We still end at k.\\n            \\n\\t\\t\\tdp[i] = 0; // reset dp[i] for the new row\\n            \\n            for (let j = i - 1; j >= 0; j--) {\\n                const avgBefore = dp[j]; \\n                const avgAfter = (sums[i] - sums[j]) / (i - j);\\n                \\n                dp[i] = Math.max(dp[i], avgBefore + avgAfter);\\n            }\\n        }\\n    }\\n\\n    return dp[N - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar largestSumOfAverages = function (A, K) {\\n    const N = A.length;\\n        \\n    const sums = new Array(N); // the prefix sum\\n    sums[0] = A[0]; // initialize the first sum\\n    \\n    for (let i = 1; i < N; i++) {\\n        sums[i] = sums[i - 1] + A[i]; // sums[i] equals the previous sum + A[i]\\n    }\\n    \\n    const dp = Array.from(Array(K), () => Array(N).fill(0)); // Create a 2-D dp array of size K by N.\\n    dp[0][0] = A[0];\\n    \\n    // initialize the condition when we have 0 dividers\\n    for (let i = 1; i < N; i++) {\\n        dp[0][i] = sums[i] / (i + 1);\\n    }\\n\\n    for (let k = 1; k < K; k++) { // k = the # of dividers we currently have. It is represented as the row of the dp array\\n        for (let i = k; i < N; i++) { // i = index of the array A. We want to figure out the best position to place the divider for A[0...i].\\n            \\n            for (let j = 0; j < i; j++) { // j represents the placement of the divider\\n                const avgBefore = dp[k - 1][j]; // The best avg. we could have from interval [0, j] when we had 1 less divider than current.\\n                const avgAfter = (sums[i] - sums[j]) / (i - j); // The avg. of the sums after the placement of the divider (j + 1) up to i.\\n                \\n                dp[k][i] = Math.max(dp[k][i], avgBefore + avgAfter);\\n            }\\n        }\\n    }\\n\\n    return dp[K - 1][N - 1];\\n};\\n```\n```\\nvar largestSumOfAverages = function (A, K) {\\n    const N = A.length;\\n        \\n    const sums = new Array(N);\\n    sums[0] = A[0];\\n    \\n    for (let i = 1; i < N; i++) {\\n        sums[i] = sums[i - 1] + A[i];\\n    }\\n    \\n    const dp = new Array(N).fill(0); // Just a 1D array.\\n    dp[0] = A[0];\\n    \\n   \\n    for (let i = 1; i < N; i++) {\\n        dp[i] = sums[i] / (i + 1);\\n    }\\n\\n    for (let k = 1; k < K; k++) {\\n        for (let i = N - 1; i >= k; i--) { // We iterate from the back to avoid overcounting. We still end at k.\\n            \\n\\t\\t\\tdp[i] = 0; // reset dp[i] for the new row\\n            \\n            for (let j = i - 1; j >= 0; j--) {\\n                const avgBefore = dp[j]; \\n                const avgAfter = (sums[i] - sums[j]) / (i - j);\\n                \\n                dp[i] = Math.max(dp[i], avgBefore + avgAfter);\\n            }\\n        }\\n    }\\n\\n    return dp[N - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673799,
                "title": "python-pure-easy-dp-solution-with-explanation",
                "content": "The idea of this question is very straightforward.\\nThere are 2 things to consider: **state** and **option**.\\n\\n1. State is the variable, what might change in the question, in this case, the length of the array & the number of partition\\n2.  Option is what we can decide. In this case, we can decide whether cut the array or not at a certain position, and we want to optimize the option, aka we need to find the best result from cut or not cut.\\n\\nDP array is defined as follow:\\ndp[i][j] states what is the maximal result given that the first **i+1** character in the array and **j** cuts.\\n\\nHere is the process:\\n**Base case:** when i = 0, j =0, means given the first char, maximum of 0 cut is allowed, dp[i][j] = A[0], piece of cake.\\n**Base nonpermissible case:** when i = 0, j = n , n in [1,2,3...], means given the first char, maximum of n cut is allowed, dp[i][j] = 0 \\n**State Transition:** for any dp[i][j] that are not classified as base cases, we want to find the maximum partition, which is the maximum of dp[k][j-1]+avg(A[k+1:i+1])) such that k in the range of 0 to i-1. (Intuitively, we don\\'t care what the partition from 0 to k is, we leave that as to our subproblems)\\n\\nHere is the code written in Python:\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        def avg(array):\\n            return sum(array) / len(array)\\n        dp = [[0 for _ in range(K)] for _ in range(len(A))]\\n        dp[0][0] = A[0]\\n        for i in range(len(A)):\\n            for j in range(K):\\n #               if i == 0 and j != 0:\\n #                  continue\\n                if j == 0:\\n                    dp[i][j] = avg(A[:i+1])\\n                else:\\n                    for k in range(i):\\n                        dp[i][j] = max(dp[i][j],dp[k][j-1]+avg(A[k+1:i+1]))\\n        return dp[len(A)-1][K-1]\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        def avg(array):\\n            return sum(array) / len(array)\\n        dp = [[0 for _ in range(K)] for _ in range(len(A))]\\n        dp[0][0] = A[0]\\n        for i in range(len(A)):\\n            for j in range(K):\\n #               if i == 0 and j != 0:\\n #                  continue\\n                if j == 0:\\n                    dp[i][j] = avg(A[:i+1])\\n                else:\\n                    for k in range(i):\\n                        dp[i][j] = max(dp[i][j],dp[k][j-1]+avg(A[k+1:i+1]))\\n        return dp[len(A)-1][K-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 309130,
                "title": "c-recursive-with-memorize-not-good-speed-but-intuitive",
                "content": "intuition:\\nwe can partition any array to 2 arrays, and then partition the second array to k-1 arrays.. so on so forth.\\n\\n```\\nclass Solution {\\n    unordered_map<int, double> data;\\npublic:\\n    double partition(vector<int>& nums, int k, int start) {\\n        int hash = k * 100 + start;\\n        if (data.find(hash) != data.end()) return data[hash];\\n        \\n        if (k == 1) {\\n            return accumulate(nums.begin() + start, nums.end(), 0.0) / double(nums.size() - start);\\n        }\\n        \\n        double answer = INT32_MIN;\\n        for (int i = start; i <= nums.size() - k; i++) {\\n            double sum = accumulate(nums.begin() + start, nums.begin() + i + 1, 0.0) / double(i + 1 - start);\\n            double partial_sum = partition(nums, k - 1, i + 1);\\n            answer = max(answer, (sum + partial_sum));\\n        }\\n        \\n        data[hash] = answer;\\n        \\n        return answer;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        return partition(A, K, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, double> data;\\npublic:\\n    double partition(vector<int>& nums, int k, int start) {\\n        int hash = k * 100 + start;\\n        if (data.find(hash) != data.end()) return data[hash];\\n        \\n        if (k == 1) {\\n            return accumulate(nums.begin() + start, nums.end(), 0.0) / double(nums.size() - start);\\n        }\\n        \\n        double answer = INT32_MIN;\\n        for (int i = start; i <= nums.size() - k; i++) {\\n            double sum = accumulate(nums.begin() + start, nums.begin() + i + 1, 0.0) / double(i + 1 - start);\\n            double partial_sum = partition(nums, k - 1, i + 1);\\n            answer = max(answer, (sum + partial_sum));\\n        }\\n        \\n        data[hash] = answer;\\n        \\n        return answer;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        return partition(A, K, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477726,
                "title": "solution",
                "content": "```C++ []\\n#define inf -100000.0\\n\\nclass Solution {\\npublic:\\n    double large_sum(vector<vector<double>> &dp,vector<int> & nums,int i, int k ){\\n        if(i>=nums.size()){\\n            return 0.0;\\n        }\\n        if(k<=0){\\n            return inf;\\n        }\\n        if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        double sum=0;\\n        double best_sum=0.0;\\n        for(int j=i;j<nums.size()-k+1;j++){\\n            sum+=nums[j];\\n            best_sum=max(best_sum, sum/(j-i+1) + large_sum(dp,nums,j+1,k-1));\\n        }\\n        return dp[i][k]=best_sum;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<vector<double>> dp(n,vector<double>(k+1,-1));\\n        return large_sum(dp,nums,0,k);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution: \\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        @cache\\n        def dfs(start, parts):\\n            if parts <= 0 or start >= n: return 0\\n            if parts == 1: return get_avg(start, n) \\n            return max(get_avg(start, end) + dfs(end, parts - 1) for end in range(start + 1, n - parts + 2))\\n        n = len(nums)\\n        running_sums = list(accumulate(nums, initial=0))\\n        get_avg = lambda start, end: (running_sums[end] - running_sums[start]) / (end - start)   \\n        return dfs(0, k)\\n    \\n    def largestSumOfAverages_(self, nums: List[int], k: int) -> float:\\n        @cache\\n        def dfs(start, parts):\\n            if parts <= 0 or start >= n: return 0\\n            if parts == 1: return get_avg(start, n) # (running_sums[n] - running_sums[start]) / (n - start) \\n            cur, total, length = 0, 0, 0 \\n            for end in range(start, n - parts + 1): \\n                cur = max(cur, get_avg(start, end + 1) + dfs(end + 1, parts - 1))\\n            return cur\\n        n = len(nums)\\n        running_sums = list(accumulate(nums, initial=0))\\n        get_avg = lambda start, end: (running_sums[end] - running_sums[start]) / (end - start) \\n        return dfs(0, k)\\n        \\n    def largestSumOfAverages_(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n)]\\n        running_sums = [0] #list(accumulate(nums, initial=0))\\n        total = 0 \\n        for i in range(n):\\n            total += nums[i]\\n            running_sums.append(total)\\n            dp[i][1] = total / (i + 1)\\n        \\n        for parts in range(2, k + 1):\\n            for end in range(parts - 1, n):\\n                for start in range(end):\\n                    dp[end][parts] = max(dp[end][parts], dp[start][parts - 1] + \\\\\\n                            (running_sums[end + 1] - running_sums[start + 1]) / (end - start)) \\n                            #sum(nums[start + 1:end + 1]) / (end - start ))  \\n        return dp[n - 1][k]\\n     \\n    def largestSumOfAverages_(self, nums: List[int], k: int) -> float:\\n        from functools import lru_cache\\n        @lru_cache(None)\\n        def dfs(start, parts):\\n            if parts <= 0 or start >= n: return 0\\n            if parts == 1: return sum(nums[start:]) / (n - start) \\n            cur, total, length = 0, 0, 0 \\n            for end in range(start, n - parts + 1):\\n                length += 1\\n                total += nums[end] \\n                cur = max(cur, total / length + dfs(end + 1, parts - 1))\\n            return cur\\n        n = len(nums)\\n        return dfs(0, k)\\n```\\n\\n```Java []\\nclass Solution {\\n  public double largestSumOfAverages(int[] A, int K) {\\n    final int n = A.length;\\n    dp = new double[n + 1][K + 1];\\n    prefix = new double[n + 1];\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i + 1] = A[i] + prefix[i];\\n\\n    return largestSumOfAverages(A, n, K);\\n  }\\n  private double[][] dp;\\n  private double[] prefix;\\n\\n  private double largestSumOfAverages(int[] A, int i, int k) {\\n    if (k == 1)\\n      return prefix[i] / i;\\n    if (dp[i][k] > 0.0)\\n      return dp[i][k];\\n\\n    for (int j = k - 1; j < i; ++j)\\n      dp[i][k] =\\n          Math.max(dp[i][k], largestSumOfAverages(A, j, k - 1) + (prefix[i] - prefix[j]) / (i - j));\\n\\n    return dp[i][k];\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#define inf -100000.0\\n\\nclass Solution {\\npublic:\\n    double large_sum(vector<vector<double>> &dp,vector<int> & nums,int i, int k ){\\n        if(i>=nums.size()){\\n            return 0.0;\\n        }\\n        if(k<=0){\\n            return inf;\\n        }\\n        if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        double sum=0;\\n        double best_sum=0.0;\\n        for(int j=i;j<nums.size()-k+1;j++){\\n            sum+=nums[j];\\n            best_sum=max(best_sum, sum/(j-i+1) + large_sum(dp,nums,j+1,k-1));\\n        }\\n        return dp[i][k]=best_sum;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<vector<double>> dp(n,vector<double>(k+1,-1));\\n        return large_sum(dp,nums,0,k);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution: \\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        @cache\\n        def dfs(start, parts):\\n            if parts <= 0 or start >= n: return 0\\n            if parts == 1: return get_avg(start, n) \\n            return max(get_avg(start, end) + dfs(end, parts - 1) for end in range(start + 1, n - parts + 2))\\n        n = len(nums)\\n        running_sums = list(accumulate(nums, initial=0))\\n        get_avg = lambda start, end: (running_sums[end] - running_sums[start]) / (end - start)   \\n        return dfs(0, k)\\n    \\n    def largestSumOfAverages_(self, nums: List[int], k: int) -> float:\\n        @cache\\n        def dfs(start, parts):\\n            if parts <= 0 or start >= n: return 0\\n            if parts == 1: return get_avg(start, n) # (running_sums[n] - running_sums[start]) / (n - start) \\n            cur, total, length = 0, 0, 0 \\n            for end in range(start, n - parts + 1): \\n                cur = max(cur, get_avg(start, end + 1) + dfs(end + 1, parts - 1))\\n            return cur\\n        n = len(nums)\\n        running_sums = list(accumulate(nums, initial=0))\\n        get_avg = lambda start, end: (running_sums[end] - running_sums[start]) / (end - start) \\n        return dfs(0, k)\\n        \\n    def largestSumOfAverages_(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n)]\\n        running_sums = [0] #list(accumulate(nums, initial=0))\\n        total = 0 \\n        for i in range(n):\\n            total += nums[i]\\n            running_sums.append(total)\\n            dp[i][1] = total / (i + 1)\\n        \\n        for parts in range(2, k + 1):\\n            for end in range(parts - 1, n):\\n                for start in range(end):\\n                    dp[end][parts] = max(dp[end][parts], dp[start][parts - 1] + \\\\\\n                            (running_sums[end + 1] - running_sums[start + 1]) / (end - start)) \\n                            #sum(nums[start + 1:end + 1]) / (end - start ))  \\n        return dp[n - 1][k]\\n     \\n    def largestSumOfAverages_(self, nums: List[int], k: int) -> float:\\n        from functools import lru_cache\\n        @lru_cache(None)\\n        def dfs(start, parts):\\n            if parts <= 0 or start >= n: return 0\\n            if parts == 1: return sum(nums[start:]) / (n - start) \\n            cur, total, length = 0, 0, 0 \\n            for end in range(start, n - parts + 1):\\n                length += 1\\n                total += nums[end] \\n                cur = max(cur, total / length + dfs(end + 1, parts - 1))\\n            return cur\\n        n = len(nums)\\n        return dfs(0, k)\\n```\n```Java []\\nclass Solution {\\n  public double largestSumOfAverages(int[] A, int K) {\\n    final int n = A.length;\\n    dp = new double[n + 1][K + 1];\\n    prefix = new double[n + 1];\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i + 1] = A[i] + prefix[i];\\n\\n    return largestSumOfAverages(A, n, K);\\n  }\\n  private double[][] dp;\\n  private double[] prefix;\\n\\n  private double largestSumOfAverages(int[] A, int i, int k) {\\n    if (k == 1)\\n      return prefix[i] / i;\\n    if (dp[i][k] > 0.0)\\n      return dp[i][k];\\n\\n    for (int j = k - 1; j < i; ++j)\\n      dp[i][k] =\\n          Math.max(dp[i][k], largestSumOfAverages(A, j, k - 1) + (prefix[i] - prefix[j]) / (i - j));\\n\\n    return dp[i][k];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829255,
                "title": "python-solution-simple-recursion-and-memoization",
                "content": "TC:O(N\\\\*N\\\\*K)\\nSC:O(N\\\\*N\\\\*K)\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        n=len(nums)\\n        dp=[[[-1 for _ in range(k+1)] for _ in range(n+1)] for _ in range(n+1)]\\n        \\n        def recur(i,j,par):\\n            #base\\n            if i>j:\\n                return 0\\n            if par==1:\\n                return sum(nums[i:j+1])/(j-i+1)\\n            if i==j:\\n                return nums[i]\\n            if dp[i][j][par]!=-1:\\n                return dp[i][j][par]\\n            #choices\\n            mx=float(\\'-inf\\')\\n            for p in range(i,j-par+2):\\n                left=sum(nums[i:p+1])/(p-i+1)\\n                tmpAns=left+recur(p+1,j,par-1)\\n                mx=max(mx,tmpAns)\\n            dp[i][j][par]=mx\\n            return dp[i][j][par]\\n\\n        return recur(0,n-1,k)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "TC:O(N\\\\*N\\\\*K)\\nSC:O(N\\\\*N\\\\*K)\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        n=len(nums)\\n        dp=[[[-1 for _ in range(k+1)] for _ in range(n+1)] for _ in range(n+1)]\\n        \\n        def recur(i,j,par):\\n            #base\\n            if i>j:\\n                return 0\\n            if par==1:\\n                return sum(nums[i:j+1])/(j-i+1)\\n            if i==j:\\n                return nums[i]\\n            if dp[i][j][par]!=-1:\\n                return dp[i][j][par]\\n            #choices\\n            mx=float(\\'-inf\\')\\n            for p in range(i,j-par+2):\\n                left=sum(nums[i:p+1])/(p-i+1)\\n                tmpAns=left+recur(p+1,j,par-1)\\n                mx=max(mx,tmpAns)\\n            dp[i][j][par]=mx\\n            return dp[i][j][par]\\n\\n        return recur(0,n-1,k)",
                "codeTag": "Java"
            },
            {
                "id": 2799259,
                "title": "java-how-to-use-recursion-transfer-to-dp-dp-recursion-memoryrecursive",
                "content": "Similar problems for partitioning arrays of characters to find the maximum and minimum can generally be solved by recursive enumeration, by enumerating each partition to get the final maximum value \\nThe recursive code is as follows.\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        return dfs(A, 0, K);\\n    }\\n    private double dfs(int A[] ,int index,int K){\\n        if(K==0){\\n            return 0.0;\\n        }\\n\\t\\t//Returns the mean value of the entire array directly when k=1\\n        if(K==1){\\n            int sum = 0;\\n            for(int i=index;i<A.length;i++){\\n                sum+=A[i];\\n            }\\n            return (double)sum/(A.length-index);\\n        }\\n        double sum = 0.0;\\n        double res = 0.0;\\n        for(int i=index;i<=A.length-K;i++){\\n\\t\\t\\t// enumerate each separation point\\n            sum+=A[i];\\n            double avage = sum/(i-index+1);\\n\\t\\t\\t//next sub array mean\\n            double temp = dfs(A,i+1,K-1);\\n\\t\\t\\t//find max\\n            res = Math.max(res, avage+temp);\\n        }\\n        return (double)res;\\n    }\\n}\\n```\\nIn this case, the recursion will time out. In general, recursion is not an optimal solution because it involves a lot of repetition, so we can use mnemonic recursion: mnemonic means using an array to record the recursive values that have been obtained, so that when the branch is entered again, the solution can be obtained quickly. After understanding the recursive code above, it is easy to modify it slightly to obtain the code\\n```\\nclass Solution {\\n    double [][] memo ;\\n    public double largestSumOfAverages(int[] A, int K) {\\n        this.memo = new double [A.length+1][K+1];\\n        return dfs(A, 0, K);\\n    }\\n    private double dfs(int A[] ,int index,int K){\\n        if(K==0){\\n            return 0.0;\\n        }\\n        if(memo[index][K]!=0.0)   return memo[index][K];\\n        if(K==1){\\n            int sum = 0;\\n            for(int i=index;i<A.length;i++){\\n                sum+=A[i];\\n            }\\n            memo[index][K] = (double)sum/(A.length-index);\\n            return memo[index][K];\\n        }\\n        double sum = 0.0;\\n        double res = 0.0;\\n        for(int i=index;i<=A.length-K;i++){\\n            sum+=A[i];\\n            double avage = sum/(i-index+1);\\n            // double temp = dfs(A,i+1,K-1);\\n            // memo[i+1][K-1] = temp;\\n            memo[i+1][K-1] = dfs(A,i+1,K-1);\\n            res = Math.max(res, avage+memo[i+1][K-1]);\\n        }\\n        memo[index][K] =res;\\n        return (double)res;\\n    }\\n}\\n```\\nFinally,how to get a dp method?\\nThe mnemonic recursion is actually very similar to dynamic programming, except that one is a top-down tableau and the other is a bottom-up tableau, and we can rewrite the mnemonic recursion as DP\\n```\\npublic double largestSumOfAverages(int[] A, int K) {\\n        double[][] dp = new double[A.length+1][K+1];\\n        double [] preSum = new double[A.length+1];\\n        for(int i=0;i<A.length;i++){\\n            preSum[i+1]= preSum[i]+A[i];\\n\\t\\t\\t//init\\n            dp[i+1][1] = preSum[i+1]/(i+1);\\n        }\\n        for(int i=1;i<=A.length;i++){\\n            for(int j=2;j<=Math.min(K, i);j++){\\n                //The maximum mean value of dp[i][j] should be the mean value of dp[t][j-1] + the mean value between array{t-i}. This result can be seen in the backtracking algorithm above\\n                for(int t = 0;t<i;t++){\\n                    dp[i][j] = Math.max(dp[i][j], dp[t][j-1]+(preSum[i]-preSum[t])/(i-t));\\n                }\\n            }\\n        }\\n        return dp[A.length][K];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        return dfs(A, 0, K);\\n    }\\n    private double dfs(int A[] ,int index,int K){\\n        if(K==0){\\n            return 0.0;\\n        }\\n\\t\\t//Returns the mean value of the entire array directly when k=1\\n        if(K==1){\\n            int sum = 0;\\n            for(int i=index;i<A.length;i++){\\n                sum+=A[i];\\n            }\\n            return (double)sum/(A.length-index);\\n        }\\n        double sum = 0.0;\\n        double res = 0.0;\\n        for(int i=index;i<=A.length-K;i++){\\n\\t\\t\\t// enumerate each separation point\\n            sum+=A[i];\\n            double avage = sum/(i-index+1);\\n\\t\\t\\t//next sub array mean\\n            double temp = dfs(A,i+1,K-1);\\n\\t\\t\\t//find max\\n            res = Math.max(res, avage+temp);\\n        }\\n        return (double)res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    double [][] memo ;\\n    public double largestSumOfAverages(int[] A, int K) {\\n        this.memo = new double [A.length+1][K+1];\\n        return dfs(A, 0, K);\\n    }\\n    private double dfs(int A[] ,int index,int K){\\n        if(K==0){\\n            return 0.0;\\n        }\\n        if(memo[index][K]!=0.0)   return memo[index][K];\\n        if(K==1){\\n            int sum = 0;\\n            for(int i=index;i<A.length;i++){\\n                sum+=A[i];\\n            }\\n            memo[index][K] = (double)sum/(A.length-index);\\n            return memo[index][K];\\n        }\\n        double sum = 0.0;\\n        double res = 0.0;\\n        for(int i=index;i<=A.length-K;i++){\\n            sum+=A[i];\\n            double avage = sum/(i-index+1);\\n            // double temp = dfs(A,i+1,K-1);\\n            // memo[i+1][K-1] = temp;\\n            memo[i+1][K-1] = dfs(A,i+1,K-1);\\n            res = Math.max(res, avage+memo[i+1][K-1]);\\n        }\\n        memo[index][K] =res;\\n        return (double)res;\\n    }\\n}\\n```\n```\\npublic double largestSumOfAverages(int[] A, int K) {\\n        double[][] dp = new double[A.length+1][K+1];\\n        double [] preSum = new double[A.length+1];\\n        for(int i=0;i<A.length;i++){\\n            preSum[i+1]= preSum[i]+A[i];\\n\\t\\t\\t//init\\n            dp[i+1][1] = preSum[i+1]/(i+1);\\n        }\\n        for(int i=1;i<=A.length;i++){\\n            for(int j=2;j<=Math.min(K, i);j++){\\n                //The maximum mean value of dp[i][j] should be the mean value of dp[t][j-1] + the mean value between array{t-i}. This result can be seen in the backtracking algorithm above\\n                for(int t = 0;t<i;t++){\\n                    dp[i][j] = Math.max(dp[i][j], dp[t][j-1]+(preSum[i]-preSum[t])/(i-t));\\n                }\\n            }\\n        }\\n        return dp[A.length][K];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796929,
                "title": "java-one-the-easiest-solution-with-explanation-and-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Problem is based on the problem of the Partition DP, If you are not familiar with this concept, i would highly advice any one to please go thorugh this once, and then came back.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n*k)\\n\\n# Code\\n```\\nclass Solution {\\n    public static double largestSumOfAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        Double[][] dp = new Double[n+1][k+1];\\n        return solve(nums, k, 0, n, dp);\\n    }\\n\\n    private static double solve(int[] nums, int k, int cur,int n, Double[][] dp){\\n        if(cur >= n || k < 0) return 0;\\n        if(k==0) return Integer.MIN_VALUE;\\n        if(dp[cur][k] != null) return dp[cur][k];\\n        double ans = 0.0;\\n        double sum = 0.0;\\n        for(int i=cur;i<n;i++){\\n            sum+=nums[i];\\n            ans = Math.max(ans, sum*1.0/(i-cur+1) + solve(nums, k-1, i+1, n, dp));\\n        }\\n        return dp[cur][k] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static double largestSumOfAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        Double[][] dp = new Double[n+1][k+1];\\n        return solve(nums, k, 0, n, dp);\\n    }\\n\\n    private static double solve(int[] nums, int k, int cur,int n, Double[][] dp){\\n        if(cur >= n || k < 0) return 0;\\n        if(k==0) return Integer.MIN_VALUE;\\n        if(dp[cur][k] != null) return dp[cur][k];\\n        double ans = 0.0;\\n        double sum = 0.0;\\n        for(int i=cur;i<n;i++){\\n            sum+=nums[i];\\n            ans = Math.max(ans, sum*1.0/(i-cur+1) + solve(nums, k-1, i+1, n, dp));\\n        }\\n        return dp[cur][k] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650815,
                "title": "c-2-methods-top-down-bottom-up-approach-solution-recursion-memoization-tabulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    double SolveByMemo(vector<int>& nums, int index , int k, vector<vector<double>>& dp)\\n    {\\n        if(index == nums.size())\\n            return 0;\\n\\n        if(dp[index][k] != -1)\\n        return dp[index][k] ;\\n\\n        if(k == 1)\\n        {\\n            double sum = 0;\\n            for(int i = index ; i<nums.size() ; i++)\\n             sum+= nums[i];\\n             \\n             return dp[index][k] = sum/(nums.size()-index);\\n        }\\n\\n        double maxi = 0;\\n        double curr_avg = 0;\\n\\n        for(int i = index ; i<=nums.size()-k ; i++)\\n        {\\n            curr_avg+= nums[i];\\n            maxi = max(maxi , (curr_avg/(i-index+1)) + SolveByMemo(nums, i+1 , k-1 , dp));\\n        }\\n\\n        return dp[index][k] = maxi;\\n    }\\n\\n     double SolveByTab(vector<int>& nums , int k)\\n    {\\n\\n       vector<vector<double>> dp(nums.size()+1 , vector<double> (k+1, 0));\\n\\n        for(int m = nums.size()-1 ; m>= 0 ; m--)\\n        {\\n             for(int n = 1 ; n <= k ; n++)\\n             {\\n                  if(n == 1)\\n                  {\\n                      double sum = 0;\\n                       for(int i = m ; i<nums.size() ; i++)\\n                        sum+= nums[i];\\n             \\n                        dp[m][n] = sum/(nums.size()-m);\\n                       continue ;\\n                 }\\n\\n                 double maxi = 0;\\n                 double curr_avg = 0;\\n                 for(int i = m ; i<= nums.size()-n ; i++)\\n                 {\\n                  curr_avg+= nums[i];\\n                  maxi = max(maxi , (curr_avg/(i-m+1)) + dp[i+1][n-1]);\\n                 }\\n\\n                 dp[m][n] = maxi;\\n             }\\n        }\\n\\n        return dp[0][k] ;\\n    }\\n\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        // vector<vector<double>> dp(nums.size() , vector<double> (k+1, -1));\\n\\n        // return SolveByMemo(nums, 0 , k , dp);\\n\\n        return SolveByTab(nums, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    double SolveByMemo(vector<int>& nums, int index , int k, vector<vector<double>>& dp)\\n    {\\n        if(index == nums.size())\\n            return 0;\\n\\n        if(dp[index][k] != -1)\\n        return dp[index][k] ;\\n\\n        if(k == 1)\\n        {\\n            double sum = 0;\\n            for(int i = index ; i<nums.size() ; i++)\\n             sum+= nums[i];\\n             \\n             return dp[index][k] = sum/(nums.size()-index);\\n        }\\n\\n        double maxi = 0;\\n        double curr_avg = 0;\\n\\n        for(int i = index ; i<=nums.size()-k ; i++)\\n        {\\n            curr_avg+= nums[i];\\n            maxi = max(maxi , (curr_avg/(i-index+1)) + SolveByMemo(nums, i+1 , k-1 , dp));\\n        }\\n\\n        return dp[index][k] = maxi;\\n    }\\n\\n     double SolveByTab(vector<int>& nums , int k)\\n    {\\n\\n       vector<vector<double>> dp(nums.size()+1 , vector<double> (k+1, 0));\\n\\n        for(int m = nums.size()-1 ; m>= 0 ; m--)\\n        {\\n             for(int n = 1 ; n <= k ; n++)\\n             {\\n                  if(n == 1)\\n                  {\\n                      double sum = 0;\\n                       for(int i = m ; i<nums.size() ; i++)\\n                        sum+= nums[i];\\n             \\n                        dp[m][n] = sum/(nums.size()-m);\\n                       continue ;\\n                 }\\n\\n                 double maxi = 0;\\n                 double curr_avg = 0;\\n                 for(int i = m ; i<= nums.size()-n ; i++)\\n                 {\\n                  curr_avg+= nums[i];\\n                  maxi = max(maxi , (curr_avg/(i-m+1)) + dp[i+1][n-1]);\\n                 }\\n\\n                 dp[m][n] = maxi;\\n             }\\n        }\\n\\n        return dp[0][k] ;\\n    }\\n\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        // vector<vector<double>> dp(nums.size() , vector<double> (k+1, -1));\\n\\n        // return SolveByMemo(nums, 0 , k , dp);\\n\\n        return SolveByTab(nums, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510992,
                "title": "c-front-partitioning-approach-dp-memoization",
                "content": "TC:O(N * K)\\nSC: O(N * K) + O(N) + Auxiliary stack space O(k)\\n```\\nclass Solution {\\npublic:\\n    double solve(int i, int j, vector<int>&arr,int part,vector<vector<double>>&dp){\\n        //base case\\n        if(i>j)return 0.0;\\n        if(part==0)\\n            return (double(arr[j]-arr[i-1]))/double(j-i+1); \\n        //check the cache\\n        if(dp[i][part]!=-1)\\n            return dp[i][part];\\n        \\n        double score=0;\\n        for(int k=i;k<=j;k++){\\n            double curr= (double(arr[k]-arr[i-1]))/double(k-i+1) +\\n                         solve(k+1,j,arr,part-1,dp);\\n            score=max(score,curr);\\n        }\\n        return dp[i][part]= score;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<vector<double>>dp(n+1,vector<double>(k,-1));\\n        vector<int>arr(n+1,0);\\n        for(int i=0;i<n;i++)arr[i+1]=nums[i]+arr[i];\\n        return solve(1,n,arr,k-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double solve(int i, int j, vector<int>&arr,int part,vector<vector<double>>&dp){\\n        //base case\\n        if(i>j)return 0.0;\\n        if(part==0)\\n            return (double(arr[j]-arr[i-1]))/double(j-i+1); \\n        //check the cache\\n        if(dp[i][part]!=-1)\\n            return dp[i][part];\\n        \\n        double score=0;\\n        for(int k=i;k<=j;k++){\\n            double curr= (double(arr[k]-arr[i-1]))/double(k-i+1) +\\n                         solve(k+1,j,arr,part-1,dp);\\n            score=max(score,curr);\\n        }\\n        return dp[i][part]= score;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<vector<double>>dp(n+1,vector<double>(k,-1));\\n        vector<int>arr(n+1,0);\\n        for(int i=0;i<n;i++)arr[i+1]=nums[i]+arr[i];\\n        return solve(1,n,arr,k-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463130,
                "title": "70-tc-and-56-sc-easy-python-solution",
                "content": "```\\ndef largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\tn = len(nums)\\n\\tpre = [0]\\n\\tfor i in nums:\\n\\t\\tpre.append(pre[-1] + i)\\n\\tdef solve(i, k):\\n\\t\\tif(k == 1): return sum(nums[i:])/(n-i)\\n\\n\\t\\tif(n-i < k): return -1\\n\\n\\t\\tif((i, k) in d): return d[(i, k)]\\n\\n\\t\\ttemp = 0\\n\\t\\tfor j in range(i+1, n):\\n\\t\\t\\ttemp = max(temp, solve(j, k-1)+(pre[j]-pre[i])/(j-i))\\n\\t\\td[(i, k)] = temp\\n\\t\\treturn temp\\n\\td = dict()            \\n\\treturn solve(0, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\tn = len(nums)\\n\\tpre = [0]\\n\\tfor i in nums:\\n\\t\\tpre.append(pre[-1] + i)\\n\\tdef solve(i, k):\\n\\t\\tif(k == 1): return sum(nums[i:])/(n-i)\\n\\n\\t\\tif(n-i < k): return -1\\n\\n\\t\\tif((i, k) in d): return d[(i, k)]\\n\\n\\t\\ttemp = 0\\n\\t\\tfor j in range(i+1, n):\\n\\t\\t\\ttemp = max(temp, solve(j, k-1)+(pre[j]-pre[i])/(j-i))\\n\\t\\td[(i, k)] = temp\\n\\t\\treturn temp\\n\\td = dict()            \\n\\treturn solve(0, k)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2435891,
                "title": "problem-with-my-code",
                "content": "Can someone explain me what\\'s the problem with my code . TIA.\\n\\n```\\ndouble largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int x = k-1;\\n        int i=1;\\n        double sum=0,sum1=0;\\n        while(x--)\\n        {\\n            sum+=nums[n-i];\\n            i++;\\n        }\\n        x=k-1;\\n        cout<<sum<<endl;\\n        int c=0,g=(n-x);\\n        for(int i =0;i<g;i++)\\n        {\\n            sum1+=nums[i];\\n            c++;\\n        }\\n        cout<<sum1<<endl;\\n        sum1/=c;\\n        return sum+sum1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int x = k-1;\\n        int i=1;\\n        double sum=0,sum1=0;\\n        while(x--)\\n        {\\n            sum+=nums[n-i];\\n            i++;\\n        }\\n        x=k-1;\\n        cout<<sum<<endl;\\n        int c=0,g=(n-x);\\n        for(int i =0;i<g;i++)\\n        {\\n            sum1+=nums[i];\\n            c++;\\n        }\\n        cout<<sum1<<endl;\\n        sum1/=c;\\n        return sum+sum1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2435851,
                "title": "c-dp-on-prefix-sum",
                "content": "```\\ndouble dp[101][101];\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        \\n        memset(dp, -1, sizeof dp);\\n        // create the prefix sum\\n        for(int i = 1; i < nums.size(); i++)\\n            nums[i] += nums[i - 1];\\n        \\n        return fun(nums, 0, k);\\n    }\\n    \\n    double fun(vector<int> &nums, int i, int l) {\\n        \\n        // if no elements remain return 0\\n        if(i >= nums.size()) return 0;\\n        // for the last subarray\\n        if(l == 1)\\n            return (nums.back() * 1.0 - (i - 1 >= 0 ? nums[i - 1] * 1.0 : 0.0)) / ((nums.size() - i) * 1.0);\\n        \\n        if(dp[i][l] > -0.00009) return dp[i][l];\\n        \\n        double mx = 0;\\n        for(int k = i; k < nums.size(); k++) {\\n            // store the current subarray average [i k] in p\\n            double p = nums[k] - (i - 1 >= 0 ? nums[i - 1] : 0);\\n            p /= ((k - i + 1) * 1.0);\\n            \\n            // we already have one subarray average call the function for l - 1 subarrays\\n            double q = fun(nums, k + 1, l - 1);\\n            \\n            // store the maximum\\n            mx = max(mx, p + q);\\n        }\\n        return dp[i][l] = mx;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndouble dp[101][101];\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        \\n        memset(dp, -1, sizeof dp);\\n        // create the prefix sum\\n        for(int i = 1; i < nums.size(); i++)\\n            nums[i] += nums[i - 1];\\n        \\n        return fun(nums, 0, k);\\n    }\\n    \\n    double fun(vector<int> &nums, int i, int l) {\\n        \\n        // if no elements remain return 0\\n        if(i >= nums.size()) return 0;\\n        // for the last subarray\\n        if(l == 1)\\n            return (nums.back() * 1.0 - (i - 1 >= 0 ? nums[i - 1] * 1.0 : 0.0)) / ((nums.size() - i) * 1.0);\\n        \\n        if(dp[i][l] > -0.00009) return dp[i][l];\\n        \\n        double mx = 0;\\n        for(int k = i; k < nums.size(); k++) {\\n            // store the current subarray average [i k] in p\\n            double p = nums[k] - (i - 1 >= 0 ? nums[i - 1] : 0);\\n            p /= ((k - i + 1) * 1.0);\\n            \\n            // we already have one subarray average call the function for l - 1 subarrays\\n            double q = fun(nums, k + 1, l - 1);\\n            \\n            // store the maximum\\n            mx = max(mx, p + q);\\n        }\\n        return dp[i][l] = mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2415311,
                "title": "easy-to-understand-c-recursion-memo-dp",
                "content": "```\\n// Recursion+Memoization\\nclass Solution {\\npublic:\\n  double largestSumOfAverages(vector<int>& A, int K) {\\n    const int n = A.size();\\n    m_ = vector<vector<double>>(K + 1, vector<double>(n + 1, 0.0));\\n    sums_ = vector<double>(n + 1, 0.0);\\n    for (int i = 1; i <= n; ++i)\\n      sums_[i] = sums_[i - 1] + A[i - 1];\\n    return LSA(A, n, K);\\n  }\\nprivate:\\n  vector<vector<double>> m_;\\n  vector<double> sums_;\\n  \\n  // Largest sum of averages for first n elements in A paritioned into k groups\\n  double LSA(const vector<int>& A, int n, int k) {\\n    if (m_[k][n] > 0) return m_[k][n];\\n    if (n < k) return 0; //18ms to 10ms\\n    if (k == 1) return sums_[n] / n;\\n    for (int i = k - 1; i < n; ++i)\\n      m_[k][n] = max(m_[k][n], LSA(A, i, k - 1) + (sums_[n] - sums_[i]) / (n - i));\\n    return m_[k][n];\\n  }\\n};\\n\\n\\n//Dynamic programming\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int K) {\\n        vector<double>sums(nums.size()+1, 0.0); \\n        vector<vector<double>>dp(K+1, vector<double>(nums.size()+1, 0.0));\\n        for(int i =1 ; i <=nums.size(); i++){\\n            sums[i]= sums[i-1]+nums[i-1];\\n            dp[1][i]= static_cast<double>(sums[i])/i;\\n        }\\n        for ( int k = 2 ; k <= K ; k++){\\n            for ( int i = k ; i <=nums.size() ; ++i){\\n                for ( int j = k-1 ; j<i; ++j){\\n                    dp[k][i]= max (dp[k][i], dp[k-1][j] + (sums[i]-sums[j]) /(i-j));\\n                }\\n            }\\n        }\\n        return dp[K][nums.size()]; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursion+Memoization\\nclass Solution {\\npublic:\\n  double largestSumOfAverages(vector<int>& A, int K) {\\n    const int n = A.size();\\n    m_ = vector<vector<double>>(K + 1, vector<double>(n + 1, 0.0));\\n    sums_ = vector<double>(n + 1, 0.0);\\n    for (int i = 1; i <= n; ++i)\\n      sums_[i] = sums_[i - 1] + A[i - 1];\\n    return LSA(A, n, K);\\n  }\\nprivate:\\n  vector<vector<double>> m_;\\n  vector<double> sums_;\\n  \\n  // Largest sum of averages for first n elements in A paritioned into k groups\\n  double LSA(const vector<int>& A, int n, int k) {\\n    if (m_[k][n] > 0) return m_[k][n];\\n    if (n < k) return 0; //18ms to 10ms\\n    if (k == 1) return sums_[n] / n;\\n    for (int i = k - 1; i < n; ++i)\\n      m_[k][n] = max(m_[k][n], LSA(A, i, k - 1) + (sums_[n] - sums_[i]) / (n - i));\\n    return m_[k][n];\\n  }\\n};\\n\\n\\n//Dynamic programming\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int K) {\\n        vector<double>sums(nums.size()+1, 0.0); \\n        vector<vector<double>>dp(K+1, vector<double>(nums.size()+1, 0.0));\\n        for(int i =1 ; i <=nums.size(); i++){\\n            sums[i]= sums[i-1]+nums[i-1];\\n            dp[1][i]= static_cast<double>(sums[i])/i;\\n        }\\n        for ( int k = 2 ; k <= K ; k++){\\n            for ( int i = k ; i <=nums.size() ; ++i){\\n                for ( int j = k-1 ; j<i; ++j){\\n                    dp[k][i]= max (dp[k][i], dp[k-1][j] + (sums[i]-sums[j]) /(i-j));\\n                }\\n            }\\n        }\\n        return dp[K][nums.size()]; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340613,
                "title": "largest-sum-of-averages-memoization",
                "content": "class Solution {\\n    double ans = 0;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(nums,0,k,new double[nums.length][k+1]);\\n    }\\n    \\n    public double solve(int[] nums,int idx,int k,double[][] dp){\\n        if(k == 1){\\n            double sum = 0;\\n            for(int i=idx;i<nums.length;i++){\\n                sum += nums[i];\\n            }\\n            return sum/(nums.length - idx);\\n        }\\n        \\n        if(dp[idx][k] != 0){\\n            return dp[idx][k];\\n        }\\n        \\n        double max = 0;\\n        for(int i=idx;i<nums.length;i++){\\n            double avg = 0;\\n            for(int j=idx;j<i+1;j++){\\n                avg += nums[j];\\n            }\\n            avg = avg / (i + 1 - idx);\\n            if(i+1<nums.length && k>1){\\n                double v = solve(nums,i+1,k-1,dp);\\n                max = Math.max(max,avg+v);\\n            }\\n        }\\n        return dp[idx][k] = max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    double ans = 0;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(nums,0,k,new double[nums.length][k+1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2309022,
                "title": "c-memoization-mcm-variation-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    double help(vector<int>&nums,int k,int i,int j,int n){\\n        if(i>j or k<=0){\\n            \\n            if(k==0 and i==n) return 0;\\n            else return INT_MIN/2;\\n        }\\n        if(dp[i][k]!=0) return dp[i][k];\\n        int sum=0;\\n        double temp=INT_MIN/2.0;\\n        for(int c=i;c<=j;c++){\\n            sum+=nums[c];\\n            double avg=(sum*1.0)/(c-i+1);\\n            temp=max(temp,avg+help(nums,k-1,c+1,j,n));\\n        }\\n        return dp[i][k]=temp;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        memset(dp,0,sizeof(dp));\\n        return help(nums,k,0,n-1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    double help(vector<int>&nums,int k,int i,int j,int n){\\n        if(i>j or k<=0){\\n            \\n            if(k==0 and i==n) return 0;\\n            else return INT_MIN/2;\\n        }\\n        if(dp[i][k]!=0) return dp[i][k];\\n        int sum=0;\\n        double temp=INT_MIN/2.0;\\n        for(int c=i;c<=j;c++){\\n            sum+=nums[c];\\n            double avg=(sum*1.0)/(c-i+1);\\n            temp=max(temp,avg+help(nums,k-1,c+1,j,n));\\n        }\\n        return dp[i][k]=temp;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        memset(dp,0,sizeof(dp));\\n        return help(nums,k,0,n-1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267492,
                "title": "easy-to-understand-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    double solve(vector<int>& nums,int k,int idx)\\n    {\\n\\t//Only one subarray remains\\n        if(k==1)\\n        {\\n            double sum=0;\\n            for(int i=idx;i<nums.size();++i)\\n            {\\n                sum+=(double)nums[i];\\n            }\\n            return (1.0)*sum/(nums.size()-idx);\\n        }\\n        if(idx>=nums.size())\\n        {\\n            return 0.0;\\n        }\\n        if(dp[k][idx]!=-1)\\n        {\\n            return dp[k][idx];\\n        }\\n        double ans=INT_MIN,avg=0.0;\\n        for(int i=idx;i<nums.size();++i)\\n        {\\n            avg+=nums[i];                                        // find avg upto ith num\\n            double rem=solve(nums,k-1,i+1);\\n            ans=max(ans,avg/(i-idx+1)+rem);       //store max avg upto ith num\\n        }\\n        return dp[k][idx]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<=k;++i)\\n        {\\n            for(int j=0;j<=n;++j)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(nums,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    double solve(vector<int>& nums,int k,int idx)\\n    {\\n\\t//Only one subarray remains\\n        if(k==1)\\n        {\\n            double sum=0;\\n            for(int i=idx;i<nums.size();++i)\\n            {\\n                sum+=(double)nums[i];\\n            }\\n            return (1.0)*sum/(nums.size()-idx);\\n        }\\n        if(idx>=nums.size())\\n        {\\n            return 0.0;\\n        }\\n        if(dp[k][idx]!=-1)\\n        {\\n            return dp[k][idx];\\n        }\\n        double ans=INT_MIN,avg=0.0;\\n        for(int i=idx;i<nums.size();++i)\\n        {\\n            avg+=nums[i];                                        // find avg upto ith num\\n            double rem=solve(nums,k-1,i+1);\\n            ans=max(ans,avg/(i-idx+1)+rem);       //store max avg upto ith num\\n        }\\n        return dp[k][idx]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<=k;++i)\\n        {\\n            for(int j=0;j<=n;++j)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(nums,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251890,
                "title": "python-simplest-optimal-solution-o-n-k",
                "content": "```class Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        sums = [0]\\n        for i in nums:\\n            sums += [sums[-1]+i]\\n        def f(i,k):\\n            if i >= n:\\n                return 0\\n            if k == 0:\\n                return (sums[-1] - sums[i])/(n-i)\\n            \\n            if dp[i][k] != -1:\\n                return dp[i][k]\\n            ans = 0\\n            for c in range(i,n):\\n                avg = (sums[c+1] - sums[i])/(c-i+1)\\n                ans = max(ans,avg+f(c+1,k-1))\\n            dp[i][k] = ans\\n            return ans\\n        dp = [[-1 for _ in range(k+1)] for _ in range(len(nums)+1)]\\n        return f(0,k-1)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        sums = [0]\\n        for i in nums:\\n            sums += [sums[-1]+i]\\n        def f(i,k):\\n            if i >= n:\\n                return 0\\n            if k == 0:\\n                return (sums[-1] - sums[i])/(n-i)\\n            \\n            if dp[i][k] != -1:\\n                return dp[i][k]\\n            ans = 0\\n            for c in range(i,n):\\n                avg = (sums[c+1] - sums[i])/(c-i+1)\\n                ans = max(ans,avg+f(c+1,k-1))\\n            dp[i][k] = ans\\n            return ans\\n        dp = [[-1 for _ in range(k+1)] for _ in range(len(nums)+1)]\\n        return f(0,k-1)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1970235,
                "title": "c-code-memoization-tabulation-commented",
                "content": "```\\n//Memoization\\nclass Solution {\\npublic:\\n    double helper(vector<int> &nums,int idx,int k,vector<vector<double>> &dp){\\n        if(idx>=nums.size()){\\n            return 0;\\n        }\\n        \\n        if(k==0){\\n            //we have already created k subarrays\\n            return INT_MIN;\\n        }\\n        if(dp[idx][k]!=-1){\\n            return dp[idx][k];\\n        }\\n        double sum=0;\\n        double ans=0.0;\\n        for(int j=idx;j<nums.size();j++){\\n\\t\\t//subarray starting at index \\'idx\\' and ending at \\'j\\'\\n\\t\\t//length of subarray is (j-idx+1)\\n            sum+=nums[j];\\n            double average=sum/(j-idx+1);\\n            ans=max(ans,average+helper(nums,j+1,k-1,dp));\\n        }\\n        return dp[idx][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<vector<double>> dp(n,vector<double> (k+1,-1));\\n        return helper(nums,0,k,dp); \\n    }\\n};\\n\\n//tabulation\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int K) {\\n        int n=nums.size();\\n        vector<vector<double>> dp(n+1,vector<double> (K+1,0));\\n        for(int k=0;k<=K;k++){\\n            dp[n][k]=0;\\n        }\\n        for(int idx=0;idx<n;idx++){\\n            dp[idx][0]=INT_MIN;\\n        }\\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int k=1;k<=K;k++){\\n                double sum=0;\\n                double ans=0.0;\\n                for(int j=idx;j<nums.size();j++){\\n                    sum+=nums[j];\\n                    double average=sum/(j-idx+1);\\n                    ans=max(ans,average + dp[j+1][k-1]);\\n                }\\n                dp[idx][k]=ans;\\n            }\\n        }\\n        return dp[0][K]; \\n    }\\n};\\n```\\nPlease do uptove if you like the post :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Memoization\\nclass Solution {\\npublic:\\n    double helper(vector<int> &nums,int idx,int k,vector<vector<double>> &dp){\\n        if(idx>=nums.size()){\\n            return 0;\\n        }\\n        \\n        if(k==0){\\n            //we have already created k subarrays\\n            return INT_MIN;\\n        }\\n        if(dp[idx][k]!=-1){\\n            return dp[idx][k];\\n        }\\n        double sum=0;\\n        double ans=0.0;\\n        for(int j=idx;j<nums.size();j++){\\n\\t\\t//subarray starting at index \\'idx\\' and ending at \\'j\\'\\n\\t\\t//length of subarray is (j-idx+1)\\n            sum+=nums[j];\\n            double average=sum/(j-idx+1);\\n            ans=max(ans,average+helper(nums,j+1,k-1,dp));\\n        }\\n        return dp[idx][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<vector<double>> dp(n,vector<double> (k+1,-1));\\n        return helper(nums,0,k,dp); \\n    }\\n};\\n\\n//tabulation\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int K) {\\n        int n=nums.size();\\n        vector<vector<double>> dp(n+1,vector<double> (K+1,0));\\n        for(int k=0;k<=K;k++){\\n            dp[n][k]=0;\\n        }\\n        for(int idx=0;idx<n;idx++){\\n            dp[idx][0]=INT_MIN;\\n        }\\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int k=1;k<=K;k++){\\n                double sum=0;\\n                double ans=0.0;\\n                for(int j=idx;j<nums.size();j++){\\n                    sum+=nums[j];\\n                    double average=sum/(j-idx+1);\\n                    ans=max(ans,average + dp[j+1][k-1]);\\n                }\\n                dp[idx][k]=ans;\\n            }\\n        }\\n        return dp[0][K]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854770,
                "title": "c-code-for-beginners-easy-to-understand-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>>dp;\\n    vector<int> prefix;\\n\\t\\n    double helper(vector<int> &nums, int curr, int k){\\n        if(k==0 && curr==nums.size()){ // this is the correct base, if k is zero and we reached nums.size this clearly means we have successfully divided the array into k PARTS \\n            return 0.0;\\n        }\\n        if(curr==nums.size() || k==0){  //not divided properly cases\\n            return INT_MIN;\\n        }\\n        if(dp[curr][k]!=-1){\\n            return dp[curr][k];\\n        }\\n        double res=0.0;\\n        for(int i=curr;i<nums.size();i++){\\n            double currSum=prefix[i]-prefix[curr]+nums[curr];\\n            double avgSum=currSum/(i-curr+1);\\n            res=max(res,avgSum+helper(nums,i+1,k-1));\\n        }\\n        return dp[curr][k]=res;\\n    }\\n\\t\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int N=nums.size();\\n        dp.resize(N+1,vector<double>(k+1,-1));\\n        prefix.resize(N);\\n\\t\\t\\n        prefix=nums;\\n        for(int i=1;i<N;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n\\t\\t\\n        return helper(nums,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>>dp;\\n    vector<int> prefix;\\n\\t\\n    double helper(vector<int> &nums, int curr, int k){\\n        if(k==0 && curr==nums.size()){ // this is the correct base, if k is zero and we reached nums.size this clearly means we have successfully divided the array into k PARTS \\n            return 0.0;\\n        }\\n        if(curr==nums.size() || k==0){  //not divided properly cases\\n            return INT_MIN;\\n        }\\n        if(dp[curr][k]!=-1){\\n            return dp[curr][k];\\n        }\\n        double res=0.0;\\n        for(int i=curr;i<nums.size();i++){\\n            double currSum=prefix[i]-prefix[curr]+nums[curr];\\n            double avgSum=currSum/(i-curr+1);\\n            res=max(res,avgSum+helper(nums,i+1,k-1));\\n        }\\n        return dp[curr][k]=res;\\n    }\\n\\t\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int N=nums.size();\\n        dp.resize(N+1,vector<double>(k+1,-1));\\n        prefix.resize(N);\\n\\t\\t\\n        prefix=nums;\\n        for(int i=1;i<N;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n\\t\\t\\n        return helper(nums,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787897,
                "title": "c-dp-o-k-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>>dp;\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int sz=nums.size();\\n        dp.resize(sz,vector<double>(k+1,-1));\\n        return calc(nums,k,sz,0);\\n    }\\n   double calc(vector<int>&nums,int k,int &size,int pos){\\n        if(k==0 && pos==size)\\n            return 0;\\n        else if(pos>=size || k==0)\\n            return double(INT_MIN);\\n        double maxAvg=0,sum=0;\\n        if(dp[pos][k]!=-1)\\n            return dp[pos][k];\\n        for(int i=pos;i<size;i++){\\n            sum+=nums[i];\\n            double retVal=calc(nums,k-1,size,i+1);\\n            if(retVal!=double(INT_MIN)){\\n            double lAvg=sum/(i-pos+1);\\n            maxAvg=max(maxAvg,lAvg+retVal);\\n        }    \\n        }\\n       dp[pos][k]=maxAvg;\\n       return maxAvg;\\n    }\\n};\\n```\\n**TC:-** O(k*n*n)\\n**SC:-** O(k*n)\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>>dp;\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int sz=nums.size();\\n        dp.resize(sz,vector<double>(k+1,-1));\\n        return calc(nums,k,sz,0);\\n    }\\n   double calc(vector<int>&nums,int k,int &size,int pos){\\n        if(k==0 && pos==size)\\n            return 0;\\n        else if(pos>=size || k==0)\\n            return double(INT_MIN);\\n        double maxAvg=0,sum=0;\\n        if(dp[pos][k]!=-1)\\n            return dp[pos][k];\\n        for(int i=pos;i<size;i++){\\n            sum+=nums[i];\\n            double retVal=calc(nums,k-1,size,i+1);\\n            if(retVal!=double(INT_MIN)){\\n            double lAvg=sum/(i-pos+1);\\n            maxAvg=max(maxAvg,lAvg+retVal);\\n        }    \\n        }\\n       dp[pos][k]=maxAvg;\\n       return maxAvg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766124,
                "title": "easy-to-understand-c-brute-force-dfs-dfs-memo",
                "content": "C++ naive way dfs brute force will TLE I assume!\\n```\\nclass Solution {\\npublic:\\n    double dfs(int start, vector<int>& nums, int partition) {\\n        if(partition == 1) {\\n            double avg = 0;\\n            for(int i = start; i < nums.size(); i++) {\\n                avg += nums[i];\\n            }\\n            return avg / (nums.size()-start);\\n        }\\n        double maxSum = 0;\\n        for(int k = start+1; k < nums.size(); k++) {\\n            double avg = 0;\\n            for(int j = start; j < k; j++) {\\n                avg += nums[j];\\n            }\\n            avg = avg / (k-start);\\n                        \\n            maxSum = max(avg + dfs(k, nums, partition-1), maxSum);\\n\\n        }\\n        return maxSum;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        return dfs(0, nums, k);\\n    }\\n};\\n```\\n\\nThen we can easily replace calc sum part into a dp memo array `dp[start][partition]`  (Accepted) \\n\\n```\\nclass Solution {\\npublic:\\n    double dfs(int start, vector<int>& nums, int partition, vector<vector<double>> &dp) {\\n        if(dp[start][partition] != 0) return dp[start][partition];\\n        \\n        if(partition == 1) {\\n            double avg = 0;\\n            for(int i = start; i < nums.size(); i++) {\\n                avg += nums[i];\\n            }\\n            dp[start][1] = avg / (nums.size()-start);\\n            return dp[start][1];\\n        }\\n        \\n        // double maxSum = 0;\\n        int k;\\n        for(k = start+1; k < nums.size(); k++) {\\n            double avg = 0;\\n            for(int j = start; j < k; j++) {\\n                avg += nums[j];\\n            }\\n            avg = avg / (k-start);\\n            \\n            dp[start][partition] = max(avg + dfs(k, nums, partition-1, dp), dp[start][partition]);\\n        }\\n        return dp[start][partition];\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        //dp[start][k]  maxSum of start and k partition\\n        vector<vector<double>> dp(nums.size(), vector<double>(k+1, 0));\\n        dfs(0, nums, k, dp);\\n        return dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double dfs(int start, vector<int>& nums, int partition) {\\n        if(partition == 1) {\\n            double avg = 0;\\n            for(int i = start; i < nums.size(); i++) {\\n                avg += nums[i];\\n            }\\n            return avg / (nums.size()-start);\\n        }\\n        double maxSum = 0;\\n        for(int k = start+1; k < nums.size(); k++) {\\n            double avg = 0;\\n            for(int j = start; j < k; j++) {\\n                avg += nums[j];\\n            }\\n            avg = avg / (k-start);\\n                        \\n            maxSum = max(avg + dfs(k, nums, partition-1), maxSum);\\n\\n        }\\n        return maxSum;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        return dfs(0, nums, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double dfs(int start, vector<int>& nums, int partition, vector<vector<double>> &dp) {\\n        if(dp[start][partition] != 0) return dp[start][partition];\\n        \\n        if(partition == 1) {\\n            double avg = 0;\\n            for(int i = start; i < nums.size(); i++) {\\n                avg += nums[i];\\n            }\\n            dp[start][1] = avg / (nums.size()-start);\\n            return dp[start][1];\\n        }\\n        \\n        // double maxSum = 0;\\n        int k;\\n        for(k = start+1; k < nums.size(); k++) {\\n            double avg = 0;\\n            for(int j = start; j < k; j++) {\\n                avg += nums[j];\\n            }\\n            avg = avg / (k-start);\\n            \\n            dp[start][partition] = max(avg + dfs(k, nums, partition-1, dp), dp[start][partition]);\\n        }\\n        return dp[start][partition];\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        //dp[start][k]  maxSum of start and k partition\\n        vector<vector<double>> dp(nums.size(), vector<double>(k+1, 0));\\n        dfs(0, nums, k, dp);\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700534,
                "title": "largest-sum-of-average-a-similar-question-to-egg-dropping-puzzle",
                "content": "class Solution {\\nprivate:\\n    double ans; vector< int >nums;\\n    vector< vector< double >>DP;\\n    \\npublic:\\n    double makeSeparation( int i , int k ){\\n        \\n        if( i >= nums.size() )\\n              return 0;\\n        \\n        if( DP[i][k] != -1 )\\n            return DP[i][k];\\n        \\n        double start = i == 0 ? 0 : nums[i-1];\\n        \\n        if( k == 1 ){\\n            \\n            double x = 1.0*( nums[ nums.size() - 1 ] - start )/( nums.size() - i );\\n            \\n            return x;\\n        }\\n        \\n        if( k >= ( nums.size() - i ) ){\\n            \\n            double x = 1.0*( nums[ nums.size() - 1 ] - start );\\n            \\n            return x;\\n        }\\n        \\n        double temp = INT_MIN;\\n        \\n        for( int j=i ; j<= ( nums.size() - k ) ; j++ ){\\n            \\n            double x = 1.0*( nums[j] - start )/( j - i + 1 );\\n            \\n            temp = max( temp , x + makeSeparation( j+1 , k-1 ) );\\n        }\\n        \\n        DP[i][k] = temp;\\n        \\n        return temp;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& mat, int k) {\\n        \\n        nums = mat;\\n        \\n        for( int i=1; i<nums.size() ; i++ )\\n            nums[i] += nums[i-1];\\n        \\n        DP = vector< vector< double >>( nums.size() + 1 , vector< double >( k+1 , -1 ) );\\n        \\n        ans = makeSeparation( 0, k );\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    double ans; vector< int >nums;\\n    vector< vector< double >>DP;\\n    \\npublic:\\n    double makeSeparation( int i , int k ){\\n        \\n        if( i >= nums.size() )\\n              return 0;\\n        \\n        if( DP[i][k] != -1 )\\n            return DP[i][k];\\n        \\n        double start = i == 0 ? 0 : nums[i-1];\\n        \\n        if( k == 1 ){\\n            \\n            double x = 1.0*( nums[ nums.size() - 1 ] - start )/( nums.size() - i );\\n            \\n            return x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1633894,
                "title": "python-3-solution-using-memoization",
                "content": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        @lru_cache(maxsize=None)\\n        def maxAvgSum(index: int, partitions_left: int) -> int:\\n            if partitions_left == 1:\\n                return sum(nums[index:]) / (len(nums) - index)\\n\\n            max_sum: float = 0.0\\n            for i in range(index, len(nums) - (partitions_left - 1)):\\n                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)\\n                cur_sum += maxAvgSum(i + 1, partitions_left - 1)\\n                max_sum = max(cur_sum, max_sum)\\n            return max_sum\\n    \\n        return maxAvgSum(0, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        @lru_cache(maxsize=None)\\n        def maxAvgSum(index: int, partitions_left: int) -> int:\\n            if partitions_left == 1:\\n                return sum(nums[index:]) / (len(nums) - index)\\n\\n            max_sum: float = 0.0\\n            for i in range(index, len(nums) - (partitions_left - 1)):\\n                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)\\n                cur_sum += maxAvgSum(i + 1, partitions_left - 1)\\n                max_sum = max(cur_sum, max_sum)\\n            return max_sum\\n    \\n        return maxAvgSum(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437697,
                "title": "python-simple-short-dp",
                "content": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n=len(nums)\\n        @lru_cache(None)\\n        def dp(idx,val,k,no):\\n            if idx==n: return val/no if no!=0 else 0\\n            #take into previous loop\\n            ans=dp(idx+1,val+nums[idx],k,no+1)\\n            #make new loop\\n            if no!=0 and k-1!=0:\\n                ans=max(ans,dp(idx+1,nums[idx],k-1,1)+val/no)\\n            return ans\\n        return dp(0,0,k,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n=len(nums)\\n        @lru_cache(None)\\n        def dp(idx,val,k,no):\\n            if idx==n: return val/no if no!=0 else 0\\n            #take into previous loop\\n            ans=dp(idx+1,val+nums[idx],k,no+1)\\n            #make new loop\\n            if no!=0 and k-1!=0:\\n                ans=max(ans,dp(idx+1,nums[idx],k-1,1)+val/no)\\n            return ans\\n        return dp(0,0,k,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336470,
                "title": "c-dynamic-approach-beats-94-time-complexity-and-93-space-complexity",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>prefix_sum(nums.size(),0);\\n        prefix_sum[0] = nums[0];\\n        //calculating prefix sum\\n        for(int i=1;i<nums.size();i++)\\n            prefix_sum[i] = nums[i]+prefix_sum[i-1];\\n        \\n        double dp[k+1][nums.size()];\\n        \\n        for(int i=0;i<n;i++)\\n            dp[1][i] = (double) prefix_sum[i]/(i+1);   //base case for k=1\\n        \\n        \\n        \\n        for(int i=2;i<=k;i++){\\n            for(int j=nums.size()-1;j>=i-1;j--){\\n                dp[i][j] = 0.0;\\n                for(int p=j;p>=i-1;p--){\\n        dp[i][j] = max(dp[i][j],(double)(prefix_sum[j]-prefix_sum[p-1])/(j-p+1) + dp[i-1][p-1] );\\n                }\\n            }\\n        }\\n      \\n        return 1.0*dp[k][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>prefix_sum(nums.size(),0);\\n        prefix_sum[0] = nums[0];\\n        //calculating prefix sum\\n        for(int i=1;i<nums.size();i++)\\n            prefix_sum[i] = nums[i]+prefix_sum[i-1];\\n        \\n        double dp[k+1][nums.size()];\\n        \\n        for(int i=0;i<n;i++)\\n            dp[1][i] = (double) prefix_sum[i]/(i+1);   //base case for k=1\\n        \\n        \\n        \\n        for(int i=2;i<=k;i++){\\n            for(int j=nums.size()-1;j>=i-1;j--){\\n                dp[i][j] = 0.0;\\n                for(int p=j;p>=i-1;p--){\\n        dp[i][j] = max(dp[i][j],(double)(prefix_sum[j]-prefix_sum[p-1])/(j-p+1) + dp[i-1][p-1] );\\n                }\\n            }\\n        }\\n      \\n        return 1.0*dp[k][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253740,
                "title": "python-dp-with-comments",
                "content": "Not the most efficient but enough to show the tenets of dp\\n\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        L=len(nums)\\n\\n        @lru_cache(None)\\n        def traverse(left,L,remaining_groups):\\n\\n            if left >=L : #If LHS has breached index limit, give 0\\n                return 0\\n\\n            if remaining_groups <= 1: # If this is the last remaining group of k, then average the remainder of array\\n                return sum(nums[left:]) / (L-left)\\n\\n            total=0\\n\\n            for right in range(left,L):\\n                this_avg=sum(nums[left:right+1]) / (right-left+1) # This array group\\n                next_iteration=traverse(right+1,L,remaining_groups-1) # The accumulate of the remainder groups\\n                total = max(total, this_avg + next_iteration) # keeps track record of optimal results\\n\\n            return total\\n\\n        return traverse(0,L,k)\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        L=len(nums)\\n\\n        @lru_cache(None)\\n        def traverse(left,L,remaining_groups):\\n\\n            if left >=L : #If LHS has breached index limit, give 0\\n                return 0\\n\\n            if remaining_groups <= 1: # If this is the last remaining group of k, then average the remainder of array\\n                return sum(nums[left:]) / (L-left)\\n\\n            total=0\\n\\n            for right in range(left,L):\\n                this_avg=sum(nums[left:right+1]) / (right-left+1) # This array group\\n                next_iteration=traverse(right+1,L,remaining_groups-1) # The accumulate of the remainder groups\\n                total = max(total, this_avg + next_iteration) # keeps track record of optimal results\\n\\n            return total\\n\\n        return traverse(0,L,k)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1231969,
                "title": "c-easy-solution-using-memoization-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <double> prefix;\\n    vector < vector <double> > dp;\\n    double recur(vector <int>& nums, int i, int k) {\\n        if (k <= 0) return 0;\\n        if (dp[i][k] != -1.00) return dp[i][k];\\n        if (k == 1) {\\n            if (i == 0) return dp[i][k] = (double)(prefix[nums.size()-1])/(double)(nums.size());\\n            return dp[i][k] = (double)(prefix[nums.size()-1] - prefix[i - 1])/(double)(nums.size() - i);\\n        }\\n        double  t = 0;\\n        for (int j = i; j < nums.size(); j++) {\\n            if (i == 0) t = max(t , (double)(prefix[j])/(double)(j + 1)+ recur(nums, j + 1, k - 1));\\n            else t = max(t , (double)(prefix[j] - prefix[i - 1])/(double)(j - i + 1)+ recur(nums, j + 1, k - 1));\\n        }\\n        return dp[i][k] = t;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        dp.assign(nums.size() + 1, vector <double> (k + 1 , -1.00));\\n        prefix.push_back(nums[0]);\\n        for (int i = 1; i < nums.size(); i++) {\\n            prefix.push_back(nums[i] + prefix[i - 1]);\\n        }\\n        return recur(nums, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <double> prefix;\\n    vector < vector <double> > dp;\\n    double recur(vector <int>& nums, int i, int k) {\\n        if (k <= 0) return 0;\\n        if (dp[i][k] != -1.00) return dp[i][k];\\n        if (k == 1) {\\n            if (i == 0) return dp[i][k] = (double)(prefix[nums.size()-1])/(double)(nums.size());\\n            return dp[i][k] = (double)(prefix[nums.size()-1] - prefix[i - 1])/(double)(nums.size() - i);\\n        }\\n        double  t = 0;\\n        for (int j = i; j < nums.size(); j++) {\\n            if (i == 0) t = max(t , (double)(prefix[j])/(double)(j + 1)+ recur(nums, j + 1, k - 1));\\n            else t = max(t , (double)(prefix[j] - prefix[i - 1])/(double)(j - i + 1)+ recur(nums, j + 1, k - 1));\\n        }\\n        return dp[i][k] = t;\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        dp.assign(nums.size() + 1, vector <double> (k + 1 , -1.00));\\n        prefix.push_back(nums[0]);\\n        for (int i = 1; i < nums.size(); i++) {\\n            prefix.push_back(nums[i] + prefix[i - 1]);\\n        }\\n        return recur(nums, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158050,
                "title": "c-dp-100-faster-memoization",
                "content": "```\\nclass Solution {\\npublic:int n;\\n    vector<int>a;\\n    double help(int i,int k,vector<vector<double>>&dp)\\n    {\\n        if(n-i<k)\\n            return 0;\\n        int sum=0;\\n        if(dp[i][k]!=-1.00)\\n            return dp[i][k];\\n        if(k==1)\\n        {\\n            for(int j=i;j<n;j++)\\n                sum+=a[j];\\n            return sum/(1.00*n-i);\\n        }\\n        double ans=0.0;\\n        for(int j=i;j<=n-k;j++)\\n        {\\n            sum+=a[j];\\n            ans=max(ans,sum/(1.00*(j-i+1))+help(j+1,k-1,dp));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& A, int k) {\\n     n=A.size();\\n        a=A;\\n        vector<vector<double>>dp(101,vector<double>(101,-1.00));\\n        return help(0,k,dp);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:int n;\\n    vector<int>a;\\n    double help(int i,int k,vector<vector<double>>&dp)\\n    {\\n        if(n-i<k)\\n            return 0;\\n        int sum=0;\\n        if(dp[i][k]!=-1.00)\\n            return dp[i][k];\\n        if(k==1)\\n        {\\n            for(int j=i;j<n;j++)\\n                sum+=a[j];\\n            return sum/(1.00*n-i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1043843,
                "title": "c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const double INF = 1e9 + 7;\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        double dp[n][K + 1];\\n        memset(dp, 0, sizeof(dp));\\n        vector<int> prefix(n);\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0) {\\n                prefix[i] = A[i];\\n                dp[i][1] = (double) prefix[i];\\n            }\\n            else {\\n                prefix[i] = prefix[i - 1] + A[i];\\n                dp[i][1] = (double) prefix[i] / (i + 1);\\n            }\\n        }\\n        auto average = [&] (int i, int j) {\\n            double sol = ((double) prefix[j] - prefix[i - 1]) / (j - i + 1);\\n            return sol;\\n        };\\n        for(int k = 2; k <= K; k++) {\\n            for(int i = 0; i < n; i++) {\\n                double val = -INF;\\n                for(int s = 0; s < i; s++) {\\n                    val = max(val, dp[s][k - 1] + average(s + 1, i));\\n                }\\n                dp[i][k] = val;\\n            }\\n        }\\n        return dp[n - 1][K];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const double INF = 1e9 + 7;\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        double dp[n][K + 1];\\n        memset(dp, 0, sizeof(dp));\\n        vector<int> prefix(n);\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0) {\\n                prefix[i] = A[i];\\n                dp[i][1] = (double) prefix[i];\\n            }\\n            else {\\n                prefix[i] = prefix[i - 1] + A[i];\\n                dp[i][1] = (double) prefix[i] / (i + 1);\\n            }\\n        }\\n        auto average = [&] (int i, int j) {\\n            double sol = ((double) prefix[j] - prefix[i - 1]) / (j - i + 1);\\n            return sol;\\n        };\\n        for(int k = 2; k <= K; k++) {\\n            for(int i = 0; i < n; i++) {\\n                double val = -INF;\\n                for(int s = 0; s < i; s++) {\\n                    val = max(val, dp[s][k - 1] + average(s + 1, i));\\n                }\\n                dp[i][k] = val;\\n            }\\n        }\\n        return dp[n - 1][K];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781413,
                "title": "very-simple-python-solution-with-detailed-explanation",
                "content": "```\\nclass Solution(object):\\n    def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        \"\"\"\\n        Logic:\\n        Question says at most K groups in the array. That means 1 to K cuts\\n        If we have just 1 group, that is K == 1, then average is equal to sum of all elements in that group divide by number of elements in that group.\\n        If we can have more than group, that is K > 1, then we need to choose our our K groups carefully\\n        F[start_index, end_index, K] = maximum average for array arr[start_index:end_index] with atmost K groups\\n        \\n        if K == 1, then F[start_index, end_index, K] = average of arr[start_index:end_index]\\n        if K > 1, then we find MAXIMUM of below things:\\n        \\n        new_index = start_index + 1\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        new_index = start_index + 2\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        new_index = start_index + 3\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        new_index = end_index - 1\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        While trying to do this, if K < 0, we need to return minint to discard that combination as we are trying to maximise the result.\\n        \\n        \"\"\"\\n        def recursion(arr, start_index, end_index, n, k):\\n            if k < 0:\\n                return -sys.maxint\\n            if start_index + 1 == end_index:\\n                return arr[start_index]\\n            \\n            if k == 1:\\n                total_group_sum = sum(arr[start_index : end_index])\\n                # print total_group_sum, (end_index + 1 - start_index)\\n                average = total_group_sum / ((end_index - start_index) * 1.0)\\n                return average\\n            else:\\n                ans = 0\\n                for cut in range(start_index + 1, end_index):\\n                    cur_ans = sum(arr[start_index:cut])/((cut - start_index) * 1.0) + recursion(arr, cut, end_index, n, k - 1)\\n                    ans = max(ans, cur_ans)\\n                    # print cur_ans, cut, ans\\n\\n                return ans\\n            \\n        \\n        def memoization(arr, start_index, end_index, n, k):\\n            if k < 0:\\n                return -sys.maxint\\n            if start_index + 1 == end_index:\\n                return arr[start_index]\\n            if memoize[start_index][k] is not None:\\n                return memoize[start_index][k]\\n            \\n            if k == 1:\\n                total_group_sum = sum(arr[start_index : end_index])\\n                # print total_group_sum, (end_index + 1 - start_index)\\n                average = total_group_sum / ((end_index - start_index) * 1.0)\\n                memoize[start_index][k] = average\\n                return average\\n            else:\\n                ans = 0\\n                for cut in range(start_index + 1, end_index):\\n                    cur_ans = sum(arr[start_index:cut])/((cut - start_index) * 1.0) + memoization(arr, cut, end_index, n, k - 1)\\n                    ans = max(ans, cur_ans)\\n                    # print cur_ans, cut, ans\\n\\n                memoize[start_index][k] = ans\\n                return ans\\n                      \\n            \\n        arr = A\\n        n = len(arr)\\n        \\n        # return recursion(arr, 0, n, n, K)\\n        \\n        memoize = [[None for _ in range(K + 1)] for _ in range(n + 1)]\\n        return memoization(arr, 0, n, n, K)\\n        \\n                      \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        \"\"\"\\n        Logic:\\n        Question says at most K groups in the array. That means 1 to K cuts\\n        If we have just 1 group, that is K == 1, then average is equal to sum of all elements in that group divide by number of elements in that group.\\n        If we can have more than group, that is K > 1, then we need to choose our our K groups carefully\\n        F[start_index, end_index, K] = maximum average for array arr[start_index:end_index] with atmost K groups\\n        \\n        if K == 1, then F[start_index, end_index, K] = average of arr[start_index:end_index]\\n        if K > 1, then we find MAXIMUM of below things:\\n        \\n        new_index = start_index + 1\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        new_index = start_index + 2\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        new_index = start_index + 3\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        new_index = end_index - 1\\n        average of arr[start_index:new_index] + F[new_index, end_index, K - 1]\\n        \\n        While trying to do this, if K < 0, we need to return minint to discard that combination as we are trying to maximise the result.\\n        \\n        \"\"\"\\n        def recursion(arr, start_index, end_index, n, k):\\n            if k < 0:\\n                return -sys.maxint\\n            if start_index + 1 == end_index:\\n                return arr[start_index]\\n            \\n            if k == 1:\\n                total_group_sum = sum(arr[start_index : end_index])\\n                # print total_group_sum, (end_index + 1 - start_index)\\n                average = total_group_sum / ((end_index - start_index) * 1.0)\\n                return average\\n            else:\\n                ans = 0\\n                for cut in range(start_index + 1, end_index):\\n                    cur_ans = sum(arr[start_index:cut])/((cut - start_index) * 1.0) + recursion(arr, cut, end_index, n, k - 1)\\n                    ans = max(ans, cur_ans)\\n                    # print cur_ans, cut, ans\\n\\n                return ans\\n            \\n        \\n        def memoization(arr, start_index, end_index, n, k):\\n            if k < 0:\\n                return -sys.maxint\\n            if start_index + 1 == end_index:\\n                return arr[start_index]\\n            if memoize[start_index][k] is not None:\\n                return memoize[start_index][k]\\n            \\n            if k == 1:\\n                total_group_sum = sum(arr[start_index : end_index])\\n                # print total_group_sum, (end_index + 1 - start_index)\\n                average = total_group_sum / ((end_index - start_index) * 1.0)\\n                memoize[start_index][k] = average\\n                return average\\n            else:\\n                ans = 0\\n                for cut in range(start_index + 1, end_index):\\n                    cur_ans = sum(arr[start_index:cut])/((cut - start_index) * 1.0) + memoization(arr, cut, end_index, n, k - 1)\\n                    ans = max(ans, cur_ans)\\n                    # print cur_ans, cut, ans\\n\\n                memoize[start_index][k] = ans\\n                return ans\\n                      \\n            \\n        arr = A\\n        n = len(arr)\\n        \\n        # return recursion(arr, 0, n, n, K)\\n        \\n        memoize = [[None for _ in range(K + 1)] for _ in range(n + 1)]\\n        return memoization(arr, 0, n, n, K)\\n        \\n                      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 773866,
                "title": "dp-solution-with-visual-explanation-must-watch",
                "content": "### **Idea**\\n![image](https://assets.leetcode.com/users/images/29a21192-66d1-43b7-a4ae-a2645f888493_1596597261.5426004.png)\\nDP, use dp[k][i] to denote the largest average sum of partitioning first i elements into k groups.\\n\\nInit\\ndp[1][i] = sum(a[0] ~ a[i \\u2013 1]) / i, for i in 1, 2, \\u2026 , n.\\n\\nTransition\\ndp[k][i] = max(dp[k \\u2013 1][j] + sum(a[j] ~ a[i \\u2013 1]) / (i \\u2013 j)) for j in k \\u2013 1,\\u2026,i-1.\\n\\nthat is find the best j such that maximize dp[k][i]\\n\\nlargest sum of partitioning first j elements (a[0] ~ a[j \\u2013 1]) into k \\u2013 1 groups (already computed)\\n\\n+ average of a[j] ~ a[i \\u2013 1] (partition a[j] ~ a[i \\u2013 1] into 1 group).\\n\\nAnswer\\ndp[K][n]\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        int sum = 0;\\n        unordered_map<int,int>m;\\n        for(int i=0; i<n; i++){\\n            sum+=A[i];\\n            m[i] = sum;\\n        }\\n        vector<vector<double>> dp(K,vector<double>(n,0.0));\\n        double s=0;\\n        for(int i=0; i<n; i++){\\n            s += A[i];\\n            dp[0][i] = (s/(double)(i+1));\\n        }\\n        for(int i=1; i<K; i++){\\n            for(int j = i; j<n; j++){\\n                for(int l = 0; l<j; l++){\\n                    dp[i][j] = max(dp[i][j],dp[i-1][l]+(double(m[j]-m[l]))/double(j-l));  \\n                }\\n            }\\n        }\\n        \\n        return dp[K-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        int sum = 0;\\n        unordered_map<int,int>m;\\n        for(int i=0; i<n; i++){\\n            sum+=A[i];\\n            m[i] = sum;\\n        }\\n        vector<vector<double>> dp(K,vector<double>(n,0.0));\\n        double s=0;\\n        for(int i=0; i<n; i++){\\n            s += A[i];\\n            dp[0][i] = (s/(double)(i+1));\\n        }\\n        for(int i=1; i<K; i++){\\n            for(int j = i; j<n; j++){\\n                for(int l = 0; l<j; l++){\\n                    dp[i][j] = max(dp[i][j],dp[i-1][l]+(double(m[j]-m[l]))/double(j-l));  \\n                }\\n            }\\n        }\\n        \\n        return dp[K-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710828,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& v, int k) {\\n        double dp[k+1][v.size()+1];\\n        for(int i=0;i<=k;i++) dp[i][0]=0;\\n        for(int j=0;j<=v.size();j++) dp[0][j]=0;\\n        vector<int>presum(v.size()+1);\\n        presum[0]=0;\\n        for(int i=1;i<=v.size();i++){\\n            presum[i]=presum[i-1]+v[i-1];\\n        }\\n        for(int i=1;i<=v.size();i++){\\n            dp[1][i]=(presum[i]*1.0)/i;\\n        }\\n        \\n        for(int i=2;i<=k;i++){\\n            for(int j=1;j<=v.size();j++){\\n                double ans=INT_MIN;\\n                for(int k=j;k>=1;k--){\\n                    double temp=(presum[j]-presum[k-1])*1.0/(j-k+1);\\n                    temp=temp+dp[i-1][k-1];\\n                    ans=max(ans,temp);\\n                }\\n                dp[i][j]=ans;\\n            }\\n        }\\n                \\n        return dp[k][v.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& v, int k) {\\n        double dp[k+1][v.size()+1];\\n        for(int i=0;i<=k;i++) dp[i][0]=0;\\n        for(int j=0;j<=v.size();j++) dp[0][j]=0;\\n        vector<int>presum(v.size()+1);\\n        presum[0]=0;\\n        for(int i=1;i<=v.size();i++){\\n            presum[i]=presum[i-1]+v[i-1];\\n        }\\n        for(int i=1;i<=v.size();i++){\\n            dp[1][i]=(presum[i]*1.0)/i;\\n        }\\n        \\n        for(int i=2;i<=k;i++){\\n            for(int j=1;j<=v.size();j++){\\n                double ans=INT_MIN;\\n                for(int k=j;k>=1;k--){\\n                    double temp=(presum[j]-presum[k-1])*1.0/(j-k+1);\\n                    temp=temp+dp[i-1][k-1];\\n                    ans=max(ans,temp);\\n                }\\n                dp[i][j]=ans;\\n            }\\n        }\\n                \\n        return dp[k][v.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682406,
                "title": "4-iterative-solutions-as-expected-in-interviews-python-multiple-solutions",
                "content": "The solutions below are based on this post\\nhttps://leetcode.com/problems/largest-sum-of-averages/discuss/126280/Naive-Detailed-Step-by-Step-Approach-from-Recursive-to-DP-O(N)-solution\\nby [@stack_UnderFlow](https://leetcode.com/stack_underflow)\\nThank you for such simple solutions \\n\\n```\\n\\'\\'\\'\\nM1: Brute Force\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n\\n        def r_calc(idx, k):\\n            if k==1: return (cum_sum[-1]-cum_sum[idx])/(n-idx)\\n            avg = 0\\n            for i in range(idx, n-k+1):\\n                avg = max(avg, (cum_sum[i+1]-cum_sum[idx])/(i-idx+1) + r_calc(i+1, k-1))\\n            return avg\\n        return r_calc(0, k)\\n\\n\\'\\'\\'\\nM2: Memoization\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        dp = [[0]*(k+1) for _ in range(n)]\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n\\n        def r_calc_with_memo(idx, k):\\n            if dp[idx][k] != 0: return dp[idx][k]\\n            if k==1: \\n                dp[idx][k] = (cum_sum[-1]-cum_sum[idx])/(n-idx)\\n                return dp[idx][k]\\n            for i in range(idx, n-k+1):\\n                dp[idx][k] = max(dp[idx][k], (cum_sum[i+1]-cum_sum[idx])/(i-idx+1) + r_calc_with_memo(i+1, k-1))\\n            return dp[idx][k]\\n        return r_calc_with_memo(0, k)\\n\\n\\'\\'\\'\\nM3: DP bottom up with O(n*n) space\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        dp = [[0]*(k+1) for _ in range(n)]\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n        \\n        for group in range(1, k+1):\\n            for idx1 in range(n-group+1):\\n                if group==1:\\n                    dp[idx1][group] = (cum_sum[-1]-cum_sum[idx1])/(n-idx1)\\n                    continue\\n                for idx2 in range(idx1, n-group+1):\\n                    dp[idx1][group] = max(dp[idx1][group], (cum_sum[idx2+1]-cum_sum[idx1])/(idx2-idx1+1) + dp[idx2+1][group-1])\\n        return dp[0][k]\\n\\n\\'\\'\\'\\nM4: DP bottom up with O(n) space\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        dp = [[0] for _ in range(n)]\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n        \\n        for group in range(1, k+1):\\n            for idx1 in range(n-group+1):\\n                if group==1:\\n                    dp[idx1] = (cum_sum[-1]-cum_sum[idx1])/(n-idx1)\\n                    continue\\n                for idx2 in range(idx1, n-group+1):\\n                    dp[idx1] = max(dp[idx1], (cum_sum[idx2+1]-cum_sum[idx1])/(idx2-idx1+1) + dp[idx2+1])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\'\\'\\'\\nM1: Brute Force\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n\\n        def r_calc(idx, k):\\n            if k==1: return (cum_sum[-1]-cum_sum[idx])/(n-idx)\\n            avg = 0\\n            for i in range(idx, n-k+1):\\n                avg = max(avg, (cum_sum[i+1]-cum_sum[idx])/(i-idx+1) + r_calc(i+1, k-1))\\n            return avg\\n        return r_calc(0, k)\\n\\n\\'\\'\\'\\nM2: Memoization\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        dp = [[0]*(k+1) for _ in range(n)]\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n\\n        def r_calc_with_memo(idx, k):\\n            if dp[idx][k] != 0: return dp[idx][k]\\n            if k==1: \\n                dp[idx][k] = (cum_sum[-1]-cum_sum[idx])/(n-idx)\\n                return dp[idx][k]\\n            for i in range(idx, n-k+1):\\n                dp[idx][k] = max(dp[idx][k], (cum_sum[i+1]-cum_sum[idx])/(i-idx+1) + r_calc_with_memo(i+1, k-1))\\n            return dp[idx][k]\\n        return r_calc_with_memo(0, k)\\n\\n\\'\\'\\'\\nM3: DP bottom up with O(n*n) space\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        dp = [[0]*(k+1) for _ in range(n)]\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n        \\n        for group in range(1, k+1):\\n            for idx1 in range(n-group+1):\\n                if group==1:\\n                    dp[idx1][group] = (cum_sum[-1]-cum_sum[idx1])/(n-idx1)\\n                    continue\\n                for idx2 in range(idx1, n-group+1):\\n                    dp[idx1][group] = max(dp[idx1][group], (cum_sum[idx2+1]-cum_sum[idx1])/(idx2-idx1+1) + dp[idx2+1][group-1])\\n        return dp[0][k]\\n\\n\\'\\'\\'\\nM4: DP bottom up with O(n) space\\n\\'\\'\\'\\nclass Solution:\\n    def largestSumOfAverages(self, A, k):\\n        n = len(A)\\n        cum_sum = [0]*(n+1)\\n        dp = [[0] for _ in range(n)]\\n        \\n        for i in range(n):\\n            cum_sum[i+1] = cum_sum[i]+A[i]\\n        \\n        for group in range(1, k+1):\\n            for idx1 in range(n-group+1):\\n                if group==1:\\n                    dp[idx1] = (cum_sum[-1]-cum_sum[idx1])/(n-idx1)\\n                    continue\\n                for idx2 in range(idx1, n-group+1):\\n                    dp[idx1] = max(dp[idx1], (cum_sum[idx2+1]-cum_sum[idx1])/(idx2-idx1+1) + dp[idx2+1])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652001,
                "title": "python-simple-dp-with-explanation",
                "content": "**Idea:** \\nDenote <code>solve(i, k)</code> the optimal value for the problem of partitioning i first numbers into k groups.\\n\\nWe can only insert the new-coming number <code>A[i]</code> into the last group. That means it has no effect to the previous <code>k - 1</code> groups. \\nThere are i ways to form the last group, the first being <code>(A[0], A[1],..., A[i])</code> in the same group, the j-th being <code>(A[j - 1], ..., A[i])</code> in the same group, and the i-th being <code>(A[i)</code> alone in the last group. \\nThe answer for <code>solve(i, k)</code> thus be <code>max( solve(j, k - 1) + average(A[j + 1]..A[i]) )</code> for all j < i. To aid the computation of the latter term, we can pre-compute prefix sum array (better), or compute the prefix directly inside the loop of j.\\n```\\n\\tdef largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        P = [0 for i in range(len(A) + 1)]\\n        for i in range(len(A)):\\n            P[i + 1] = P[i] + A[i]\\n        @lru_cache(None)\\n        def solve(i, k):\\n            if k == 1:\\n                return P[i + 1]/(i + 1)\\n            res = 0\\n            for j in range(i):\\n                res = max(res, solve(j, k - 1) + (P[i + 1] - P[j + 1])/(i - j))\\n            return res\\n        return solve(len(A) - 1, K)\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        P = [0 for i in range(len(A) + 1)]\\n        for i in range(len(A)):\\n            P[i + 1] = P[i] + A[i]\\n        @lru_cache(None)\\n        def solve(i, k):\\n            if k == 1:\\n                return P[i + 1]/(i + 1)\\n            res = 0\\n            for j in range(i):\\n                res = max(res, solve(j, k - 1) + (P[i + 1] - P[j + 1])/(i - j))\\n            return res\\n        return solve(len(A) - 1, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 612183,
                "title": "best-explaination-from-recusice-to-dp-space-n-k-to-space-n",
                "content": "1.recursive+memorize\\n```\\npublic double largestSumOfAverages(int[] A, int K) {\\n        double[] sum=new double[A.length];\\n        sum[0]=A[0];\\n        for(int i=1;i<A.length;i++){\\n            sum[i]+=sum[i-1]+A[i];\\n        }\\n        double[][] dp=new double[A.length][K+1];\\n        for(int i=A.length-1;i>=0;i--){\\n            for(int k=1;k<=K;k++){\\n                if(k==1){\\n                    dp[i][1]=(sum[A.length-1]-(i-1>=0?sum[i-1]:0))/(A.length-i);\\n                }else{\\n                   for(int j=i;j+k<=A.length;j++){\\n                    double target=(sum[j]-(i-1>=0?sum[i-1]:0))/(j-i+1);\\n                    dp[i][k]=Math.max(dp[i][k],target+(j+1<A.length?dp[j+1][k-1]:0));\\n                } \\n              }\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n```\\n\\n2. dp,space(N*K)\\n```\\n/**\\n    * 1.i did not figure out the dp problem,i think dp[A][K] can\\n    *   represent the dp,but dp[A][K]=dp[i][K-1],some case are not considered\\n    * 2.dfs,if not figure out\\uFF0Cwhat is the recursion exit? how many params i need in dfs           *    method?\\n    * 3.if the index will be out of array.pls check every time.\\n    * 4.double and int parse cause accuracy lose.\\n    * 5.how to log?think the algorithm execution,what factor can represent the case\\uFF1F\\n    * 6.when we use the dp[n][k] memorize,why it is wrong to use the avg to track the total     *   sum and return the avg in dfs?\\n    *   the dfs&dp[n][k] means [i,K] subproblems,but use the avg that returns is the tatol       *   sum,it means [0,K],not [i,K],so we can not use the way that return tatol sum.\\n    *   we should return the [i,K] sum, it means currentAvg+dfs, not dfs(avg+currentAvg)\\n    **/\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum=new int[A.length];\\n        sum[0]=A[0];\\n        for(int i=1;i<A.length;i++){\\n            sum[i]+=sum[i-1]+A[i];\\n        }\\n        return largestSumOfAverages(A,0,K,new double[A.length][K+1],sum);\\n    }\\n    public double largestSumOfAverages(int[] A,int start,int K,double[][] dp,int[] sum){\\n        if(K==1){\\n            return (sum[A.length-1]-(start-1>0?sum[start-1]:0))/(A.length-start);\\n        }\\n        if(dp[start][K]>0){\\n            return dp[start][K];\\n        }\\n        for(int i=start;i+K<=A.length;i++){\\n            double target=((double)sum[i]-(start>0?sum[start-1]:0))/(i-start+1);\\n            dp[start][K]=Math.max(dp[start][K],target+largestSumOfAverages(A,i+1,K-1,dp,sum));\\n        }\\n        return dp[start][K];\\n    }\\n```\\n3.opt space from O(N*K\\uFF09 to O(N)\\n```\\n/**\\n    * 1. why change for(k) to out? if we use one-dimensional dp, k should keep between k and k-1, not for(k:1->K)\\n      2. why change from  [for(i:A.length-1->0) to for(i:0->A.length-1)], dp[i]=dp[i+1],\\n      * the dp[i+1] is previous dp[i+1], we should not use current dp[i+1],so we need use\\n      from[for(i:0->A.length-1)]\\n    **/\\n    public double largestSumOfAverages(int[] A, int K) {\\n        double[] sum=new double[A.length];\\n        sum[0]=A[0];\\n        for(int i=1;i<A.length;i++){\\n            sum[i]+=sum[i-1]+A[i];\\n        }\\n        double[] dp=new double[A.length];\\n        for(int k=1;k<=K;k++){\\n            for(int i=0;i<=A.length-1;i++){\\n                if(k==1){\\n                    dp[i]=(sum[A.length-1]-(i-1>=0?sum[i-1]:0))/(A.length-i);\\n                    continue;\\n                }\\n                for(int j=i;j+k<=A.length;j++){\\n                double target=(sum[j]-(i-1>=0?sum[i-1]:0))/(j-i+1);\\n                dp[i]=Math.max(dp[i],target+(j+1<A.length?dp[j+1]:0));\\n              }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double largestSumOfAverages(int[] A, int K) {\\n        double[] sum=new double[A.length];\\n        sum[0]=A[0];\\n        for(int i=1;i<A.length;i++){\\n            sum[i]+=sum[i-1]+A[i];\\n        }\\n        double[][] dp=new double[A.length][K+1];\\n        for(int i=A.length-1;i>=0;i--){\\n            for(int k=1;k<=K;k++){\\n                if(k==1){\\n                    dp[i][1]=(sum[A.length-1]-(i-1>=0?sum[i-1]:0))/(A.length-i);\\n                }else{\\n                   for(int j=i;j+k<=A.length;j++){\\n                    double target=(sum[j]-(i-1>=0?sum[i-1]:0))/(j-i+1);\\n                    dp[i][k]=Math.max(dp[i][k],target+(j+1<A.length?dp[j+1][k-1]:0));\\n                } \\n              }\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n```\n```\\n/**\\n    * 1.i did not figure out the dp problem,i think dp[A][K] can\\n    *   represent the dp,but dp[A][K]=dp[i][K-1],some case are not considered\\n    * 2.dfs,if not figure out\\uFF0Cwhat is the recursion exit? how many params i need in dfs           *    method?\\n    * 3.if the index will be out of array.pls check every time.\\n    * 4.double and int parse cause accuracy lose.\\n    * 5.how to log?think the algorithm execution,what factor can represent the case\\uFF1F\\n    * 6.when we use the dp[n][k] memorize,why it is wrong to use the avg to track the total     *   sum and return the avg in dfs?\\n    *   the dfs&dp[n][k] means [i,K] subproblems,but use the avg that returns is the tatol       *   sum,it means [0,K],not [i,K],so we can not use the way that return tatol sum.\\n    *   we should return the [i,K] sum, it means currentAvg+dfs, not dfs(avg+currentAvg)\\n    **/\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int[] sum=new int[A.length];\\n        sum[0]=A[0];\\n        for(int i=1;i<A.length;i++){\\n            sum[i]+=sum[i-1]+A[i];\\n        }\\n        return largestSumOfAverages(A,0,K,new double[A.length][K+1],sum);\\n    }\\n    public double largestSumOfAverages(int[] A,int start,int K,double[][] dp,int[] sum){\\n        if(K==1){\\n            return (sum[A.length-1]-(start-1>0?sum[start-1]:0))/(A.length-start);\\n        }\\n        if(dp[start][K]>0){\\n            return dp[start][K];\\n        }\\n        for(int i=start;i+K<=A.length;i++){\\n            double target=((double)sum[i]-(start>0?sum[start-1]:0))/(i-start+1);\\n            dp[start][K]=Math.max(dp[start][K],target+largestSumOfAverages(A,i+1,K-1,dp,sum));\\n        }\\n        return dp[start][K];\\n    }\\n```\n```\\n/**\\n    * 1. why change for(k) to out? if we use one-dimensional dp, k should keep between k and k-1, not for(k:1->K)\\n      2. why change from  [for(i:A.length-1->0) to for(i:0->A.length-1)], dp[i]=dp[i+1],\\n      * the dp[i+1] is previous dp[i+1], we should not use current dp[i+1],so we need use\\n      from[for(i:0->A.length-1)]\\n    **/\\n    public double largestSumOfAverages(int[] A, int K) {\\n        double[] sum=new double[A.length];\\n        sum[0]=A[0];\\n        for(int i=1;i<A.length;i++){\\n            sum[i]+=sum[i-1]+A[i];\\n        }\\n        double[] dp=new double[A.length];\\n        for(int k=1;k<=K;k++){\\n            for(int i=0;i<=A.length-1;i++){\\n                if(k==1){\\n                    dp[i]=(sum[A.length-1]-(i-1>=0?sum[i-1]:0))/(A.length-i);\\n                    continue;\\n                }\\n                for(int j=i;j+k<=A.length;j++){\\n                double target=(sum[j]-(i-1>=0?sum[i-1]:0))/(j-i+1);\\n                dp[i]=Math.max(dp[i],target+(j+1<A.length?dp[j+1]:0));\\n              }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583453,
                "title": "python-5-liner-memoization-with-comments",
                "content": "```\\ndef largestSumOfAverages(self, a: List[int], K: int) -> float:\\n\\t@lru_cache(None)\\n\\tdef dp(i,j,k):\\n\\t\\tif i==j-1: return a[i]  # // if only one element is left just return the element\\n\\t\\tif k==1: return sum(a[i:j])/(j-i) # if no partitions can be further made return the avg. \\n\\t\\treturn max(dp(i,x,1)+dp(x,j,k-1) for x in range(i+1,j)) # return max of all possible partitions.\\n\\treturn dp(0,len(a),K)\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestSumOfAverages(self, a: List[int], K: int) -> float:\\n\\t@lru_cache(None)\\n\\tdef dp(i,j,k):\\n\\t\\tif i==j-1: return a[i]  # // if only one element is left just return the element\\n\\t\\tif k==1: return sum(a[i:j])/(j-i) # if no partitions can be further made return the avg. \\n\\t\\treturn max(dp(i,x,1)+dp(x,j,k-1) for x in range(i+1,j)) # return max of all possible partitions.\\n\\treturn dp(0,len(a),K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 561368,
                "title": "python3-dp-now-max-min-dp-previous-cost-previous-to-now",
                "content": "Typical dp problem, the formula for this kind of dp is (in general) ```dp(now) = MAX/MIN{dp(previous) + cost(previous to now)}```, where ```now``` is the current state we\\'re solving, ```previous``` is the previous state we already solved, and ```cost``` is a function defined on the range ```(previous, now]```. In this problem, ```dp[i][j] = max(dp[m][j-1] + avg(m+1, i)) for 0 <= m < i```.\\n\\nsimilar problems: \\n1. 1335 Minimum Difficulty of a Job Schedule \\n2. 1278 Palindrome Partitioning III\\n\\n```\\ndef largestSumOfAverages(self, A: List[int], K: int) -> float:\\n\\t\"\"\"\\n\\tdp[i][j] is the largest score we can achieve by partitioning A[0..i] into j groups\\n\\n\\tdp[i][j] = max(dp[m][j-1] + avg(m+1, i)) for 0 <= m < i\\n\\n\\tcorner case:\\n\\tdp[0][j] = 0 for any valid j\\n\\tdp[i][0] = -INF for any valid i\\n\\n\\treturn: \\n\\tdp[tot-1][k], where tot = len(A) + 1\\n\\t\"\"\"\\n\\tk = K\\n\\tNEG_INF = float(\"-inf\")\\n\\tdef avg(i, j):\\n\\t\\t\"\"\"\\n\\t\\treturn the avg of A[i:j+1]\\n\\t\\t\"\"\"\\n\\t\\tif i <= j:\\n\\t\\t\\treturn sum(A[i:j+1]) / (j-i+1)\\n\\t\\treturn NEG_INF\\n\\n\\tA = [0] + A\\n\\ttot = len(A)  # original length of A + 1\\n\\tdp = [[NEG_INF]*(k+1) for _ in range(tot)]\\n\\n\\tfor j in range(k+1):\\n\\t\\tdp[0][j] = 0\\n\\n\\tfor i in range(1, tot):\\n\\t\\tfor j in range(1, k+1):\\n\\t\\t\\tif i < j:\\n\\t\\t\\t\\tcontinue  # can\\'t make a partition of j groups\\n\\t\\t\\tfor m in range(i):\\n\\t\\t\\t\\tdp[i][j] = max(dp[m][j-1] + avg(m+1, i), dp[i][j])\\n\\treturn dp[tot-1][k]\\n```\\n\\nIn fact, ```avg``` can also be computed by dp instead of calling the function each time. But because I\\'m lazy I shall omit the implementation here.",
                "solutionTags": [],
                "code": "```dp(now) = MAX/MIN{dp(previous) + cost(previous to now)}```\n```now```\n```previous```\n```cost```\n```(previous, now]```\n```dp[i][j] = max(dp[m][j-1] + avg(m+1, i)) for 0 <= m < i```\n```\\ndef largestSumOfAverages(self, A: List[int], K: int) -> float:\\n\\t\"\"\"\\n\\tdp[i][j] is the largest score we can achieve by partitioning A[0..i] into j groups\\n\\n\\tdp[i][j] = max(dp[m][j-1] + avg(m+1, i)) for 0 <= m < i\\n\\n\\tcorner case:\\n\\tdp[0][j] = 0 for any valid j\\n\\tdp[i][0] = -INF for any valid i\\n\\n\\treturn: \\n\\tdp[tot-1][k], where tot = len(A) + 1\\n\\t\"\"\"\\n\\tk = K\\n\\tNEG_INF = float(\"-inf\")\\n\\tdef avg(i, j):\\n\\t\\t\"\"\"\\n\\t\\treturn the avg of A[i:j+1]\\n\\t\\t\"\"\"\\n\\t\\tif i <= j:\\n\\t\\t\\treturn sum(A[i:j+1]) / (j-i+1)\\n\\t\\treturn NEG_INF\\n\\n\\tA = [0] + A\\n\\ttot = len(A)  # original length of A + 1\\n\\tdp = [[NEG_INF]*(k+1) for _ in range(tot)]\\n\\n\\tfor j in range(k+1):\\n\\t\\tdp[0][j] = 0\\n\\n\\tfor i in range(1, tot):\\n\\t\\tfor j in range(1, k+1):\\n\\t\\t\\tif i < j:\\n\\t\\t\\t\\tcontinue  # can\\'t make a partition of j groups\\n\\t\\t\\tfor m in range(i):\\n\\t\\t\\t\\tdp[i][j] = max(dp[m][j-1] + avg(m+1, i), dp[i][j])\\n\\treturn dp[tot-1][k]\\n```\n```avg```",
                "codeTag": "Python3"
            },
            {
                "id": 535715,
                "title": "javascript-dp-97-100",
                "content": "```\\n/*\\n * @lc app=leetcode id=813 lang=javascript\\n *\\n * [813] Largest Sum of Averages\\n */\\n\\n// @lc code=start\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumOfAverages = function (A, K) {\\n    let N = A.length;\\n    const sums = [A[0]];\\n    const dp = Array.from(Array(K), () => Array(N).fill(0));\\n    dp[0][0] = A[0];\\n    for (let i = 1; i < N; i++) {\\n        sums[i] = A[i] + sums[i - 1];\\n        dp[0][i] = sums[i] / (i + 1);\\n    }\\n\\n    for (let k = 1; k < K; k++) {\\n        for (let n = 1; n < N; n++) {\\n            for (let j = k - 1; j < n; j++) {\\n                dp[k][n] = Math.max(\\n                    dp[k][n],\\n                    dp[k - 1][j] + (sums[n] - sums[j]) / (n - j)\\n                );\\n                //console.log({ k, n, j });\\n                //console.log({ sums });\\n                //console.table(dp);\\n            }\\n        }\\n    }\\n\\n    //console.log({ sums });\\n    //console.table(dp);\\n    return dp[K - 1][N - 1];\\n};\\n// dp[k][i] = Math.max(dp[k-1][j]+avgs(a[j+1]))\\n\\n\\n// @lc code=end\\nconsole.table(largestSumOfAverages(\\n    [9, 1, 2, 3, 9], 3\\n))\\n/*\\nAccepted\\n51/51 cases passed (52 ms)\\nYour runtime beats 96.77 % of javascript submissions\\nYour memory usage beats 100 % of javascript submissions (36 MB)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n * @lc app=leetcode id=813 lang=javascript\\n *\\n * [813] Largest Sum of Averages\\n */\\n\\n// @lc code=start\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumOfAverages = function (A, K) {\\n    let N = A.length;\\n    const sums = [A[0]];\\n    const dp = Array.from(Array(K), () => Array(N).fill(0));\\n    dp[0][0] = A[0];\\n    for (let i = 1; i < N; i++) {\\n        sums[i] = A[i] + sums[i - 1];\\n        dp[0][i] = sums[i] / (i + 1);\\n    }\\n\\n    for (let k = 1; k < K; k++) {\\n        for (let n = 1; n < N; n++) {\\n            for (let j = k - 1; j < n; j++) {\\n                dp[k][n] = Math.max(\\n                    dp[k][n],\\n                    dp[k - 1][j] + (sums[n] - sums[j]) / (n - j)\\n                );\\n                //console.log({ k, n, j });\\n                //console.log({ sums });\\n                //console.table(dp);\\n            }\\n        }\\n    }\\n\\n    //console.log({ sums });\\n    //console.table(dp);\\n    return dp[K - 1][N - 1];\\n};\\n// dp[k][i] = Math.max(dp[k-1][j]+avgs(a[j+1]))\\n\\n\\n// @lc code=end\\nconsole.table(largestSumOfAverages(\\n    [9, 1, 2, 3, 9], 3\\n))\\n/*\\nAccepted\\n51/51 cases passed (52 ms)\\nYour runtime beats 96.77 % of javascript submissions\\nYour memory usage beats 100 % of javascript submissions (36 MB)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535305,
                "title": "python-dp-with-explanation",
                "content": "idea:\\n**dp[i][k]** means the largest score we can get from **A[i:]** with **k**\\n1. on each step **i**, we can choose **A[i:j]** to be the first group, but we must leave at least **k-1** numbers for the next **k-1** groups, which means **j <= n-(k-1)**\\n2. for each choice of **j**, we get the first group score: **avg(A[i:j])**, then we move on to step **j** for **k-1** groups, and store our result\\n\\n\\n```\\nn = len(A)\\ndp = [[None] * (K+1) for _ in range(n)]\\n\\ndef lsa(A, k, i):\\n\\tif i >= n:\\n\\t\\treturn 0\\n\\tif dp[i][k] is not None:\\n\\t\\treturn dp[i][k]\\n\\tif k == 1:\\n\\t\\tscore = sum(A[i:]) / (n-i)\\n\\telse:\\n\\t\\tscore = max(sum(A[i:j]) / (j-i) + lsa(A, k-1, j) for j in range(i+1, n-k+2))\\n\\tdp[i][k] = score\\n\\treturn score\\n\\nreturn lsa(A, K, 0)",
                "solutionTags": [],
                "code": "idea:\\n**dp[i][k]** means the largest score we can get from **A[i:]** with **k**\\n1. on each step **i**, we can choose **A[i:j]** to be the first group, but we must leave at least **k-1** numbers for the next **k-1** groups, which means **j <= n-(k-1)**\\n2. for each choice of **j**, we get the first group score: **avg(A[i:j])**, then we move on to step **j** for **k-1** groups, and store our result\\n\\n\\n```\\nn = len(A)\\ndp = [[None] * (K+1) for _ in range(n)]\\n\\ndef lsa(A, k, i):\\n\\tif i >= n:\\n\\t\\treturn 0\\n\\tif dp[i][k] is not None:\\n\\t\\treturn dp[i][k]\\n\\tif k == 1:\\n\\t\\tscore = sum(A[i:]) / (n-i)\\n\\telse:\\n\\t\\tscore = max(sum(A[i:j]) / (j-i) + lsa(A, k-1, j) for j in range(i+1, n-k+2))\\n\\tdp[i][k] = score\\n\\treturn score\\n\\nreturn lsa(A, K, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 500615,
                "title": "go-golang-clean-solusion",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Largest Sum of Averages.\\nMemory Usage: 2.5 MB, less than 100.00% of Go online submissions for Largest Sum of Averages.\\n\\n```go\\nfunc largestSumOfAverages(A []int, K int) float64 {\\n    sum := make([]float64, len(A) + 1)\\n    mem := make([][]float64, K + 1)\\n    for i := range mem {\\n        mem[i] = make([]float64, len(A) + 1)\\n    }\\n    for i, v := range A {\\n        sum[i+1] = sum[i] + float64(v)\\n    }\\n    return helper(A, len(A), K, &mem, &sum)\\n}\\n\\nfunc helper(A []int, n, k int, mem *[][]float64, sum *[]float64) float64 {\\n    if (*mem)[k][n] > 0 { return (*mem)[k][n] }\\n    if k == 1 { return (*sum)[n] / float64(n) }\\n    for i := k - 1; i < n; i++ {\\n        (*mem)[k][n] = max((*mem)[k][n], helper(A, i, k - 1, mem, sum) + ((*sum)[n] - (*sum)[i]) / float64(n - i))\\n    }\\n    return (*mem)[k][n]\\n}\\n\\nfunc max(a, b float64) float64 {\\n    if a > b { return a }\\n    return b\\n} \\n```",
                "solutionTags": [],
                "code": "```go\\nfunc largestSumOfAverages(A []int, K int) float64 {\\n    sum := make([]float64, len(A) + 1)\\n    mem := make([][]float64, K + 1)\\n    for i := range mem {\\n        mem[i] = make([]float64, len(A) + 1)\\n    }\\n    for i, v := range A {\\n        sum[i+1] = sum[i] + float64(v)\\n    }\\n    return helper(A, len(A), K, &mem, &sum)\\n}\\n\\nfunc helper(A []int, n, k int, mem *[][]float64, sum *[]float64) float64 {\\n    if (*mem)[k][n] > 0 { return (*mem)[k][n] }\\n    if k == 1 { return (*sum)[n] / float64(n) }\\n    for i := k - 1; i < n; i++ {\\n        (*mem)[k][n] = max((*mem)[k][n], helper(A, i, k - 1, mem, sum) + ((*sum)[n] - (*sum)[i]) / float64(n - i))\\n    }\\n    return (*mem)[k][n]\\n}\\n\\nfunc max(a, b float64) float64 {\\n    if a > b { return a }\\n    return b\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450892,
                "title": "python-recursion-memo",
                "content": "```class Solution(object):\\n    \\n    def partition(self, A, i):\\n        left = A[:i+1]\\n        right = A[i+1:]\\n        return left, right\\n    \\n    def avg(self, A):\\n        N = float(len(A))\\n        return sum(A)/N\\n    \\n    def solve(self, A, K, cache):\\n        _key = \"{}_{}\".format(A, K)\\n        \\n        if _key in cache:\\n            return cache[_key]\\n        if K == 1:\\n            return self.avg(A)\\n        if K == len(A):\\n            return sum(A)\\n        \\n        ans = float(\"-inf\")\\n        for i in xrange(len(A)):\\n            left, right = self.partition(A, i)\\n            if left and right:\\n                left_avg = self.avg(left)\\n                right_avg = self.solve(right, K-1, cache)\\n                candidate = left_avg+right_avg\\n                ans = max(ans, candidate)\\n        cache[_key] = ans\\n        return ans\\n            \\n    \\n    def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        cache = dict()\\n        return self.solve(A, K, cache)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    \\n    def partition(self, A, i):\\n        left = A[:i+1]\\n        right = A[i+1:]\\n        return left, right\\n    \\n    def avg(self, A):\\n        N = float(len(A))\\n        return sum(A)/N\\n    \\n    def solve(self, A, K, cache):\\n        _key = \"{}",
                "codeTag": "Java"
            },
            {
                "id": 406837,
                "title": "python-recursion-with-memo",
                "content": "```\\nclass Solution:\\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        def helper(i, K):\\n            if (i, K) not in dic:\\n                if K == 1:\\n                    dic[i, K] = sum(A[i:])/(L-i)\\n                else:\\n                    j = i + 1\\n                    cur = 0\\n                    res = 0\\n                    while j <= L and L - j >= K - 1:\\n                        cur += A[j-1]\\n                        res = max(res, cur/(j-i) + helper(j, K-1))\\n                        j += 1\\n                    dic[i, K] = res\\n            return dic[i, K]\\n        \\n        L = len(A)\\n        dic = {}\\n        return helper(0, K)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n        def helper(i, K):\\n            if (i, K) not in dic:\\n                if K == 1:\\n                    dic[i, K] = sum(A[i:])/(L-i)\\n                else:\\n                    j = i + 1\\n                    cur = 0\\n                    res = 0\\n                    while j <= L and L - j >= K - 1:\\n                        cur += A[j-1]\\n                        res = max(res, cur/(j-i) + helper(j, K-1))\\n                        j += 1\\n                    dic[i, K] = res\\n            return dic[i, K]\\n        \\n        L = len(A)\\n        dic = {}\\n        return helper(0, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282444,
                "title": "c-dp-similar-to-the-given-solution-with-o-n-space-and-o-k-n-2-time",
                "content": "With the help of prefix sum array the average from A[i] to A[j] can be achieved in O(1) time:\\n(prefix[j]-prefix[i-1])/(j-i);\\nBottom-up DP;\\nSince the Kth situation is only related to the (K-1)th one, the space can be cut from O(NK) to O(N)\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<double> prefix(n);\\n        prefix[0] = A[0];\\n        for(int i = 1; i < n; ++i){prefix[i] = prefix[i-1] + A[i];} //O(n)\\n        vector<double> dp(prefix);\\n        for(int i = 1; i < n; ++i){dp[i] = dp[i] / (i+1);} //O(n)\\n        for(int k = 1; k < K; ++k){  //O(K-1)\\n            for(int i = n-1; i >= k; --i){ //O(n-k)\\n                for(int j = k-1; j < i; ++j) //O(n-k)\\n                {dp[i] = max(dp[i], dp[j] + (prefix[i]-prefix[j])/(i-j));}\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n//time: O(K*N^2) space: O(N)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<double> prefix(n);\\n        prefix[0] = A[0];\\n        for(int i = 1; i < n; ++i){prefix[i] = prefix[i-1] + A[i];}",
                "codeTag": "Java"
            },
            {
                "id": 237913,
                "title": "c-easily-understand-dp-method",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n          //first I think method is dynamic program, but I don\\'t know how to do it. So do you have some idea?\\n        vector<int> sums(A.size()+1,0);\\n        //O(n)\\n        for(int i =1;i<=A.size();i++)\\n        {\\n            sums[i] = A[i-1]+sums[i-1]; \\n        }\\n        vector<vector<double>> dp(A.size(),vector<double>(K,0));\\n        int n = A.size();\\n        //dp[i][k] = max(avgA[i:j)+dp[j][k-1]\\n        for(int i = 0;i<n;i++)\\n        {\\n            dp[i][0] = (sums[n]-sums[i])*1.0/(n-i);\\n        }\\n        //step k from 1:2\\n        //step i from the state transform function we know if we get dp[i][k] ,we must get dp[j][k-1] ,so we must reverse from n-1 to 0\\n        //step j from i+1 to n-1\\n        \\n        for(int k =1;k<K;k++)\\n        {\\n            for(int i = n-1;i>=0;i--)\\n            {\\n                for(int j = i+1;j<n;j++)\\n                {\\n                    dp[i][k] = max((sums[j]-sums[i])*1./(j-i)+dp[j][k-1],dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[0].back();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K) {\\n          //first I think method is dynamic program, but I don\\'t know how to do it. So do you have some idea?\\n        vector<int> sums(A.size()+1,0);\\n        //O(n)\\n        for(int i =1;i<=A.size();i++)\\n        {\\n            sums[i] = A[i-1]+sums[i-1]; \\n        }\\n        vector<vector<double>> dp(A.size(),vector<double>(K,0));\\n        int n = A.size();\\n        //dp[i][k] = max(avgA[i:j)+dp[j][k-1]\\n        for(int i = 0;i<n;i++)\\n        {\\n            dp[i][0] = (sums[n]-sums[i])*1.0/(n-i);\\n        }\\n        //step k from 1:2\\n        //step i from the state transform function we know if we get dp[i][k] ,we must get dp[j][k-1] ,so we must reverse from n-1 to 0\\n        //step j from i+1 to n-1\\n        \\n        for(int k =1;k<K;k++)\\n        {\\n            for(int i = n-1;i>=0;i--)\\n            {\\n                for(int j = i+1;j<n;j++)\\n                {\\n                    dp[i][k] = max((sums[j]-sums[i])*1./(j-i)+dp[j][k-1],dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[0].back();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237237,
                "title": "dp-solution-o-knn-similar-to-stock-problem-with-at-most-k-transactions",
                "content": "```\\n public double largestSumOfAverages(int[] A, int K) {\\n        if(A == null || A.length==0){\\n            return 0;\\n        }\\n        double  sum = 0;\\n        double[] sumA = new double[A.length+1];\\n        for(int i=0; i<A.length; i++){\\n            sum += (double) A[i];\\n            sumA[i+1] = sum; \\n        }\\n        if(K>A.length){\\n            K = A.length;\\n        }\\n        double[][] dp = new double[K+1][A.length+1];  //dp[partNo][index] denotes avg of atmost \"partNo\" partitions ending at \"index\"\\n        for(int i=0; i<dp.length;i++){\\n            Arrays.fill(dp[i],-1.0);\\n        }\\n        \\n        dp[0][0]= 0;\\n        for(int partNo=1; partNo<=K; partNo++) {\\n            for(int avgEnd=partNo; avgEnd<=A.length; avgEnd++){\\n                dp[partNo][avgEnd] = dp[partNo-1][avgEnd];  //assign it with average of partNo-1 partitions until avgEnd index \\n                for(int avgStart=partNo; avgStart<=avgEnd; avgStart++) { //find the start index of  partition ending at avgEnd which is Max(avg from avgStart to avg End + avg of 1 less partition ending before avgStart)\\n                    double avg  = Double.valueOf(sumA[avgEnd]-sumA[avgStart-1])/(avgEnd-avgStart+1);\\n                    if(dp[partNo-1][avgStart-1] != -1.0) //if there is one less partition ending at avgStart-1\\n                         dp[partNo][avgEnd] =Math.max(dp[partNo][avgEnd],  dp[partNo-1][avgStart-1]+ avg);\\n                }\\n            }\\n        }\\n        return dp[K][A.length];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public double largestSumOfAverages(int[] A, int K) {\\n        if(A == null || A.length==0){\\n            return 0;\\n        }\\n        double  sum = 0;\\n        double[] sumA = new double[A.length+1];\\n        for(int i=0; i<A.length; i++){\\n            sum += (double) A[i];\\n            sumA[i+1] = sum; \\n        }\\n        if(K>A.length){\\n            K = A.length;\\n        }\\n        double[][] dp = new double[K+1][A.length+1];  //dp[partNo][index] denotes avg of atmost \"partNo\" partitions ending at \"index\"\\n        for(int i=0; i<dp.length;i++){\\n            Arrays.fill(dp[i],-1.0);\\n        }\\n        \\n        dp[0][0]= 0;\\n        for(int partNo=1; partNo<=K; partNo++) {\\n            for(int avgEnd=partNo; avgEnd<=A.length; avgEnd++){\\n                dp[partNo][avgEnd] = dp[partNo-1][avgEnd];  //assign it with average of partNo-1 partitions until avgEnd index \\n                for(int avgStart=partNo; avgStart<=avgEnd; avgStart++) { //find the start index of  partition ending at avgEnd which is Max(avg from avgStart to avg End + avg of 1 less partition ending before avgStart)\\n                    double avg  = Double.valueOf(sumA[avgEnd]-sumA[avgStart-1])/(avgEnd-avgStart+1);\\n                    if(dp[partNo-1][avgStart-1] != -1.0) //if there is one less partition ending at avgStart-1\\n                         dp[partNo][avgEnd] =Math.max(dp[partNo][avgEnd],  dp[partNo-1][avgStart-1]+ avg);\\n                }\\n            }\\n        }\\n        return dp[K][A.length];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230756,
                "title": "short-easy-understand-dp-solution",
                "content": "dp[i] means the maximum answer of current k in sub array[i....n-1]\\nwe iterete k from 1 to K\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n  = A.size();\\n        vector<double> dp(n,0);\\n        double acc = 0;\\n        for(int i=n-1;i>=0;i--){\\n            acc+=A[i];\\n            dp[i]=acc/(n-i);\\n        }\\n        for(int k=0;k<K-1;k++){\\n            for(int i=0;i<n;i++){\\n                double acc = 0;\\n                for(int j=i;j<n-1;j++){\\n                    acc+=A[j];\\n                    dp[i]=max(dp[i],acc/(j-i+1)+dp[j+1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        int n  = A.size();\\n        vector<double> dp(n,0);\\n        double acc = 0;\\n        for(int i=n-1;i>=0;i--){\\n            acc+=A[i];\\n            dp[i]=acc/(n-i);\\n        }\\n        for(int k=0;k<K-1;k++){\\n            for(int i=0;i<n;i++){\\n                double acc = 0;\\n                for(int j=i;j<n-1;j++){\\n                    acc+=A[j];\\n                    dp[i]=max(dp[i],acc/(j-i+1)+dp[j+1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208883,
                "title": "c-top-down-and-bottom-up-dp-solution",
                "content": "Top-down memory search approach:\\nSpace complexity: O(n^2)\\nTime complexity: O(K n^2)\\nmemo[i, j] := the largest average sum by paritioning the first i items into j groups.\\nsum[i]:  the prefix sum A[1] + ... + A[i]. \\n\\nmemo[i, j] = max{ memo[k-1, j-1] + average(A[k], A[k+1], ... , A[i])  |    for k = j..i}\\n\\nEdge case:\\nmemo[i, j] = 0  if i < j   or   i = 0 or j = 0.\\nmemo[i,1] = sum[i] / i \\n\\n```\\n\\tdouble memo[101][101];\\n    double sum[101];\\n    double calc(int i, int j){\\n    \\tif (i < j) return 0;\\n    \\tif (i==0 or j == 0) return 0;\\n    \\tif (j == 1) return sum[i]*1.0 / i;\\n        if (memo[i][j] != 0) return memo[i][j];\\n        for (int k = j; k <= i; k++)\\n        \\tmemo[i][j] = max(memo[i][j], calc(k-1, j-1) + (sum[i] - sum[k-1]) * 1.0 / (i-k+1));\\n        return memo[i][j];\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        memset(memo, 0, sizeof(memo));\\n       \\tfor (int i = 0; i < A.size(); i++)\\n       \\t\\tsum[i+1] = sum[i] + A[i];\\n       \\treturn calc(A.size(), K);\\n    }\\n```\\n\\nbottom-up DP\\nTime complexity: O(Kn^2).\\nSpace complexity: O(nK).\\n\\n```\\n    double dp(int n, int K){\\n        memset(memo, 0, sizeof(memo));\\n\\n        //edge case\\n        for(int i = 1; i <= n; i++)\\n            memo[1][i] = sum[i]*1.0 / i;\\n\\n        for(int g = 2; g <= K; g++) // number of groups\\n            for (int i = g; i <= n; i++)\\n                for (int j = g; j <= i; j++)\\n                    memo[g][i] = max(memo[g][i], memo[g-1][j-1] + (sum[i]-sum[j-1]) * 1.0 / (i-j+1) );\\n        return memo[K][n];\\n    }\\n```\\n\\nThe space complexity can be reduced to O(n).\\n```\\n    double dp(int n, int K){\\n        memset(memo, 0, sizeof(memo));\\n\\n        //edge case\\n        for(int i = 1; i <= n; i++)\\n            memo[i] = sum[i]*1.0 / i;\\n\\n        for(int g = 2; g <= K; g++) // number of groups\\n            for (int i = n; i >= g; i--)\\n                for (int j = g; j <= i; j++)\\n                    memo[i] = max(memo[i], memo[j-1] + (sum[i]-sum[j-1]) * 1.0 / (i-j+1) );\\n        return memo[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdouble memo[101][101];\\n    double sum[101];\\n    double calc(int i, int j){\\n    \\tif (i < j) return 0;\\n    \\tif (i==0 or j == 0) return 0;\\n    \\tif (j == 1) return sum[i]*1.0 / i;\\n        if (memo[i][j] != 0) return memo[i][j];\\n        for (int k = j; k <= i; k++)\\n        \\tmemo[i][j] = max(memo[i][j], calc(k-1, j-1) + (sum[i] - sum[k-1]) * 1.0 / (i-k+1));\\n        return memo[i][j];\\n    }\\n    \\n    double largestSumOfAverages(vector<int>& A, int K) {\\n        memset(memo, 0, sizeof(memo));\\n       \\tfor (int i = 0; i < A.size(); i++)\\n       \\t\\tsum[i+1] = sum[i] + A[i];\\n       \\treturn calc(A.size(), K);\\n    }\\n```\n```\\n    double dp(int n, int K){\\n        memset(memo, 0, sizeof(memo));\\n\\n        //edge case\\n        for(int i = 1; i <= n; i++)\\n            memo[1][i] = sum[i]*1.0 / i;\\n\\n        for(int g = 2; g <= K; g++) // number of groups\\n            for (int i = g; i <= n; i++)\\n                for (int j = g; j <= i; j++)\\n                    memo[g][i] = max(memo[g][i], memo[g-1][j-1] + (sum[i]-sum[j-1]) * 1.0 / (i-j+1) );\\n        return memo[K][n];\\n    }\\n```\n```\\n    double dp(int n, int K){\\n        memset(memo, 0, sizeof(memo));\\n\\n        //edge case\\n        for(int i = 1; i <= n; i++)\\n            memo[i] = sum[i]*1.0 / i;\\n\\n        for(int g = 2; g <= K; g++) // number of groups\\n            for (int i = n; i >= g; i--)\\n                for (int j = g; j <= i; j++)\\n                    memo[i] = max(memo[i], memo[j-1] + (sum[i]-sum[j-1]) * 1.0 / (i-j+1) );\\n        return memo[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204912,
                "title": "python-dp",
                "content": "```\\n   def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        dp = [[0] * len(A) for i in range(K)]\\n        sum_num = 0\\n        for a in range(len(A)):\\n            sum_num += A[a]\\n            dp[0][a] = sum_num / float(a+1)\\n        for k in range(1, K):\\n            for i in range(k, len(A)):\\n                dp[k][i] = max([dp[k-1][j] + sum(A[j+1:i+1])/float(i-j) for j in range(i)])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\n   def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        dp = [[0] * len(A) for i in range(K)]\\n        sum_num = 0\\n        for a in range(len(A)):\\n            sum_num += A[a]\\n            dp[0][a] = sum_num / float(a+1)\\n        for k in range(1, K):\\n            for i in range(k, len(A)):\\n                dp[k][i] = max([dp[k-1][j] + sum(A[j+1:i+1])/float(i-j) for j in range(i)])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 186175,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        double[][][] dp = new double[A.length+1][A.length+1][K+1];\\n        return dfs(dp,K,0,A.length,A);\\n    }\\n    public double dfs(double[][][] dp, int k, int l, int r, int[] arr){\\n        if(dp[l][r][k]!=0) return dp[l][r][k];\\n        double max = getAvg(l,r,arr);\\n        if(k==1||l==r) return max;\\n        for(int i=l;i<=r;i++){\\n            max = Math.max(max,getAvg(l,i,arr)+dfs(dp,k-1,i,r,arr));\\n        }\\n        dp[l][r][k] = max;\\n        return max;\\n    }\\n    public double getAvg(int l, int r, int[] arr){\\n        if(l==r) return 0;\\n        int sum = 0;for(int i=l;i<r;i++){\\n            sum+=arr[i];\\n        }\\n        return sum/(double)(r-l);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        double[][][] dp = new double[A.length+1][A.length+1][K+1];\\n        return dfs(dp,K,0,A.length,A);\\n    }\\n    public double dfs(double[][][] dp, int k, int l, int r, int[] arr){\\n        if(dp[l][r][k]!=0) return dp[l][r][k];\\n        double max = getAvg(l,r,arr);\\n        if(k==1||l==r) return max;\\n        for(int i=l;i<=r;i++){\\n            max = Math.max(max,getAvg(l,i,arr)+dfs(dp,k-1,i,r,arr));\\n        }\\n        dp[l][r][k] = max;\\n        return max;\\n    }\\n    public double getAvg(int l, int r, int[] arr){\\n        if(l==r) return 0;\\n        int sum = 0;for(int i=l;i<r;i++){\\n            sum+=arr[i];\\n        }\\n        return sum/(double)(r-l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174109,
                "title": "textbook-solution",
                "content": "This is a classic dp program. \\n1. For each recursive stack choose the elements that will be averaged.\\n2. If K is equal to 1, then you must average the remaining elements. This will make sure that you cant have K = 2 when you have 3 elements left.\\n3. Memoize based on start index position and K.\\n\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        return help(A, K, 0, new double[A.length][K + 1]);\\n    }\\n    \\n    public double help(int[] A, int k, int start, double[][] mem){\\n        if(start == A.length) return 0;\\n        if(mem[start][k] != 0) return mem[start][k];\\n        \\n        double max = 0;\\n        double sum = 0;\\n        \\n        if(k == 1){\\n            for(int i = start; i < A.length; i++) sum += A[i];\\n            max = sum / (A.length - start);\\n        }\\n        else{\\n            for(int i = start; i < A.length - k + 1; i++){\\n                sum += A[i];\\n                max = Math.max(max, sum / (i - start + 1) + help(A, k - 1, i + 1, mem));\\n            } \\n        }\\n\\n        return mem[start][k] = max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        return help(A, K, 0, new double[A.length][K + 1]);\\n    }\\n    \\n    public double help(int[] A, int k, int start, double[][] mem){\\n        if(start == A.length) return 0;\\n        if(mem[start][k] != 0) return mem[start][k];\\n        \\n        double max = 0;\\n        double sum = 0;\\n        \\n        if(k == 1){\\n            for(int i = start; i < A.length; i++) sum += A[i];\\n            max = sum / (A.length - start);\\n        }\\n        else{\\n            for(int i = start; i < A.length - k + 1; i++){\\n                sum += A[i];\\n                max = Math.max(max, sum / (i - start + 1) + help(A, k - 1, i + 1, mem));\\n            } \\n        }\\n\\n        return mem[start][k] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163092,
                "title": "very-short-python-dp",
                "content": "The idea is to work our way from left to the right, computing at every index **i** and every **k <= K** the max result if we want to split the subarray **A[0 : i]** into **k** segments. The solution can be easily sped up in multiple ways, including computing in advance **sum(A[r:i])** efficiently, but this works well enough. \\n```\\nclass Solution(object):\\n    def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        ans = [[0] + [-float(\\'inf\\')] * K]\\n        for i in range(1, len(A) + 1):\\n            Z = [-float(\\'inf\\')] * (K + 1)\\n            for j in range(1, K + 1):\\n                Z[j] = max([ans[r][j - 1] + (sum(A[r:i]) + 0.0)/(i - r) for r in range(i)])\\n            ans.append(Z)\\n        return ans[-1][K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestSumOfAverages(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: float\\n        \"\"\"\\n        ans = [[0] + [-float(\\'inf\\')] * K]\\n        for i in range(1, len(A) + 1):\\n            Z = [-float(\\'inf\\')] * (K + 1)\\n            for j in range(1, K + 1):\\n                Z[j] = max([ans[r][j - 1] + (sum(A[r:i]) + 0.0)/(i - r) for r in range(i)])\\n            ans.append(Z)\\n        return ans[-1][K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123729,
                "title": "c-dp-method-using-recursive",
                "content": "```c++\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K)\\n    {\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = 0; j < A.size(); j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n        return go(A, 0, K);\\n    }\\n    double go(vector<int>& A, int now, int remain)\\n    {\\n        if (now >= A.size())\\n            return 0;\\n        double& ans = dp[now][remain];\\n        if (ans > 0)\\n            return ans;\\n        double sum = 0;\\n        int cnt = 0;\\n        if (remain == 1) {\\n            for (int i = now; i < A.size(); i++) {\\n                sum += A[i];\\n                cnt++;\\n            }\\n            ans = sum / cnt;\\n        } else {\\n            for (int i = now; i < A.size(); i++) {\\n                sum += A[i];\\n                cnt++;\\n                ans = max(ans, sum / cnt + go(A, i + 1, remain - 1));\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    double dp[100][100];\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& A, int K)\\n    {\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = 0; j < A.size(); j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n        return go(A, 0, K);\\n    }\\n    double go(vector<int>& A, int now, int remain)\\n    {\\n        if (now >= A.size())\\n            return 0;\\n        double& ans = dp[now][remain];\\n        if (ans > 0)\\n            return ans;\\n        double sum = 0;\\n        int cnt = 0;\\n        if (remain == 1) {\\n            for (int i = now; i < A.size(); i++) {\\n                sum += A[i];\\n                cnt++;\\n            }\\n            ans = sum / cnt;\\n        } else {\\n            for (int i = now; i < A.size(); i++) {\\n                sum += A[i];\\n                cnt++;\\n                ans = max(ans, sum / cnt + go(A, i + 1, remain - 1));\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    double dp[100][100];\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123196,
                "title": "python-dp",
                "content": "dp[n][k] stores the maximum sum of average obtained by partitioning the first n numbers in to k groups.\\nWithin the n numbers, we iteratively exclude the last (n - i) numbers and assume the first i numbers are partitioned in to (k - 1) groups.\\n```\\nclass Solution(object):\\n    def largestSumOfAverages(self, A, K):\\n            N = len(A)\\n            dp = [[0 for i in range(K+1)] for i in range(N+1)]\\n            cur_sum = 0.0\\n            for i in range(N):\\n                cur_sum += A[i]\\n                dp[i+1][1] = cur_sum / (i + 1)\\n            \\n            for n in range(1, N + 1):\\n                for k in range(2, K + 1):\\n                    if n < k:\\n                        continue\\n                    cur_sum = 0.0\\n                    for i in range(n - 1, 0, -1):\\n                        cur_sum += A[i]\\n                        dp[n][k] = max(dp[n][k], dp[i][k-1] + cur_sum / (n - i))\\n            \\n            return dp[N][K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestSumOfAverages(self, A, K):\\n            N = len(A)\\n            dp = [[0 for i in range(K+1)] for i in range(N+1)]\\n            cur_sum = 0.0\\n            for i in range(N):\\n                cur_sum += A[i]\\n                dp[i+1][1] = cur_sum / (i + 1)\\n            \\n            for n in range(1, N + 1):\\n                for k in range(2, K + 1):\\n                    if n < k:\\n                        continue\\n                    cur_sum = 0.0\\n                    for i in range(n - 1, 0, -1):\\n                        cur_sum += A[i]\\n                        dp[n][k] = max(dp[n][k], dp[i][k-1] + cur_sum / (n - i))\\n            \\n            return dp[N][K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123008,
                "title": "java-easy-top-down-dp-applicable-to-k-partitioning",
                "content": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int N = A.length;\\n        double[] P = new double[N];\\n        P[0] = A[0];\\n        for (int i = 1; i < N; ++i) P[i] = P[i - 1] + A[i];\\n        if(K == 1) return (P[N - 1])/N;\\n        double [][] dp = new double[N + 1][K + 1];\\n        double sol = 0;\\n        for(int i = 0; i < A.length; ++i) dp[i][1] = P[i]/(i + 1);\\n        for(int i = 0; i < A.length; ++i){\\n            for(int j = 0; j < i; ++j){\\n                for(int k = 2; k < K + 1; ++k){\\n                    dp[i][k] = Math.max(dp[i][k], dp[j][k - 1] + (P[i] - P[j])/(i - j));\\n                    if(i == N - 1) sol = Math.max(sol, dp[i][k]);\\n                }\\n            }\\n        }\\n        return sol;        \\n    }\\n}\\n```\\n\\nTime is O(KN^2), simple DP approach with N*K array.\\n\\n**Explanation:** dp[i][k] represents the max sum of averages until i with exactly k blocks.\\n\\nThe formula is quite simple then.\\n\\ndp[i][k] = Math.max(dp[i][k], dp[j][k - 1] + (P[i] - P[j])/(i - j)) for all 0 <= j < i",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] A, int K) {\\n        int N = A.length;\\n        double[] P = new double[N];\\n        P[0] = A[0];\\n        for (int i = 1; i < N; ++i) P[i] = P[i - 1] + A[i];\\n        if(K == 1) return (P[N - 1])/N;\\n        double [][] dp = new double[N + 1][K + 1];\\n        double sol = 0;\\n        for(int i = 0; i < A.length; ++i) dp[i][1] = P[i]/(i + 1);\\n        for(int i = 0; i < A.length; ++i){\\n            for(int j = 0; j < i; ++j){\\n                for(int k = 2; k < K + 1; ++k){\\n                    dp[i][k] = Math.max(dp[i][k], dp[j][k - 1] + (P[i] - P[j])/(i - j));\\n                    if(i == N - 1) sol = Math.max(sol, dp[i][k]);\\n                }\\n            }\\n        }\\n        return sol;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122794,
                "title": "java-dp-solution-with-explanation",
                "content": "```sums[i]``` means the sum from ```A[0]``` to ```A[i - 1]```\\n```dp[k][i]``` means the largest sum of averages if we devide the ```A[0] ... A[i - 1]``` into ```k``` parts\\nFor each ```k``` and ```i```, ```dp[k][i] = max(dp[k - 1][j - 1] + avg(j, i))```, in which ```j``` is in range from ```k``` to ```i``` \\n```\\npublic double largestSumOfAverages(int[] A, int K) {\\n        int n = A.length;\\n        int[] sums = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            sums[i] = sums[i - 1] + A[i - 1];\\n        }\\n        double[][] dp = new double[K + 1][n + 1];\\n        for (int k = 1; k <= K; k++) {\\n            for (int i = k; i <= n; i++) {\\n                for (int j = k; j <= i; j++) {\\n                    if (k == 1) {\\n                        dp[k][i] = (double)sums[i] / i;\\n                    } else {\\n                        dp[k][i] = Math.max(dp[k][i], dp[k - 1][j - 1] + (double)(sums[i] - sums[j - 1]) / (i - j + 1));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[K][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```sums[i]```\n```A[0]```\n```A[i - 1]```\n```dp[k][i]```\n```A[0] ... A[i - 1]```\n```k```\n```k```\n```i```\n```dp[k][i] = max(dp[k - 1][j - 1] + avg(j, i))```\n```j```\n```k```\n```i```\n```\\npublic double largestSumOfAverages(int[] A, int K) {\\n        int n = A.length;\\n        int[] sums = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            sums[i] = sums[i - 1] + A[i - 1];\\n        }\\n        double[][] dp = new double[K + 1][n + 1];\\n        for (int k = 1; k <= K; k++) {\\n            for (int i = k; i <= n; i++) {\\n                for (int j = k; j <= i; j++) {\\n                    if (k == 1) {\\n                        dp[k][i] = (double)sums[i] / i;\\n                    } else {\\n                        dp[k][i] = Math.max(dp[k][i], dp[k - 1][j - 1] + (double)(sums[i] - sums[j - 1]) / (i - j + 1));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[K][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122749,
                "title": "c-11-line-dp",
                "content": "```\\ndouble largestSumOfAverages(vector<int>& a, int k) {\\n\\n    int n = a.size();\\n    vector<double> c{0.0};\\n    partial_sum(a.begin(), a.end(), back_inserter(c));\\n\\n    vector<vector<double>> dp(n+1, vector<double>(k+1,-1));\\n    dp[0][0] = 0;\\n\\n    for(int i=1; i<=n; i++)\\n        for(int d=1; d<=k; d++)\\n            for(int j=0; j<i; j++)\\n                if(dp[j][d-1] != -1)\\n                    dp[i][d] = max(dp[i][d], dp[j][d-1]+(c[i]-c[j])/(i-j));\\n    return dp[n][k];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestSumOfAverages(vector<int>& a, int k) {\\n\\n    int n = a.size();\\n    vector<double> c{0.0};\\n    partial_sum(a.begin(), a.end(), back_inserter(c));\\n\\n    vector<vector<double>> dp(n+1, vector<double>(k+1,-1));\\n    dp[0][0] = 0;\\n\\n    for(int i=1; i<=n; i++)\\n        for(int d=1; d<=k; d++)\\n            for(int j=0; j<i; j++)\\n                if(dp[j][d-1] != -1)\\n                    dp[i][d] = max(dp[i][d], dp[j][d-1]+(c[i]-c[j])/(i-j));\\n    return dp[n][k];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051724,
                "title": "dp-memorization-way-of-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n      private int len;\\n    private double[][]dp; //dp[start][k]\\n    private int[] sum;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n         len = nums.length;\\n        dp = new double[len][k+1];\\n        sum = new int[len+1];\\n        //prefix sum to speed up the avg compuation.\\n        for(int i = 1; i <= len; i++) sum[i] = sum[i-1] + nums[i-1];\\n\\n        double res = dfs(0,k);\\n       // System.out.println(Arrays.deepToString(dp ));\\n        return res;\\n    }\\n    \\n    private double dfs(int start, int k){\\n       //when k == 1, then we return the avg of nums[start , len-1];\\n        if(k == 1){\\n            dp[start][k] = (sum[len] - sum[start])*1.0/(len-start);\\n            return dp[start][k];\\n        }\\n        if(dp[start][k] != 0.0d){\\n            return dp[start][k];\\n        }\\n\\n         double res = 0;\\n        //we have to make sure that in the next round dfs(i+1, k-1), i + (k -1) <= len -1\\n        //so we get the i\\'s upbound is i <= len - k;\\n\\n        for(int i = start; i <= len  -k  ; i++){\\n               \\n            double curAvg = (sum[i+1] - sum[start])*1.0d/(i+1-start);\\n            double nextAvg =   dfs(i+1, k-1);\\n            res = Math.max(res,curAvg + nextAvg);\\n        }\\n         return dp[start][k] = res;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      private int len;\\n    private double[][]dp; //dp[start][k]\\n    private int[] sum;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n         len = nums.length;\\n        dp = new double[len][k+1];\\n        sum = new int[len+1];\\n        //prefix sum to speed up the avg compuation.\\n        for(int i = 1; i <= len; i++) sum[i] = sum[i-1] + nums[i-1];\\n\\n        double res = dfs(0,k);\\n       // System.out.println(Arrays.deepToString(dp ));\\n        return res;\\n    }\\n    \\n    private double dfs(int start, int k){\\n       //when k == 1, then we return the avg of nums[start , len-1];\\n        if(k == 1){\\n            dp[start][k] = (sum[len] - sum[start])*1.0/(len-start);\\n            return dp[start][k];\\n        }\\n        if(dp[start][k] != 0.0d){\\n            return dp[start][k];\\n        }\\n\\n         double res = 0;\\n        //we have to make sure that in the next round dfs(i+1, k-1), i + (k -1) <= len -1\\n        //so we get the i\\'s upbound is i <= len - k;\\n\\n        for(int i = start; i <= len  -k  ; i++){\\n               \\n            double curAvg = (sum[i+1] - sum[start])*1.0d/(i+1-start);\\n            double nextAvg =   dfs(i+1, k-1);\\n            res = Math.max(res,curAvg + nextAvg);\\n        }\\n         return dp[start][k] = res;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045192,
                "title": "python-3-liner-dp-memoization",
                "content": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i, k, curr_count, curr_sum):\\n            if i >= n: return 0\\n            if not k: return float(\\'-inf\\')\\n            return max((curr_sum + nums[i])/(curr_count + 1) + dp(i+1, k-1, 0, 0), dp(i+1, k, (curr_count + 1), (curr_sum + nums[i])))\\n    \\n        return dp(0, k, 0, 0)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i, k, curr_count, curr_sum):\\n            if i >= n: return 0\\n            if not k: return float(\\'-inf\\')\\n            return max((curr_sum + nums[i])/(curr_count + 1) + dp(i+1, k-1, 0, 0), dp(i+1, k, (curr_count + 1), (curr_sum + nums[i])))\\n    \\n        return dp(0, k, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 4041942,
                "title": "go-dp-with-comments",
                "content": "```\\nfunc largestSumOfAverages(nums []int, k int) float64 {\\n    n := len(nums)\\n    prefixsum := make([]float64, n + 1)\\n\\n    // calculate prefix sum\\n    for i := 0; i < n; i++ {\\n        prefixsum[i + 1] = prefixsum[i] + float64(nums[i])\\n    }\\n\\n    dp := make([]float64, n)\\n\\n    // the average value if it were one partition\\n    // starting from i\\n    for i := 0; i < n; i++ {\\n        dp[i] = (prefixsum[n] - prefixsum[i]) / float64(n - i)\\n    }\\n\\n    // for each additional partition\\n    for p := 1; p < k; p++ {\\n        for i := 0; i < n; i++ {\\n            for j := i + 1; j < n; j++ {\\n                // calculating average value of a partition plus\\n                // the max value if partitioned from the j th point\\n                dp[i] = math.Max(dp[i], (prefixsum[j] - prefixsum[i]) / float64(j - i) + dp[j])\\n            }\\n        }\\n    }\\n\\n    return dp[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestSumOfAverages(nums []int, k int) float64 {\\n    n := len(nums)\\n    prefixsum := make([]float64, n + 1)\\n\\n    // calculate prefix sum\\n    for i := 0; i < n; i++ {\\n        prefixsum[i + 1] = prefixsum[i] + float64(nums[i])\\n    }\\n\\n    dp := make([]float64, n)\\n\\n    // the average value if it were one partition\\n    // starting from i\\n    for i := 0; i < n; i++ {\\n        dp[i] = (prefixsum[n] - prefixsum[i]) / float64(n - i)\\n    }\\n\\n    // for each additional partition\\n    for p := 1; p < k; p++ {\\n        for i := 0; i < n; i++ {\\n            for j := i + 1; j < n; j++ {\\n                // calculating average value of a partition plus\\n                // the max value if partitioned from the j th point\\n                dp[i] = math.Max(dp[i], (prefixsum[j] - prefixsum[i]) / float64(j - i) + dp[j])\\n            }\\n        }\\n    }\\n\\n    return dp[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032758,
                "title": "cpp-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[101][101]={0.0};\\n    double func(int i, vector<int>&nums,int k){\\n        if(i==nums.size() || dp[i][k]>0) return dp[i][k];\\n        double sum=0;\\n        double ans=INT_MIN;\\n        double avg;\\n         for(int j=i;j<nums.size();j++){\\n             sum+=nums[j];\\n              avg=sum/(j-i+1);\\n             if(k>1)\\n             ans=max(ans,avg+func(j+1,nums,k-1));\\n                 \\n             \\n         }\\n        if(k==1){\\n            ans=max(ans,avg);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        return func(0,nums,k);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double dp[101][101]={0.0}",
                "codeTag": "Java"
            },
            {
                "id": 4018319,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n   public double largestSumOfAverages(int[] nums, int k) {\\n    return getLargestSumOfAverages(nums, k, 0, new Double[nums.length][k+1]);\\n}\\npublic double getLargestSumOfAverages(int[] nums, int k, int index, Double[][] dp)\\n{\\n\\tif(index>= nums.length || k==1)\\n\\t{\\n\\t\\tint count =0;\\n\\t\\tdouble res = 0;\\n\\t\\twhile(index<nums.length)\\n\\t\\t{\\n\\t\\t\\tres+=nums[index];\\n\\t\\t\\tindex++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tif(res == 0)\\n\\t\\t\\treturn res;\\n\\t\\treturn res/count;\\n\\t\\t\\n\\t}\\n\\tif(dp[index][k] != null)\\n\\t\\treturn dp[index][k];\\n\\t\\n\\tdouble result = 0;\\n\\tint count = 0;\\n\\tdouble res = 0;\\n\\tfor(int i = index;i<nums.length;i++)\\n\\t{\\n\\t\\tcount++;\\n\\t\\tres +=nums[i];\\n\\t\\tdouble res1 = getLargestSumOfAverages(nums, k-1, i+1, dp);\\n        //System.out.println(\"res1 -->>\"+res1);\\n       // System.out.println(\"res -->>\"+res);\\n\\t\\tresult = Math.max(result, ((res/count)+res1));\\n        // System.out.println(\"result -->>\"+result);\\n\\t\\t\\n\\t\\t\\n\\t}\\n\\treturn dp[index][k]= result;\\n\\t\\n}\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    double solve(int i, int j, vector<int>&arr,int part,vector<vector<double>>&dp){\\n        //base case\\n        if(i>j)return 0.0;\\n        if(part==0)\\n            return (double(arr[j]-arr[i-1]))/double(j-i+1); \\n        //check the cache\\n        if(dp[i][part]!=-1)\\n            return dp[i][part];\\n        \\n        double score=0;\\n        for(int k=i;k<=j;k++){\\n            double curr= (double(arr[k]-arr[i-1]))/double(k-i+1) +\\n                         solve(k+1,j,arr,part-1,dp);\\n            score=max(score,curr);\\n        }\\n        return dp[i][part]= score;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<vector<double>>dp(n+1,vector<double>(k,-1));\\n        vector<int>arr(n+1,0);\\n        for(int i=0;i<n;i++)arr[i+1]=nums[i]+arr[i];\\n        return solve(1,n,arr,k-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n   public double largestSumOfAverages(int[] nums, int k) {\\n    return getLargestSumOfAverages(nums, k, 0, new Double[nums.length][k+1]);\\n}\\npublic double getLargestSumOfAverages(int[] nums, int k, int index, Double[][] dp)\\n{\\n\\tif(index>= nums.length || k==1)\\n\\t{\\n\\t\\tint count =0;\\n\\t\\tdouble res = 0;\\n\\t\\twhile(index<nums.length)\\n\\t\\t{\\n\\t\\t\\tres+=nums[index];\\n\\t\\t\\tindex++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tif(res == 0)\\n\\t\\t\\treturn res;\\n\\t\\treturn res/count;\\n\\t\\t\\n\\t}\\n\\tif(dp[index][k] != null)\\n\\t\\treturn dp[index][k];\\n\\t\\n\\tdouble result = 0;\\n\\tint count = 0;\\n\\tdouble res = 0;\\n\\tfor(int i = index;i<nums.length;i++)\\n\\t{\\n\\t\\tcount++;\\n\\t\\tres +=nums[i];\\n\\t\\tdouble res1 = getLargestSumOfAverages(nums, k-1, i+1, dp);\\n        //System.out.println(\"res1 -->>\"+res1);\\n       // System.out.println(\"res -->>\"+res);\\n\\t\\tresult = Math.max(result, ((res/count)+res1));\\n        // System.out.println(\"result -->>\"+result);\\n\\t\\t\\n\\t\\t\\n\\t}\\n\\treturn dp[index][k]= result;\\n\\t\\n}\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    double solve(int i, int j, vector<int>&arr,int part,vector<vector<double>>&dp){\\n        //base case\\n        if(i>j)return 0.0;\\n        if(part==0)\\n            return (double(arr[j]-arr[i-1]))/double(j-i+1); \\n        //check the cache\\n        if(dp[i][part]!=-1)\\n            return dp[i][part];\\n        \\n        double score=0;\\n        for(int k=i;k<=j;k++){\\n            double curr= (double(arr[k]-arr[i-1]))/double(k-i+1) +\\n                         solve(k+1,j,arr,part-1,dp);\\n            score=max(score,curr);\\n        }\\n        return dp[i][part]= score;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<vector<double>>dp(n+1,vector<double>(k,-1));\\n        vector<int>arr(n+1,0);\\n        for(int i=0;i<n;i++)arr[i+1]=nums[i]+arr[i];\\n        return solve(1,n,arr,k-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016820,
                "title": "largest-sum-of-averages",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumOfAverages = function(nums, k) {\\n    const n = nums.length;\\n    const memo = new Array(n).fill(null).map(() => new Array(k + 1).fill(null));\\n\\n    function average(start, end) {\\n        return (nums.slice(start, end + 1).reduce((a, b) => a + b, 0)) / (end - start + 1);\\n    }\\n\\n    function dp(start, k) {\\n        if (memo[start][k] !== null) {\\n            return memo[start][k];\\n        }\\n        if (k === 1) {\\n            return average(start, n - 1);\\n        }\\n        let maxAvg = 0;\\n        for (let i = start; i < n - k + 1; i++) {\\n            maxAvg = Math.max(maxAvg, average(start, i) + dp(i + 1, k - 1));\\n        }\\n        memo[start][k] = maxAvg;\\n        return maxAvg;\\n    }\\n\\n    return dp(0, k);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumOfAverages = function(nums, k) {\\n    const n = nums.length;\\n    const memo = new Array(n).fill(null).map(() => new Array(k + 1).fill(null));\\n\\n    function average(start, end) {\\n        return (nums.slice(start, end + 1).reduce((a, b) => a + b, 0)) / (end - start + 1);\\n    }\\n\\n    function dp(start, k) {\\n        if (memo[start][k] !== null) {\\n            return memo[start][k];\\n        }\\n        if (k === 1) {\\n            return average(start, n - 1);\\n        }\\n        let maxAvg = 0;\\n        for (let i = start; i < n - k + 1; i++) {\\n            maxAvg = Math.max(maxAvg, average(start, i) + dp(i + 1, k - 1));\\n        }\\n        memo[start][k] = maxAvg;\\n        return maxAvg;\\n    }\\n\\n    return dp(0, k);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3988079,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "### dynamic programming\\ndp[i][j] is max sum of averages where j-th(0-indexed) subarray\\'s last element is nums[i].\\nCalculate prefix sum at first.\\ndp[0][j] is average of (nums[0] ... nums[j]).\\ndp[i][j] = max(dp[i][j], dp[i-1][m-1] + (prefix[j+1] - prefix[m]) / (j - m + 1)), where nums[m] ... num[j] form i-th subarray.\\n\\ntc is O(len(nums)^2 * k), sc is O(len(nums) * k).\\n### python\\n```python\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        size = len(nums)\\n        dp = [[0] * (size) for _ in range(k)]\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        for i in range(k):\\n            for j in range(i, size):\\n                if i == 0:\\n                    dp[i][j] = prefix[j+1] / (j + 1)\\n                else:\\n                    for m in range(j, i-1, -1):\\n                        dp[i][j] = max(dp[i][j], dp[i-1][m-1] + (prefix[j+1] - prefix[m]) / (j - m + 1))\\n        return dp[-1][-1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int size = nums.size();\\n        vector<vector<double>> dp (k, vector<double>(size));\\n        vector<double> prefix {0};\\n        for (auto &x: nums) prefix.emplace_back(prefix.back() + x);\\n        for (int i = 0; i < k; i+=1) {\\n            for (int j = i; j < size; j+=1) {\\n                if (i == 0) dp[i][j] = prefix[j+1]/ (j + 1);\\n                else {\\n                    for (int m = j; m >= i; m-=1)\\n                        dp[i][j] = max(dp[i][j], dp[i-1][m-1] + (prefix[j+1] - prefix[m]) / (j - m + 1));\\n                }\\n            }\\n        }\\n        return dp[k-1][size-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        size = len(nums)\\n        dp = [[0] * (size) for _ in range(k)]\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        for i in range(k):\\n            for j in range(i, size):\\n                if i == 0:\\n                    dp[i][j] = prefix[j+1] / (j + 1)\\n                else:\\n                    for m in range(j, i-1, -1):\\n                        dp[i][j] = max(dp[i][j], dp[i-1][m-1] + (prefix[j+1] - prefix[m]) / (j - m + 1))\\n        return dp[-1][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int size = nums.size();\\n        vector<vector<double>> dp (k, vector<double>(size));\\n        vector<double> prefix {0};\\n        for (auto &x: nums) prefix.emplace_back(prefix.back() + x);\\n        for (int i = 0; i < k; i+=1) {\\n            for (int j = i; j < size; j+=1) {\\n                if (i == 0) dp[i][j] = prefix[j+1]/ (j + 1);\\n                else {\\n                    for (int m = j; m >= i; m-=1)\\n                        dp[i][j] = max(dp[i][j], dp[i-1][m-1] + (prefix[j+1] - prefix[m]) / (j - m + 1));\\n                }\\n            }\\n        }\\n        return dp[k-1][size-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920035,
                "title": "python-3-2d-dynamic-programming-tc-94-61-sc-98-6-without-redundant-update",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\n        # create dp, set base case\\n            # dp[i][j] means having i number of subarrays(choosing (i + 1)th subarray)\\n            # including jth element from the nums as the last element included in the (i + 1)th subarray\\n            # the maximum sum of the average of the subarrays\\n        N = len(nums)\\n        dp = [[0] * N for _ in range(k)] # k * N dp\\n        subtotal = 0\\n        for i in range(N - k + 1): # 5 -> 3\\n            subtotal += nums[i]\\n            dp[0][i] = subtotal / (i + 1)\\n        \\n        # update dp\\n        for r in range(1, k): # update each row in the order\\n            right = N - (k - r - 1) # leave k - r number of elements at the end of each row\\n            for j in range(r, right): # for each column\\n                subtotal = 0\\n\\n                # update with max for the additional subaray + previously formed subarray\\n                for c in range(j, right): \\n                    subtotal += nums[c]\\n                    dp[r][c] = max(dp[r][c], dp[r - 1][j - 1] + subtotal / (c - j + 1))\\n\\n        return dp[k - 1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\n        # create dp, set base case\\n            # dp[i][j] means having i number of subarrays(choosing (i + 1)th subarray)\\n            # including jth element from the nums as the last element included in the (i + 1)th subarray\\n            # the maximum sum of the average of the subarrays\\n        N = len(nums)\\n        dp = [[0] * N for _ in range(k)] # k * N dp\\n        subtotal = 0\\n        for i in range(N - k + 1): # 5 -> 3\\n            subtotal += nums[i]\\n            dp[0][i] = subtotal / (i + 1)\\n        \\n        # update dp\\n        for r in range(1, k): # update each row in the order\\n            right = N - (k - r - 1) # leave k - r number of elements at the end of each row\\n            for j in range(r, right): # for each column\\n                subtotal = 0\\n\\n                # update with max for the additional subaray + previously formed subarray\\n                for c in range(j, right): \\n                    subtotal += nums[c]\\n                    dp[r][c] = max(dp[r][c], dp[r - 1][j - 1] + subtotal / (c - j + 1))\\n\\n        return dp[k - 1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890940,
                "title": "short-and-clean-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,double> mp;\\n    double largestSumOfAverages(vector<int>& nums, int k, int x=0) {\\n        if(x>=nums.size())      return 0;\\n        if(mp.count({x,k}))     return mp[{x,k}];\\n        double ans=0,sum=0;\\n        for(int i=x;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(k>1)         ans=max(ans,sum/(i-x+1)+largestSumOfAverages(nums,k-1,i+1));\\n        }\\n        if(k==1)            return mp[{x,k}]=sum/(nums.size()-x);\\n        return mp[{x,k}]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,double> mp;\\n    double largestSumOfAverages(vector<int>& nums, int k, int x=0) {\\n        if(x>=nums.size())      return 0;\\n        if(mp.count({x,k}))     return mp[{x,k}];\\n        double ans=0,sum=0;\\n        for(int i=x;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(k>1)         ans=max(ans,sum/(i-x+1)+largestSumOfAverages(nums,k-1,i+1));\\n        }\\n        if(k==1)            return mp[{x,k}]=sum/(nums.size()-x);\\n        return mp[{x,k}]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885084,
                "title": "dp-solution-expalined-in-detail-with-dry-run",
                "content": "# Code\\n```\\nclass Solution {\\n    int n;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        // at most k partition -> partition karne mai hi bhalai hai \\n        // kyu? \\n        // a> {1,1000} -> partion mai 1001 ayyega aur bina partition ke 1001/2.\\n        // b> {1,1} -> with partition 2, without is 1.\\n        // c> {1000, 2000} -> with partition 3000, without partition 1500.\\n        // so we better perform k partition\\n\\n        // calculate prefix sum\\n        n = nums.length;\\n        int[] pre = new int[n];\\n        pre[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n            pre[i] = pre[i-1] + nums[i];\\n\\n        // create a 3d dp and fill it with -1\\n        double[][][] dp = new double[n][n][k+1];\\n        for(double[][] arr: dp)\\n            for(double[] row : arr)\\n                Arrays.fill(row, -1.0);\\n\\n        return f(0, n-1, k, pre, dp);\\n    }\\n    private double f(int start, int end, int k, int[] pre, double[][][] dp){\\n        // all partions are done\\n        if(k <= 0) {\\n            // when k is 0, there will be 2 cases\\n            // nums = {4,1,7,5,6,2,3}\\n            // Case 1 - if it\\'s not fully traversed, i.e. \\n            // we take pairs are {4,1}, {7}, {5}, {6}. Now, {2,3} is left to traverse but k=0. That means some elements are left. We can\\'t take this array into consideration. So we return minimum integer value.\\n            // Case 2 - if it\\'s fully traversed. Then just return 0.\\n\\n            if(start > n-1) return 0.0;\\n            else return Integer.MIN_VALUE;\\n        }\\n\\n        // case when we partition only 1 element.\\n        // if(start == end) return getAvg(pre, start, end);\\n        // we can ignore this case too. cz we even this case will be considered in our recusion.\\n\\n        // when array is fully traversed then return 0.\\n        if(start > end) return 0.0;\\n\\n        if(dp[start][end][k] != -1.0) return dp[start][end][k]; // memoization\\n\\n        // partion at every index from start to end.\\n        double res = 0.0;\\n        for(int i=start; i<= end; i++){\\n            // get the average of elements from start to i (partion). Then solve recusively for other elements.\\n            double avg = getAvg(pre, start, i) + f(i+1, end, k-1, pre, dp);\\n\\n            // take max of all the averages\\n            res = Math.max(avg, res);\\n        }\\n\\n        return dp[start][end][k] = res; // memoization\\n    }\\n    private double getAvg(int[] pre, int start, int end){\\n        // it\\'s simple prefix sum.\\n        // first get sum from start to end. Then, divide it by length to get average.\\n\\n        if(start == 0) return (double) pre[end]/(end+1);\\n        return (double)(pre[end] - pre[start-1])/(end-start+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        // at most k partition -> partition karne mai hi bhalai hai \\n        // kyu? \\n        // a> {1,1000} -> partion mai 1001 ayyega aur bina partition ke 1001/2.\\n        // b> {1,1} -> with partition 2, without is 1.\\n        // c> {1000, 2000} -> with partition 3000, without partition 1500.\\n        // so we better perform k partition\\n\\n        // calculate prefix sum\\n        n = nums.length;\\n        int[] pre = new int[n];\\n        pre[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n            pre[i] = pre[i-1] + nums[i];\\n\\n        // create a 3d dp and fill it with -1\\n        double[][][] dp = new double[n][n][k+1];\\n        for(double[][] arr: dp)\\n            for(double[] row : arr)\\n                Arrays.fill(row, -1.0);\\n\\n        return f(0, n-1, k, pre, dp);\\n    }\\n    private double f(int start, int end, int k, int[] pre, double[][][] dp){\\n        // all partions are done\\n        if(k <= 0) {\\n            // when k is 0, there will be 2 cases\\n            // nums = {4,1,7,5,6,2,3}\\n            // Case 1 - if it\\'s not fully traversed, i.e. \\n            // we take pairs are {4,1}, {7}, {5}, {6}. Now, {2,3} is left to traverse but k=0. That means some elements are left. We can\\'t take this array into consideration. So we return minimum integer value.\\n            // Case 2 - if it\\'s fully traversed. Then just return 0.\\n\\n            if(start > n-1) return 0.0;\\n            else return Integer.MIN_VALUE;\\n        }\\n\\n        // case when we partition only 1 element.\\n        // if(start == end) return getAvg(pre, start, end);\\n        // we can ignore this case too. cz we even this case will be considered in our recusion.\\n\\n        // when array is fully traversed then return 0.\\n        if(start > end) return 0.0;\\n\\n        if(dp[start][end][k] != -1.0) return dp[start][end][k]; // memoization\\n\\n        // partion at every index from start to end.\\n        double res = 0.0;\\n        for(int i=start; i<= end; i++){\\n            // get the average of elements from start to i (partion). Then solve recusively for other elements.\\n            double avg = getAvg(pre, start, i) + f(i+1, end, k-1, pre, dp);\\n\\n            // take max of all the averages\\n            res = Math.max(avg, res);\\n        }\\n\\n        return dp[start][end][k] = res; // memoization\\n    }\\n    private double getAvg(int[] pre, int start, int end){\\n        // it\\'s simple prefix sum.\\n        // first get sum from start to end. Then, divide it by length to get average.\\n\\n        if(start == 0) return (double) pre[end]/(end+1);\\n        return (double)(pre[end] - pre[start-1])/(end-start+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759802,
                "title": "c-memoizatoin-3-d-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     double parition(vector<int>&nums,int k,int prev,int ind,vector<vector<vector<double>>>&dp){\\n\\n       if(k==1){\\n           double sum=0; \\n           for(int i{ind};i<nums.size();i++){\\n               sum+= nums[i]; \\n           }\\n            double divide= (double)nums.size() - (double)ind; \\n            return sum/divide; \\n       }\\n\\n       if(ind==nums.size()){\\n           return -99999999.000000;\\n       }\\n\\n        if(dp[k][prev][ind]!=-1){ return dp[k][prev][ind]; }\\n\\n       double sum=0; \\n\\n       for(int i{prev};i<=ind;i++){\\n           sum+= (double)nums[i]; \\n       }\\n\\n        double divide= double(ind)-double(prev)+1;\\n       \\n        double answer1= (sum/divide) + parition(nums,k-1,ind+1,ind+1,dp);\\n\\n        double answer2= parition(nums,k,prev,ind+1,dp);\\n\\n        return dp[k][prev][ind]= max(answer1,answer2); \\n\\n\\n     }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n\\n        \\n        int n= nums.size(); \\n       vector<vector<vector<double>>> dp(n+1, vector<vector<double>>(n+1,vector<double>(n+1,-1)));\\n\\n        double answer= parition(nums,k,0,0,dp); \\n\\n        return answer; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     double parition(vector<int>&nums,int k,int prev,int ind,vector<vector<vector<double>>>&dp){\\n\\n       if(k==1){\\n           double sum=0; \\n           for(int i{ind};i<nums.size();i++){\\n               sum+= nums[i]; \\n           }\\n            double divide= (double)nums.size() - (double)ind; \\n            return sum/divide; \\n       }\\n\\n       if(ind==nums.size()){\\n           return -99999999.000000;\\n       }\\n\\n        if(dp[k][prev][ind]!=-1){ return dp[k][prev][ind]; }\\n\\n       double sum=0; \\n\\n       for(int i{prev};i<=ind;i++){\\n           sum+= (double)nums[i]; \\n       }\\n\\n        double divide= double(ind)-double(prev)+1;\\n       \\n        double answer1= (sum/divide) + parition(nums,k-1,ind+1,ind+1,dp);\\n\\n        double answer2= parition(nums,k,prev,ind+1,dp);\\n\\n        return dp[k][prev][ind]= max(answer1,answer2); \\n\\n\\n     }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n\\n        \\n        int n= nums.size(); \\n       vector<vector<vector<double>>> dp(n+1, vector<vector<double>>(n+1,vector<double>(n+1,-1)));\\n\\n        double answer= parition(nums,k,0,0,dp); \\n\\n        return answer; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701436,
                "title": "c-code-memoization-striver-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    \\n    double f(int i ,vector<int>& nums, int k, vector<vector<double>>& dp){\\n        if( i == nums.size() || k < 0) return 0 ;\\n\\n        if( k == 0) return INT_MIN /2 ;\\n\\n        if(dp[i][k] != -1) return dp[i][k] ;\\n\\n        int n = nums.size() ;\\n\\n        double len = 0 , sum = 0 , avg = 0 , maxAns = 0;\\n        for(int j = i ; j < n ; j++){\\n            len ++ ;\\n            sum += nums[j];\\n            \\n            avg = (double)(sum/len) + f(j+1 , nums , k-1 , dp) ;\\n            maxAns = max(maxAns , avg) ;\\n        }\\n        return dp[i][k] =  maxAns ;\\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        vector<vector<double>>dp(n+1 , vector<double>(n+1 , -1)) ;\\n        \\n        return f(0 , nums , k , dp) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n    double f(int i ,vector<int>& nums, int k, vector<vector<double>>& dp){\\n        if( i == nums.size() || k < 0) return 0 ;\\n\\n        if( k == 0) return INT_MIN /2 ;\\n\\n        if(dp[i][k] != -1) return dp[i][k] ;\\n\\n        int n = nums.size() ;\\n\\n        double len = 0 , sum = 0 , avg = 0 , maxAns = 0;\\n        for(int j = i ; j < n ; j++){\\n            len ++ ;\\n            sum += nums[j];\\n            \\n            avg = (double)(sum/len) + f(j+1 , nums , k-1 , dp) ;\\n            maxAns = max(maxAns , avg) ;\\n        }\\n        return dp[i][k] =  maxAns ;\\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        vector<vector<double>>dp(n+1 , vector<double>(n+1 , -1)) ;\\n        \\n        return f(0 , nums , k , dp) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671981,
                "title": "solution-for-bignnrs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public double largestSumOfAverages(int[] nums, int p) {\\n        double[] dp = new double[nums.length];\\n        for (int i = 0; i < p; i++){ // p stands for \"num of partition\"\\n            double[] next = new double[nums.length];\\n            double sum = 0;\\n            for (int j = 0; j < nums.length; j++){\\n                sum += nums[j];\\n                if (i == 0){ // base case\\n                    next[j] = sum/(j+1);\\n                }\\n                for (int k = j; k > 0 && i > 0; k--){ // only enter this loop when there is a partition (not base case)\\n                    sum = k == j? nums[k] : sum+nums[k]; // reset sum if it is a new loop\\n                    next[j] = Math.max(next[j], sum/(j-k+1)+dp[k-1]);\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public double largestSumOfAverages(int[] nums, int p) {\\n        double[] dp = new double[nums.length];\\n        for (int i = 0; i < p; i++){ // p stands for \"num of partition\"\\n            double[] next = new double[nums.length];\\n            double sum = 0;\\n            for (int j = 0; j < nums.length; j++){\\n                sum += nums[j];\\n                if (i == 0){ // base case\\n                    next[j] = sum/(j+1);\\n                }\\n                for (int k = j; k > 0 && i > 0; k--){ // only enter this loop when there is a partition (not base case)\\n                    sum = k == j? nums[k] : sum+nums[k]; // reset sum if it is a new loop\\n                    next[j] = Math.max(next[j], sum/(j-k+1)+dp[k-1]);\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605357,
                "title": "python-easy-solution-easy-to-understand-and-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def f(self,idx,arr,k,dp):\\n        if idx==len(arr) or k<0:\\n            return 0\\n        \\n        if k==0:return float(\"-inf\")\\n        if dp[idx][k]!=-1:return dp[idx][k]\\n        ans=0\\n        Sum=0\\n        for i in range(idx,len(arr)):\\n            Sum+=arr[i]\\n            ans=max(ans,Sum/(i-idx+1)+self.f(i+1,arr,k-1,dp))\\n        \\n        dp[idx][k]=ans\\n        return dp[idx][k]\\n\\n    def largestSumOfAverages(self, arr: List[int], k: int) -> float:\\n        dp=[[-1]*(k+1) for _ in range(len(arr))]\\n        return self.f(0,arr,k,dp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,idx,arr,k,dp):\\n        if idx==len(arr) or k<0:\\n            return 0\\n        \\n        if k==0:return float(\"-inf\")\\n        if dp[idx][k]!=-1:return dp[idx][k]\\n        ans=0\\n        Sum=0\\n        for i in range(idx,len(arr)):\\n            Sum+=arr[i]\\n            ans=max(ans,Sum/(i-idx+1)+self.f(i+1,arr,k-1,dp))\\n        \\n        dp[idx][k]=ans\\n        return dp[idx][k]\\n\\n    def largestSumOfAverages(self, arr: List[int], k: int) -> float:\\n        dp=[[-1]*(k+1) for _ in range(len(arr))]\\n        return self.f(0,arr,k,dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596009,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double func(vector<int>&nums , int i , int k , vector<vector<double>>&dp){\\n        if(i>=nums.size() and k==0) return 0;\\n        if(k==0 or i>=nums.size()) return -1e7;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        double ans=0;\\n        double sum=0;\\n        for(int j=i;j<nums.size();j++){\\n            sum+=nums[j];\\n            ans=max(ans ,(sum/(j-i+1))+ func(nums , j+1 , k-1 , dp));\\n        }\\n        return dp[i][k]=ans;\\n\\n    }\\n\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>>dp(nums.size() , vector<double>(k+1,-1));\\n        double ans=func(nums , 0 , k , dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double func(vector<int>&nums , int i , int k , vector<vector<double>>&dp){\\n        if(i>=nums.size() and k==0) return 0;\\n        if(k==0 or i>=nums.size()) return -1e7;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        double ans=0;\\n        double sum=0;\\n        for(int j=i;j<nums.size();j++){\\n            sum+=nums[j];\\n            ans=max(ans ,(sum/(j-i+1))+ func(nums , j+1 , k-1 , dp));\\n        }\\n        return dp[i][k]=ans;\\n\\n    }\\n\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>>dp(nums.size() , vector<double>(k+1,-1));\\n        double ans=func(nums , 0 , k , dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595964,
                "title": "c-easy-fast-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*3)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[101][101][101];\\n    double solve(vector<int>& nums, int k,int prev,int curr)\\n    {\\n        \\n        if(curr==nums.size())\\n        {\\n            int n=nums.size();\\n            if(k>=1)\\n            {\\n                if(prev!=0 and prev!=n)\\n                return (double)(nums[n-1]-nums[prev-1])/(n-prev);\\n                else\\n                return (double)nums[n-1]/n;\\n            }\\n            else\\n            return 0;\\n        }\\n\\n        if(dp[k][prev][curr]!=-1)\\n        return dp[k][prev][curr];\\n        \\n\\n        double notPar=solve(nums,k,prev,curr+1);\\n        double par=0;\\n        if(k>1)\\n        {\\n            if(prev==0)\\n            par=(double)nums[curr-1]/(curr)+solve(nums,k-1,curr,curr+1);\\n            else if(curr!=prev)\\n            par=(double)(nums[curr - 1] - nums[prev - 1]) / (curr - prev) + solve(nums, k - 1, curr, curr + 1);\\n        }\\n        return dp[k][prev][curr]=max(notPar,par);\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        for(int i=0;i<101;i++)\\n        {\\n            for(int j=0;j<101;j++)\\n            {\\n                for(int k=0;k<101;k++)\\n                {\\n                    dp[i][j][k]=-1.0;\\n                }\\n            }\\n        }\\n        return solve(pre,k,0,1);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[101][101][101];\\n    double solve(vector<int>& nums, int k,int prev,int curr)\\n    {\\n        \\n        if(curr==nums.size())\\n        {\\n            int n=nums.size();\\n            if(k>=1)\\n            {\\n                if(prev!=0 and prev!=n)\\n                return (double)(nums[n-1]-nums[prev-1])/(n-prev);\\n                else\\n                return (double)nums[n-1]/n;\\n            }\\n            else\\n            return 0;\\n        }\\n\\n        if(dp[k][prev][curr]!=-1)\\n        return dp[k][prev][curr];\\n        \\n\\n        double notPar=solve(nums,k,prev,curr+1);\\n        double par=0;\\n        if(k>1)\\n        {\\n            if(prev==0)\\n            par=(double)nums[curr-1]/(curr)+solve(nums,k-1,curr,curr+1);\\n            else if(curr!=prev)\\n            par=(double)(nums[curr - 1] - nums[prev - 1]) / (curr - prev) + solve(nums, k - 1, curr, curr + 1);\\n        }\\n        return dp[k][prev][curr]=max(notPar,par);\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        for(int i=0;i<101;i++)\\n        {\\n            for(int j=0;j<101;j++)\\n            {\\n                for(int k=0;k<101;k++)\\n                {\\n                    dp[i][j][k]=-1.0;\\n                }\\n            }\\n        }\\n        return solve(pre,k,0,1);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554034,
                "title": "well-commented-dp-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n    Time complexity: O(k*n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    Space complexity: O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double helper(int i, vector<int>&nums, int k, vector<vector<double>>&dp){\\n        // base case when index has reached outside the array\\n        if(i>=nums.size()) return 0;\\n        // if k==0, we can partition further so return a very small number so that its contribution can not \\n        // be taken in the result \\n        if(k==0) return INT_MIN;\\n        // checking cache\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        double sum=0, avg=0;\\n        // computing average\\n        for(int j=i; j<nums.size(); j++){\\n            sum += nums[j];\\n            // taking average from (i...j)\\n            avg = max(avg, sum/(j-i+1) + helper(j+1, nums, k-1, dp));\\n        }\\n        // storing value in cache\\n        return dp[i][k] = avg;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<double>>dp(n, vector<double>(k+1, -1));\\n        return helper(0, nums, k, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double helper(int i, vector<int>&nums, int k, vector<vector<double>>&dp){\\n        // base case when index has reached outside the array\\n        if(i>=nums.size()) return 0;\\n        // if k==0, we can partition further so return a very small number so that its contribution can not \\n        // be taken in the result \\n        if(k==0) return INT_MIN;\\n        // checking cache\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        double sum=0, avg=0;\\n        // computing average\\n        for(int j=i; j<nums.size(); j++){\\n            sum += nums[j];\\n            // taking average from (i...j)\\n            avg = max(avg, sum/(j-i+1) + helper(j+1, nums, k-1, dp));\\n        }\\n        // storing value in cache\\n        return dp[i][k] = avg;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<double>>dp(n, vector<double>(k+1, -1));\\n        return helper(0, nums, k, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519292,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[105][105] ;\\n    double recursive(vector<int>nums, int curr, int k){\\n        if(curr>=nums.size() || k<0){\\n            return 0 ; \\n        }\\n        if(k==0){\\n            return INT_MIN ;\\n        }\\n        if(dp[curr][k]!=0){return dp[curr][k]; }\\n\\n        double sum = 0 ; \\n        double ans = INT_MIN;\\n\\n        for(int i=curr; i <nums.size() ; i++){\\n            sum += nums[i] ; \\n            ans = max(ans, sum/(i-curr+1) + recursive(nums,i+1,k-1) )  ;\\n            // cout<<\"The ans is \"<<ans<<endl;\\n        }\\n        return dp[curr][k] = ans;\\n    } \\n    \\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        memset(dp,0,sizeof(dp)) ; \\n        double result = recursive(nums,0,k) ; \\n        cout<<\"The result is \"<<result ;\\n        \\n        return result ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[105][105] ;\\n    double recursive(vector<int>nums, int curr, int k){\\n        if(curr>=nums.size() || k<0){\\n            return 0 ; \\n        }\\n        if(k==0){\\n            return INT_MIN ;\\n        }\\n        if(dp[curr][k]!=0){return dp[curr][k]; }\\n\\n        double sum = 0 ; \\n        double ans = INT_MIN;\\n\\n        for(int i=curr; i <nums.size() ; i++){\\n            sum += nums[i] ; \\n            ans = max(ans, sum/(i-curr+1) + recursive(nums,i+1,k-1) )  ;\\n            // cout<<\"The ans is \"<<ans<<endl;\\n        }\\n        return dp[curr][k] = ans;\\n    } \\n    \\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        memset(dp,0,sizeof(dp)) ; \\n        double result = recursive(nums,0,k) ; \\n        cout<<\"The result is \"<<result ;\\n        \\n        return result ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3516656,
                "title": "easy-recursive-solution-with-memoization",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        def dfs(i, k, memo={}):\\n            if i != len(nums) and k == 0:\\n                return float(\\'-inf\\')\\n            if i == len(nums):\\n                return 0\\n            if (i, k) in memo:\\n                return memo[(i, k)]\\n            largest = 0\\n            total = 0\\n            for j in range(i, len(nums)):\\n                total += nums[j]\\n                largest = max(largest, (total / (j - i + 1)) + dfs(j + 1, k - 1))\\n            memo[(i, k)] = largest\\n            return largest\\n        \\n        return dfs(0, k)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        def dfs(i, k, memo={}):\\n            if i != len(nums) and k == 0:\\n                return float(\\'-inf\\')\\n            if i == len(nums):\\n                return 0\\n            if (i, k) in memo:\\n                return memo[(i, k)]\\n            largest = 0\\n            total = 0\\n            for j in range(i, len(nums)):\\n                total += nums[j]\\n                largest = max(largest, (total / (j - i + 1)) + dfs(j + 1, k - 1))\\n            memo[(i, k)] = largest\\n            return largest\\n        \\n        return dfs(0, k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507024,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int [] sums;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        sums=new int[nums.length+1];\\n        for (int i=1;i<nums.length+1;i++) \\n            sums[i]= sums[i-1] + nums[i-1];\\n        return largestSumOfAverages(nums,k,0,nums.length,new HashMap<>());\\n    }\\n\\n\\n    public double largestSumOfAverages(int[] nums, int k, int start, int end ,Map<Integer,Double> mamo) {  \\n        if (mamo.containsKey(start*101*101+end*101+k)) return mamo.get(start*101*101+end*101+k);\\n\\n        if (k==1) {\\n            mamo.put(start*101*101+end*101+k,(double)(sums[end] -sums[start])/(end-start));\\n            return mamo.get(start*101*101+end*101+k);\\n        }\\n\\n        if (k==end-start){\\n            mamo.put(start*101*101+end*101+k,(double)(sums[end] -sums[start]));\\n            return mamo.get(start*101*101+end*101+k);\\n        }\\n\\n        double max= 0;\\n        for (int i=start+1; k-1 <= end-i; i++){\\n            double till = largestSumOfAverages(nums,1,start,i,mamo);\\n            double after =  largestSumOfAverages(nums,k-1,i,end,mamo);\\n            max = Math.max(max,till+after);\\n        }\\n\\n        mamo.put(start*101*101+end*101+k,max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int [] sums;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        sums=new int[nums.length+1];\\n        for (int i=1;i<nums.length+1;i++) \\n            sums[i]= sums[i-1] + nums[i-1];\\n        return largestSumOfAverages(nums,k,0,nums.length,new HashMap<>());\\n    }\\n\\n\\n    public double largestSumOfAverages(int[] nums, int k, int start, int end ,Map<Integer,Double> mamo) {  \\n        if (mamo.containsKey(start*101*101+end*101+k)) return mamo.get(start*101*101+end*101+k);\\n\\n        if (k==1) {\\n            mamo.put(start*101*101+end*101+k,(double)(sums[end] -sums[start])/(end-start));\\n            return mamo.get(start*101*101+end*101+k);\\n        }\\n\\n        if (k==end-start){\\n            mamo.put(start*101*101+end*101+k,(double)(sums[end] -sums[start]));\\n            return mamo.get(start*101*101+end*101+k);\\n        }\\n\\n        double max= 0;\\n        for (int i=start+1; k-1 <= end-i; i++){\\n            double till = largestSumOfAverages(nums,1,start,i,mamo);\\n            double after =  largestSumOfAverages(nums,k-1,i,end,mamo);\\n            max = Math.max(max,till+after);\\n        }\\n\\n        mamo.put(start*101*101+end*101+k,max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502326,
                "title": "c-dynamic-programming",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*k)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n\\n    double solve(vector<int>& nums, int j, int k) {\\n        if (j >= nums.size()) return 0;\\n        if (dp[j][k] != -1) return dp[j][k];\\n        if (k == 1) {\\n            double sum = 0;\\n            for (int i = j; i < nums.size(); ++ i) sum += nums[i];\\n            dp[j][k] = sum / (nums.size() - j);\\n            return dp[j][k];\\n        }\\n        double res = 0, sum = 0;\\n        for (int i = j; i < nums.size(); ++ i) {\\n            sum += nums[i];\\n            res = max(res, sum / (i - j + 1) + solve(nums, i + 1, k - 1));\\n        }\\n        dp[j][k] = res;\\n        return res;\\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        for (int i = 0; i < 101; ++ i) {\\n            for (int j = 0; j < 101; ++ j) dp[i][j] = -1.0;\\n        }\\n        return solve(nums, 0, k);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n\\n    double solve(vector<int>& nums, int j, int k) {\\n        if (j >= nums.size()) return 0;\\n        if (dp[j][k] != -1) return dp[j][k];\\n        if (k == 1) {\\n            double sum = 0;\\n            for (int i = j; i < nums.size(); ++ i) sum += nums[i];\\n            dp[j][k] = sum / (nums.size() - j);\\n            return dp[j][k];\\n        }\\n        double res = 0, sum = 0;\\n        for (int i = j; i < nums.size(); ++ i) {\\n            sum += nums[i];\\n            res = max(res, sum / (i - j + 1) + solve(nums, i + 1, k - 1));\\n        }\\n        dp[j][k] = res;\\n        return res;\\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        for (int i = 0; i < 101; ++ i) {\\n            for (int j = 0; j < 101; ++ j) dp[i][j] = -1.0;\\n        }\\n        return solve(nums, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489798,
                "title": "dp-memoization-easy-approach-python-3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        return self.sabseBadaJodd(nums,k,0,{})\\n\\n    def sabseBadaJodd(self,nums,k,ind,dp):\\n        n = len(nums)\\n        if ind!=n and  k==0:\\n            return -1e9\\n        \\n        if ind==n :\\n            return 0\\n\\n        if (ind,k) in dp:\\n            return dp[(ind,k)]\\n\\n        sumi = 0\\n        ans=0\\n        count=0\\n        for i in range(ind,n):\\n            count+=1\\n            sumi+=nums[i]\\n            ans= max(ans,sumi/count+self.sabseBadaJodd(nums,k-1,i+1,dp))\\n            dp[(ind,k)] = ans\\n                \\n        return dp[(ind,k)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        return self.sabseBadaJodd(nums,k,0,{})\\n\\n    def sabseBadaJodd(self,nums,k,ind,dp):\\n        n = len(nums)\\n        if ind!=n and  k==0:\\n            return -1e9\\n        \\n        if ind==n :\\n            return 0\\n\\n        if (ind,k) in dp:\\n            return dp[(ind,k)]\\n\\n        sumi = 0\\n        ans=0\\n        count=0\\n        for i in range(ind,n):\\n            count+=1\\n            sumi+=nums[i]\\n            ans= max(ans,sumi/count+self.sabseBadaJodd(nums,k-1,i+1,dp))\\n            dp[(ind,k)] = ans\\n                \\n        return dp[(ind,k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461201,
                "title": "javascript-iterative-dynamic-programming-o-k-n-n",
                "content": "# Complexity\\n- Time complexity: $$O(k*n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar largestSumOfAverages = function(nums, k) {\\n    const n = nums.length, prefixSum = [nums[0]];\\n    let prev = [nums[0]];\\n\\n    for (let i = 1; i < n;)\\n        prefixSum.push(prefixSum.at(-1) + nums[i]),\\n        prev.push(prefixSum.at(-1) / ++i);\\n\\n    for (let i = 2; i <= k; i++) {\\n        const cur = [...prev];\\n\\n        for (let j = 0; j < n; j++)\\n            for (let l = 0; l < j; l++)\\n                cur[j] = Math.max(cur[j],\\n                    prev[l] + (prefixSum[j] - prefixSum[l]) / (j - l));\\n\\n        prev = cur;\\n    }\\n\\n    return prev[n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar largestSumOfAverages = function(nums, k) {\\n    const n = nums.length, prefixSum = [nums[0]];\\n    let prev = [nums[0]];\\n\\n    for (let i = 1; i < n;)\\n        prefixSum.push(prefixSum.at(-1) + nums[i]),\\n        prev.push(prefixSum.at(-1) / ++i);\\n\\n    for (let i = 2; i <= k; i++) {\\n        const cur = [...prev];\\n\\n        for (let j = 0; j < n; j++)\\n            for (let l = 0; l < j; l++)\\n                cur[j] = Math.max(cur[j],\\n                    prev[l] + (prefixSum[j] - prefixSum[l]) / (j - l));\\n\\n        prev = cur;\\n    }\\n\\n    return prev[n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419269,
                "title": "c-dp-recursion-memoization",
                "content": "# Intuition\\nWe can do at most k-1 partitions. Hence we use a dynamic programming approach and check for maximum score by doing partition at each point.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double solve(int idx,vector<int>& pref,int k,vector<vector<double>> &dp)\\n    {\\n        int n = pref.size();\\n        if(idx==n)\\n        return 0;\\n        if(k==0)\\n        return ((double)(pref[n-1]-pref[idx-1]))/(n-idx);\\n        \\n        if(dp[idx][k]!=-1)\\n        return dp[idx][k];\\n        double ans = 0;\\n        double sum = 0;\\n        for(int i=idx;i<n;i++)\\n        {\\n            if(idx>0)\\n            {\\n                sum = ((double)pref[i]-pref[idx-1])/(i-idx+1);\\n            }\\n            else\\n            sum = ((double)pref[i])/(i+1);\\n            ans = max(ans,sum+solve(i+1,pref,k-1,dp));\\n        }\\n        \\n        return dp[idx][k] = ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>> dp(nums.size()+1,vector<double>(k+1,-1));\\n        int n = nums.size();\\n        vector<int> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i] = pref[i-1]+nums[i];\\n        }\\n        if(k==1)\\n        {\\n            return ((double)pref[n-1])/(n);\\n        }\\n        return solve(0,pref,k-1,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double solve(int idx,vector<int>& pref,int k,vector<vector<double>> &dp)\\n    {\\n        int n = pref.size();\\n        if(idx==n)\\n        return 0;\\n        if(k==0)\\n        return ((double)(pref[n-1]-pref[idx-1]))/(n-idx);\\n        \\n        if(dp[idx][k]!=-1)\\n        return dp[idx][k];\\n        double ans = 0;\\n        double sum = 0;\\n        for(int i=idx;i<n;i++)\\n        {\\n            if(idx>0)\\n            {\\n                sum = ((double)pref[i]-pref[idx-1])/(i-idx+1);\\n            }\\n            else\\n            sum = ((double)pref[i])/(i+1);\\n            ans = max(ans,sum+solve(i+1,pref,k-1,dp));\\n        }\\n        \\n        return dp[idx][k] = ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>> dp(nums.size()+1,vector<double>(k+1,-1));\\n        int n = nums.size();\\n        vector<int> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i] = pref[i-1]+nums[i];\\n        }\\n        if(k==1)\\n        {\\n            return ((double)pref[n-1])/(n);\\n        }\\n        return solve(0,pref,k-1,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401550,
                "title": "swift-dp-top-down",
                "content": "# Code\\n```\\nclass Solution {\\n    func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double {\\n        \\n        var memo: [[Double]] = Array(\\n            repeating: Array(repeating: -1.0, count: k + 1), \\n            count: nums.count\\n        )\\n\\n        func partition(_ index: Int, _ k: Int) -> Double {\\n            if index >= nums.count { return 0.0 }\\n            if k == 0 { return -1000000000.0 }\\n\\n            if memo[index][k] != -1.0 {\\n                return memo[index][k]\\n            }\\n\\n            var sum = 0\\n            memo[index][k] = 0.0\\n            for i in index..<nums.count {\\n                sum += nums[i]\\n                memo[index][k] = max(\\n                    memo[index][k],\\n                    partition(i + 1, k - 1) + (Double(sum) / Double(i - index + 1))\\n                )\\n            }\\n\\n            return memo[index][k]\\n        }\\n\\n        return partition(0, k)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double {\\n        \\n        var memo: [[Double]] = Array(\\n            repeating: Array(repeating: -1.0, count: k + 1), \\n            count: nums.count\\n        )\\n\\n        func partition(_ index: Int, _ k: Int) -> Double {\\n            if index >= nums.count { return 0.0 }\\n            if k == 0 { return -1000000000.0 }\\n\\n            if memo[index][k] != -1.0 {\\n                return memo[index][k]\\n            }\\n\\n            var sum = 0\\n            memo[index][k] = 0.0\\n            for i in index..<nums.count {\\n                sum += nums[i]\\n                memo[index][k] = max(\\n                    memo[index][k],\\n                    partition(i + 1, k - 1) + (Double(sum) / Double(i - index + 1))\\n                )\\n            }\\n\\n            return memo[index][k]\\n        }\\n\\n        return partition(0, k)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378956,
                "title": "easiest-solution-by-aayush-sharma",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force- i will take the k-1 maximum elements and the remaining elements sum/divide by remaining elements ,i mean\\nsuppose arr={9,1,2,3,9} k=3 so the maximum elements=k-1=2\\ntherefore maximum elements are=9,9 so their 9/1=9,9/1=0,so till\\nnow sum=18,now remaining elements={1,2,3} so find their average,\\ni.e (1+2+3)/3=2 so maximum sum=18+2=20 ,but this is not good approach it can takes lot of time to run,for better approach we can think about  greedy but then i see the constraints ,since so i can use recursive approach and then can memoise it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp approach:\\nsuppose ={9,1,2,3,9} i try to make cuts,and try to maximise the result,i make cut and check for remaining array.\\n\\nsum-contain the sum till the ith index,\\nsuppose sum/length length=elements that your cut have\\nand now recusively check for remaining ,since you make cut so value of k reduces,and now u move forward to check for remaining elements.\\nThat\\'s the simple apporach first i write recursive code,then i memoise it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[105][105];\\n    double helper(vector<int>&nums,int cur,int k){\\n        if(cur>=nums.size() || k<0)return 0; \\n        //cuts must be less than size(meansoutof bound ni jana chaiye)\\n        //  and k should be greater than 0 hona chaiye\\n        if(k==0)return INT_MIN;  //means i use all the cuts\\n\\n        if(dp[cur][k]!=0)return dp[cur][k];\\n        double ans=0;\\n        double sum=0;\\n        for(int i=cur;i<nums.size();i++){\\n            sum+=nums[i]; \\n            //sum=sum till the ith point\\n\\n            ans=max(ans,sum/(i-cur+1)+helper(nums,i+1,k-1));\\n\\n            //in above line i try to maximise the result,\\n//so if i make the cut,then sum/total length \\n            // if i make the cut then total cuts reduces by 1 i.e k-1\\n            // and also i make the cut so,i move forward i.e i+1\\n        }\\n        return dp[cur][k]=ans;//here we return the maximum answer\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n      memset(dp,0,sizeof(dp));\\n      return helper(nums,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[105][105];\\n    double helper(vector<int>&nums,int cur,int k){\\n        if(cur>=nums.size() || k<0)return 0; \\n        //cuts must be less than size(meansoutof bound ni jana chaiye)\\n        //  and k should be greater than 0 hona chaiye\\n        if(k==0)return INT_MIN;  //means i use all the cuts\\n\\n        if(dp[cur][k]!=0)return dp[cur][k];\\n        double ans=0;\\n        double sum=0;\\n        for(int i=cur;i<nums.size();i++){\\n            sum+=nums[i]; \\n            //sum=sum till the ith point\\n\\n            ans=max(ans,sum/(i-cur+1)+helper(nums,i+1,k-1));\\n\\n            //in above line i try to maximise the result,\\n//so if i make the cut,then sum/total length \\n            // if i make the cut then total cuts reduces by 1 i.e k-1\\n            // and also i make the cut so,i move forward i.e i+1\\n        }\\n        return dp[cur][k]=ans;//here we return the maximum answer\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n      memset(dp,0,sizeof(dp));\\n      return helper(nums,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374497,
                "title": "easy-c-memoization",
                "content": "# Intuition\\nSimple memoization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfind max of all temp answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: beat : 87%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:beat : 80%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double solve(int ind, int k,vector<int>& nums,int n,vector<vector<double>>&dp){\\n        if(ind == n)return 0; //base case\\n\\n        if(k==0){ //base case\\n            return INT_MIN;\\n        }\\n\\n        if(dp[ind][k]!=-1)return dp[ind][k]; // memoization\\n\\n        double ans = 0;\\n        double sum = 0;\\n        // find max of all possible ans\\n        for(int i = ind;i<n;i++){\\n               sum+= nums[i];\\n               double temp = (sum / (i-ind+1)) + solve(i+1,k-1,nums,n,dp); //temp ans\\n               ans = max(ans,temp); //ans\\n        }\\n\\n        return dp[ind][k] = ans;\\n    \\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<double>>dp(n+1,vector<double>(k+1,-1));\\n\\n        return solve(0,k,nums,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double solve(int ind, int k,vector<int>& nums,int n,vector<vector<double>>&dp){\\n        if(ind == n)return 0; //base case\\n\\n        if(k==0){ //base case\\n            return INT_MIN;\\n        }\\n\\n        if(dp[ind][k]!=-1)return dp[ind][k]; // memoization\\n\\n        double ans = 0;\\n        double sum = 0;\\n        // find max of all possible ans\\n        for(int i = ind;i<n;i++){\\n               sum+= nums[i];\\n               double temp = (sum / (i-ind+1)) + solve(i+1,k-1,nums,n,dp); //temp ans\\n               ans = max(ans,temp); //ans\\n        }\\n\\n        return dp[ind][k] = ans;\\n    \\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<double>>dp(n+1,vector<double>(k+1,-1));\\n\\n        return solve(0,k,nums,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356381,
                "title": "dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double solve(vector<int>&v,int index,int k,vector<vector<double>>&dp){\\n        if(index==v.size() || k==0)return 0;\\n        double sum=0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        if(k==1){\\n            for(int i=index;i<v.size();i++)\\n            sum+=v[i];\\n            return dp[index][k]=(sum/(v.size()-index));\\n        }\\n        sum=0;\\n        double res=0;\\n        double counter=0;\\n        for(int i=index;i<v.size();i++){\\n         sum+=v[i];\\n         counter++;\\n         double ans=solve(v,i+1,k-1,dp)+(sum/(counter));\\n         res=max(res,ans);\\n        }\\n        return dp[index][k]=res;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>>dp(nums.size(),vector<double>(k+1,-1));\\n        return solve(nums,0,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double solve(vector<int>&v,int index,int k,vector<vector<double>>&dp){\\n        if(index==v.size() || k==0)return 0;\\n        double sum=0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        if(k==1){\\n            for(int i=index;i<v.size();i++)\\n            sum+=v[i];\\n            return dp[index][k]=(sum/(v.size()-index));\\n        }\\n        sum=0;\\n        double res=0;\\n        double counter=0;\\n        for(int i=index;i<v.size();i++){\\n         sum+=v[i];\\n         counter++;\\n         double ans=solve(v,i+1,k-1,dp)+(sum/(counter));\\n         res=max(res,ans);\\n        }\\n        return dp[index][k]=res;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<double>>dp(nums.size(),vector<double>(k+1,-1));\\n        return solve(nums,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349092,
                "title": "python-dp-with-intuition-o-kn-2-time-and-o-n-2-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI spent some time trying to figure out exactly what my dp array should represent. Settled on using a 2d array where dp[i][j] represented the largest sum of averages for nums[0:i+1] using (j - 1) partitions.\\n\\nI use a prefix sum array for O(1) queries later.\\n\\nAfter that, I figured out the base cases; filling in the first row and column, which is trivial. Using 1 partition, it\\'s just the prefix array divided by the number of elements upto that point. And using only the first element, regardless of the number of partitions its just that value. (technically not possible given the constraints)\\n\\nFinally, figure out the recurrence relation.\\n\\nTo find dp[i][j] = \\n\\nIf you\\'re incrementing k by 1, then you just need to find all possible answers using less than i elements and using exactly k - 1 partitions. You can add the new partition average you are about to create given the chosen i, to that dp value which should\\'ve already been tabulated and find the max across these possible i\\'s.\\n\\nTo help visualize the use of memoized results here\\'s a random table:\\nThe circled value uses all the values along the arrow.\\n\\n![image.png](https://assets.leetcode.com/users/images/2ed486dd-3458-4f0d-957c-82a26994c820_1679943584.432434.png)\\n\\nYou might notice we don\\'t use the ith value with k - 1 partitions. This is because each partition needs to be non-empty, meaning I can at most make only i - 1 elements with k - 1 partitions.\\n\\n# Complexity\\n- Time complexity: $$O(kn^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\nNote: I have seen another solution using just O(n) space.\\n# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        pref = list(accumulate(nums))\\n        n = len(nums)\\n        dp = [[float(\\'-inf\\')] * k for _ in range(n)]\\n\\n        for i in range(n):\\n            dp[i][0] = pref[i] / (i + 1)\\n        for i in range(k):\\n            dp[0][i] = pref[0]\\n\\n        for i in range(1, n):\\n            for j in range(1, k):\\n                for x in range(0, i):\\n                    p_avg = (pref[i] - pref[x]) / (i - x)\\n                    dp[i][j] = max(dp[i][j], dp[x][j - 1] + p_avg)\\n\\n        return dp[n - 1][k - 1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        pref = list(accumulate(nums))\\n        n = len(nums)\\n        dp = [[float(\\'-inf\\')] * k for _ in range(n)]\\n\\n        for i in range(n):\\n            dp[i][0] = pref[i] / (i + 1)\\n        for i in range(k):\\n            dp[0][i] = pref[0]\\n\\n        for i in range(1, n):\\n            for j in range(1, k):\\n                for x in range(0, i):\\n                    p_avg = (pref[i] - pref[x]) / (i - x)\\n                    dp[i][j] = max(dp[i][j], dp[x][j - 1] + p_avg)\\n\\n        return dp[n - 1][k - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284967,
                "title": "c-dp-table-solution-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        for(int i=1;i<nums.size();i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        vector<vector<double>> dp_1(nums.size(),vector<double>(nums.size(),0));\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                dp_1[i][j]=nums[j]-((i!=0)?nums[i-1]:0);\\n                dp_1[i][j]/=(j-i+1);\\n            }\\n        }\\n        vector<vector<double>> dp(k,vector<double>(nums.size(),0));\\n        for(int i=0;i<nums.size();i++){\\n            dp[0][i]=dp_1[i][nums.size()-1];\\n        }\\n        double ans=dp[0][0];\\n        for(int i=1;i<k;i++){\\n            for(int j=nums.size()-i-1;j>=0;j--){\\n                int t=j+1;\\n                double res=0;\\n                while(nums.size()-t>=i){\\n                    res=max(res,dp_1[j][t-1]+dp[i-1][t]);\\n                    t++;\\n                }\\n                dp[i][j]=res;\\n            }\\n            ans=max(ans,dp[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        for(int i=1;i<nums.size();i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        vector<vector<double>> dp_1(nums.size(),vector<double>(nums.size(),0));\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                dp_1[i][j]=nums[j]-((i!=0)?nums[i-1]:0);\\n                dp_1[i][j]/=(j-i+1);\\n            }\\n        }\\n        vector<vector<double>> dp(k,vector<double>(nums.size(),0));\\n        for(int i=0;i<nums.size();i++){\\n            dp[0][i]=dp_1[i][nums.size()-1];\\n        }\\n        double ans=dp[0][0];\\n        for(int i=1;i<k;i++){\\n            for(int j=nums.size()-i-1;j>=0;j--){\\n                int t=j+1;\\n                double res=0;\\n                while(nums.size()-t>=i){\\n                    res=max(res,dp_1[j][t-1]+dp[i-1][t]);\\n                    t++;\\n                }\\n                dp[i][j]=res;\\n            }\\n            ans=max(ans,dp[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280261,
                "title": "python-using-dp-bottom-up",
                "content": "Here is my solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        length = len(nums)\\n        cache = [[0 for i in range(k + 1)] for i in range(length + 1)]\\n        sum = 0\\n\\n        for x in range(length - 1, -1, -1):\\n            sum += nums[x]\\n            cache[x][1] = sum / (length - x)\\n\\n        for x in range(length - 1, -1, -1):\\n            for y in range(2, k + 1):\\n                sum = 0\\n\\n                for z in range(x, length):\\n                    sum += nums[z]\\n                    average = sum / (z - x + 1)\\n                    cache[x][y] = max(cache[x][y], average + cache[z + 1][y - 1])\\n\\n        return cache[0][k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        length = len(nums)\\n        cache = [[0 for i in range(k + 1)] for i in range(length + 1)]\\n        sum = 0\\n\\n        for x in range(length - 1, -1, -1):\\n            sum += nums[x]\\n            cache[x][1] = sum / (length - x)\\n\\n        for x in range(length - 1, -1, -1):\\n            for y in range(2, k + 1):\\n                sum = 0\\n\\n                for z in range(x, length):\\n                    sum += nums[z]\\n                    average = sum / (z - x + 1)\\n                    cache[x][y] = max(cache[x][y], average + cache[z + 1][y - 1])\\n\\n        return cache[0][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231596,
                "title": "my-java-solution-using-prefix-sum-and-recursion-80-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst i have created the prefix array and then use the prefix arr to calculate avg at each idx and then used memoization at each idx to make it efficient.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        \\n        int[] psum = new int[nums.length];\\n        psum[0] = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            psum[i] = psum[i - 1] + nums[i];\\n        }\\n        return largeSum(0, psum, k, new Double[nums.length][k + 1]);\\n    }\\n\\n    public double largeSum(int idx, int[] psum, int k, Double[][] cache){\\n        if(idx == psum.length){\\n            return Double.MIN_VALUE;\\n        }\\n        if(cache[idx][k] != null){\\n            return cache[idx][k];\\n        }\\n        if(k == 1){\\n            double sum = psum[psum.length - 1] - (idx > 0 ? psum[idx - 1] : 0);\\n            return (double) sum / (double)(psum.length - idx);\\n        }\\n\\n        double max = Double.MIN_VALUE;\\n        for(int i = idx; i < psum.length; i++){\\n            double current = psum[i] - (idx > 0 ? psum[idx - 1] : 0);\\n            current = (double) current / (double)(i - idx + 1);\\n            max = Math.max(max, current + largeSum(i + 1, psum, k - 1, cache));\\n        }\\n        cache[idx][k] = max;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        \\n        int[] psum = new int[nums.length];\\n        psum[0] = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            psum[i] = psum[i - 1] + nums[i];\\n        }\\n        return largeSum(0, psum, k, new Double[nums.length][k + 1]);\\n    }\\n\\n    public double largeSum(int idx, int[] psum, int k, Double[][] cache){\\n        if(idx == psum.length){\\n            return Double.MIN_VALUE;\\n        }\\n        if(cache[idx][k] != null){\\n            return cache[idx][k];\\n        }\\n        if(k == 1){\\n            double sum = psum[psum.length - 1] - (idx > 0 ? psum[idx - 1] : 0);\\n            return (double) sum / (double)(psum.length - idx);\\n        }\\n\\n        double max = Double.MIN_VALUE;\\n        for(int i = idx; i < psum.length; i++){\\n            double current = psum[i] - (idx > 0 ? psum[idx - 1] : 0);\\n            current = (double) current / (double)(i - idx + 1);\\n            max = Math.max(max, current + largeSum(i + 1, psum, k - 1, cache));\\n        }\\n        cache[idx][k] = max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219813,
                "title": "python-super-easy-dp-top-down-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\n        pre = nums\\n        for i in range(1, len(pre)):\\n            pre[i] += pre[i-1]\\n\\n        @functools.lru_cache(None)\\n        def dp(i, n):\\n            if n == 0 and i != len(pre):\\n                return float(\"-inf\")\\n            if i == len(pre):\\n                return 0\\n            ans = float(\"-inf\")\\n            for j in range(i, len(pre)):\\n                if n == k:\\n                    ans = max(ans, pre[j]/(j-i+1) + dp(j+1, n-1))\\n                else:\\n                    ans = max(ans, (pre[j] - pre[i-1])/(j-i+1) + dp(j+1, n-1))\\n            return ans\\n        \\n        return dp(0, k)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\n        pre = nums\\n        for i in range(1, len(pre)):\\n            pre[i] += pre[i-1]\\n\\n        @functools.lru_cache(None)\\n        def dp(i, n):\\n            if n == 0 and i != len(pre):\\n                return float(\"-inf\")\\n            if i == len(pre):\\n                return 0\\n            ans = float(\"-inf\")\\n            for j in range(i, len(pre)):\\n                if n == k:\\n                    ans = max(ans, pre[j]/(j-i+1) + dp(j+1, n-1))\\n                else:\\n                    ans = max(ans, (pre[j] - pre[i-1])/(j-i+1) + dp(j+1, n-1))\\n            return ans\\n        \\n        return dp(0, k)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216339,
                "title": "java-dp-prefixsum-easy-understaning",
                "content": "```\\nclass Solution {\\n    \\n    double max = Double.MIN_VALUE;\\n    \\n    public double largestSumOfAverages(int[] nums, int k) {\\n    \\n        //we will solve this problem by cuts problem\\n        //we will try to cut array in each postion\\n        \\n        double[] sumArr = new double[nums.length];\\n        sumArr[0] = 0.0 + nums[0];\\n       \\n        for(int i = 1 ;  i < nums.length ; i++){\\n        \\n            //creating prefix sum array\\n            sumArr[i]  = nums[i] + sumArr[i-1];\\n             //System.out.println(sumArr[i]);\\n        }\\n        double[][] dp = new double[nums.length][k+1];\\n        for(double[] dpArr : dp){\\n            Arrays.fill(dpArr,-1.00);\\n        }\\n        \\n        return helper(0,sumArr,k,dp);\\n    \\n    }\\n    \\n    \\n    public double helper(int start,double[] sumArr,int k,double[][] dp){\\n    \\n        if(k == 1){\\n            if(start == 0 ){\\n                return (double)(sumArr[sumArr.length - 1])/sumArr.length;\\n            }\\n            //reached the base condition\\n             return (double)(sumArr[sumArr.length - 1] - sumArr[start-1])/( sumArr.length - 1 - start + 1) ;\\n\\n        }\\n        \\n         if(dp[start][k] != -1.00){\\n          \\n             return dp[start][k];\\n        \\n         }\\n         double res = 0.0;\\n        for(int i = start; i < sumArr.length ; i++){\\n            //get the sumfrom start to i\\n\\n            double ans = 0.0;\\n            if(start == 0){\\n                ans = (double)sumArr[i]/(i+1);\\n            }else{\\n                ans = (double)(sumArr[i] - sumArr[start-1])/(i - start + 1) ;\\n            }\\n            if(i+1<sumArr.length && k>1){\\n                double val = (double)ans + helper(i+1,sumArr,k-1,dp);\\n                res = Math.max(res,val);\\n            }\\n            \\n        }\\n        \\n        return dp[start][k] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    double max = Double.MIN_VALUE;\\n    \\n    public double largestSumOfAverages(int[] nums, int k) {\\n    \\n        //we will solve this problem by cuts problem\\n        //we will try to cut array in each postion\\n        \\n        double[] sumArr = new double[nums.length];\\n        sumArr[0] = 0.0 + nums[0];\\n       \\n        for(int i = 1 ;  i < nums.length ; i++){\\n        \\n            //creating prefix sum array\\n            sumArr[i]  = nums[i] + sumArr[i-1];\\n             //System.out.println(sumArr[i]);\\n        }\\n        double[][] dp = new double[nums.length][k+1];\\n        for(double[] dpArr : dp){\\n            Arrays.fill(dpArr,-1.00);\\n        }\\n        \\n        return helper(0,sumArr,k,dp);\\n    \\n    }\\n    \\n    \\n    public double helper(int start,double[] sumArr,int k,double[][] dp){\\n    \\n        if(k == 1){\\n            if(start == 0 ){\\n                return (double)(sumArr[sumArr.length - 1])/sumArr.length;\\n            }\\n            //reached the base condition\\n             return (double)(sumArr[sumArr.length - 1] - sumArr[start-1])/( sumArr.length - 1 - start + 1) ;\\n\\n        }\\n        \\n         if(dp[start][k] != -1.00){\\n          \\n             return dp[start][k];\\n        \\n         }\\n         double res = 0.0;\\n        for(int i = start; i < sumArr.length ; i++){\\n            //get the sumfrom start to i\\n\\n            double ans = 0.0;\\n            if(start == 0){\\n                ans = (double)sumArr[i]/(i+1);\\n            }else{\\n                ans = (double)(sumArr[i] - sumArr[start-1])/(i - start + 1) ;\\n            }\\n            if(i+1<sumArr.length && k>1){\\n                double val = (double)ans + helper(i+1,sumArr,k-1,dp);\\n                res = Math.max(res,val);\\n            }\\n            \\n        }\\n        \\n        return dp[start][k] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215601,
                "title": "memoization-tabulation-dp-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    double dfs(int i, int n, int k, vector<int> &nums, vector<vector<double>> &dp) {\\n        if(i == n) return 0;\\n        if(!k) {\\n            double sum = 0;\\n            for(int j=i; j<n; j++) sum += nums[j];\\n            return sum / (n - i);\\n        }\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        double sum = 0, ans = 0;\\n        for(int j=i; j<n; j++) {\\n            sum += nums[j];\\n            double cut = (sum) / (j - i + 1) + dfs(j + 1, n, k - 1, nums, dp);\\n            ans = max(ans, cut);\\n        }\\n        return dp[i][k] = ans;\\n    }\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<double>> dp(n, vector<double>(k, -1));\\n        return dfs(0, n, k - 1, nums, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int K) {\\n        int n = nums.size();\\n        vector<vector<double>> dp(n + 1, vector<double>(K + 1));\\n    \\n        double s = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            s += nums[i];\\n            dp[i][0] = s / (n - i);\\n        }\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int k=1; k<=K-1; k++) {\\n                double sum = 0, ans = 0;\\n                for(int j=i; j<n; j++) {\\n                    sum += nums[j];\\n                    double cut = (sum) / (j - i + 1) + dp[j + 1][k - 1];\\n                    ans = max(ans, cut);\\n                }\\n                dp[i][k] = ans;\\n            }\\n        }\\n        return dp[0][K - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    double dfs(int i, int n, int k, vector<int> &nums, vector<vector<double>> &dp) {\\n        if(i == n) return 0;\\n        if(!k) {\\n            double sum = 0;\\n            for(int j=i; j<n; j++) sum += nums[j];\\n            return sum / (n - i);\\n        }\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        double sum = 0, ans = 0;\\n        for(int j=i; j<n; j++) {\\n            sum += nums[j];\\n            double cut = (sum) / (j - i + 1) + dfs(j + 1, n, k - 1, nums, dp);\\n            ans = max(ans, cut);\\n        }\\n        return dp[i][k] = ans;\\n    }\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<double>> dp(n, vector<double>(k, -1));\\n        return dfs(0, n, k - 1, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int K) {\\n        int n = nums.size();\\n        vector<vector<double>> dp(n + 1, vector<double>(K + 1));\\n    \\n        double s = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            s += nums[i];\\n            dp[i][0] = s / (n - i);\\n        }\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int k=1; k<=K-1; k++) {\\n                double sum = 0, ans = 0;\\n                for(int j=i; j<n; j++) {\\n                    sum += nums[j];\\n                    double cut = (sum) / (j - i + 1) + dp[j + 1][k - 1];\\n                    ans = max(ans, cut);\\n                }\\n                dp[i][k] = ans;\\n            }\\n        }\\n        return dp[0][K - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192319,
                "title": "easy-c-solution-using-dp",
                "content": "# Approach\\n.At every index, we have two choices, either to include that index in the previous subarray , or to start a new subarray from that index.\\n.f(ind, k)-> It return the maximum sum of averages till the index ind , if we are allowed to do K operations.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   double f(int ind, int k, vector<vector<double>> &dp, vector<int> &nums)\\n{\\n\\t// Out of Bound check.\\n\\tif (k <= 0)\\n\\t\\treturn 0;\\n\\t// If we have calculated it before then we simply need to return it.\\n\\tif (dp[ind][k] != -1)\\n\\t\\treturn dp[ind][k];\\n\\tdouble ans = 0, sum = 0;\\n\\tfor (int i = ind; i < nums.size(); ++i)\\n\\t{\\n\\t\\tsum += nums[i];\\n\\t\\tif (k != 1 || i == nums.size() - 1)\\n\\t\\t\\tans = max(ans, sum / (i - ind + 1) + f(i + 1, k - 1, dp, nums));\\n\\t}\\n\\treturn dp[ind][k] = ans;\\n}\\ndouble largestSumOfAverages(vector<int> &nums, int k)\\n{\\n\\tint n = nums.size();\\n\\tvector<vector<double>> dp(n + 1, vector<double>(k + 1, -1));\\n\\treturn f(0, k, dp, nums);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   double f(int ind, int k, vector<vector<double>> &dp, vector<int> &nums)\\n{\\n\\t// Out of Bound check.\\n\\tif (k <= 0)\\n\\t\\treturn 0;\\n\\t// If we have calculated it before then we simply need to return it.\\n\\tif (dp[ind][k] != -1)\\n\\t\\treturn dp[ind][k];\\n\\tdouble ans = 0, sum = 0;\\n\\tfor (int i = ind; i < nums.size(); ++i)\\n\\t{\\n\\t\\tsum += nums[i];\\n\\t\\tif (k != 1 || i == nums.size() - 1)\\n\\t\\t\\tans = max(ans, sum / (i - ind + 1) + f(i + 1, k - 1, dp, nums));\\n\\t}\\n\\treturn dp[ind][k] = ans;\\n}\\ndouble largestSumOfAverages(vector<int> &nums, int k)\\n{\\n\\tint n = nums.size();\\n\\tvector<vector<double>> dp(n + 1, vector<double>(k + 1, -1));\\n\\treturn f(0, k, dp, nums);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188550,
                "title": "python-dp-bottom-up-solution",
                "content": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        dp = [[0 for i in range(n)] for j in range(k)]\\n        count = 0\\n        total = 0\\n        for i in range(n):\\n            count += nums[i]\\n            total += 1\\n            dp[0][i] = count/total\\n            \\n        for i in range(1,k):\\n            for j in range(i,n):\\n                total = 0\\n                count = 0\\n                for m in range(j,n):\\n                    total += nums[m]\\n                    count += 1\\n                    dp[i][m] = max(dp[i-1][j-1] + total/count, dp[i][m])\\n        \\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        n = len(nums)\\n        dp = [[0 for i in range(n)] for j in range(k)]\\n        count = 0\\n        total = 0\\n        for i in range(n):\\n            count += nums[i]\\n            total += 1\\n            dp[0][i] = count/total\\n            \\n        for i in range(1,k):\\n            for j in range(i,n):\\n                total = 0\\n                count = 0\\n                for m in range(j,n):\\n                    total += nums[m]\\n                    count += 1\\n                    dp[i][m] = max(dp[i-1][j-1] + total/count, dp[i][m])\\n        \\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151797,
                "title": "dp-approach-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[105][105];\\n    double helper(vector< int>&nums, int curr, int k){\\n        if(curr>=nums.size() || k<0) return 0;\\n        if(k == 0) return INT_MIN;\\n\\n        if(dp[curr][k] !=0) return dp[curr][k];\\n\\n        double sum = 0;\\n        double ans = 0;\\n\\n        for(int i = curr; i<nums.size(); i++){\\n            sum +=nums[i];\\n            ans = max(ans, (sum/(i-curr+1) + helper(nums,i+1, k-1)));\\n        }\\n\\n        return dp[curr][k] = ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k){\\n        memset(dp,0,sizeof(dp));\\n        return helper(nums,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[105][105];\\n    double helper(vector< int>&nums, int curr, int k){\\n        if(curr>=nums.size() || k<0) return 0;\\n        if(k == 0) return INT_MIN;\\n\\n        if(dp[curr][k] !=0) return dp[curr][k];\\n\\n        double sum = 0;\\n        double ans = 0;\\n\\n        for(int i = curr; i<nums.size(); i++){\\n            sum +=nums[i];\\n            ans = max(ans, (sum/(i-curr+1) + helper(nums,i+1, k-1)));\\n        }\\n\\n        return dp[curr][k] = ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k){\\n        memset(dp,0,sizeof(dp));\\n        return helper(nums,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109531,
                "title": "java-solution-based-on-partition-dp-memoization-shortest-code-easy-to-understand",
                "content": "# Intuition\\nfor an array for length N, we have N-1 choices to perform partition\\nWe\\'ll recursive check for each partition. \\n\\n# Approach\\nThis is a problem of partition DP where we\\'ve to check for each partition.\\n\\'\\'\\'\\n    consider an example : arr=[9,1,2,3,9]\\n\\n            possible parittions are [9][1,2,3,9], [9,1][2,3,9], [9,1,2][3,9]\\n    Now we have subproblems:\\n\\n        we have to maximize the values of (averageTillPointer+solve(pointer+1));\\n\\n    so partition will something look like:\\n    for(int i=1;i<n;i++)\\n        sum+=arr[i];\\n        max=Math.max(sum/cnt+solve(i+1));\\n\\n            return max;\\n\\'\\'\\'\\n\\n# Complexity\\n- Time complexity:\\nO(n*k)\\n\\n- Space complexity:\\nO(n*k)\\n\\n# Code\\n```\\nclass Solution {\\n    double[][] dp;\\n    public double solve(int i,int[] nums,int k)\\n    {\\n        if(k<0) return Integer.MIN_VALUE/2;\\n        if(i==nums.length)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int n=nums.length;\\n        double max=Integer.MIN_VALUE/2;\\n        int sum=0;\\n        for(int st=i;st<n;st++)\\n        {\\n            sum+=nums[st];\\n                max=Math.max(max,(double)((1.0)*sum/(st-i+1)*1.0)+solve(st+1,nums,k-1));\\n        }\\n\\n            return dp[i][k]=max;\\n    }\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        dp=new double[nums.length+1][k+1];\\n\\n        for(int i=0;i<=nums.length;i++)\\n            Arrays.fill(dp[i],-1);\\n\\n        return solve(0,nums,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    double[][] dp;\\n    public double solve(int i,int[] nums,int k)\\n    {\\n        if(k<0) return Integer.MIN_VALUE/2;\\n        if(i==nums.length)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int n=nums.length;\\n        double max=Integer.MIN_VALUE/2;\\n        int sum=0;\\n        for(int st=i;st<n;st++)\\n        {\\n            sum+=nums[st];\\n                max=Math.max(max,(double)((1.0)*sum/(st-i+1)*1.0)+solve(st+1,nums,k-1));\\n        }\\n\\n            return dp[i][k]=max;\\n    }\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        dp=new double[nums.length+1][k+1];\\n\\n        for(int i=0;i<=nums.length;i++)\\n            Arrays.fill(dp[i],-1);\\n\\n        return solve(0,nums,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108073,
                "title": "c",
                "content": "```\\ndouble largestSumOfAverages(int* nums, int numsSize, int k){\\n    int n = numsSize ;\\n    double** dp = malloc((n + 1) * sizeof(double *) ) ;\\n    for(int i = 0; i <= n; i++){\\n        dp[i] = calloc((k+1) , sizeof(double) ) ;\\n        dp[i][0] = INT_MIN ;\\n    }\\n    dp[0][0] = 0 ;\\n    \\n    for(int i = 1; i <= n; i++){\\n        for(int j = 1; j <= fmin(i, k); j++){\\n            double sum = 0 ;\\n            for(int  m = i; m >= j; m--){\\n                sum += (double)nums[m-1] ;                \\n                dp[i][j] = fmax(dp[i][j], (double)dp[m-1][j-1] + (double)(sum)/(i-m+1)) ;\\n            }\\n        }\\n    }\\n    double ans = 0 ;\\n    for(int i = 1; i <= k; i++){\\n        ans = fmax(ans, dp[n][i] ) ;\\n    }\\n    for(int i = 0; i <= n; i++){\\n        free(dp[i]) ;\\n    }\\n    free(dp) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestSumOfAverages(int* nums, int numsSize, int k){\\n    int n = numsSize ;\\n    double** dp = malloc((n + 1) * sizeof(double *) ) ;\\n    for(int i = 0; i <= n; i++){\\n        dp[i] = calloc((k+1) , sizeof(double) ) ;\\n        dp[i][0] = INT_MIN ;\\n    }\\n    dp[0][0] = 0 ;\\n    \\n    for(int i = 1; i <= n; i++){\\n        for(int j = 1; j <= fmin(i, k); j++){\\n            double sum = 0 ;\\n            for(int  m = i; m >= j; m--){\\n                sum += (double)nums[m-1] ;                \\n                dp[i][j] = fmax(dp[i][j], (double)dp[m-1][j-1] + (double)(sum)/(i-m+1)) ;\\n            }\\n        }\\n    }\\n    double ans = 0 ;\\n    for(int i = 1; i <= k; i++){\\n        ans = fmax(ans, dp[n][i] ) ;\\n    }\\n    for(int i = 0; i <= n; i++){\\n        free(dp[i]) ;\\n    }\\n    free(dp) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106517,
                "title": "c-dp-solution-using-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    double helper(int n, vector<int>& prefixSum, int start, int k, vector<vector<double>>& dp) {\\n        \\n        // Base Case\\n        if(start >= n) {\\n            return 0.0;\\n        }\\n        \\n        // If k is 1 then the only subarray left would be from start to n.\\n        if(k == 1) {\\n            return double(prefixSum[n - 1] - prefixSum[start - 1])/(double(n - 1 - (start - 1)));\\n        }\\n        \\n        if(dp[start][k] != -1) {\\n            return dp[start][k];\\n        }\\n        \\n        // Recursive Case\\n        double ans = 0.0;\\n        \\n        // Make partition for every possible solution.\\n        for(int i = start; i < prefixSum.size(); i++) {\\n            \\n            // Calculate the subarray sum and the average.\\n            double currSum = prefixSum[i] - prefixSum[start - 1];\\n            currSum = currSum /  double(i - (start - 1));\\n            \\n            // Do a recursive call and find the maximum answer.\\n            ans = max(ans, currSum + helper(n, prefixSum, i + 1, k - 1, dp));\\n        }\\n        return dp[start][k] = ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<int>prefixSum;\\n        prefixSum.push_back(0);\\n        \\n        // Populate the prefixSum array.\\n        for(int i = 0; i < nums.size(); i++) {\\n            prefixSum.push_back(nums[i] + prefixSum.back());\\n        }\\n        vector<vector<double>>dp(nums.size() + 2, vector<double>(nums.size() + 2, -1));\\n        return helper(prefixSum.size(), prefixSum, 1, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double helper(int n, vector<int>& prefixSum, int start, int k, vector<vector<double>>& dp) {\\n        \\n        // Base Case\\n        if(start >= n) {\\n            return 0.0;\\n        }\\n        \\n        // If k is 1 then the only subarray left would be from start to n.\\n        if(k == 1) {\\n            return double(prefixSum[n - 1] - prefixSum[start - 1])/(double(n - 1 - (start - 1)));\\n        }\\n        \\n        if(dp[start][k] != -1) {\\n            return dp[start][k];\\n        }\\n        \\n        // Recursive Case\\n        double ans = 0.0;\\n        \\n        // Make partition for every possible solution.\\n        for(int i = start; i < prefixSum.size(); i++) {\\n            \\n            // Calculate the subarray sum and the average.\\n            double currSum = prefixSum[i] - prefixSum[start - 1];\\n            currSum = currSum /  double(i - (start - 1));\\n            \\n            // Do a recursive call and find the maximum answer.\\n            ans = max(ans, currSum + helper(n, prefixSum, i + 1, k - 1, dp));\\n        }\\n        return dp[start][k] = ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<int>prefixSum;\\n        prefixSum.push_back(0);\\n        \\n        // Populate the prefixSum array.\\n        for(int i = 0; i < nums.size(); i++) {\\n            prefixSum.push_back(nums[i] + prefixSum.back());\\n        }\\n        vector<vector<double>>dp(nums.size() + 2, vector<double>(nums.size() + 2, -1));\\n        return helper(prefixSum.size(), prefixSum, 1, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065380,
                "title": "c-dp-with-prefix-sum",
                "content": "# Intuition\\nWe precalculate prefix sum, then use a to-down dp to partition an array by k parts\\n\\n# Complexity\\n- Time complexity:\\nWithout DP it looks like O(2^K) but with DP I\\'m not sure how many unique paths I have, any suggestions?\\n\\n# Code\\n```\\npublic class Solution {\\n    private int[] _pref;\\n    private const double NO_VAL = double.MinValue / 2;\\n    public double LargestSumOfAverages(int[] nums, int k)\\n    {\\n        // compute prefix sum\\n        _pref = new int[nums.Length];\\n        _pref[0] = nums[0];\\n        for (int i = 1; i < nums.Length; i++)\\n            _pref[i] = _pref[i - 1] + nums[i];\\n\\n        return Partition(0, 0, k, new());\\n    }\\n\\n    private double GetSum(int l, int r) => l > r ? NO_VAL : _pref[r] - (l - 1 < 0 ? 0 : _pref[l - 1]);\\n\\n    public double Partition(int ind, int len, int k,Dictionary<int,double> dp)\\n    {\\n        var key = HashCode.Combine(ind, k, len);\\n        if (dp.ContainsKey(key)) return dp[key];\\n\\n        if (ind <= _pref.Length - 1 && k == 1) return (GetSum(ind - len, _pref.Length - 1) / (_pref.Length-(ind - len)));// cut last partition\\n        if (ind == _pref.Length) return NO_VAL;// no room left for last partition\\n\\n        // 2 choices, cut OR extend\\n\\n        // 1. we cut partition here\\n        var cut = Partition(ind + 1, 0, k - 1,dp)+ GetSum(ind - len, ind) / (len + 1);\\n        // 2. keep extending partition\\n        var extend = Partition(ind + 1, len + 1, k,dp);\\n\\n        return dp[key] = Math.Max(cut, extend);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] _pref;\\n    private const double NO_VAL = double.MinValue / 2;\\n    public double LargestSumOfAverages(int[] nums, int k)\\n    {\\n        // compute prefix sum\\n        _pref = new int[nums.Length];\\n        _pref[0] = nums[0];\\n        for (int i = 1; i < nums.Length; i++)\\n            _pref[i] = _pref[i - 1] + nums[i];\\n\\n        return Partition(0, 0, k, new());\\n    }\\n\\n    private double GetSum(int l, int r) => l > r ? NO_VAL : _pref[r] - (l - 1 < 0 ? 0 : _pref[l - 1]);\\n\\n    public double Partition(int ind, int len, int k,Dictionary<int,double> dp)\\n    {\\n        var key = HashCode.Combine(ind, k, len);\\n        if (dp.ContainsKey(key)) return dp[key];\\n\\n        if (ind <= _pref.Length - 1 && k == 1) return (GetSum(ind - len, _pref.Length - 1) / (_pref.Length-(ind - len)));// cut last partition\\n        if (ind == _pref.Length) return NO_VAL;// no room left for last partition\\n\\n        // 2 choices, cut OR extend\\n\\n        // 1. we cut partition here\\n        var cut = Partition(ind + 1, 0, k - 1,dp)+ GetSum(ind - len, ind) / (len + 1);\\n        // 2. keep extending partition\\n        var extend = Partition(ind + 1, len + 1, k,dp);\\n\\n        return dp[key] = Math.Max(cut, extend);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056182,
                "title": "0ms-simple-c-solution-using-dynamic-programing",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    double res;\\n    vector<int> nums;\\n    vector<vector<double>>DP;\\n\\npublic:\\n    double makeSeparation(int i , int k){\\n\\n        if(i>=nums.size()) return 0;\\n        if(DP[i][k] != -1) return DP[i][k];\\n        double start = i == 0 ? 0: nums[i-1];\\n        if(k == 1){\\n\\n            double x = 1.0*(nums[nums.size() - 1] - start)/(nums.size() - i);\\n            return x;\\n        }\\n        if(k>=(nums.size() -i)){\\n\\n            double x= 1.0*(nums[nums.size() - 1] - start);\\n            return x;\\n        }\\n        double temp = INT_MIN;\\n        for(int j = i ; j<=(nums.size()-k) ; j++){\\n\\n            double x = 1.0*(nums[j] - start)/(j-i+1);\\n            temp = max(temp , x+makeSeparation(j+1 , k-1));\\n        }\\n        DP[i][k] = temp;\\n        return temp;\\n    }\\n    double largestSumOfAverages(vector<int>& mat, int k) {\\n\\n        nums = mat;\\n        for(int i = 1; i<nums.size() ; i++) nums[i] += nums[i-1];\\n        DP = vector<vector<double>>(nums.size()+1 , vector<double>(k+1 , -1));\\n        res = makeSeparation(0,k);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    double res;\\n    vector<int> nums;\\n    vector<vector<double>>DP;\\n\\npublic:\\n    double makeSeparation(int i , int k){\\n\\n        if(i>=nums.size()) return 0;\\n        if(DP[i][k] != -1) return DP[i][k];\\n        double start = i == 0 ? 0: nums[i-1];\\n        if(k == 1){\\n\\n            double x = 1.0*(nums[nums.size() - 1] - start)/(nums.size() - i);\\n            return x;\\n        }\\n        if(k>=(nums.size() -i)){\\n\\n            double x= 1.0*(nums[nums.size() - 1] - start);\\n            return x;\\n        }\\n        double temp = INT_MIN;\\n        for(int j = i ; j<=(nums.size()-k) ; j++){\\n\\n            double x = 1.0*(nums[j] - start)/(j-i+1);\\n            temp = max(temp , x+makeSeparation(j+1 , k-1));\\n        }\\n        DP[i][k] = temp;\\n        return temp;\\n    }\\n    double largestSumOfAverages(vector<int>& mat, int k) {\\n\\n        nums = mat;\\n        for(int i = 1; i<nums.size() ; i++) nums[i] += nums[i-1];\\n        DP = vector<vector<double>>(nums.size()+1 , vector<double>(k+1 , -1));\\n        res = makeSeparation(0,k);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031008,
                "title": "top-down-and-bottom-up",
                "content": "\\n\\n# Top Down\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        double[][] memo = new double[nums.length][k + 1];\\n        return recur(nums, k, 0, 0, memo);\\n    }\\n\\n    private double recur(int[] nums, int k, int index, int partition, double[][] memo) {\\n\\n        if (index == nums.length) {\\n            return 0.0;\\n        }\\n        double sum = 0;\\n\\n        if (k - partition == 1) {\\n            for (int i = index; i < nums.length; i++) {\\n                sum += nums[i];\\n            }\\n            double avg = sum / (nums.length - index);\\n            return avg;\\n        }\\n\\n        if (memo[index][partition] != 0) {\\n            return memo[index][partition];\\n        }\\n        double ans = 0;\\n        \\n        for (int i = index; i < nums.length; i++) {\\n            sum += nums[i];\\n            double avg = sum / (i - index + 1);\\n            double temp = recur(nums, k, i + 1, partition + 1, memo);\\n            ans = Math.max(ans, temp + avg);\\n        }\\n        return memo[index][partition] = ans;\\n    }\\n}\\n```\\n\\n# Bottom Up\\n\\n# Code\\n```\\npublic double largestSumOfAverages(int[] nums, int k) {\\n        double[][] memo = new double[nums.length + 1][k + 1];\\n\\n        for (int index = nums.length - 1; index >= 0; index--) {\\n\\n            for (int partition = k - 1; partition >= 0; partition--) {\\n                double sum = 0;\\n\\n                if (k - partition == 1) {\\n                    for (int i = index; i < nums.length; i++) {\\n                        sum += nums[i];\\n                    }\\n                    double avg = sum / (nums.length - index);\\n                    memo[index][partition] = avg;\\n                    continue;\\n                }\\n                double ans = 0;\\n                \\n                for (int i = index; i < nums.length; i++) {\\n                    sum += nums[i];\\n                    double avg = sum / (i - index + 1);\\n                    double temp = memo[i + 1][partition + 1];\\n                    ans = Math.max(ans, temp + avg);\\n                }\\n                memo[index][partition] = ans;\\n            }\\n        }\\n        return memo[0][0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        double[][] memo = new double[nums.length][k + 1];\\n        return recur(nums, k, 0, 0, memo);\\n    }\\n\\n    private double recur(int[] nums, int k, int index, int partition, double[][] memo) {\\n\\n        if (index == nums.length) {\\n            return 0.0;\\n        }\\n        double sum = 0;\\n\\n        if (k - partition == 1) {\\n            for (int i = index; i < nums.length; i++) {\\n                sum += nums[i];\\n            }\\n            double avg = sum / (nums.length - index);\\n            return avg;\\n        }\\n\\n        if (memo[index][partition] != 0) {\\n            return memo[index][partition];\\n        }\\n        double ans = 0;\\n        \\n        for (int i = index; i < nums.length; i++) {\\n            sum += nums[i];\\n            double avg = sum / (i - index + 1);\\n            double temp = recur(nums, k, i + 1, partition + 1, memo);\\n            ans = Math.max(ans, temp + avg);\\n        }\\n        return memo[index][partition] = ans;\\n    }\\n}\\n```\n```\\npublic double largestSumOfAverages(int[] nums, int k) {\\n        double[][] memo = new double[nums.length + 1][k + 1];\\n\\n        for (int index = nums.length - 1; index >= 0; index--) {\\n\\n            for (int partition = k - 1; partition >= 0; partition--) {\\n                double sum = 0;\\n\\n                if (k - partition == 1) {\\n                    for (int i = index; i < nums.length; i++) {\\n                        sum += nums[i];\\n                    }\\n                    double avg = sum / (nums.length - index);\\n                    memo[index][partition] = avg;\\n                    continue;\\n                }\\n                double ans = 0;\\n                \\n                for (int i = index; i < nums.length; i++) {\\n                    sum += nums[i];\\n                    double avg = sum / (i - index + 1);\\n                    double temp = memo[i + 1][partition + 1];\\n                    ans = Math.max(ans, temp + avg);\\n                }\\n                memo[index][partition] = ans;\\n            }\\n        }\\n        return memo[0][0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990050,
                "title": "java-tabulation-o-k-n-2-time-o-n-space-clear-and-concise",
                "content": "```\\n    public double largestSumOfAverages(int[] a, int K) {\\n        int[]ps = new int[a.length];\\n        for(int i=0;i<a.length;i++)ps[i] = a[i] + (i-1>=0?ps[i-1]:0);\\n        double[]dp = new double[a.length];\\n        \\n        for(int i=a.length-1;i>=0;i--) {\\n            dp[i] = getAvg(0, i, ps);\\n        }\\n        \\n        for(int i=2; i<=K; i++) {\\n            double[]temp = new double[a.length];\\n            for(int j = 0; j<a.length; j++) {\\n                for(int x = j; x >= 0; x--) {\\n                    temp[j] = Math.max(temp[j], getAvg(x, j, ps) + (x-1>=0?dp[x-1]:0));\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[a.length-1];\\n    }\\n    \\n    public double getAvg(int l, int r, int[]a) {\\n        r = Math.min(r, a.length-1);\\n        return (a[r] - (l-1 >= 0 ? a[l-1] : 0))*1.0/(r-l+1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double largestSumOfAverages(int[] a, int K) {\\n        int[]ps = new int[a.length];\\n        for(int i=0;i<a.length;i++)ps[i] = a[i] + (i-1>=0?ps[i-1]:0);\\n        double[]dp = new double[a.length];\\n        \\n        for(int i=a.length-1;i>=0;i--) {\\n            dp[i] = getAvg(0, i, ps);\\n        }\\n        \\n        for(int i=2; i<=K; i++) {\\n            double[]temp = new double[a.length];\\n            for(int j = 0; j<a.length; j++) {\\n                for(int x = j; x >= 0; x--) {\\n                    temp[j] = Math.max(temp[j], getAvg(x, j, ps) + (x-1>=0?dp[x-1]:0));\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[a.length-1];\\n    }\\n    \\n    public double getAvg(int l, int r, int[]a) {\\n        r = Math.min(r, a.length-1);\\n        return (a[r] - (l-1 >= 0 ? a[l-1] : 0))*1.0/(r-l+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2944452,
                "title": "clean-must-see-easy-to-understand-0-1-knapsack-with-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:  \\n    //we will require to find the sum of the subarray in o(1) time\\n    //first of all we will generate the prefix sum array for the given array\\n    vector<int>prefix;\\n    vector<vector<vector<double>>>dp;\\n    double largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        //resizing the dp size \\n        dp.resize(nums.size()+1,vector<vector<double>>(nums.size()+1,vector<double>(k+1,-1)));\\n        //preprocessing for generating the prefiix sum array \\n        for(int i=0;i<(nums.size());i++)\\n        {\\n            if(i == 0)\\n            prefix.push_back(nums[i]);\\n            else\\n            prefix.push_back(prefix[i-1]+nums[i]);\\n        }    \\n        //here in the question we have given that we can partition into at most k\\n        //we have the choise to partition the array or not at a point if the k is available\\n        int start = 0;\\n        int end = 0;\\n        \\n        return fun(nums,start,end,k);\\n    }\\n    double fun(vector<int>&nums,int start,int end,int k)\\n    {\\n        if(k==0 and end>=nums.size())\\n        return 0;\\n\\n        if((k==0 and end<nums.size()) or (k>0 and end>=nums.size()))\\n        return INT_MIN;\\n        //now we have the choise to partition the array at the curr point or not\\n        \\n        if(dp[start][end][k] !=-1 )\\n        return dp[start][end][k];\\n\\n        //patition choise iff the k is alive\\n        double choise1=0;\\n        double choise2=0;\\n        \\n        if(k > 0)\\n        {\\n             double  sum;\\n             int size = (end - start + 1);\\n             if(start == 0)\\n             {\\n                 sum = prefix[end];\\n             }\\n             else \\n             {\\n                 sum = prefix[end] - prefix[start-1];\\n             }\\n             double avg = sum / size ;\\n             choise1 = avg + fun(nums,end+1,end+1,k-1);\\n        }\\n\\n        choise2 = 0 + fun(nums,start,end+1,k);\\n\\n        return dp[start][end][k] = max(choise1,choise2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    //we will require to find the sum of the subarray in o(1) time\\n    //first of all we will generate the prefix sum array for the given array\\n    vector<int>prefix;\\n    vector<vector<vector<double>>>dp;\\n    double largestSumOfAverages(vector<int>& nums, int k) \\n    {\\n        //resizing the dp size \\n        dp.resize(nums.size()+1,vector<vector<double>>(nums.size()+1,vector<double>(k+1,-1)));\\n        //preprocessing for generating the prefiix sum array \\n        for(int i=0;i<(nums.size());i++)\\n        {\\n            if(i == 0)\\n            prefix.push_back(nums[i]);\\n            else\\n            prefix.push_back(prefix[i-1]+nums[i]);\\n        }    \\n        //here in the question we have given that we can partition into at most k\\n        //we have the choise to partition the array or not at a point if the k is available\\n        int start = 0;\\n        int end = 0;\\n        \\n        return fun(nums,start,end,k);\\n    }\\n    double fun(vector<int>&nums,int start,int end,int k)\\n    {\\n        if(k==0 and end>=nums.size())\\n        return 0;\\n\\n        if((k==0 and end<nums.size()) or (k>0 and end>=nums.size()))\\n        return INT_MIN;\\n        //now we have the choise to partition the array at the curr point or not\\n        \\n        if(dp[start][end][k] !=-1 )\\n        return dp[start][end][k];\\n\\n        //patition choise iff the k is alive\\n        double choise1=0;\\n        double choise2=0;\\n        \\n        if(k > 0)\\n        {\\n             double  sum;\\n             int size = (end - start + 1);\\n             if(start == 0)\\n             {\\n                 sum = prefix[end];\\n             }\\n             else \\n             {\\n                 sum = prefix[end] - prefix[start-1];\\n             }\\n             double avg = sum / size ;\\n             choise1 = avg + fun(nums,end+1,end+1,k-1);\\n        }\\n\\n        choise2 = 0 + fun(nums,start,end+1,k);\\n\\n        return dp[start][end][k] = max(choise1,choise2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939235,
                "title": "python3-concise-solution-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        @lru_cache(maxsize=None)\\n        def maxAvgSum(index: int, partitions_left: int) -> int:\\n            if partitions_left == 1:\\n                return sum(nums[index:]) / (len(nums) - index)\\n\\n            max_sum: float = 0.0\\n            for i in range(index, len(nums) - (partitions_left - 1)):\\n                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)\\n                cur_sum += maxAvgSum(i + 1, partitions_left - 1)\\n                max_sum = max(cur_sum, max_sum)\\n            return max_sum\\n    \\n        return maxAvgSum(0, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        @lru_cache(maxsize=None)\\n        def maxAvgSum(index: int, partitions_left: int) -> int:\\n            if partitions_left == 1:\\n                return sum(nums[index:]) / (len(nums) - index)\\n\\n            max_sum: float = 0.0\\n            for i in range(index, len(nums) - (partitions_left - 1)):\\n                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)\\n                cur_sum += maxAvgSum(i + 1, partitions_left - 1)\\n                max_sum = max(cur_sum, max_sum)\\n            return max_sum\\n    \\n        return maxAvgSum(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927644,
                "title": "813-largest-sum-of-averages-c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[105][105];\\n    double helper(vector<int> &nums,int curr, int k){\\n        if(curr>=nums.size() or k<0)\\n            return 0;\\n        if(k==0)\\n            return INT_MIN;\\n        if(dp[curr][k]!=0)\\n            return dp[curr][k];\\n        double sum=0;\\n        double ans=0;\\n        for(int i=curr;i<nums.size();i++){\\n            sum+=nums[i];\\n            ans=max(ans, sum/(i-curr+1)+helper(nums, i+1, k-1));\\n        }\\n        return dp[curr][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        memset(dp, 0, sizeof(dp));\\n        return helper(nums, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[105][105];\\n    double helper(vector<int> &nums,int curr, int k){\\n        if(curr>=nums.size() or k<0)\\n            return 0;\\n        if(k==0)\\n            return INT_MIN;\\n        if(dp[curr][k]!=0)\\n            return dp[curr][k];\\n        double sum=0;\\n        double ans=0;\\n        for(int i=curr;i<nums.size();i++){\\n            sum+=nums[i];\\n            ans=max(ans, sum/(i-curr+1)+helper(nums, i+1, k-1));\\n        }\\n        return dp[curr][k]=ans;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        memset(dp, 0, sizeof(dp));\\n        return helper(nums, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924337,
                "title": "c-dynamic-programming-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<double>v;\\n    vector<vector<double>>dp;\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        dp.resize(nums.size()+1,vector<double>(k+1,-1));\\n        v.resize(nums.size());\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            v[i]=v[i-1]+nums[i];\\n        }\\n        return fun(0,v.size()-1,k,nums);\\n    }\\n    double fun(int start,int end,int k,vector<int>&nums)\\n    {\\n        if(start>end and k==0)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return -1e5;\\n        }\\n        if(dp[start][k]!=-1)\\n        {\\n            return dp[start][k];\\n        }\\n        double sum=0.0;\\n        double ans=0.0;\\n        for(int i=start;i<=end;i++)\\n        {\\n           if(i==start)\\n           {\\n               sum=(double)nums[i]+fun(i+1,end,k-1,nums);\\n           }\\n           else if(start==0)\\n           {\\n               sum=(v[i]/(i-start+1))+fun(i+1,end,k-1,nums);\\n           }\\n           else\\n           {\\n               sum=(v[i]-v[start-1])/(i-start+1)+fun(i+1,end,k-1,nums);\\n           }\\n           ans=max(ans,sum);\\n        }\\n        return dp[start][k]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double>v;\\n    vector<vector<double>>dp;\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        dp.resize(nums.size()+1,vector<double>(k+1,-1));\\n        v.resize(nums.size());\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            v[i]=v[i-1]+nums[i];\\n        }\\n        return fun(0,v.size()-1,k,nums);\\n    }\\n    double fun(int start,int end,int k,vector<int>&nums)\\n    {\\n        if(start>end and k==0)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return -1e5;\\n        }\\n        if(dp[start][k]!=-1)\\n        {\\n            return dp[start][k];\\n        }\\n        double sum=0.0;\\n        double ans=0.0;\\n        for(int i=start;i<=end;i++)\\n        {\\n           if(i==start)\\n           {\\n               sum=(double)nums[i]+fun(i+1,end,k-1,nums);\\n           }\\n           else if(start==0)\\n           {\\n               sum=(v[i]/(i-start+1))+fun(i+1,end,k-1,nums);\\n           }\\n           else\\n           {\\n               sum=(v[i]-v[start-1])/(i-start+1)+fun(i+1,end,k-1,nums);\\n           }\\n           ans=max(ans,sum);\\n        }\\n        return dp[start][k]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921293,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn largest_sum_of_averages(nums: Vec<i32>, k: i32) -> f64 {\\n        fn solve(nums: &Vec<i32>, idx: usize, k: i32, dp: &mut Vec<Vec<f64>>) -> f64 {\\n            if idx >= nums.len() {\\n                return 0.0;\\n            }\\n            if k == 0 {\\n                return std::f64::MIN;\\n            }\\n            if dp[idx][k as usize] != -1.0 {\\n                return dp[idx][k as usize];\\n            }\\n            let mut ans = std::f64::MIN;\\n            let mut sum = 0.0;\\n            for i in idx..nums.len() {\\n                sum += nums[i] as f64;\\n                ans = ans.max(sum / (i - idx + 1) as f64 + solve(nums, i + 1, k - 1, dp));\\n            }\\n            dp[idx][k as usize] = ans;\\n            ans\\n        }\\n\\n        let n = nums.len();\\n        let mut dp = vec![vec![-1.0; k as usize + 1]; n + 1];\\n        solve(&nums, 0, k, &mut dp)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_sum_of_averages(nums: Vec<i32>, k: i32) -> f64 {\\n        fn solve(nums: &Vec<i32>, idx: usize, k: i32, dp: &mut Vec<Vec<f64>>) -> f64 {\\n            if idx >= nums.len() {\\n                return 0.0;\\n            }\\n            if k == 0 {\\n                return std::f64::MIN;\\n            }\\n            if dp[idx][k as usize] != -1.0 {\\n                return dp[idx][k as usize];\\n            }\\n            let mut ans = std::f64::MIN;\\n            let mut sum = 0.0;\\n            for i in idx..nums.len() {\\n                sum += nums[i] as f64;\\n                ans = ans.max(sum / (i - idx + 1) as f64 + solve(nums, i + 1, k - 1, dp));\\n            }\\n            dp[idx][k as usize] = ans;\\n            ans\\n        }\\n\\n        let n = nums.len();\\n        let mut dp = vec![vec![-1.0; k as usize + 1]; n + 1];\\n        solve(&nums, 0, k, &mut dp)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2856680,
                "title": "defeat-90-98-dp-prefix-sum-solution",
                "content": "# Approach\\n1. Use prefix sum to help calculate the mean of consecutive subarray.\\nThe first is the prefix sum for fast calculation of the mean of consecutive subarrays.\\n2. About the DP idea, let dp[i][j] represent the maximum sum of the averages when there are still i times of partition left and the subarray start from the `nums[i]` (include) to most right.\\nThe initial state of the dp table is when remaining 1 partition, and the maximum sum of the averages start from j. So `dp[1][j]=mean(nums[j:])`.\\nIf the start position of the x-th partition is i, the end position is j, and the mean value of subarray i~j is mean(i,j), then the state transition formula of dp is\\n`dp[i][j] = mean(i,j) + dp[i-1][j+1]`.\\n\\n# Code\\n```\\n# solution with 2-D DP table\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        prefix = list(accumulate(nums, initial=0))\\n        n = len(nums)\\n        # initialize dp\\n        dp = [[0] * (n + 1) for _ in range(k+1)]\\n        for i in range(n-1, -1, -1):\\n            dp[1][i] = (prefix[-1] - prefix[i]) / (n - i)\\n        # update dp\\n        for part in range(2, k+1):\\n            for i in range(n-part, -1, -1):\\n                local_max = 0\\n                for j in range(i, n-part+1):\\n                    local_mean = (prefix[j+1] - prefix[i]) / (j+1-i)\\n                    local_max = max(local_max, local_mean + dp[part-1][j+1])\\n                dp[part][i] = local_max\\n        return max(x[0] for x in dp)\\n```\\nWe can also use 1-D dp table to solve this problem.\\n```\\n# solution with 1-D DP\\nfrom itertools import accumulate\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        prefix = list(accumulate(nums, initial=0))\\n        n = len(nums)\\n        # initialize dp\\n        dp = [0] * (n + 1)\\n        for i in range(n-1, -1, -1):\\n            dp[i] = (prefix[-1] - prefix[i]) / (n - i)\\n        # update dp\\n        for part in range(2, k+1):\\n            for i in range(n-part+1): # from left to right!\\n                local_max = 0\\n                for j in range(i, n-part+1):\\n                    local_mean = (prefix[j+1] - prefix[i]) / (j+1-i)\\n                    local_max = max(local_max, local_mean + dp[j+1])\\n                dp[i] = local_max\\n        return dp[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n# solution with 2-D DP table\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        prefix = list(accumulate(nums, initial=0))\\n        n = len(nums)\\n        # initialize dp\\n        dp = [[0] * (n + 1) for _ in range(k+1)]\\n        for i in range(n-1, -1, -1):\\n            dp[1][i] = (prefix[-1] - prefix[i]) / (n - i)\\n        # update dp\\n        for part in range(2, k+1):\\n            for i in range(n-part, -1, -1):\\n                local_max = 0\\n                for j in range(i, n-part+1):\\n                    local_mean = (prefix[j+1] - prefix[i]) / (j+1-i)\\n                    local_max = max(local_max, local_mean + dp[part-1][j+1])\\n                dp[part][i] = local_max\\n        return max(x[0] for x in dp)\\n```\n```\\n# solution with 1-D DP\\nfrom itertools import accumulate\\nclass Solution:\\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        prefix = list(accumulate(nums, initial=0))\\n        n = len(nums)\\n        # initialize dp\\n        dp = [0] * (n + 1)\\n        for i in range(n-1, -1, -1):\\n            dp[i] = (prefix[-1] - prefix[i]) / (n - i)\\n        # update dp\\n        for part in range(2, k+1):\\n            for i in range(n-part+1): # from left to right!\\n                local_max = 0\\n                for j in range(i, n-part+1):\\n                    local_mean = (prefix[j+1] - prefix[i]) / (j+1-i)\\n                    local_max = max(local_max, local_mean + dp[j+1])\\n                dp[i] = local_max\\n        return dp[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856033,
                "title": "c-solution-by-recursion-and-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>> records;\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n        this->records = vector<vector<double>>(k + 1, vector<double>(n, -1));\\n        return helper(nums, n, k, 0);\\n    }\\n    /*  subproblem:\\n        helper(nums, n, k, 0)\\n    */\\n    double helper(vector<int>& nums, int n, int k, int p){\\n        \\n        if (p >= n){\\n            return 0.0;\\n        }\\n        if (k == 1){\\n            int sum = 0;\\n            for (int i = p; i < n; i++) sum += nums[i];\\n            return (double)sum / (double)(n - p);\\n        }\\n        if (this->records[k][p] > 0.0){\\n            return this->records[k][p];\\n        }\\n        /*  regular case:\\n            start from p:\\n        */\\n        double sub, result = -DBL_MAX;\\n        int sum = 0;\\n        double average = 0.0;\\n        for (int i = p; i < n; i++){\\n            sum += nums[i];\\n            average = (double)sum / (double)(i - p + 1);\\n            sub = average + helper(nums, n, k - 1, i + 1);\\n            result = max(result, sub);\\n        }\\n        this->records[k][p] = result;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>> records;\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n        this->records = vector<vector<double>>(k + 1, vector<double>(n, -1));\\n        return helper(nums, n, k, 0);\\n    }\\n    /*  subproblem:\\n        helper(nums, n, k, 0)\\n    */\\n    double helper(vector<int>& nums, int n, int k, int p){\\n        \\n        if (p >= n){\\n            return 0.0;\\n        }\\n        if (k == 1){\\n            int sum = 0;\\n            for (int i = p; i < n; i++) sum += nums[i];\\n            return (double)sum / (double)(n - p);\\n        }\\n        if (this->records[k][p] > 0.0){\\n            return this->records[k][p];\\n        }\\n        /*  regular case:\\n            start from p:\\n        */\\n        double sub, result = -DBL_MAX;\\n        int sum = 0;\\n        double average = 0.0;\\n        for (int i = p; i < n; i++){\\n            sum += nums[i];\\n            average = (double)sum / (double)(i - p + 1);\\n            sub = average + helper(nums, n, k - 1, i + 1);\\n            result = max(result, sub);\\n        }\\n        this->records[k][p] = result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842500,
                "title": "cpp-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    double helper(int i, int n, int k, vector<int>&nums){\\n        if(i==n) return 0;\\n        if(dp[i][k]) return dp[i][k];\\n        if(k==1){\\n            double lsum=0,len=0;\\n            for(int j=i;j<n;j++){\\n                lsum+=nums[j];\\n                len++;\\n            }\\n            return lsum/len;\\n        }\\n        double len=0,maxi=INT_MIN,maxAns=INT_MIN,sum=0;\\n        for(int j=i;j<n;j++){\\n            len++;\\n            sum+=nums[j];\\n            maxi=sum/len+helper(j+1,n,k-1,nums);\\n            maxAns=max(maxi,maxAns);\\n        }\\n        return dp[i][k]=maxAns;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        return helper(0,n,k,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[101][101];\\n    double helper(int i, int n, int k, vector<int>&nums){\\n        if(i==n) return 0;\\n        if(dp[i][k]) return dp[i][k];\\n        if(k==1){\\n            double lsum=0,len=0;\\n            for(int j=i;j<n;j++){\\n                lsum+=nums[j];\\n                len++;\\n            }\\n            return lsum/len;\\n        }\\n        double len=0,maxi=INT_MIN,maxAns=INT_MIN,sum=0;\\n        for(int j=i;j<n;j++){\\n            len++;\\n            sum+=nums[j];\\n            maxi=sum/len+helper(j+1,n,k-1,nums);\\n            maxAns=max(maxi,maxAns);\\n        }\\n        return dp[i][k]=maxAns;\\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        return helper(0,n,k,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841990,
                "title": "c-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<double>> dp;\\n    double solve(vector<int>& nums,int idx,int k)\\n    {\\n        if(idx>=nums.size()) return 0;\\n        if(!k)\\n            return INT_MIN;\\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        double ans=INT_MIN;\\n        double sum=0;\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            ans=max(sum/(i-idx+1)+solve(nums,i+1,k-1),ans);\\n        }\\n        return dp[idx][k]=ans;\\n        \\n    }\\n    double largestSumOfAverages(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        dp.resize(n+1,vector<double>(k+1,-1));\\n        return solve(nums,0,k);\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<double>> dp;\\n    double solve(vector<int>& nums,int idx,int k)\\n    {\\n        if(idx>=nums.size()) return 0;\\n        if(!k)\\n            return INT_MIN;\\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        double ans=INT_MIN;\\n        double sum=0;\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            ans=max(sum/(i-idx+1)+solve(nums,i+1,k-1),ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2820453,
                "title": "c-solution-recursion-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double solve(vector<int>& nums, int k, vector<vector<int>>& sum, int idx, vector<vector<double>>& dp){\\n        if(idx==nums.size()) return 0;\\n        if(k==0) return ((double)sum[idx][nums.size()-1]/(double)(nums.size()-idx));\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        double max_average = 0.0;\\n        for(int i=idx;i<nums.size();i++){\\n            double sum_average = ((double)sum[idx][i]/(double)(i-idx+1)) + solve(nums,k-1,sum,i+1,dp);\\n            max_average = max(max_average, sum_average);\\n        }\\n        return dp[idx][k] = max_average;\\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<int>> sum(nums.size(), vector<int>(nums.size()));\\n        for(int i=0;i<nums.size();i++){\\n            sum[i][i] = nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                sum[i][j] = sum[i][j-1] + nums[j];\\n            }\\n        }\\n        vector<vector<double>> dp(nums.size(), vector<double>(k,-1));\\n        double answer = solve(nums, k-1, sum, 0, dp);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double solve(vector<int>& nums, int k, vector<vector<int>>& sum, int idx, vector<vector<double>>& dp){\\n        if(idx==nums.size()) return 0;\\n        if(k==0) return ((double)sum[idx][nums.size()-1]/(double)(nums.size()-idx));\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        double max_average = 0.0;\\n        for(int i=idx;i<nums.size();i++){\\n            double sum_average = ((double)sum[idx][i]/(double)(i-idx+1)) + solve(nums,k-1,sum,i+1,dp);\\n            max_average = max(max_average, sum_average);\\n        }\\n        return dp[idx][k] = max_average;\\n    }\\n\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        vector<vector<int>> sum(nums.size(), vector<int>(nums.size()));\\n        for(int i=0;i<nums.size();i++){\\n            sum[i][i] = nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                sum[i][j] = sum[i][j-1] + nums[j];\\n            }\\n        }\\n        vector<vector<double>> dp(nums.size(), vector<double>(k,-1));\\n        double answer = solve(nums, k-1, sum, 0, dp);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774474,
                "title": "java-dp-recursion",
                "content": "```\\nclass Solution {\\n   public double largestSumOfAverages(int[] nums, int k) {\\n    return getLargestSumOfAverages(nums, k, 0, new Double[nums.length][k+1]);\\n}\\npublic double getLargestSumOfAverages(int[] nums, int k, int index, Double[][] dp)\\n{\\n\\tif(index>= nums.length || k==1)\\n\\t{\\n\\t\\tint count =0;\\n\\t\\tdouble res = 0;\\n\\t\\twhile(index<nums.length)\\n\\t\\t{\\n\\t\\t\\tres+=nums[index];\\n\\t\\t\\tindex++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tif(res == 0)\\n\\t\\t\\treturn res;\\n\\t\\treturn res/count;\\n\\t\\t\\n\\t}\\n\\tif(dp[index][k] != null)\\n\\t\\treturn dp[index][k];\\n\\t\\n\\tdouble result = 0;\\n\\tint count = 0;\\n\\tdouble res = 0;\\n\\tfor(int i = index;i<nums.length;i++)\\n\\t{\\n\\t\\tcount++;\\n\\t\\tres +=nums[i];\\n\\t\\tdouble res1 = getLargestSumOfAverages(nums, k-1, i+1, dp);\\n        //System.out.println(\"res1 -->>\"+res1);\\n       // System.out.println(\"res -->>\"+res);\\n\\t\\tresult = Math.max(result, ((res/count)+res1));\\n        // System.out.println(\"result -->>\"+result);\\n\\t\\t\\n\\t\\t\\n\\t}\\n\\treturn dp[index][k]= result;\\n\\t\\n}\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n   public double largestSumOfAverages(int[] nums, int k) {\\n    return getLargestSumOfAverages(nums, k, 0, new Double[nums.length][k+1]);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2771482,
                "title": "c-shortest-and-easiest-solution-dp",
                "content": "```\\ndouble largestSumOfAverages(vector<int>& nums, int k) {\\n        if(nums.empty() || k==0) return 0;\\n        vector<int> sum;\\n        sum.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            sum.push_back(nums[i] + sum.back());\\n        }\\n        \\n        vector<vector<double>> dp(k+1, vector<double>(nums.size(), 0));\\n        for(int parts=1; parts<=k; parts++){\\n            for(int i=parts-1; i<nums.size(); i++){\\n                if(parts == 1) dp[parts][i] = double(sum[i])/(i+1);\\n                else{\\n                    for(int j= parts-2; j<i; j++){\\n                        dp[parts][i] = max(dp[parts][i], dp[parts-1][j] + double(sum[i]-sum[j])/(i-j) );\\n                    }\\n                }\\n            }\\n        }\\n        return dp[k][nums.size()-1];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble largestSumOfAverages(vector<int>& nums, int k) {\\n        if(nums.empty() || k==0) return 0;\\n        vector<int> sum;\\n        sum.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            sum.push_back(nums[i] + sum.back());\\n        }\\n        \\n        vector<vector<double>> dp(k+1, vector<double>(nums.size(), 0));\\n        for(int parts=1; parts<=k; parts++){\\n            for(int i=parts-1; i<nums.size(); i++){\\n                if(parts == 1) dp[parts][i] = double(sum[i])/(i+1);\\n                else{\\n                    for(int j= parts-2; j<i; j++){\\n                        dp[parts][i] = max(dp[parts][i], dp[parts-1][j] + double(sum[i]-sum[j])/(i-j) );\\n                    }\\n                }\\n            }\\n        }\\n        return dp[k][nums.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565629,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1568021,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1572021,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1574610,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1570443,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1573690,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 2035415,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1815159,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1627567,
                "content": [
                    {
                        "username": "kaynaat007",
                        "content": "\\nProblem statement wants us to calculate max score in an array with at most K distinct partitions which are non empty. \\nscore is defined as sum of average of these partitions. \\n\\nNOTE:  \"at most K\" means our answer can come from any j such that  1<=j <=k . \\n\\n**BASE CASES  and Recursive behaviour:**\\n\\nConsider a slightly simpler problem where we \"exactly\" divide the array into given paritions with no partition being empty. \\n\\nHow would you partition [9] into exactly 1 partition so that score is maximised ? \\n\\nOnly 1 way to do that which is just take up the whole array. so ans=9.  ( remember this point P1 ) \\n\\nwhat about A = [9, 1]  when k = 1 ? \\nAgain take up whole array and divide by n so  9 + 1 = 10/2 = 5. ( remember this point P2) \\n\\nNote there is no solution when k exceeds length of the array. \\n\\nHow about A = [9, 1, 2] and k = 2. \\n\\nNow you need to divide the arrray into 2 distinct partitions. How many choices we have ? \\n\\nclearly two choices.\\n\\nstarting from behind\\n\\nselect last element 2 and recur for remaining array and remaining k and \\nselect till 1 and recur for remaining array and remaining k . \\n\\nSee explanation below\\n\\nChoice 1:  fix 2 ( you are essentially partitioning here at 2 ) and take maximal average of remaining array with remaining k, so we want maximal score for [9, 1] for 1 less k which is 2-1 = 1. Let\\'s call it left average since its coming from left side of the array.  But we have calculated that already ! see point P1 above.  so maximal score of [9,1] with k = 1 is 5 which we add up to right average = 2/1 ( why we divide by 1 ? ) which becomes avg1 = 7. \\n\\nChoice 2: fix at 1 and take maximal score of remaining array and remaining k which is for array [9] and k = 1. This we know already from above !  However the current right average is (1+2)/2 = 1.5. Left average we already know which is 9 and so avg2 = 9 + 1.5 = 10.5 \\n\\nSo answer will be max of these two choices which is 10.5 \\nSo optimal way of partitioning array A = [9, 1, 2] into exactly 2 peices yields a score of 10.5. \\n\\nHow about array A = [9, 1, 2,3] and k = 3 \\n\\nchoice 1:  cut at last element 3, recur for [9, 1,2] with k = 2 \\nchoice 2: cut at second last element 2, recur for [9, 1] with k = 2 \\n\\nSo for a given j , 1<=j <=K, you can come up with a recursive approach which divides the array into exactly j partitions and returns maximum score for that j. \\n\\nmax of all these for all such j is the required answer. \\n\\n**Lose recursive equation**\\n\\nif score(i, j) represents maximum possible score by considering an array A[0...j] and  j till [1...i], then \\n\\nscore(i,j) = max { \\n\\n       s(1) = score(i-1, j-1) + right average of A[j], \\n\\t   s(2) = score(i-1, j-2) + right average of A[j-1], A[j], \\n\\t   ...\\n\\t   ..\\n\\t   s(r) = score(i-1, j-r) + right average of A[j-r+1], A[j-r+2] ....A[j]   where r represents an index beyond which we need not  go further since the k here which is i-1 will be larger than remaining length of array. \\n\\t  \\n  }\\n\\nOnce done for each   j, 1<=j <= k, max of all score(j, n-1) is our answer. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "cicero",
                        "content": "Input:\\n[4,1,7,5,6,2,3]\\n4\\nOutput:\\n20.5\\nExpected:\\n18.16667\\n\\nif split to these 4 arrays: [7], [6], [5], [4,3,2,1]\\n\\nThen average = 7+6+5+ (4+3+2+1)/4 = 20.5\\n\\nWhy expected value is 18.16667?\\n\\nThanks."
                    },
                    {
                        "username": "NamanVer02",
                        "content": "The question specifies that we have to split in adjacent subarrays, we cannot interchange the location elements."
                    },
                    {
                        "username": "Hong_tao",
                        "content": "The strategy here is Divide and Conquer.\\n\\nFirst, I will denote our desired function as f(n, k, A).\\nDevide the function into 2 parts: First Group, denoted as **FG**, and **The Rest**. Let me explain FG first. There are n ways we can group our FG, with length of FG varying from 1 to n. I will denote FG with lenght *d* as FG*d*. the average of FG*d* can be calculated by one single addition and one division, which I whill explain later. As for **The Rest**, a single recursive call to f(n-d, k-1, A) is enough. So, the desired result is **max{avg(FG*d*) + f(n-d, k-1, A)}, d = 1,2,...,n**\\n\\n**Calculation of avg(FG*d)***\\nkeep a variable *sum* to store the sum of FB*d* and a varibal *len* to store the length of FG*d*.\\nStarting from the end of A(which is more convinient for coding), each time we  group one more element into FG, we will add the element to *sum* and increase our *len* variable. Thus avg(FG) = *sum*/*len*\\n\\n**Base Condition for the recursive call**\\nWhen k == 1, which means all the left part of A can be grouped into one single group, we can calculate the average of the group, and return.\\n\\n**the use of Dynamic Programming**\\nTake an example, f(5,3,A), as illustration why DP is nessesary.\\nAs described above, we can get FG1, FG2, FG3, FG4, FG5, with corresponding recursive call to \\nf(4,2,A), f(3,2,A), ...\\n\\nDescending down into to call stack of f(4,2,A) and f(3,2,A) respectivily:\\nf(4,2,A): FG1, FG2, FG3, FG4--f(3,1,A), **f(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nf(3,2,A):FG1, FG2, FG3---**F(2,1,A)**, **f(1,1,A)**, f(0,1,A)\\nAs we can see, there are several overlap between them, witch can be speeded up by the introduction of DP.\\n\\nFor the code, pls refer to https://leetcode.com/problems/largest-sum-of-averages/discuss/122739/C++JavaPython-Easy-Understood-Solution-with-Explanation"
                    },
                    {
                        "username": "p23_5",
                        "content": "Use dp\\nF(i,k) = max(F(j,k-1)) for all j>i and j<=n\\nbase case k==1, return sum of the window"
                    },
                    {
                        "username": "vikasmaan",
                        "content": "There is an ask to divide array into max K partitions. We solve the problem for 0 partition, then 1 Partition and then upto K partitions. \\n\\ndp(i,0) means best average from i..N for 0 partition. This is simply nothing but average from i..N. \\ndp(i,1) means best average from i..N for 1 partition. This is simply nothing but trying 1 partition from i to N. \\n\\ndp(i,1) = Max(dp(i,0),average(i,j)+dp(j,0)) where j will range from i..N. \\nThe above list is most important to understand. Here is the explanation. We make first partition from i to j, and add dp(j,0). This we will do for j from i..N. \\n\\nAnd follows this to compute dp(i,K). Our answer is sitting at dp[0,K) because it keeps the best partition start from element 0 for K partitions."
                    },
                    {
                        "username": "Petersburg",
                        "content": "please could you change it appropriately.."
                    },
                    {
                        "username": "georgebyles73",
                        "content": "My program works in the Python installed on my computer, but not on this website. What\\'s going on"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Try to write brute force solution first and then use prefisum and then use memoization."
                    },
                    {
                        "username": "Parmeshk07",
                        "content": "C++ Solution  || Recursion + Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    double largestSumOfAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int prefix[100] = {0};\\n        double dp[100][100];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            prefix[i] = nums[i] + (i == 0 ? 0 : prefix[i-1]);\\n        }\\n        return solve(0, k, n, nums, prefix, dp);\\n    }\\n\\nprivate:\\n    double solve(int start, int k, int n, vector<int> nums, int prefix[], double dp[100][100]){\\n        if(k == 1)  return (double)(prefix[n-1]-((start==0) ? 0 : prefix[start-1]))/(n-start);\\n\\n        if(dp[start][k] != 0)      return dp[start][k];\\n\\n        double score = 0;\\n        for(int i = start+1; n-i >= (k-1); i++){\\n            score = max((double)(prefix[i-1] - ((start==0) ? 0 : prefix[start-1]))/(i-start)  + solve(i, k-1, n, nums, prefix, dp), score);\\n        }\\n        return dp[start][k] = score;\\n    }\\n\\n    double max(double a, double b){\\n        return (a > b ? a : b);\\n    }\\n};\\n\\n"
                    }
                ]
            }
        ]
    }
]