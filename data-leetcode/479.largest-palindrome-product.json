[
    {
        "title": "Largest Palindrome Product",
        "question_content": "Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\n\nExample 2:\n\nInput: n = 1\nOutput: 9\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 8",
        "solutions": [
            {
                "id": 96306,
                "title": "java-solutions-with-two-different-approaches",
                "content": "There are two directions for approaching the problem: one is to first construct the palindrome and then test whether it can be written as the product of two `n-digit` numbers; the other is to first obtain the product of the two `n-digit` number and then test whether the product is a palindrome.\\n\\n---\\n**`Part I -- From palindrome to product`**\\n\\nIt looks like most of the posts here took the first approach, so I will start from the first one also. For this approach, we need to consider the following two problems:\\n\\n1. How to construct the palindromes and arrange them in descending order (note we are interested in the maximum palindrome).\\n2. How to test if a given palindrome can be written as the product of two  `n-digit` numbers.\\n\\nFor the first problem, we need to know how many digits in each of the palindrome. Since the palindrome is meant to be the product of two  `n-digit` numbers, it can have either `2n` or `2n - 1` digits. And since we are interested in maximum palindrome, those with `2n` digits will be considered first. These palindromes can be divided into two parts with equal number of digits (`n` for each part): `left` and `right`. And `left` will be a mirror image of `right`, and vice versa. Therefore each palindrome will be fully determined by either its `left` or `right` part. \\n\\nNote the `left` part is an `n-digit` number and if we arrange it in descending order, the resulted palindrome will also be in descending order. Therefore we may start from the maximum `n-digit` number and go towards the minimum `n-digit` number. For each number, we can construct the palindrome by concatenating the number with its mirror image.\\n\\nNow we come to the second problem, i.e., how to check if the constructed palindrome can be written as the product of two `n-digit` numbers. This is essentially the \"integer factorization\" problem. One straightforward way would be the \"trial division\" algorithm, i.e., test each of the `n-digit` number to see if it is a factor of the palindrome and if so, further check if the other factor is also an `n-digit` number. \\n\\nHere is the java problem for this approach. Note we only considered palindromes with `2n` digits. Fortunately for each case (`n = 1 to  8`), we are able to find at least one palindrome that can be decomposed into two `n-digit` numbers, therefore there is no need to check those with `2n - 1` digits (However if you are still concerned, refer to this [post](https://discuss.leetcode.com/topic/74533/java-solution-115ms)).\\n\\n```\\npublic int largestPalindrome(int n) {\\n    long max = (long)Math.pow(10, n) - 1;\\n    long min = max / 10;\\n        \\n    for (long h = max; h > min; h--) {\\n        long left = h, right = 0;\\n        for (long i = h; i != 0; right = right * 10 + i % 10, i /= 10, left *= 10);\\n        long palindrom = left + right;      // construct the palindrome\\n            \\n        for (long i = max; i > min; i--) {\\n            long j = palindrom / i;\\n            if (j > i) break;     // terminate if the other number is greater than current number\\n            if (palindrom % i == 0) return (int)(palindrom % 1337); // found if current number is a factor\\n        }\\n    }\\n\\n    return 9;    // account for case n = 1\\n}\\n```\\nApparently the algorithm goes exponentially: `O(10^n)`\\n\\n---\\n**`Part II -- Observations and optimizations`**\\n\\nBefore I continue to the other approach, I\\'d like to point out some observations and the corresponding optimizations.\\n\\nAs I mentioned, we are interested in the maximum palindrome, thus it\\'s reasonable to first check palindromes starting with digit `9`. If not found, then those starting with digit `8, 7, 6,...`. If the palindrome is starting with digit `9`, it must also be ending with digit `9`. Now if the palindrome is the product of the two `n-digit` numbers, the two numbers must be ending with digits `1, 3, 7, or 9`. Similarly for other cases. \\n\\nIt looks like for each `n`, there exists at least one palindrome with `2n` digits and starting with digit `9` that can be written as the product of two `n-digit` numbers. I was able to prove for the case when `n` is even, but failed for the case when `n` is odd.\\n\\nIf `n` is even, let `n = 2k`. The two `n-digit` numbers can be `num1 = 10^n - 1` and `num2 = 10^n - 10^k + 1`. Their product will be `p = num1 * num2 = 10^(3k) * (10^k - 1) + (10^k - 1) = 9..0..9`, where `p` will have `k` leading and trailing digit of `9` and `2k` digit `0` in the middle. For `n <= 8`, this is also the maximum palindrome that is found (not sure if it holds true for higher `n`, but most likely it will do).\\n\\nIf `n` is odd, the above trick does not work (`p` will have unbalanced `9`\\'s). For this case, however, I would like to propose the following statement: let `n = 2k + 1`, there exists at least two `n-digit` numbers `num1` and `num2`, `10^n - 10^(k+1) <= num1, num2 <= 10^n - 1`, whose product will be a palindrome (verified for `n <= 8`). \\n\\nIn summary, we have the following conclusion: for each `n`, there exists at least two `n-digit` numbers `num1` and `num2`, `10^n - 10^m <= num1, num2 <= 10^n - 1 and m = [(n+1)/2]`, whose product will be a palindrome.\\n\\n---\\n**`Part III -- From product to palindrome`**\\n\\nSimilar to the first approach, we need to consider the following two problems:\\n\\n1. How to construct the products and arrange them in descending order.\\n2. How to test if a given product is a palindrome.\\n\\nThe second problem is easy, simply reverse the product and check if it is the same as the original product. The first problem, however, is a little tricky. Obtaining the product is a no-brainer. The hard part is how to arrange them in descending order. \\n\\nFirst we need to determine the candidate products. From `part II`, we will only consider products obtained with the two `n-digit` numbers in the range `[10^n - 10^m, 10^n - 1]`. Second we will use a PriorityQueue to extract these candidate products in descending order.\\n\\nHowever, the total number of candidates above still blows up the memory when `n = 8`. So we need further pruning. First again since the product ends with digit `9`, the two numbers must be ending with digits `1, 3, 7, or 9`. Second, to avoid repetition, the first number will be no less than the second. Third, for all products obtained with the first number fixed, there is no need to include them all at once but instead we can consider them once at a time with the second number going in decreasing order. So eventually we end up storing the two numbers in the PriorityQueue while extracting them according to their product.\\n\\nWith these optimizations, here is the java program for this approach:\\n\\n```\\npublic int largestPalindrome(int n) {\\n    int max = (int)Math.pow(10, n) - 1;\\n    int min = max - (int)Math.pow(10, (n + 1) >> 1);\\n    \\t\\n    Comparator<int[]> cmp = new Comparator<int[]>() {\\n    \\t@Override\\n\\t    public int compare(int[] a, int[] b) {\\n    \\t    return Long.compare((long)b[0] * b[1], (long)a[0] * a[1]);\\n    \\t}\\n    };\\n    \\t\\n    PriorityQueue<int[]> pq = new PriorityQueue<>(max - min, cmp);\\n    \\t\\n    for (int i = max; i > min; i--) {\\n    \\tint r = i % 10;\\n    \\t\\t\\n    \\tif (r == 3 || r == 7) {\\n    \\t    pq.offer(new int[] {i, i});\\n    \\t} else if (r == 1) {\\n    \\t    pq.offer(new int[] {i, i - 2});\\n    \\t} else if (r == 9) {\\n    \\t    pq.offer(new int[] {i, i - 8});\\n    \\t}\\n    }\\n    \\t\\n    while (!pq.isEmpty()) {\\n    \\tint[] a = pq.poll();\\n    \\tlong p = (long)a[0] * a[1];\\n    \\t\\t\\n    \\tif (isPalindrome(p)) return (int)(p % 1337);\\n    \\t\\t\\n    \\tif (a[1] > min) {\\n    \\t    a[1] -= 10;\\n    \\t    pq.offer(a);\\n    \\t}\\n    }\\n    \\n    return 0;\\n}\\n    \\nprivate boolean isPalindrome(long z) {\\n    long r = 0;\\n    for (long x = z; x != 0; r = r * 10 + x % 10, x /= 10);\\n    return r == z;\\n}\\n```\\n\\nThis algorithm still goes exponentially with `n` while also requires extra space of the same order.",
                "solutionTags": [],
                "code": "```\\npublic int largestPalindrome(int n) {\\n    long max = (long)Math.pow(10, n) - 1;\\n    long min = max / 10;\\n        \\n    for (long h = max; h > min; h--) {\\n        long left = h, right = 0;\\n        for (long i = h; i != 0; right = right * 10 + i % 10, i /= 10, left *= 10);\\n        long palindrom = left + right;      // construct the palindrome\\n            \\n        for (long i = max; i > min; i--) {\\n            long j = palindrom / i;\\n            if (j > i) break;     // terminate if the other number is greater than current number\\n            if (palindrom % i == 0) return (int)(palindrom % 1337); // found if current number is a factor\\n        }\\n    }\\n\\n    return 9;    // account for case n = 1\\n}\\n```\n```\\npublic int largestPalindrome(int n) {\\n    int max = (int)Math.pow(10, n) - 1;\\n    int min = max - (int)Math.pow(10, (n + 1) >> 1);\\n    \\t\\n    Comparator<int[]> cmp = new Comparator<int[]>() {\\n    \\t@Override\\n\\t    public int compare(int[] a, int[] b) {\\n    \\t    return Long.compare((long)b[0] * b[1], (long)a[0] * a[1]);\\n    \\t}\\n    };\\n    \\t\\n    PriorityQueue<int[]> pq = new PriorityQueue<>(max - min, cmp);\\n    \\t\\n    for (int i = max; i > min; i--) {\\n    \\tint r = i % 10;\\n    \\t\\t\\n    \\tif (r == 3 || r == 7) {\\n    \\t    pq.offer(new int[] {i, i});\\n    \\t} else if (r == 1) {\\n    \\t    pq.offer(new int[] {i, i - 2});\\n    \\t} else if (r == 9) {\\n    \\t    pq.offer(new int[] {i, i - 8});\\n    \\t}\\n    }\\n    \\t\\n    while (!pq.isEmpty()) {\\n    \\tint[] a = pq.poll();\\n    \\tlong p = (long)a[0] * a[1];\\n    \\t\\t\\n    \\tif (isPalindrome(p)) return (int)(p % 1337);\\n    \\t\\t\\n    \\tif (a[1] > min) {\\n    \\t    a[1] -= 10;\\n    \\t    pq.offer(a);\\n    \\t}\\n    }\\n    \\n    return 0;\\n}\\n    \\nprivate boolean isPalindrome(long z) {\\n    long r = 0;\\n    for (long x = z; x != 0; r = r * 10 + x % 10, x /= 10);\\n    return r == z;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96297,
                "title": "java-solution-using-assumed-max-palindrom",
                "content": "```\\n        public int largestPalindrome(int n) {\\n        // if input is 1 then max is 9 \\n        if(n == 1){\\n            return 9;\\n        }\\n        \\n        // if n = 3 then upperBound = 999 and lowerBound = 99\\n        int upperBound = (int) Math.pow(10, n) - 1, lowerBound = upperBound / 10;\\n        long maxNumber = (long) upperBound * (long) upperBound;\\n        \\n        // represents the first half of the maximum assumed palindrom.\\n        // e.g. if n = 3 then maxNumber = 999 x 999 = 998001 so firstHalf = 998\\n        int firstHalf = (int)(maxNumber / (long) Math.pow(10, n));\\n        \\n        boolean palindromFound = false;\\n        long palindrom = 0;\\n        \\n        while (!palindromFound) {\\n            // creates maximum assumed palindrom\\n            // e.g. if n = 3 first time the maximum assumed palindrom will be 998 899\\n            palindrom = createPalindrom(firstHalf);\\n            \\n            // here i and palindrom/i forms the two factor of assumed palindrom\\n            for (long i = upperBound; upperBound > lowerBound; i--) {\\n                // if n= 3 none of the factor of palindrom  can be more than 999 or less than square root of assumed palindrom \\n                if (palindrom / i > maxNumber || i * i < palindrom) {\\n                    break;\\n                }\\n                \\n                // if two factors found, where both of them are n-digits,\\n                if (palindrom % i == 0) {\\n                    palindromFound = true;\\n                    break;\\n                }\\n            }\\n\\n            firstHalf--;\\n        }\\n\\n        return (int) (palindrom % 1337);\\n    }\\n\\n    private long createPalindrom(long num) {\\n        String str = num + new StringBuilder().append(num).reverse().toString();\\n        return Long.parseLong(str);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int largestPalindrome(int n) {\\n        // if input is 1 then max is 9 \\n        if(n == 1){\\n            return 9;\\n        }\\n        \\n        // if n = 3 then upperBound = 999 and lowerBound = 99\\n        int upperBound = (int) Math.pow(10, n) - 1, lowerBound = upperBound / 10;\\n        long maxNumber = (long) upperBound * (long) upperBound;\\n        \\n        // represents the first half of the maximum assumed palindrom.\\n        // e.g. if n = 3 then maxNumber = 999 x 999 = 998001 so firstHalf = 998\\n        int firstHalf = (int)(maxNumber / (long) Math.pow(10, n));\\n        \\n        boolean palindromFound = false;\\n        long palindrom = 0;\\n        \\n        while (!palindromFound) {\\n            // creates maximum assumed palindrom\\n            // e.g. if n = 3 first time the maximum assumed palindrom will be 998 899\\n            palindrom = createPalindrom(firstHalf);\\n            \\n            // here i and palindrom/i forms the two factor of assumed palindrom\\n            for (long i = upperBound; upperBound > lowerBound; i--) {\\n                // if n= 3 none of the factor of palindrom  can be more than 999 or less than square root of assumed palindrom \\n                if (palindrom / i > maxNumber || i * i < palindrom) {\\n                    break;\\n                }\\n                \\n                // if two factors found, where both of them are n-digits,\\n                if (palindrom % i == 0) {\\n                    palindromFound = true;\\n                    break;\\n                }\\n            }\\n\\n            firstHalf--;\\n        }\\n\\n        return (int) (palindrom % 1337);\\n    }\\n\\n    private long createPalindrom(long num) {\\n        String str = num + new StringBuilder().append(num).reverse().toString();\\n        return Long.parseLong(str);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96303,
                "title": "java-solution-with-explanation",
                "content": "Hi there! I am sharing my solution. My idea is strightforward. First off, let's pay attention on some facts. Let's consider maximum number with n digits. Of course that is the number consisting only of digit 9 (999..9). Let's denote that number ```max```, and consider ```max*max```. \\n* It is  obvious that any number which is product of two n digit numbers is less than or equal to ```max*max```.\\n* Maximum possible length of the product is ```2*n```.\\n* If we partition palindrome number into two equal halves, then left half must be equals to the reverse of the right half.\\n\\nWell, how to find the largest possible palindrome number? Answer: If ```max*max``` is palindrome itself, then that is the largest possible palindrome. Otherwise partition it into two equal(by length) halves. If left half is less than, or equals to the right half, then the largest palindrome number is concatenation of left part and reversed left part. Otherwise decrement left part, then find the largest palindrome as concatenation of left and reverse of it. Can we find next palindrome? Answer: yes. It is enough to repeat the latter operation, to obtain next largest palindrome. For example for input n = 2, ```max*max``` = 99*99 = 9801. So left half (further just ```left```) is 98 and right half (further just ```right```) is 01. 98>1, it mean largest palindrome is 9779. But it is not answer for our problem. Because this number is not product of two numbers with 2 digits. Well, to get valid palindromic number, we need to traverse all the palindromic numbers and check whether that number is a product of two numbers with n digits. To get the largest palindromic number, we have to approach the palindromic numbers greedily. It means, we need to traverse them from the largest to the smallest. Once we have found a palindrome, which is product of two n digital numbers return that number by mod 1337. That's all with the idea. \\n```  ```Note the following points in implementation:\\n* To optimally validate a palindrome number, (i.e whether it is product of two n digital numbers) use greedy approach. In other words, start from largest possible number until the number is greater than its pair. Because it prevents you from considering duplicate pairs. For instance, if ```a>b and a*b = pal ```, then no need to consider ```b*a = pal```. It saves huge amount of time. Cope example:\\n ```   \\n        for(int i = max;i>pro/i;i--){\\n                if(pro%i == 0 ) {\\n                    return (int)(pro%m);\\n                }\\n         }\\n```\\n* Do not forget to assign palindrome number ( pro in my case, which stands for product) long datatype. Because maximum possible palindrome consists of 16 digits, which is greater than Integer.MAX_VALUE.\\n\\nTo sum up, I think this problem is NOT an EASY one. It would be better to tag it as MEDIUM.\\n\\nP.S: Sorry for dirty code.\\n\\n```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        if(n == 1) return 9;\\n        int m = 1337;\\n        int mod = (int)Math.pow(10, n);\\n        int max = (int)Math.pow(10, n)-1;\\n        long pro = (long)max*(long)max;\\n        int right = (int)(pro%mod);\\n        int left = (int)(pro/mod);\\n        if(left == reverse(right,n)) return (int)(pro%m);\\n        if(left > right) {left--;}\\n        pro = (long)left*(long)mod+(long)reverse(left,n);\\n        while(left != mod/10){\\n            for(int i = max;i>pro/i;i--){\\n                if(pro%i == 0 ) {\\n                    return (int)(pro%m);\\n                }\\n            }\\n            left--;\\n            pro = (long)left*(long)mod+(long)reverse(left,n);\\n        }\\n        \\n        return (int)(pro%m);\\n    }\\n    \\n    private int reverse(int n, int dig){\\n        int x = n;\\n        int res = 0;\\n        int ten = (int)Math.pow(10,dig-1);\\n        while(x != 0 ){\\n            int d = x%10;\\n            res+=ten*d;\\n            ten/=10;\\n            x/=10;\\n        }\\n        return res;\\n    }\\n   \\n}",
                "solutionTags": [],
                "code": "```max```\n```max*max```\n```max*max```\n```2*n```\n```max*max```\n```max*max```\n```left```\n```right```\n```  ```\n```a>b and a*b = pal ```\n```b*a = pal```\n```   \\n        for(int i = max;i>pro/i;i--){\\n                if(pro%i == 0 ) {\\n                    return (int)(pro%m);\\n                }\\n         }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96301,
                "title": "concise-c-solution",
                "content": "Inspired by [@chiranjeeb2](https://discuss.leetcode.com/topic/74125/java-solution-using-assumed-max-palindrom) \\n\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        int upper = pow(10, n) - 1;\\n        int lower = pow(10, n-1);\\n        for (int i = upper; i >= lower; i--) {\\n            long cand = buildPalindrome(i);\\n            for (long j = upper; j*j >= cand; j--) {\\n                if (cand % j == 0 && cand / j <= upper) {\\n                    return cand % 1337;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    long buildPalindrome(int n) {\\n        string s = to_string(n);\\n        reverse(s.begin(), s.end());\\n        return stol(to_string(n) + s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        int upper = pow(10, n) - 1;\\n        int lower = pow(10, n-1);\\n        for (int i = upper; i >= lower; i--) {\\n            long cand = buildPalindrome(i);\\n            for (long j = upper; j*j >= cand; j--) {\\n                if (cand % j == 0 && cand / j <= upper) {\\n                    return cand % 1337;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    long buildPalindrome(int n) {\\n        string s = to_string(n);\\n        reverse(s.begin(), s.end());\\n        return stol(to_string(n) + s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96291,
                "title": "an-easy-9-line-java-solution",
                "content": "``` java\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        int max=(int)Math.pow(10, n)-1;\\n        for (int v=max-1;v>max/10;v--) {\\n            long u=Long.valueOf(v+new StringBuilder().append(v).reverse().toString());\\n            for (long x=max;x*x>=u;x--)\\n                if (u%x==0)\\n                    return (int)(u%1337);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        int max=(int)Math.pow(10, n)-1;\\n        for (int v=max-1;v>max/10;v--) {\\n            long u=Long.valueOf(v+new StringBuilder().append(v).reverse().toString());\\n            for (long x=max;x*x>=u;x--)\\n                if (u%x==0)\\n                    return (int)(u%1337);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171580,
                "title": "python-solution-using-math-detailed-mathematical-deduction",
                "content": "I got the idea from @nizametdinov and @CerebrumMaize\\'s posts.\\n`largest_palindrome = first_number * second_number\\n= (10^n - x)*(10^n - y)` where `x,y` are integers, and we want to keep them as small as possible to get the largest palindrome\\nsome algebra:\\n`largest_palindrome = 10^(2n) - 10^n * (x+y) + xy = 10^n * (10^n - (x+y)) + xy`\\nInterestingly this palindrome has been expressed as two numbers left and right, where\\n`left = 10^n - (x+y)`, `right = xy` and `right = int(str(left)[::-1])`\\ne.g. palindrome `ABCCBA = (10^3)*ABC+ CBA` where `ABC = 10^3-(x+y)` and `CBA = xy` where `n=3`\\nLet\\'s define `z=x+y`, some algebra:\\n`left = 10^n - z`\\n`right = x(z-x) = -x^2 + zx` ==> `x^2 - zx + right = 0`\\n`right = int(str(left)[::-1])` (link `left` with `right`)\\nIt becomes a quadratic equation of `x`, recall `x = 10^n - first_number`, **x has to be an integer**. Hence we set `z` as the integer parameter to increment from lowest possible value of 2 (we want to keep multiplication of `(10^n - x)*(10^n - y)` as large as possible). When `z` is defined as integer parameter, hence we can guarantee `y` is also integer if `x` is integer. Hence the problem becomes searching for integer solution of `x` when `z` increments from 2.\\n\\n**CAVEAT**: There is an underlying assumption that restrict the use case to `n <= 8`, reason being we need `(x+y) < 10^n` and `xy < 10^n` to make sure largest palindrome can be represented in the format of `10^n * left + right` when `n = 9` , such assumption is violated. as `x = 19653` , `y = 79683` and `xy=1566009999 > 10^9`. The largest palindrome product being `(10^9-19653) * (10^9-79683) = 999900665566009999` Thanks to @hvsavage for pointing out!\\n\\n```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 9\\n        for z in range(2, 2 * (9 * 10**n) - 1):\\n            left = 10**n - z\\n            right = int(str(left)[::-1])\\n            root_1, root_2 = 0, 0\\n\\t\\t\\t\\t\\t\\t\\n            if z**2 - 4*right < 0:\\n                continue\\n            else:\\n                root_1 = 1/2 * (z + (z**2-4*right)**0.5)\\n                root_2 = 1/2 * (z - (z**2-4*right)**0.5)\\n                if root_1.is_integer() or root_2.is_integer():\\n                    return (10**n*left+right) %1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 9\\n        for z in range(2, 2 * (9 * 10**n) - 1):\\n            left = 10**n - z\\n            right = int(str(left)[::-1])\\n            root_1, root_2 = 0, 0\\n\\t\\t\\t\\t\\t\\t\\n            if z**2 - 4*right < 0:\\n                continue\\n            else:\\n                root_1 = 1/2 * (z + (z**2-4*right)**0.5)\\n                root_2 = 1/2 * (z - (z**2-4*right)**0.5)\\n                if root_1.is_integer() or root_2.is_integer():\\n                    return (10**n*left+right) %1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190107,
                "title": "swift-largest-palindrome-product",
                "content": "```swift\\nclass Solution {\\n    func largestPalindrome(_ n: Int) -> Int {\\n        let upper = Int(pow(10.0,Double(n))) - 1\\n        let lower = upper / 10, num = lower + 1\\n        for i in (num...upper).reversed() {\\n            let str = String(i)\\n            let p = Int(str + String(str.reversed()))!\\n            var j = upper\\n            while j * j > p {\\n                if p % j == 0 { return p % 1337 }\\n                j -= 1\\n            }\\n        }\\n        return 9\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.007) seconds\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.largestPalindrome(2), 987) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.largestPalindrome(1), 9) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func largestPalindrome(_ n: Int) -> Int {\\n        let upper = Int(pow(10.0,Double(n))) - 1\\n        let lower = upper / 10, num = lower + 1\\n        for i in (num...upper).reversed() {\\n            let str = String(i)\\n            let p = Int(str + String(str.reversed()))!\\n            var j = upper\\n            while j * j > p {\\n                if p % j == 0 { return p % 1337 }\\n                j -= 1\\n            }\\n        }\\n        return 9\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.007) seconds\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.largestPalindrome(2), 987) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.largestPalindrome(1), 9) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521512,
                "title": "python3-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        # just to forget about 1-digit case\\n        if n == 1:\\n            return 9\\n        \\n        # min number with n digits (for ex. for n = 4, min_num = 1000)\\n        min_num = 10 ** (n - 1)\\n        \\n        # max number with n digits (for ex. 9999)\\n        max_num = 10 ** n - 1       \\n        \\n        max_pal = 0\\n        \\n        # step is equal to 2, because we have to get a number, the 1st digit of which is 9, so we have to   \\n\\t\\t# iterate only over odd numbers\\n        for i in range(max_num, min_num - 1, -2): \\n            \\n            # since we are looking for the maximum palindrome number, it makes no sense to iterate over the \\n            # product less than the max_pal obtained from the last iteration\\n            if i * i < max_pal:\\n                break\\n                \\n            for j in range(max_num, i - 1, -2):\\n                product = i * j\\n                \\n                # since a palindrome with an even number of digits must be mod 11 == 0 and we have no reason to \\n                # check the product which less or equal than max_pal\\n                if product % 11 != 0 and product >= max_pal:\\n                    continue\\n                    \\n                # check if product is a palindrome then update the max_pal\\n                if str(product) == str(product)[::-1]:\\n                    max_pal = product\\n\\n        return max_pal % 1337\\n```\\n\\nPalindrome with an even number of digits satisfies the criteria for divisibility by 11:\\n1) If the number of digits is even, add the first and subtract the last digit from the rest. The result must be divisible by 11:\\nFor example: 9966006699\\n96600669 + 9 - 9 = 96600669,\\n96600669 / 11 = 8781879\\n2) Form the alternating sum of the digits. The result must be divisible by 11:\\nabs(9 + 6 + 0 + 6 + 9) - abs(9 + 6 + 0 + 6 +9) = 0, \\n0 is a multiple of 11",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        # just to forget about 1-digit case\\n        if n == 1:\\n            return 9\\n        \\n        # min number with n digits (for ex. for n = 4, min_num = 1000)\\n        min_num = 10 ** (n - 1)\\n        \\n        # max number with n digits (for ex. 9999)\\n        max_num = 10 ** n - 1       \\n        \\n        max_pal = 0\\n        \\n        # step is equal to 2, because we have to get a number, the 1st digit of which is 9, so we have to   \\n\\t\\t# iterate only over odd numbers\\n        for i in range(max_num, min_num - 1, -2): \\n            \\n            # since we are looking for the maximum palindrome number, it makes no sense to iterate over the \\n            # product less than the max_pal obtained from the last iteration\\n            if i * i < max_pal:\\n                break\\n                \\n            for j in range(max_num, i - 1, -2):\\n                product = i * j\\n                \\n                # since a palindrome with an even number of digits must be mod 11 == 0 and we have no reason to \\n                # check the product which less or equal than max_pal\\n                if product % 11 != 0 and product >= max_pal:\\n                    continue\\n                    \\n                # check if product is a palindrome then update the max_pal\\n                if str(product) == str(product)[::-1]:\\n                    max_pal = product\\n\\n        return max_pal % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96305,
                "title": "python-solution-using-math-in-48ms",
                "content": "Thanks to @nizametdinov 's reply in this [thread](https://discuss.leetcode.com/topic/78852/could-any-python-experts-share-their-codes-within-100ms/2), I came out below solution.\\nBecause `i^2 - a*i - lower = 0`\\nthus, `(i-a/2)^2 = (4*lower-a^2)/2`\\nthus, i.f.f. `(4*lower-a^2)/2` is some integer's square, can lower `i^2 - a*i - lower = 0` have integer result.\\nso I use `(a^2-4*lo)^.5 == int((a^2-4*lo)^.5)` to check.\\n```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        if n==1: return 9\\n        if n==2: return 987\\n        for a in xrange(2, 9*10**(n-1)):\\n            hi=(10**n)-a\\n            lo=int(str(hi)[::-1])\\n            if a**2-4*lo < 0: continue\\n            if (a**2-4*lo)**.5 == int((a**2-4*lo)**.5):\\n                return (lo+10**n*(10**n-a))%1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        if n==1: return 9\\n        if n==2: return 987\\n        for a in xrange(2, 9*10**(n-1)):\\n            hi=(10**n)-a\\n            lo=int(str(hi)[::-1])\\n            if a**2-4*lo < 0: continue\\n            if (a**2-4*lo)**.5 == int((a**2-4*lo)**.5):\\n                return (lo+10**n*(10**n-a))%1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96300,
                "title": "java-1ms-a-stupid-solution",
                "content": "```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        int[] x = {9,99,993,9999,99979,999999,9998017,99999999};\\n        int[] y = {1,91,913,9901,99681,999001,9997647,99990001};\\n        \\n        return ((x[n-1]%1337)*(y[n-1]%1337))%1337;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        int[] x = {9,99,993,9999,99979,999999,9998017,99999999};\\n        int[] y = {1,91,913,9901,99681,999001,9997647,99990001};\\n        \\n        return ((x[n-1]%1337)*(y[n-1]%1337))%1337;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333880,
                "title": "16ms-code-c-with-math-explanation",
                "content": "My original solution was pretty slow.\\nThen I find this code, this is actually someone else\\'s code.\\nIt took me quite a while to figure it out the math behind.\\nSo I would like to share my understanding of this very interesting code.\\n```\\n    int largestPalindrome(int n) \\n    {\\n        if(n==1)\\n            return 9;      \\n        for(long long int x = 1;x<=pow(10,n)-1;x++)\\n        {\\n\\t\\t\\t//constracting the a Palindrome number by following lines\\n            long long int a = pow(10,n) - x;\\n            string str = to_string(a);\\n            reverse(str.begin(),str.end());\\n            stringstream sm(str);\\n            long long int b=0;\\n            sm>>b;\\n\\t\\t\\t// Here the Palindrome number we get is:  \\n\\t\\t\\t//  \\t\\t\\t\\trst = pow(10,n)*a + b;\\n\\t\\t\\t//  Let\\'s assume n = 2;\\n\\t\\t\\t//  so: \\n\\t\\t\\t//  \\t\\t\\t\\trst = 100*(100-x) + b;\\n\\t\\t\\t//  if rst is the number we want, then we can find c and d satisfy this: \\n\\t\\t\\t//  \\t\\t\\t\\trst = (100-c)*(100-d)\\n\\t\\t\\t//  so we have :\\n\\t\\t\\t//   \\t\\t\\t\\t100*(100-x) + b = (100-c)*(100-d)\\n\\t\\t\\t//                  100*(c+d-x) = c*d - b\\n\\t\\t\\t//  one solution that satisfies the above equation is that :\\n\\t\\t\\t//                  c+d = x\\n\\t\\t\\t//                  c*d = b\\n\\t\\t\\t//  if that is the case, then we have\\n\\t\\t\\t//                  (c-d)^2 = x*x-4*b\\n\\t\\t\\t//  now if temp: \\n\\t\\t\\t//                  temp =x*x -4*b;\\n\\t\\t\\t//  have squre root:\\n\\t\\t\\t//  then we have c-d =sqrt(temp)\\n\\t\\t\\t//  now we have 2*c = x+sqrt(temp)\\n\\t\\t\\t//  we can definitly find integer solution for c and d, then we can simply return rst. \\n            long long int temp =x*x -4*b;\\n            if(temp>=0)\\n            {\\n                long long int temp1 =(int)sqrt(temp);\\n                if(temp1*temp1 == temp&&(x+temp1)%2==0)\\n                {\\n                    long long int ret= pow(10,n)*a;\\n                    ret = ret+ b;\\n                    return ret;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int largestPalindrome(int n) \\n    {\\n        if(n==1)\\n            return 9;      \\n        for(long long int x = 1;x<=pow(10,n)-1;x++)\\n        {\\n\\t\\t\\t//constracting the a Palindrome number by following lines\\n            long long int a = pow(10,n) - x;\\n            string str = to_string(a);\\n            reverse(str.begin(),str.end());\\n            stringstream sm(str);\\n            long long int b=0;\\n            sm>>b;\\n\\t\\t\\t// Here the Palindrome number we get is:  \\n\\t\\t\\t//  \\t\\t\\t\\trst = pow(10,n)*a + b;\\n\\t\\t\\t//  Let\\'s assume n = 2;\\n\\t\\t\\t//  so: \\n\\t\\t\\t//  \\t\\t\\t\\trst = 100*(100-x) + b;\\n\\t\\t\\t//  if rst is the number we want, then we can find c and d satisfy this: \\n\\t\\t\\t//  \\t\\t\\t\\trst = (100-c)*(100-d)\\n\\t\\t\\t//  so we have :\\n\\t\\t\\t//   \\t\\t\\t\\t100*(100-x) + b = (100-c)*(100-d)\\n\\t\\t\\t//                  100*(c+d-x) = c*d - b\\n\\t\\t\\t//  one solution that satisfies the above equation is that :\\n\\t\\t\\t//                  c+d = x\\n\\t\\t\\t//                  c*d = b\\n\\t\\t\\t//  if that is the case, then we have\\n\\t\\t\\t//                  (c-d)^2 = x*x-4*b\\n\\t\\t\\t//  now if temp: \\n\\t\\t\\t//                  temp =x*x -4*b;\\n\\t\\t\\t//  have squre root:\\n\\t\\t\\t//  then we have c-d =sqrt(temp)\\n\\t\\t\\t//  now we have 2*c = x+sqrt(temp)\\n\\t\\t\\t//  we can definitly find integer solution for c and d, then we can simply return rst. \\n            long long int temp =x*x -4*b;\\n            if(temp>=0)\\n            {\\n                long long int temp1 =(int)sqrt(temp);\\n                if(temp1*temp1 == temp&&(x+temp1)%2==0)\\n                {\\n                    long long int ret= pow(10,n)*a;\\n                    ret = ret+ b;\\n                    return ret;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1618527,
                "title": "python-fast-swift-100-faster-100-less-memory-no-cheating",
                "content": "This is a very efficient solution for solving the problem; turns out to be a very straightforward way. Hint: it\\'s about solving quadratic equations.\\n```\\nproduct = multiplicand * multiplier\\nNow for an n-digit number, the maximum a multiplicand or a multiplier can be is (10\\u207F - 1). So,\\nproduct = \\n           = (10\\u207F - x) * (10\\u207F - y)           (where x, y > 0); n = no. of digits\\n           = 10\\xB2\\u207F - 10\\u207Fx - 10\\u207Fy + xy\\n           = 10\\xB2\\u207F - 10\\u207F(x + y) + xy\\n           = 10\\u207F * (10\\u207F - (x + y)) + xy\\n           = 10\\u207F * left + right               (let left = 10\\u207F - (x + y) and right = xy)\\n```\\n\\t\\t   \\nNow, we\\'ve\\n```\\n      right = xy\\n      let z = x + y\\n      \\u2234 right = x(z - x)\\n      \\u2234 right = zx - x\\xB2\\n      \\u2234 x\\xB2 - zx + right = 0\\n\\nWhich is a quadratic equation!\\n\\tax\\xB2 + bx + c = 0\\n\\t\\tx = -b \\xB1 \\u221A(b\\xB2 - 4ac)\\n\\t\\t\\t----------------\\n\\t\\t\\t\\t   2a\\n\\twhere; a = 1\\n\\t\\t  b = -z\\n\\t\\t  c = right\\n```\\nThus our problem is now reduced to solving a quadratic equation.\\n**Python**\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        maxi = 10 ** n   # store the value of 10\\u207F \\n        for z in range(2, maxi): # since both x, y > 0 and z = x + y; which implies that z has a minimum value of 2\\n            left = maxi - z\\n            right = int(str(left)[::-1]) # reverese number\\n            \\n            discriminant = z ** 2 - 4 * right # b\\xB2 - 4ac\\n            if discriminant < 0: # no root\\n                continue\\n            else: # there exists at least one real solution; so calculate the roots\\n                root_1 = (z + discriminant ** 0.5) / 2\\n                root_2 = (z - discriminant ** 0.5) / 2\\n                if root_1.is_integer() or root_2.is_integer():\\n                    return (maxi * left + right) % 1337\\n```\\n\\n**PS: Don\\'t get daunted by the program, it\\'s difficult only syntactically!!**\\nKindly ignore the ```isInt()``` and ```power()``` methods!!\\n```\\nclass Solution {\\n    private func isInt(_ num: Double) -> Bool {\\n        return num.truncatingRemainder(dividingBy: 1) == 0\\n    }\\n    private func power(_ num: Int, raisedTo: Int) -> Int {\\n        guard raisedTo != 0 else { return 0 }\\n        guard raisedTo != 1 else { return num }\\n        var ans = num\\n        for _ in 2...raisedTo {\\n            ans *= num\\n        }\\n        return ans\\n    }\\n    func largestPalindrome(_ n: Int) -> Int {\\n        if n == 1 { \\n            return 9 \\n        }\\n        let max = power(10, raisedTo: n)   // store the value of 10\\u207F \\n        for z in 2..<max { // since both x, y > 0 and z = x + y; which implies that z has a minimum value of 2\\n            let left = max - z  \\n            let right = Int(String(String(left).reversed()))! // reverese number\\n            let discriminant = power(z, raisedTo: 2) - 4 * right // b\\xB2 - 4ac\\n            \\n            if discriminant < 0 { // no root\\n                continue\\n            } else { // there exists at least one real solution\\n                // calculate the roots\\n                let roots = (first: 0.5 * (Double(z) + Double(discriminant).squareRoot()),\\n                            second: 0.5 * (Double(z) - Double(discriminant).squareRoot()))\\n                if isInt(roots.first) || isInt(roots.second) {\\n                    return (max * left + right) % 1337\\n                }\\n            }\\n        }\\n        return 0\\n    }\\n}\\n```\\n\\nReference: https://medium.com/@d_dchris/largest-palindrome-product-problem-brilliant-approach-using-mathematics-python3-leetcode-479-b3f2dd91b1aa",
                "solutionTags": [
                    "Python3",
                    "Swift",
                    "Math"
                ],
                "code": "```\\nproduct = multiplicand * multiplier\\nNow for an n-digit number, the maximum a multiplicand or a multiplier can be is (10\\u207F - 1). So,\\nproduct = \\n           = (10\\u207F - x) * (10\\u207F - y)           (where x, y > 0); n = no. of digits\\n           = 10\\xB2\\u207F - 10\\u207Fx - 10\\u207Fy + xy\\n           = 10\\xB2\\u207F - 10\\u207F(x + y) + xy\\n           = 10\\u207F * (10\\u207F - (x + y)) + xy\\n           = 10\\u207F * left + right               (let left = 10\\u207F - (x + y) and right = xy)\\n```\n```\\n      right = xy\\n      let z = x + y\\n      \\u2234 right = x(z - x)\\n      \\u2234 right = zx - x\\xB2\\n      \\u2234 x\\xB2 - zx + right = 0\\n\\nWhich is a quadratic equation!\\n\\tax\\xB2 + bx + c = 0\\n\\t\\tx = -b \\xB1 \\u221A(b\\xB2 - 4ac)\\n\\t\\t\\t----------------\\n\\t\\t\\t\\t   2a\\n\\twhere; a = 1\\n\\t\\t  b = -z\\n\\t\\t  c = right\\n```\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        maxi = 10 ** n   # store the value of 10\\u207F \\n        for z in range(2, maxi): # since both x, y > 0 and z = x + y; which implies that z has a minimum value of 2\\n            left = maxi - z\\n            right = int(str(left)[::-1]) # reverese number\\n            \\n            discriminant = z ** 2 - 4 * right # b\\xB2 - 4ac\\n            if discriminant < 0: # no root\\n                continue\\n            else: # there exists at least one real solution; so calculate the roots\\n                root_1 = (z + discriminant ** 0.5) / 2\\n                root_2 = (z - discriminant ** 0.5) / 2\\n                if root_1.is_integer() or root_2.is_integer():\\n                    return (maxi * left + right) % 1337\\n```\n```isInt()```\n```power()```\n```\\nclass Solution {\\n    private func isInt(_ num: Double) -> Bool {\\n        return num.truncatingRemainder(dividingBy: 1) == 0\\n    }\\n    private func power(_ num: Int, raisedTo: Int) -> Int {\\n        guard raisedTo != 0 else { return 0 }\\n        guard raisedTo != 1 else { return num }\\n        var ans = num\\n        for _ in 2...raisedTo {\\n            ans *= num\\n        }\\n        return ans\\n    }\\n    func largestPalindrome(_ n: Int) -> Int {\\n        if n == 1 { \\n            return 9 \\n        }\\n        let max = power(10, raisedTo: n)   // store the value of 10\\u207F \\n        for z in 2..<max { // since both x, y > 0 and z = x + y; which implies that z has a minimum value of 2\\n            let left = max - z  \\n            let right = Int(String(String(left).reversed()))! // reverese number\\n            let discriminant = power(z, raisedTo: 2) - 4 * right // b\\xB2 - 4ac\\n            \\n            if discriminant < 0 { // no root\\n                continue\\n            } else { // there exists at least one real solution\\n                // calculate the roots\\n                let roots = (first: 0.5 * (Double(z) + Double(discriminant).squareRoot()),\\n                            second: 0.5 * (Double(z) - Double(discriminant).squareRoot()))\\n                if isInt(roots.first) || isInt(roots.second) {\\n                    return (max * left + right) % 1337\\n                }\\n            }\\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398405,
                "title": "easy-python-solution-accepted",
                "content": "Got TLE first.\\n\\nThen I observed two things:\\n\\n1. if the final result is of length 2n, because it is Palindrom, the result can be divided by 11 (that means that we do not have to search with step size of 1 but step size of 11---ten times faster!\\n2. The constructed palindrom, for example n =7:  ABCDEFGGFEDCBA, if it is divisible by two number of size n, both numbers will be greater than number ABCDEFG. Why? because  ABCDEFGGFEDCBA > ABCDEFG * 10^n, note that 10^n is a number of size (n+1). \\nWith the above two derived characters, TLE is avoided:)\\n\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        \\n        hi, lo = 10**n -1, 10**(n-1)\\n        top = (hi // 11) * 11\\n        \\n        for left in range(hi, lo-1, -1):\\n            res = int(str(left) + str(left)[::-1])\\n            \\n            for d in range(top, left -1, -11):\\n                if res % d == 0:\\n                    q = res // d\\n                    \\n                    if lo <= q <= hi:\\n                        return res % 1337\\n```\\n\\nIf you like my post, please upvote:)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        \\n        hi, lo = 10**n -1, 10**(n-1)\\n        top = (hi // 11) * 11\\n        \\n        for left in range(hi, lo-1, -1):\\n            res = int(str(left) + str(left)[::-1])\\n            \\n            for d in range(top, left -1, -11):\\n                if res % d == 0:\\n                    q = res // d\\n                    \\n                    if lo <= q <= hi:\\n                        return res % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276101,
                "title": "python3-math-and-non-math-solutions-with-detailed-explanation",
                "content": "**Non-math solution:**\\nmaximum assumed palindrom: iterate by the first half of maxNumber\\na palindrome with an even number of digits is a multiple of 11\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1: return 9\\n        hi = 10**n - 1\\n        lo = 10**(n-1)\\n        maxNum = hi*hi\\n        firstHalf = maxNum // (10**n)\\n        for first in range(firstHalf, lo-1, -1):\\n            second = str(first)[::-1]\\n            num = int(str(first) + second)\\n            y_hi = hi//11*11\\n            for y in range(y_hi, lo-1, -11):\\n                if num % y == 0 and lo <= num // y <= hi:\\n                    return num % 1337\\n                if num // y > hi:\\n                    break\\n```\\n\\n**Math solution:**\\nLet `Palindrome = X * Y`, both have `n` digits, and assume they are very close to `10^n`\\nDenote `X = 10^n - i, Y = 10^n - j`, with assumption: `i*j < 10^n`\\n`Palindrome = upper*10^n + lower = (10^n - i)*(10^n - j) = (10^n-i-j)*10^n + i*j`\\ntherefore: `upper = 10^n-i-j, lower = i*j`\\nLet **`a = i + j`**, then `lower = i*(a-i), upper = 10^n-a`\\nAlgorithm: we iterate **`a`** and search for an integer i\\n`i^2 - a*i + lower = 0  => (i-a/2)^2 = 0.25*a^2 - lower`\\nGiven **a** start from 2, check if `sqrt(a^2 - lower*4)` is an integer, then return `upper*10^n + lower`\\n\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1: return 9\\n        a = 2\\n        while a < 10**n:\\n            upper = 10**n-a\\n            lower = int(str(upper)[::-1])\\n            if a**2-lower*4 >= 0 and (a**2-lower*4)**0.5 == int((a**2-lower*4)**0.5):\\n                return (upper*10**n+lower) % 1337\\n            a += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1: return 9\\n        hi = 10**n - 1\\n        lo = 10**(n-1)\\n        maxNum = hi*hi\\n        firstHalf = maxNum // (10**n)\\n        for first in range(firstHalf, lo-1, -1):\\n            second = str(first)[::-1]\\n            num = int(str(first) + second)\\n            y_hi = hi//11*11\\n            for y in range(y_hi, lo-1, -11):\\n                if num % y == 0 and lo <= num // y <= hi:\\n                    return num % 1337\\n                if num // y > hi:\\n                    break\\n```\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1: return 9\\n        a = 2\\n        while a < 10**n:\\n            upper = 10**n-a\\n            lower = int(str(upper)[::-1])\\n            if a**2-lower*4 >= 0 and (a**2-lower*4)**0.5 == int((a**2-lower*4)**0.5):\\n                return (upper*10**n+lower) % 1337\\n            a += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834073,
                "title": "simple-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfinding the palindrome and trying to find is there a element n digit elemnet dividing that palinbdrome\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if(n==1)\\n        {\\n            return 9;\\n        }\\n        int hi=pow(10,n)-1;\\n        int lo=pow(10,n-1);\\n        int kk=1337;\\n        for(int i=hi;i>=lo;i--)\\n        {\\n            string s=to_string(i);\\n            string k=s;\\n            reverse(k.begin(),k.end());\\n            s+=k;\\n            long long int ll=stol(s);\\n            for(int j=hi;j>=sqrtl(ll);j--)\\n            {\\n                if(ll%j==0)\\n                {\\n                    return ll%kk;\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if(n==1)\\n        {\\n            return 9;\\n        }\\n        int hi=pow(10,n)-1;\\n        int lo=pow(10,n-1);\\n        int kk=1337;\\n        for(int i=hi;i>=lo;i--)\\n        {\\n            string s=to_string(i);\\n            string k=s;\\n            reverse(k.begin(),k.end());\\n            s+=k;\\n            long long int ll=stol(s);\\n            for(int j=hi;j>=sqrtl(ll);j--)\\n            {\\n                if(ll%j==0)\\n                {\\n                    return ll%kk;\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911228,
                "title": "c-3ms-fast-math-based-solution-with-explanation",
                "content": "This is based on a very nicely explained article on:\\nhttps://medium.com/@d_dchris/largest-palindrome-product-problem-brilliant-approach-using-mathematics-python3-leetcode-479-b3f2dd91b1aa\\nThe main idea is to  based around the fact that we represent the biggest palindrome number as `(10^n -x)*(10^n-y)` and we want to find the smallest `x` and `y` (greater than 1 to respect the constraint of the input digits) so that  the result is a palindrome.\\nLet\\'s call the biggest palindrome `P`. We could say that  `(10^n -x)*(10^n-y) = P` and expanding that equation we could obtain that `10^n*(10^n -(x+y)) + xy = P`. This is a very convenient representation as soon as we notice that two `n` digits numbers could generate a `2n` digits palindrome (or 2n-1 but we are looking for the biggest) and we represent a `2n` digit palindrome such as `abcddcba` as `10^n*abcd + dcba`. Now we could say that we have a `left` side `abcd` and a right side `dcba = flip(left)` and also that `left = 10^n - (x+y)` and `right = xy`. Let\\'s call `x+y = z` and start solving the resulting equation `right = xy` -> `right = x(z-x)` -> `right - xz - x^2 = 0`  from `z=2` since `x` and `y` needs to be at least `1` each.\\n\\n```\\nclass Solution {\\npublic:\\n    int flip(int n){\\n        // given integer abc returns intger cba by going to a temporary string\\n        auto str = to_string(n);\\n        std::reverse(str.begin(), str.end());\\n        return atoi(str.c_str());\\n    }\\n       \\n    bool isInteger(double v){\\n        // checks if the double v represents an integer value\\n        double tmp;\\n        return std::modf(v, &tmp) == 0.0;\\n        // alternative less robust implementation\\n        // return  static_cast<double>(static_cast<long>(v)) == v;\\n    }\\n    \\n    int largestPalindrome(int n) {\\n        \\n        if (n == 1) return 9;\\n        \\n        const long max = pow(10, n);\\n        \\n        for (int z = 2; z < max -1; z++){\\n            const long left = max -z;\\n            const long right = flip(left);\\n            const double sqrt_term = z*z - 4*right;\\n           \\n\\t\\t    // let\\'s avoid generating nans applying the square root to negative numbers\\n            if (sqrt_term < 0.0){ continue; }\\n            \\n            const double root1 = 0.5*(z + sqrt(sqrt_term));\\n            const double root2 = 0.5*(z - sqrt(sqrt_term));\\n            \\n            if (isInteger(root1) || isInteger(root2)){\\n                return (max*left + right) % 1337;\\n            }\\n        }\\n\\t\\t// This should never be reached so we don\\'t really care about what we return in here\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flip(int n){\\n        // given integer abc returns intger cba by going to a temporary string\\n        auto str = to_string(n);\\n        std::reverse(str.begin(), str.end());\\n        return atoi(str.c_str());\\n    }\\n       \\n    bool isInteger(double v){\\n        // checks if the double v represents an integer value\\n        double tmp;\\n        return std::modf(v, &tmp) == 0.0;\\n        // alternative less robust implementation\\n        // return  static_cast<double>(static_cast<long>(v)) == v;\\n    }\\n    \\n    int largestPalindrome(int n) {\\n        \\n        if (n == 1) return 9;\\n        \\n        const long max = pow(10, n);\\n        \\n        for (int z = 2; z < max -1; z++){\\n            const long left = max -z;\\n            const long right = flip(left);\\n            const double sqrt_term = z*z - 4*right;\\n           \\n\\t\\t    // let\\'s avoid generating nans applying the square root to negative numbers\\n            if (sqrt_term < 0.0){ continue; }\\n            \\n            const double root1 = 0.5*(z + sqrt(sqrt_term));\\n            const double root2 = 0.5*(z - sqrt(sqrt_term));\\n            \\n            if (isInteger(root1) || isInteger(root2)){\\n                return (max*left + right) % 1337;\\n            }\\n        }\\n\\t\\t// This should never be reached so we don\\'t really care about what we return in here\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676360,
                "title": "c-algorithm-faster-than-100-and-less-memory-than-100-and-its-python-equivalent",
                "content": "I wrote this algorithm in python at first and it was pretty fast imo (aroudn 2.5 seconds for all 8 case) but exceeded it exceeded the time limit. So I just rewrote it in C and got faster than 100% and less memory than 100% (probably because no one else submitted it in C lol).\\n\\n```py\\ndef largestPalindrome(n: int) -> int:\\n    S = 10**n-1\\n    Sr = S - (S%11)\\n    Pmax = 9 # start Pmax at 9 to work for n=1\\n    for i in range(Sr, (10**(n-1))*9-1, -11):\\n        for j in range(S, (10**(n-1))-1, -2):\\n            p = i*j\\n            if p < Pmax:\\n                break\\n            sr = str(p)\\n            if sr == sr[::-1]:\\n                Pmax = p\\n                break\\n        if S*(i-11) < Pmax:\\n            break\\n    return Pmax % 1337\\n```\\nI managed to optimise the search space by using several methods:\\n1. The outer search starts at the biggest possible number that is divisible by 11 and decreases by 11 steps each loop, which reduced the search space to 1/11. This works because the palindroms will always have an even number of digits, so they will always be divisible by 11.\\n2. The inner search decreases by 2 steps each loop, which also decreases the search space to 1/2. I did this because I assumed the biggest palindrome is going to start with a 9, so that means that the palindrome can\\'t be even. The first number is always odd because it\\'s always a multiple of 11. The second number starts at 99..99, so it starts as an odd number, so I decrease it by 2 each step to skip the even numbers.\\n3. The outer search covers only the largest 10% of the numbers, which decreases the search space to 1/10. This works because it\\'s fair to assume that the numbers are on the larger side. I tested up with different values and managed to get it up to the largest 10% while getting correct results up to at least n=10, I didn\\'t test further.\\n4. The inner search stops when it reaches a number that\\'s larger than the previously largest palindrome since it will only continue to decrease from now on.\\n\\n1-3 decrease the search space to around 0.0045x of the full search space. And 4 decreases it further by stopping the inner search early in about the largest 20% of its range, decreasing the search space to around 0.0009x.\\n\\nHere is the code in C:\\n```c\\nint largestPalindrome(int n)\\n{\\n    long long S = pow(10, n) - 1;\\n    long long Sr = S - (S % 11);\\n    long long Pmax = 9;\\n    for (long long i = Sr; i >= pow(10, n-1)*9; i-=11)\\n    {\\n        for (long long j = S; j >= pow(10, n-1); j-=2)\\n        {\\n            long long p = i*j;\\n            if (p < Pmax) break;\\n            /* this part just gets the reversed p */\\n            long long Po = p;\\n            long long Pr = 0;\\n            while (p != 0)\\n            {\\n                int rem = p % 10;\\n                Pr = Pr*10 + rem;\\n                p /= 10;\\n            }\\n            if (Po == Pr) Pmax = Po;\\n        }\\n        if (S*(i-11) < Pmax) break;\\n    }\\n    return Pmax % 1337;\\n}\\n```",
                "solutionTags": [],
                "code": "```py\\ndef largestPalindrome(n: int) -> int:\\n    S = 10**n-1\\n    Sr = S - (S%11)\\n    Pmax = 9 # start Pmax at 9 to work for n=1\\n    for i in range(Sr, (10**(n-1))*9-1, -11):\\n        for j in range(S, (10**(n-1))-1, -2):\\n            p = i*j\\n            if p < Pmax:\\n                break\\n            sr = str(p)\\n            if sr == sr[::-1]:\\n                Pmax = p\\n                break\\n        if S*(i-11) < Pmax:\\n            break\\n    return Pmax % 1337\\n```\n```c\\nint largestPalindrome(int n)\\n{\\n    long long S = pow(10, n) - 1;\\n    long long Sr = S - (S % 11);\\n    long long Pmax = 9;\\n    for (long long i = Sr; i >= pow(10, n-1)*9; i-=11)\\n    {\\n        for (long long j = S; j >= pow(10, n-1); j-=2)\\n        {\\n            long long p = i*j;\\n            if (p < Pmax) break;\\n            /* this part just gets the reversed p */\\n            long long Po = p;\\n            long long Pr = 0;\\n            while (p != 0)\\n            {\\n                int rem = p % 10;\\n                Pr = Pr*10 + rem;\\n                p /= 10;\\n            }\\n            if (Po == Pr) Pmax = Po;\\n        }\\n        if (S*(i-11) < Pmax) break;\\n    }\\n    return Pmax % 1337;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 150954,
                "title": "fast-algorithm-by-constrains-on-tail-digits",
                "content": "## Basic Ideas\\n## Trailing 9s\\nThe idea is based on the observation that there are always at least t=n//2 trailing 9 in the tail of Largest Palindrome Product:\\n```\\n 1       9\\n 2       900_9\\n 3       90660_9\\n 4       990000_99\\n 5       99660066_99\\n 6       999000000_999\\n 7       99956644665_999\\n 8       999900000000_9999\\n 9       99990066556600_9999\\n10       999998340000438_99999\\n11       9999994020000204_999999\\n```\\n\\nWe first enumerate all combinations of t=n//2 digit number whose product gives 999..99 ending\\n+ For t=1, there are only `1*9%10=9, 3*3%10=9, 7*7%10=9`. \\n    + So for n=3, we only search for i, j with the form `XY1, XY9, XY3`, where XY represents a number in range 0~9.\\n+ For t=2, the possible tail combinations are: `{(1, 99), (13, 23), (49, 51), (77, 87), (63, 73), (3, 33), (29, 31), (27, 37), (69, 71), (7, 57), (39, 41), (43, 93), (67, 97), (9, 11), (79, 81), (89, 91), (17, 47), (53, 83), (59, 61), (19, 21)}`\\n+ For larger t, the number of combinations is essentially `2*10**(t-1)`\\n\\nWith constraints on the tail, the search space of tail is reduced from `10**2t` to `2*10**(t-1)`\\n\\n## Searching order\\nLets define head digits to be digits starting n-n//2 digits. We first search solutions with product of head digits larger than `999*999`, then `998*998`, then `997*997` and so on.\\n\\n## Performance\\nIt only takes less than 0.1s to give all results for n<=8. For n<=13, it takes 3 seconds to give:\\n```\\n n  i*j%1337 (i, j) i*j\\n 1         9 (9, 1) 9\\n 2       987 (91, 99) 9009\\n 3       123 (993, 913) 906609\\n 4       597 (9901, 9999) 99000099\\n 5       677 (99979, 99681) 9966006699\\n 6      1218 (999001, 999999) 999000000999\\n 7       877 (9998017, 9997647) 99956644665999\\n 8       475 (99990001, 99999999) 9999000000009999\\n 9      1226 (999980347, 999920317) 999900665566009999\\n10       875 (9999986701, 9999996699) 99999834000043899999\\n11       108 (99999943851, 99999996349) 9999994020000204999999\\n12       378 (999999000001, 999999999999) 999999000000000000999999\\n13      1097 (9999999993349, 9999996340851) 99999963342000024336999999\\n```\\n\\n## Code\\n```\\nT=[set([(0, 0)])]\\n\\ndef double(it):\\n    for a, b in it:\\n        yield a, b\\n        yield b, a\\n\\ndef tails(n):\\n    \\'\\'\\'Construct pair of n-digit numbers that their product ends with 99...9 pattern\\'\\'\\'\\n    if len(T)<=n:\\n        l = set()\\n        for i in range(10):\\n            for j in range(i, 10):\\n                I = i*10**(n-1)\\n                J = j*10**(n-1)\\n                it = tails(n-1)\\n                if I!=J: it = double(it)\\n                for t1, t2 in it:\\n                    if ((I+t1)*(J+t2)+1)%10**n == 0:\\n                        l.add((I+t1, J+t2))\\n        T.append(l)\\n    return T[n]\\n\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        tail = n//2\\n        head = n - tail\\n        up=10**head\\n        for L in range(1, 9*10**(head-1)+1):\\n            # Consider small shell (up-L)^2 < (up-i)*(up-j) <= (up-L)^2, 1<=i<=L<=j\\n            m = 0\\n            sol = None\\n            for i in range(1, L+1):\\n                lo = max(i, int(up-(up-L+1)**2/(up-i))+1)\\n                hi = int(up-(up-L)**2/(up-i))\\n                for j in range(lo, hi+1):\\n                    I = (up-i)*10**tail\\n                    J = (up-j)*10**tail\\n                    it = tails(tail)\\n                    if I!=J: it = double(it)\\n                    for t1, t2 in it:\\n                        val = (I+t1)*(J+t2)\\n                        s = str(val)\\n                        if s == s[::-1] and val>m:\\n                            sol = (I+t1, J+t2)\\n                            m = val\\n            if m:\\n                print(\"{:2d}\\\\t{:4d}\".format(n, m%1337), sol, sol[0]*sol[1])\\n                return m%1337\\n\\nif __name__ == \"__main__\":\\n    s = Solution()\\n    for i in range(1, 14):\\n        s.largestPalindrome(i)\\n```",
                "solutionTags": [],
                "code": "```\\n 1       9\\n 2       900_9\\n 3       90660_9\\n 4       990000_99\\n 5       99660066_99\\n 6       999000000_999\\n 7       99956644665_999\\n 8       999900000000_9999\\n 9       99990066556600_9999\\n10       999998340000438_99999\\n11       9999994020000204_999999\\n```\n```\\n n  i*j%1337 (i, j) i*j\\n 1         9 (9, 1) 9\\n 2       987 (91, 99) 9009\\n 3       123 (993, 913) 906609\\n 4       597 (9901, 9999) 99000099\\n 5       677 (99979, 99681) 9966006699\\n 6      1218 (999001, 999999) 999000000999\\n 7       877 (9998017, 9997647) 99956644665999\\n 8       475 (99990001, 99999999) 9999000000009999\\n 9      1226 (999980347, 999920317) 999900665566009999\\n10       875 (9999986701, 9999996699) 99999834000043899999\\n11       108 (99999943851, 99999996349) 9999994020000204999999\\n12       378 (999999000001, 999999999999) 999999000000000000999999\\n13      1097 (9999999993349, 9999996340851) 99999963342000024336999999\\n```\n```\\nT=[set([(0, 0)])]\\n\\ndef double(it):\\n    for a, b in it:\\n        yield a, b\\n        yield b, a\\n\\ndef tails(n):\\n    \\'\\'\\'Construct pair of n-digit numbers that their product ends with 99...9 pattern\\'\\'\\'\\n    if len(T)<=n:\\n        l = set()\\n        for i in range(10):\\n            for j in range(i, 10):\\n                I = i*10**(n-1)\\n                J = j*10**(n-1)\\n                it = tails(n-1)\\n                if I!=J: it = double(it)\\n                for t1, t2 in it:\\n                    if ((I+t1)*(J+t2)+1)%10**n == 0:\\n                        l.add((I+t1, J+t2))\\n        T.append(l)\\n    return T[n]\\n\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        tail = n//2\\n        head = n - tail\\n        up=10**head\\n        for L in range(1, 9*10**(head-1)+1):\\n            # Consider small shell (up-L)^2 < (up-i)*(up-j) <= (up-L)^2, 1<=i<=L<=j\\n            m = 0\\n            sol = None\\n            for i in range(1, L+1):\\n                lo = max(i, int(up-(up-L+1)**2/(up-i))+1)\\n                hi = int(up-(up-L)**2/(up-i))\\n                for j in range(lo, hi+1):\\n                    I = (up-i)*10**tail\\n                    J = (up-j)*10**tail\\n                    it = tails(tail)\\n                    if I!=J: it = double(it)\\n                    for t1, t2 in it:\\n                        val = (I+t1)*(J+t2)\\n                        s = str(val)\\n                        if s == s[::-1] and val>m:\\n                            sol = (I+t1, J+t2)\\n                            m = val\\n            if m:\\n                print(\"{:2d}\\\\t{:4d}\".format(n, m%1337), sol, sol[0]*sol[1])\\n                return m%1337\\n\\nif __name__ == \"__main__\":\\n    s = Solution()\\n    for i in range(1, 14):\\n        s.largestPalindrome(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150068,
                "title": "9-line-c-solution",
                "content": "```\\n\\n    int largestPalindrome(int n) {\\n\\tif (n == 1)return 9;\\n\\tlong long max = pow(10, n) - 1;\\n\\tfor (int v = max - 1; v>(max / 10); v--) {\\n\\t\\tstring s = to_string(v), s0 = s;\\n\\t\\treverse(s.begin(), s.end());\\n\\t\\tlong long u = atoll((s0 + s).c_str());\\n\\t\\tfor (long long x = max; x*x >= u; x--)if (u%x == 0)return(int)(u%1337);\\n\\t}\\n\\treturn 0;\\n    }\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\nThis is just a conversion from the \"An easy 9-line Java solution\" by ckcz123 plus some explanation.\\n\\n- max is the biggest possible n digit number\\n- you may have noticed that \\n9x9 = 81\\n99x99 = 9801\\n999x999 = 998001\\n9999x9999 = 9980001\\netc.\\nThe biggest possibe n digit numbers multipled together are never palindromes. So the first loop iteration is from max-1. \\n\\n- v will be used to generate a palindrome and will get smaller in every iteration. This solution assumes that a palindrome will be found before v becomes 10x smaller than the biggest possible n digit number (max). This must be true because if v becomes 10x smaller, it will no longer be an n digit number.\\n\\n- Generating the palindrome from v is fairly straight forward except in C++ you have to make sure your variables are big enough to hold the numbers.\\n\\n- The second for loop relies on some key observations. \\n\\n1. If x is one of the numbers that can be multiplied with something else to make the palindrome, then that something else cannot be bigger than x. Since the solution starts from the biggest numbers and works back, if a bigger number than x was part of the solution, it would have been found earlier.\\n2. If x is not a multiple, next we check if x-1 is big enough to be a multiple for the palindrome u.\\n3. If at any point x^2 is found to be smaller than the palindrome u then it cannot be a multiple for it since all numbers greater than x have been checked and the numbers below it will only further decrease the value of x^2.\\n\\n- Once a multiple is found for u we know that it comes from x and x%u, and that u is the biggest palindrome possible given those numbers.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n    int largestPalindrome(int n) {\\n\\tif (n == 1)return 9;\\n\\tlong long max = pow(10, n) - 1;\\n\\tfor (int v = max - 1; v>(max / 10); v--) {\\n\\t\\tstring s = to_string(v), s0 = s;\\n\\t\\treverse(s.begin(), s.end());\\n\\t\\tlong long u = atoll((s0 + s).c_str());\\n\\t\\tfor (long long x = max; x*x >= u; x--)if (u%x == 0)return(int)(u%1337);\\n\\t}\\n\\treturn 0;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96323,
                "title": "time-limit-exceeded-in-python",
                "content": "I have tried a couple of variation, most recently a Python port of the \"Java Solution using assumed max palindrome.\"  As optimized as I know how to get it using just Python, I still get a \"Time Limit Exceeded\" error at n = 8.  On my system (2 Ghz i7 MacBook) this one step takes about 20 seconds.\\n\\nAnyway to get this through?  Code is below.\\n```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1: return 9\\n    \\n        upper = 10**n-1             # Largest n-digit number\\n        firstHalf = int(upper*upper/10**n)   # First n digits of largest palindrome\\n        \\n        # Loop over palindromes\\n        found = False\\n        while not found:\\n            secondHalf = int(str(firstHalf)[::-1])\\n            tryThis = firstHalf*10**n + secondHalf\\n            \\n            # Loop over a.  If a is an integer multiple of tryThis, you win.\\n            for a in xrange(upper, 0, -1):\\n                \\n                # Test for b more than n digits or a^2 greater than the palindrome.\\n                # (The second check is valid because we are searching in decreasing order of a).\\n                if tryThis/a > upper or a*a < tryThis: \\n                    break\\n                if tryThis % a == 0: \\n                    found = True\\n                    break\\n            firstHalf -= 1\\n        return tryThis % 1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1: return 9\\n    \\n        upper = 10**n-1             # Largest n-digit number\\n        firstHalf = int(upper*upper/10**n)   # First n digits of largest palindrome\\n        \\n        # Loop over palindromes\\n        found = False\\n        while not found:\\n            secondHalf = int(str(firstHalf)[::-1])\\n            tryThis = firstHalf*10**n + secondHalf\\n            \\n            # Loop over a.  If a is an integer multiple of tryThis, you win.\\n            for a in xrange(upper, 0, -1):\\n                \\n                # Test for b more than n digits or a^2 greater than the palindrome.\\n                # (The second check is valid because we are searching in decreasing order of a).\\n                if tryThis/a > upper or a*a < tryThis: \\n                    break\\n                if tryThis % a == 0: \\n                    found = True\\n                    break\\n            firstHalf -= 1\\n        return tryThis % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96336,
                "title": "c-solution-with-some-comments",
                "content": "rewrite @ZhassanB  solution into C++\\n\\n   \\n \\n   \\n    class Solution {\\n    public:\\n    int largestPalindrome(int n) {\\n           if(n == 1) {\\n            return 9;\\n        }\\n        \\n        long maxNum = pow(10, n) - 1;\\n        long possibleNum = maxNum * maxNum;\\n        \\n        long divider = pow(10,n);\\n        long left = possibleNum / divider;   //Find the left part\\n        long right = possibleNum % divider; //Find the right part\\n        \\n        if(left == reverts(right)) {  // if they are palindrome\\n            return possibleNum % 1337;\\n        }\\n        \\n        /* example: if number is 9869, then the possibleNum  can only be 9779, if number is 9379, then the possibleNum can be 9339, \\n       so the left part number is determined by the function below*/\\n        if(reverts(left) > right) {\\n            left --;\\n        }\\n        \\n        possibleNum = left * divider + reverts(left);\\n        \\n        while(left >= divider / 10) { // left should be no smaller than pow(10, n-1)\\n            for(long i = maxNum; i > possibleNum/i; i --) {\\n                if(possibleNum % i == 0) {\\n                    return possibleNum % 1337;\\n                }\\n            }\\n            left --;\\n            possibleNum = left * divider + reverts(left);\\n        }\\n        \\n        return possibleNum % 1337;\\n    }\\n    \\n    private:\\n        long reverts(long right) {\\n           long result = 0;\\n           while(right != 0) {\\n               result = 10* result + right%10;\\n               right /= 10;\\n          }\\n        return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int largestPalindrome(int n) {\\n           if(n == 1) {\\n            return 9;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3281253,
                "title": "479-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. If n is 1, return 9.\\n2. Set upper to the largest n-digit number (10^n - 1) and lower to the smallest n-digit number (10^(n-1)).\\n3. Starting from upper, iterate through all possible n-digit numbers i in descending order.\\n4. Construct a palindrome number pal by concatenating the string of i and its reversed string.\\n5. Starting from upper, iterate through all possible n-digit numbers j in descending order until j is less than the square root of pal.\\n6. Check if pal is divisible by j without any remainder and if the quotient of pal divided by j is an n-digit number.\\n7. If pal is divisible by j without any remainder and the quotient is an n-digit number, return the result of pal modulo 1337.\\n8. If no palindrome product is found, return -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        \\n        upper = pow(10, n) - 1\\n        lower = pow(10, n - 1)\\n        \\n        for i in range(upper, lower-1, -1):\\n            s = str(i)\\n            # construct the palindrome number from its first half\\n            pal = int(s + s[::-1])\\n            # check if the palindrome number is the product of two n-digit numbers\\n            for j in range(upper, int(pow(pal, 0.5))-1, -1):\\n                if pal % j == 0 and len(str(pal//j)) == n:\\n                    return pal % 1337\\n        return -1  # no palindrome product found\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        \\n        upper = pow(10, n) - 1\\n        lower = pow(10, n - 1)\\n        \\n        for i in range(upper, lower-1, -1):\\n            s = str(i)\\n            # construct the palindrome number from its first half\\n            pal = int(s + s[::-1])\\n            # check if the palindrome number is the product of two n-digit numbers\\n            for j in range(upper, int(pow(pal, 0.5))-1, -1):\\n                if pal % j == 0 and len(str(pal//j)) == n:\\n                    return pal % 1337\\n        return -1  # no palindrome product found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451092,
                "title": "rant",
                "content": "I\\'m sick of all such implementation/brute force problems. Always looks like an interesting problem at first glance and then I look at the constraints and then I\\'m like here we go again. \\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2010371,
                "title": "another-way-javascript-solution-1-line-less-than-100-hahahaha",
                "content": "```\\nvar largestPalindrome = n => [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestPalindrome = n => [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96322,
                "title": "java-easy-to-understand-solution-92",
                "content": "Just one trick to speed up the processes, which is to start checking the factor X from `sqrt(Z)`:\\nwhere `Z=X*Y` and `X>=Y`.\\nFor example, if the left-part of palindrome is `90`, then `Z= 9009` and `sqrt(Z)=94`. \\n`X` must greater or equal to `94` and less than `100`.\\nThis is because of  the condition `X>=Y`, which makes `X` has  the lower bound of  `sqrt(Z)`.\\n```\\npublic class Solution {\\n    long[] tens = new long[]{1,10,100,1000,10000,100000,1000000,10000000,100000000};\\n    long getReverse(long num, int n){\\n        long ret = 0;\\n        for (int i=1; i<=n; i++){\\n            ret += (num%10)*tens[n-i];\\n            num /= 10;\\n        }\\n        return ret;\\n    }\\n\\n    public int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        long ret = 0, max = tens[n], min = tens[n-1];\\n        for (long i=max-1; i > 0; i--){\\n            ret = i* max + getReverse(i, n);\\n            for (long factor = (long)Math.sqrt(ret); factor < max; factor++)\\n                if (ret%factor==0 && ret/factor < max) \\n                    return (int)(ret%1337);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    long[] tens = new long[]{1,10,100,1000,10000,100000,1000000,10000000,100000000};\\n    long getReverse(long num, int n){\\n        long ret = 0;\\n        for (int i=1; i<=n; i++){\\n            ret += (num%10)*tens[n-i];\\n            num /= 10;\\n        }\\n        return ret;\\n    }\\n\\n    public int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        long ret = 0, max = tens[n], min = tens[n-1];\\n        for (long i=max-1; i > 0; i--){\\n            ret = i* max + getReverse(i, n);\\n            for (long factor = (long)Math.sqrt(ret); factor < max; factor++)\\n                if (ret%factor==0 && ret/factor < max) \\n                    return (int)(ret%1337);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96333,
                "title": "java-solution-115ms",
                "content": "There are two key points of this problem:\\n (1) how to efficiently generate the possible palindrome number in a greedy way?\\n (2) how to efficiently check whether the palindrome number can be made by two ***n***-digit numbers product?\\n\\nHere are my answers to the two points.\\n(1) First, think about how many digits of the possible palindrome number could be?\\n     It is could be a ***2n***-digit number, and also could be a (***2n-1***)-digit number.  For example, if n is 2, the smallest product of two 2-digits numbers is 100, which has 3 digits; and the largest product of two 2-digits numbers is 9801. \\n     So we can first the check the ***2n***-digit palindromes, then check the (***2n-1***)-digit palindromes; because the ***2n***-digit palindromes always larger than the (***2n-1***)-digit palindromes. If there is no valid ***2n***-digit palindrome number, nor  (***2n-1***)-digit palindrome number, then it can be sure that there will be no valid number (in this case, -1 is returned). \\n\\n  Second, try to generate the ***2n***-digit palindromes (see function *getParlindrome*) and  the (***2n-1***)-digit palindromes ( see function ***getOddParlindrome***) greedily.\\n     \\n(2) To check whether the (palindrome) number can be made by two ***n***-digit numbers product, I use the square root as the start points. Because I think the two ***n***-digit factors should be near to the square root. (see function ***isValid***)\\n\\n    protected long getParlindrome(int high, int n) {\\n        long result = high * (long)(Math.pow(10, n));\\n        \\n        int tmp = 0;\\n        while(high > 0) {\\n            tmp = tmp * 10 + high % 10;\\n            high = high/10;\\n        }\\n        \\n        return result + tmp;\\n    }\\n    \\n    protected long getOddParlindrome(int high, int mid, int n) {\\n        if(n == 0) {\\n            return mid;\\n        }\\n        \\n        long result = high * (long)(Math.pow(10, n+1))  + mid;\\n        \\n        int tmp = 0;\\n        while(high > 0) {\\n            tmp = tmp * 10 + high % 10;\\n            high = high /10;\\n        }\\n        \\n        return result + tmp;\\n    }\\n    \\n    protected boolean isValid(long val, int high, int low) {\\n        long root = (long)Math.sqrt(val);\\n        if(root > high || root < low) {\\n            return false;\\n        }\\n        \\n        long myh = root;\\n        long myl = root;\\n        long tmp = myh * myl;\\n        \\n        while(tmp != val) {\\n            if(tmp < val) {\\n                myh += 1;\\n                if(myh > high) {\\n                    return false;\\n                }\\n            } else {\\n                myl -= 1;\\n                if(myl < low) {\\n                    return false;\\n                }\\n            }\\n            \\n            tmp = myh * myl;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int largestPalindrome(int n) {\\n        \\n        long product = 0;\\n        int high = (int)Math.pow(10, n) - 1;\\n        int low = (int)Math.pow(10, n-1);\\n        \\n        //product = 2*n digits\\n        for(int i = high; i >= low; i --) {\\n            product = getParlindrome(i, n);\\n            if(isValid(product, high, low)) {\\n                return (int)(product % 1337);\\n            }\\n        }\\n        \\n        //product = 2*n-1 digits\\n        for(int i = low-1; i >= (int)(Math.pow(10, n-2)); i --) {\\n            for(int k = 9; k >= 0; k --) {\\n                product = getOddParlindrome(i, k, n-1);\\n                if(isValid(product, high, low)) {\\n                    return (int)(product % 1337);\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "There are two key points of this problem:\\n (1) how to efficiently generate the possible palindrome number in a greedy way?\\n (2) how to efficiently check whether the palindrome number can be made by two ***n***-digit numbers product?\\n\\nHere are my answers to the two points.\\n(1) First, think about how many digits of the possible palindrome number could be?\\n     It is could be a ***2n***-digit number, and also could be a (***2n-1***)-digit number.  For example, if n is 2, the smallest product of two 2-digits numbers is 100, which has 3 digits; and the largest product of two 2-digits numbers is 9801. \\n     So we can first the check the ***2n***-digit palindromes, then check the (***2n-1***)-digit palindromes; because the ***2n***-digit palindromes always larger than the (***2n-1***)-digit palindromes. If there is no valid ***2n***-digit palindrome number, nor  (***2n-1***)-digit palindrome number, then it can be sure that there will be no valid number (in this case, -1 is returned). \\n\\n  Second, try to generate the ***2n***-digit palindromes (see function *getParlindrome*) and  the (***2n-1***)-digit palindromes ( see function ***getOddParlindrome***) greedily.\\n     \\n(2) To check whether the (palindrome) number can be made by two ***n***-digit numbers product, I use the square root as the start points. Because I think the two ***n***-digit factors should be near to the square root. (see function ***isValid***)\\n\\n    protected long getParlindrome(int high, int n) {\\n        long result = high * (long)(Math.pow(10, n));\\n        \\n        int tmp = 0;\\n        while(high > 0) {\\n            tmp = tmp * 10 + high % 10;\\n            high = high/10;\\n        }\\n        \\n        return result + tmp;\\n    }\\n    \\n    protected long getOddParlindrome(int high, int mid, int n) {\\n        if(n == 0) {\\n            return mid;\\n        }\\n        \\n        long result = high * (long)(Math.pow(10, n+1))  + mid;\\n        \\n        int tmp = 0;\\n        while(high > 0) {\\n            tmp = tmp * 10 + high % 10;\\n            high = high /10;\\n        }\\n        \\n        return result + tmp;\\n    }\\n    \\n    protected boolean isValid(long val, int high, int low) {\\n        long root = (long)Math.sqrt(val);\\n        if(root > high || root < low) {\\n            return false;\\n        }\\n        \\n        long myh = root;\\n        long myl = root;\\n        long tmp = myh * myl;\\n        \\n        while(tmp != val) {\\n            if(tmp < val) {\\n                myh += 1;\\n                if(myh > high) {\\n                    return false;\\n                }\\n            } else {\\n                myl -= 1;\\n                if(myl < low) {\\n                    return false;\\n                }\\n            }\\n            \\n            tmp = myh * myl;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int largestPalindrome(int n) {\\n        \\n        long product = 0;\\n        int high = (int)Math.pow(10, n) - 1;\\n        int low = (int)Math.pow(10, n-1);\\n        \\n        //product = 2*n digits\\n        for(int i = high; i >= low; i --) {\\n            product = getParlindrome(i, n);\\n            if(isValid(product, high, low)) {\\n                return (int)(product % 1337);\\n            }\\n        }\\n        \\n        //product = 2*n-1 digits\\n        for(int i = low-1; i >= (int)(Math.pow(10, n-2)); i --) {\\n            for(int k = 9; k >= 0; k --) {\\n                product = getOddParlindrome(i, k, n-1);\\n                if(isValid(product, high, low)) {\\n                    return (int)(product % 1337);\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3373533,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int flip(int n){\\n        auto str = to_string(n);\\n        std::reverse(str.begin(), str.end());\\n        return atoi(str.c_str());\\n    }\\n    bool isInteger(double v){\\n        double tmp;\\n        return std::modf(v, &tmp) == 0.0;\\n    }\\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        const long max = pow(10, n);\\n        for (int z = 2; z < max -1; z++){\\n            const long left = max -z;\\n            const long right = flip(left);\\n            const double sqrt_term = z*z - 4*right;\\n           \\n            if (sqrt_term < 0.0){ continue; }\\n            \\n            const double root1 = 0.5*(z + sqrt(sqrt_term));\\n            const double root2 = 0.5*(z - sqrt(sqrt_term));\\n            \\n            if (isInteger(root1) || isInteger(root2)){\\n                return (max*left + right) % 1337;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        return [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]     \\n    def isPalindrome(x):\\n        return str(x) == str(x)[::-1]\\n    def solve(n):\\n        best = 0\\n        for i in range(10**n-1, 0, -1):\\n            for j in range(max(i, (best-1)//i+1), 10**n):\\n                if isPalindrome(i*j):\\n                    best = i*j\\n        return best\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int flip(int n){\\n        auto str = to_string(n);\\n        std::reverse(str.begin(), str.end());\\n        return atoi(str.c_str());\\n    }\\n    bool isInteger(double v){\\n        double tmp;\\n        return std::modf(v, &tmp) == 0.0;\\n    }\\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        const long max = pow(10, n);\\n        for (int z = 2; z < max -1; z++){\\n            const long left = max -z;\\n            const long right = flip(left);\\n            const double sqrt_term = z*z - 4*right;\\n           \\n            if (sqrt_term < 0.0){ continue; }\\n            \\n            const double root1 = 0.5*(z + sqrt(sqrt_term));\\n            const double root2 = 0.5*(z - sqrt(sqrt_term));\\n            \\n            if (isInteger(root1) || isInteger(root2)){\\n                return (max*left + right) % 1337;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        return [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]     \\n    def isPalindrome(x):\\n        return str(x) == str(x)[::-1]\\n    def solve(n):\\n        best = 0\\n        for i in range(10**n-1, 0, -1):\\n            for j in range(max(i, (best-1)//i+1), 10**n):\\n                if isPalindrome(i*j):\\n                    best = i*j\\n        return best\\n```\n```Java []\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757727,
                "title": "java-check-if-pal-is-a-product",
                "content": "Ref: https://leetcode.com/problems/largest-palindrome-product/discuss/96306/Java-solutions-with-two-different-approaches\\nhttps://www.youtube.com/watch?v=AKVEXDVqvvI\\n```\\n    public int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        long u = (long) (Math.pow(10, n) - 1), l = u / 10 + 1, half = u * u / (long) Math.pow(10, n);\\n        while(true) {\\n            long pal = Long.parseLong(half + new StringBuilder().append(half--).reverse().toString());\\n            for (long i = u; i * i >= pal && i > l; i--) if (pal % i == 0) return (int) (pal % 1337);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        long u = (long) (Math.pow(10, n) - 1), l = u / 10 + 1, half = u * u / (long) Math.pow(10, n);\\n        while(true) {\\n            long pal = Long.parseLong(half + new StringBuilder().append(half--).reverse().toString());\\n            for (long i = u; i * i >= pal && i > l; i--) if (pal % i == 0) return (int) (pal % 1337);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 585869,
                "title": "rust-mathematically-unsound-math",
                "content": "This is a math based solution that is only valid for this particular problem of 0 < n < 9. If you make the assumption that the smallest factor of the largest palindrome will be close to the square root of the palindrome then you can pick some arbitrary floor near the square root.\\n\\nThis solution makes another assumption as well. At least one factor of the palindrome must be divisible by 11. This solution assumes (with no rational basis) that the larger factor of n digits will be divisible by 11. This turns out to be true for n = 2, 4, 5, 6, 8 but not n = 3, 7. Thus the floor for the search must be lowered beyond the square root to account for n = 3 or n = 7. \\n\\nIt\\'s pretty fast, ~35msec for n = 8, which I think is as fast as any solution not using a cheating dictionary/hashmap.\\n\\n```\\nimpl Solution {\\n    pub fn largest_palindrome(n: i32) -> i32 {\\n        \\n        let min_factor = (10_i32.pow(n as u32 - 1)) as i64;\\n        let max = (10_i32.pow(n as u32)-1) as i64;\\n        let max_factor = (max / 11) * 11; \\n\\t\\t// because integer division, this gives the largest n digit number divisible by 11\\n            \\n        for i in (min_factor..=max).rev() { \\n\\t\\t// reverse the range to start with the biggest n digit number first and decrement from there as needed\\n            let palindrome = build_palindrome(i, n); // mirror the digits to create your palindrome\\n            let lower = (palindrome as f64).sqrt().floor() as i64 - (44 * (n as i64 - 2)); \\n\\t\\t\\t// the square root is a reasonable guess for a starting point, but we have this arbitrary \\n\\t\\t\\t// fudge factor that works for our given cases without any guarantee it will work for other cases\\n\\t\\t\\t\\n            for j in (lower..=max_factor).rev().step_by(11) { \\n\\t\\t\\t// we step by 11 b/c we assume the larger factor is divisible by 11\\n\\t\\t\\t// because our lower limit goes beyond the square root we still catch \\n\\t\\t\\t// some smaller factors divisible by 11 if necessary\\n\\t\\t\\t\\n                if palindrome % j == 0 && (palindrome / j) / (max+1) == 0 {\\n                    return (palindrome % 1337) as i32\\n                }\\n            }\\n        }\\n        9\\n    }\\n}\\n\\nfn build_palindrome(i: i64, n: i32) -> i64 {\\n    let mut x = i * 10_i64.pow(n as u32);\\n    \\n    let mut y = i;\\n    let mut pal = 0;\\n    while y > 0 {\\n        pal = 10 * pal + y % 10;\\n        y /= 10;\\n        \\n    }\\n    pal += x;\\n    pal\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_palindrome(n: i32) -> i32 {\\n        \\n        let min_factor = (10_i32.pow(n as u32 - 1)) as i64;\\n        let max = (10_i32.pow(n as u32)-1) as i64;\\n        let max_factor = (max / 11) * 11; \\n\\t\\t// because integer division, this gives the largest n digit number divisible by 11\\n            \\n        for i in (min_factor..=max).rev() { \\n\\t\\t// reverse the range to start with the biggest n digit number first and decrement from there as needed\\n            let palindrome = build_palindrome(i, n); // mirror the digits to create your palindrome\\n            let lower = (palindrome as f64).sqrt().floor() as i64 - (44 * (n as i64 - 2)); \\n\\t\\t\\t// the square root is a reasonable guess for a starting point, but we have this arbitrary \\n\\t\\t\\t// fudge factor that works for our given cases without any guarantee it will work for other cases\\n\\t\\t\\t\\n            for j in (lower..=max_factor).rev().step_by(11) { \\n\\t\\t\\t// we step by 11 b/c we assume the larger factor is divisible by 11\\n\\t\\t\\t// because our lower limit goes beyond the square root we still catch \\n\\t\\t\\t// some smaller factors divisible by 11 if necessary\\n\\t\\t\\t\\n                if palindrome % j == 0 && (palindrome / j) / (max+1) == 0 {\\n                    return (palindrome % 1337) as i32\\n                }\\n            }\\n        }\\n        9\\n    }\\n}\\n\\nfn build_palindrome(i: i64, n: i32) -> i64 {\\n    let mut x = i * 10_i64.pow(n as u32);\\n    \\n    let mut y = i;\\n    let mut pal = 0;\\n    while y > 0 {\\n        pal = 10 * pal + y % 10;\\n        y /= 10;\\n        \\n    }\\n    pal += x;\\n    pal\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371278,
                "title": "c-solution-with-explanation",
                "content": "We make all palindrome from [10^(n-1), 10^n), and check every palindrome whether can be made. pal() make i to a palindrome i + reverse(i), e.g. 123 -> 123321, pal1() make i to i[:-1] + reverse(i), e.g. 123 -> 12321. A number with n digit mutiplyed by anthoer number with n digit, has at least n+n-1 digits(10^(n-1) * 10^(n-1)) and at most n+n digits. pal() makes n+n digits while pal1() makes n+n-1 digits.\\n```c++\\n\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    LL pal(LL i, int n) {\\n        LL res = i;\\n        LL p = i;\\n        while (p) {\\n            res *= 10;\\n            res += p % 10;\\n            p /= 10;\\n        }\\n        return res;\\n    }\\n    LL pal1(LL i, int n) {\\n        LL res = i / 10;\\n        LL p = i;\\n        while (p) {\\n            res *= 10;\\n            res += p % 10;\\n            p /= 10;\\n        }\\n        return res;\\n    }\\n    int largestPalindrome(int n) {\\n        LL res = 0;\\n        LL l = pow(10, n-1);\\n        LL r = pow(10, n) - 1;\\n        for (int i = r; i >= l; i--) {\\n            LL p = pal(i, n);\\n            // IMPORT j*j>=p! j is the larger between p\\'s divisor\\n            for (LL j = r; j >= l & j * j >= p; j--) if (p % j == 0) return p % 1337;\\n        }\\n        for (int i = r; i >= l; i--) {\\n            LL p = pal1(i, n);\\n            // IMPORT j*j>=p! j is the larger between p\\'s divisor\\n            for (LL j = r; j >= l & j * j >= p; j--) if (p % j == 0) return p % 1337;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    LL pal(LL i, int n) {\\n        LL res = i;\\n        LL p = i;\\n        while (p) {\\n            res *= 10;\\n            res += p % 10;\\n            p /= 10;\\n        }\\n        return res;\\n    }\\n    LL pal1(LL i, int n) {\\n        LL res = i / 10;\\n        LL p = i;\\n        while (p) {\\n            res *= 10;\\n            res += p % 10;\\n            p /= 10;\\n        }\\n        return res;\\n    }\\n    int largestPalindrome(int n) {\\n        LL res = 0;\\n        LL l = pow(10, n-1);\\n        LL r = pow(10, n) - 1;\\n        for (int i = r; i >= l; i--) {\\n            LL p = pal(i, n);\\n            // IMPORT j*j>=p! j is the larger between p\\'s divisor\\n            for (LL j = r; j >= l & j * j >= p; j--) if (p % j == 0) return p % 1337;\\n        }\\n        for (int i = r; i >= l; i--) {\\n            LL p = pal1(i, n);\\n            // IMPORT j*j>=p! j is the larger between p\\'s divisor\\n            for (LL j = r; j >= l & j * j >= p; j--) if (p % j == 0) return p % 1337;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144726,
                "title": "1-line-1-ms-java-200-iq-solution",
                "content": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        int [] ans = {9,987,123,597,677,1218,877,475}; return ans[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        int [] ans = {9,987,123,597,677,1218,877,475}; return ans[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96313,
                "title": "c-generate-palindrome-by-dfs-then-verify",
                "content": "The idea is to generate possible palindrome number from great to small, which is 2n or 2n-1 digit. Check whether it is product of 2 n-digit number. If so, return the answer. For n = 2-10, it seems that there is always a number of 2n digit matching the requirements.\\nI feel the solution to this question is like brute force, but with a bit optimization.\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        string s(n*2,'0');\\n        // for case: abccba\\n        int ans = helper(s, 0, 2*n-1);\\n        if (ans != -1) return ans;\\n        s.pop_back();\\n        // for case: abcba; This is unnecessary for n: 2-10\\n        return helper(s, 0, 2*n-2);\\n    }\\nprivate:\\n    // build palindrome number from great to small by backtracking\\n    // check whether it is product of 2 n-digit numbers\\n    int helper(string& s, int l, int r) {\\n        if (l > r) return check(s);\\n        for (int i = 9; i >= 0; i--) {\\n            if (l == 0 && i == 0) continue;\\n            s[l] = '0'+i;\\n            s[r] = '0'+i;\\n            int ans = helper(s, l+1, r-1);\\n            if (ans != -1) return ans;\\n        }\\n        return -1;\\n    }\\n    int check(string& s) {\\n        int n = (s.size()+1)/2;\\n        long m = 0;\\n        for (int i = 0; i < s.size(); i++) \\n            m = m*10+s[i]-'0';\\n        // if exsiting, the smaller numbers is in range [left, right] \\n        long left = pow(10, n-1), right = sqrt(m);\\n        for (long i = right; i >= left && m/i < left*10; i--) {\\n            if (i*(m/i) == m) return m%1337;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        string s(n*2,'0');\\n        // for case: abccba\\n        int ans = helper(s, 0, 2*n-1);\\n        if (ans != -1) return ans;\\n        s.pop_back();\\n        // for case: abcba; This is unnecessary for n: 2-10\\n        return helper(s, 0, 2*n-2);\\n    }\\nprivate:\\n    // build palindrome number from great to small by backtracking\\n    // check whether it is product of 2 n-digit numbers\\n    int helper(string& s, int l, int r) {\\n        if (l > r) return check(s);\\n        for (int i = 9; i >= 0; i--) {\\n            if (l == 0 && i == 0) continue;\\n            s[l] = '0'+i;\\n            s[r] = '0'+i;\\n            int ans = helper(s, l+1, r-1);\\n            if (ans != -1) return ans;\\n        }\\n        return -1;\\n    }\\n    int check(string& s) {\\n        int n = (s.size()+1)/2;\\n        long m = 0;\\n        for (int i = 0; i < s.size(); i++) \\n            m = m*10+s[i]-'0';\\n        // if exsiting, the smaller numbers is in range [left, right] \\n        long left = pow(10, n-1), right = sqrt(m);\\n        for (long i = right; i >= left && m/i < left*10; i--) {\\n            if (i*(m/i) == m) return m%1337;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96317,
                "title": "share-my-11-line-c-solution",
                "content": "\\n```\\nclass Solution {\\n    long create(int n){\\n        string s = to_string(n), ss = s;\\n        reverse(s.begin(),s.end());\\n        return stol(ss+s);\\n    }\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        long lo = pow(10,n-1), hi = pow(10,n)-1, num = hi*hi/pow(10,n), val;\\n        while (1){\\n            val = create(num--);\\n            for (int j=hi; j>=lo; --j){\\n                if (val%j==0) return val%1337;\\n                if (j*hi < val) break;\\n            }\\n        }\\n        return val%1337;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long create(int n){\\n        string s = to_string(n), ss = s;\\n        reverse(s.begin(),s.end());\\n        return stol(ss+s);\\n    }\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        long lo = pow(10,n-1), hi = pow(10,n)-1, num = hi*hi/pow(10,n), val;\\n        while (1){\\n            val = create(num--);\\n            for (int j=hi; j>=lo; --j){\\n                if (val%j==0) return val%1337;\\n                if (j*hi < val) break;\\n            }\\n        }\\n        return val%1337;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967382,
                "title": "beats-100-ruby-easy-to-understand",
                "content": "# Ruby\\n```\\n# @param {Integer} n\\n# @return {Integer}\\ndef largest_palindrome(n)\\n    return 9 if n == 1\\n    upper = (10.pow(n)) - 1 \\n    lower = 10.pow(n-1)\\n    i =  upper\\n    (lower).times do\\n        i = i - 1\\n        s = i.to_s\\n        pal = (s + s.reverse).to_i\\n        lPal = ((pal.pow(0.5))-1).to_i\\n        j= upper\\n        (lPal).times do\\n            j = j-1\\n            if pal % j == 0 && ((pal / j).to_s).length == n\\n                return pal % 1337\\n            end\\n        end\\n    end\\n    return -1    \\nend\\n```\\n# Pythone3\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        upper = pow(10, n) - 1\\n        lower = pow(10, n - 1)\\n        for i in range(upper, lower-1, -1):\\n            s = str(i)\\n            pal = int(s + s[::-1])\\n            for j in range(upper, int(pow(pal, 0.5))-1, -1):\\n                if pal % j == 0 and len(str(pal//j)) == n:\\n                    return pal % 1337\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Ruby",
                    "Math"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer}\\ndef largest_palindrome(n)\\n    return 9 if n == 1\\n    upper = (10.pow(n)) - 1 \\n    lower = 10.pow(n-1)\\n    i =  upper\\n    (lower).times do\\n        i = i - 1\\n        s = i.to_s\\n        pal = (s + s.reverse).to_i\\n        lPal = ((pal.pow(0.5))-1).to_i\\n        j= upper\\n        (lPal).times do\\n            j = j-1\\n            if pal % j == 0 && ((pal / j).to_s).length == n\\n                return pal % 1337\\n            end\\n        end\\n    end\\n    return -1    \\nend\\n```\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        upper = pow(10, n) - 1\\n        lower = pow(10, n - 1)\\n        for i in range(upper, lower-1, -1):\\n            s = str(i)\\n            pal = int(s + s[::-1])\\n            for j in range(upper, int(pow(pal, 0.5))-1, -1):\\n                if pal % j == 0 and len(str(pal//j)) == n:\\n                    return pal % 1337\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562857,
                "title": "my-solution-using-pure-js",
                "content": "I decided to go from the opposite, from the formation of a palindrome in two parts,\\nand not from the multipliers from which the check for the palindrome is made.\\nSince the length of a palindrome of `N = (10 ^ n) - 1` is equal to the number of characters in the number `N` multiplied by `2`,\\nIt is possible to form a palindrome by decreasing one part by `1` and mirroring and concatenating it.\\n1. Form a polyindrome.\\n2. Next, I am looking for the divisor of the polyindrome in a cycle from `hi` to `2` with a step of `2` (2-picked up empirically).\\n3. I am trying to get the second factor `j`.\\n4. If `j > hi`, which means there is no multiplier of the required length `n` and the loop is exited.\\n5. If the palindrome is divisible by `i` without a remainder, then we have found the maximum polyindrome!\\n\\nWhere:\\n**i** - a first divider of palindrome\\n**j** - a second divider of palindrome\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar largestPalindrome = function(n) {\\n    if (n === 1) return 9;\\n    let hi = BigInt(Math.pow(10, n) - 1);\\n    let num = hi;\\n    while(num > 0) {\\n        num -= 1n;\\n        const palindrome = BigInt(String(num) + String(num).split(\\'\\').reverse().join(\\'\\'));\\n        for (let i = hi; i >= 2n; i -= 2n) {\\n            const j = palindrome / i; \\n            if (j > hi) break;\\n            if (palindrome % i === 0n) {\\n                return String(palindrome % 1337n);\\n            };\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar largestPalindrome = function(n) {\\n    if (n === 1) return 9;\\n    let hi = BigInt(Math.pow(10, n) - 1);\\n    let num = hi;\\n    while(num > 0) {\\n        num -= 1n;\\n        const palindrome = BigInt(String(num) + String(num).split(\\'\\').reverse().join(\\'\\'));\\n        for (let i = hi; i >= 2n; i -= 2n) {\\n            const j = palindrome / i; \\n            if (j > hi) break;\\n            if (palindrome % i === 0n) {\\n                return String(palindrome % 1337n);\\n            };\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231162,
                "title": "java-4ms",
                "content": "```java\\nimport static java.lang.Math.*;\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        long pow_10 = (long) pow(10, n);\\n        long max = (pow_10 - 1) * (pow_10 - (long) sqrt(pow_10) + 1);\\n        long left = (max / pow_10), t = pow_10 / 11;\\n        t -= ~t & 1;\\n        for (long i = left; i > 0; i--)\\n            for (long j = t, num = gen(i); j >= i / 11; j -= 2)\\n                if (num % j == 0) return (int) (num % 1337);\\n        return 9;\\n    }\\n\\t//Generate palindrome\\n    private long gen(long x) {\\n        long r = x;\\n        for (; x > 0; r = r * 10 + x % 10, x /= 10) ;\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport static java.lang.Math.*;\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        long pow_10 = (long) pow(10, n);\\n        long max = (pow_10 - 1) * (pow_10 - (long) sqrt(pow_10) + 1);\\n        long left = (max / pow_10), t = pow_10 / 11;\\n        t -= ~t & 1;\\n        for (long i = left; i > 0; i--)\\n            for (long j = t, num = gen(i); j >= i / 11; j -= 2)\\n                if (num % j == 0) return (int) (num % 1337);\\n        return 9;\\n    }\\n\\t//Generate palindrome\\n    private long gen(long x) {\\n        long r = x;\\n        for (; x > 0; r = r * 10 + x % 10, x /= 10) ;\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650143,
                "title": "c-create-palindrome-and-find-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        \\n        if (n == 1) return 9;\\n        \\n        long long h = pow(10, n)-1;\\n        long long l = pow(10, n-1);\\n        \\n        for (long long i = h; i >= l; i--) {\\n            string s = to_string(i);\\n            string r = s;\\n            reverse(r.begin(), r.end());\\n            string sr = s+r;\\n            istringstream ss(sr);\\n            long long val;\\n            ss >> val;\\n            for (long long j = h; j >= l; j--) {\\n                if (val/j > h)\\n                    break;\\n                if (val % j == 0)\\n                    return val%1337;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        \\n        if (n == 1) return 9;\\n        \\n        long long h = pow(10, n)-1;\\n        long long l = pow(10, n-1);\\n        \\n        for (long long i = h; i >= l; i--) {\\n            string s = to_string(i);\\n            string r = s;\\n            reverse(r.begin(), r.end());\\n            string sr = s+r;\\n            istringstream ss(sr);\\n            long long val;\\n            ss >> val;\\n            for (long long j = h; j >= l; j--) {\\n                if (val/j > h)\\n                    break;\\n                if (val % j == 0)\\n                    return val%1337;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216509,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1:\\n            return 9\\n        high=10**n\\n        low=10**(n-1)\\n        for i in range(high-1,low-1,-1):\\n            w=int(str(i)+str(i)[::-1])\\n            for i in range(high-1,int(w**0.5)+1,-1):\\n                #print(w,i)\\n                if w%i==0:\\n                    z=w//i\\n                    if z<high and z>=low:\\n                        return w%1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1:\\n            return 9\\n        high=10**n\\n        low=10**(n-1)\\n        for i in range(high-1,low-1,-1):\\n            w=int(str(i)+str(i)[::-1])\\n            for i in range(high-1,int(w**0.5)+1,-1):\\n                #print(w,i)\\n                if w%i==0:\\n                    z=w//i\\n                    if z<high and z>=low:\\n                        return w%1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140113,
                "title": "python-46ms-solution",
                "content": "Solution inspired from a comment [here](http://leetcode.com/problems/largest-palindrome-product/discuss/96294/Could-any-python-experts-share-their-codes-within-100ms/100809) \\n```\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 9\\n        tenN = 10**n\\n        for iPlusj  in xrange(2, 9*tenN/10+1):\\n            upper = tenN - iPlusj\\n            lower = int(str(upper)[::-1])\\n            discriminant = iPlusj**2 - 4*lower\\n            if discriminant >=0:\\n                root = discriminant**0.5\\n                j1 = (iPlusj + root) /2\\n                j2 = (iPlusj - root) /2\\n                if (j1>0 and abs(j1-int(j1))< 1e-6) or (j2>0 and abs(j2-int(j2))<1e-6):\\n                    return (upper* tenN+lower)%1337\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 9\\n        tenN = 10**n\\n        for iPlusj  in xrange(2, 9*tenN/10+1):\\n            upper = tenN - iPlusj\\n            lower = int(str(upper)[::-1])\\n            discriminant = iPlusj**2 - 4*lower\\n            if discriminant >=0:\\n                root = discriminant**0.5\\n                j1 = (iPlusj + root) /2\\n                j2 = (iPlusj - root) /2\\n                if (j1>0 and abs(j1-int(j1))< 1e-6) or (j2>0 and abs(j2-int(j2))<1e-6):\\n                    return (upper* tenN+lower)%1337\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 134897,
                "title": "evaluate-products-in-approximately-descending-order-tle-on-n-8",
                "content": "* Solution gets TLE for n=8, but runs in < 2s and uses unique approach\\n* Generate products in approximately descending order from two length-n factors, in the following way illustrated visually, with the left and right numbers being the outer and inner loop variables:\\n  * 999\\n     *  999\\n  * 998\\n    * 999\\n    * 998\\n  * 997\\n    *  999\\n    *  998\\n    *  997\\n   * etc \\n* if a new largest palindrome is found, there may still be a palindrome with larger value that we haven\\'t seen, since our order isn\\'t strictly decreasing. For example:\\n  * 924 x 962 = 888888 (seen when outer loop variable `i=924`)\\n  * (913 x 993) = 906609 (outter loop variable `i=913`)\\n * But a new largest palindrome gives us a lower bound for one of the 2 products, which can be used as a lower bound for the outer loop variable.\\n   * Example:  If 888888 is the largest palindrome product we\\'ve seen, then the smallest length-n factor of any larger product must be at least 888888/MX, where `MX` is the max value for one of the factors. In this case, 888888/10^3=888\\n```\\nint largestPalindrome(int n) {\\n    int MX=1;for(int i=0;i<n;i++,MX*=10);\\n    long mx=0;\\n    int lo=0;\\n    long MOD=1337;\\n    // long iters=0;\\n    for (long i=MX-1;i>0;i--){\\n        if (lo && i<lo) {\\n            // printf(\"iters %dl\\\\n\",iters);\\n            // printf(\"%ld\\\\n\",mx);\\n            return mx%MOD;\\n        }\\n        long stop = mx? mx/i: i;\\n        // iters+=MX-stop;\\n        // printf(\"%dl\\\\n\",MX-stop);\\n        for (long ii=MX-1;ii>stop;ii--){\\n            long p = i*ii;\\n            // assert(p>=mx);\\n            long rev=0;\\n            for(long pp=p;pp; rev=rev*10+pp%10, pp/=10);\\n            if (rev==p){\\n                // assert(p>mx);\\n                mx=p;\\n                lo=p/MX;\\n                break;\\n            }\\n        }\\n    }\\n    return mx;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPalindrome(int n) {\\n    int MX=1;for(int i=0;i<n;i++,MX*=10);\\n    long mx=0;\\n    int lo=0;\\n    long MOD=1337;\\n    // long iters=0;\\n    for (long i=MX-1;i>0;i--){\\n        if (lo && i<lo) {\\n            // printf(\"iters %dl\\\\n\",iters);\\n            // printf(\"%ld\\\\n\",mx);\\n            return mx%MOD;\\n        }\\n        long stop = mx? mx/i: i;\\n        // iters+=MX-stop;\\n        // printf(\"%dl\\\\n\",MX-stop);\\n        for (long ii=MX-1;ii>stop;ii--){\\n            long p = i*ii;\\n            // assert(p>=mx);\\n            long rev=0;\\n            for(long pp=p;pp; rev=rev*10+pp%10, pp/=10);\\n            if (rev==p){\\n                // assert(p>mx);\\n                mx=p;\\n                lo=p/MX;\\n                break;\\n            }\\n        }\\n    }\\n    return mx;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132977,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        long max = (long)Math.pow(10, n) - 1;\\n        long min = max / 10;\\n        for (long left = max; left > min; left--) {\\n            long right = Long.parseLong(new StringBuilder(\"\" + left).reverse().toString());\\n            long target = left * (max + 1) + right;\\n            for (long i = max; i * i >= target; i--) {\\n                if (target % i == 0) {\\n                    return (int)(target % 1337);\\n                }\\n            }\\n        }\\n        return 9;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        long max = (long)Math.pow(10, n) - 1;\\n        long min = max / 10;\\n        for (long left = max; left > min; left--) {\\n            long right = Long.parseLong(new StringBuilder(\"\" + left).reverse().toString());\\n            long target = left * (max + 1) + right;\\n            for (long i = max; i * i >= target; i--) {\\n                if (target % i == 0) {\\n                    return (int)(target % 1337);\\n                }\\n            }\\n        }\\n        return 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114770,
                "title": "c-solution-with-explanation",
                "content": "For the question, I don't find a better way but only the stupid ergodic. \\nFirstly, find the first palindrome by the max n-digit numbers. Assume the two factors are MaxIntX, MinIntY.\\nSecondly, find the other palindromes between MaxIntX, MinIntY. If there is another palindrome found, we update the minIntY to the small one. If the palindrome is bigger than current, update the current palindrome.\\nTips: Since palindrome should start at 9, so we can skip all the even integer as factor.\\n```\\n        int LargestPalindrome(int n)\\n        {\\n            var largestPalindrome = GetMaxPalindrome(n);\\n            long result = largestPalindrome % 1337;\\n            return (int)result;\\n        }\\n\\n        private static long GetMaxPalindrome(int n)\\n        {\\n            long maxInteger = GetMaxInt(n);\\n            long minInteger = 1;\\n            long currentPalindrome = maxInteger;\\n            for (var i = maxInteger; (i >= minInteger); i-=2)\\n            {\\n                for (var j = i; (j >= minInteger); j-=2)\\n                {\\n                    long result  = i * j;\\n                    if (result <= currentPalindrome)\\n                    {\\n                        break;\\n                    }\\n                    if (IsPalindrome(result))\\n                    {\\n                        if ((result > currentPalindrome))\\n                        {\\n                            currentPalindrome = result;\\n                        }\\n                        minInteger = j;\\n                    }\\n                }\\n            }\\n            return currentPalindrome;\\n        }\\n\\n        private static long GetMaxInt(int length)\\n        {\\n            long result = 9;\\n            while (length > 1)\\n            {\\n                result = result * 10 + 9;\\n                length--;\\n            }\\n            return result;\\n        }\\n\\n        private static bool IsPalindrome(long value)\\n        {\\n            var str = value.ToString();\\n            int j = str.Length - 1;\\n            for (int i = 0; i < j; i++, j--)\\n            {\\n                if (str[i] != str[j])\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        int LargestPalindrome(int n)\\n        {\\n            var largestPalindrome = GetMaxPalindrome(n);\\n            long result = largestPalindrome % 1337;\\n            return (int)result;\\n        }\\n\\n        private static long GetMaxPalindrome(int n)\\n        {\\n            long maxInteger = GetMaxInt(n);\\n            long minInteger = 1;\\n            long currentPalindrome = maxInteger;\\n            for (var i = maxInteger; (i >= minInteger); i-=2)\\n            {\\n                for (var j = i; (j >= minInteger); j-=2)\\n                {\\n                    long result  = i * j;\\n                    if (result <= currentPalindrome)\\n                    {\\n                        break;\\n                    }\\n                    if (IsPalindrome(result))\\n                    {\\n                        if ((result > currentPalindrome))\\n                        {\\n                            currentPalindrome = result;\\n                        }\\n                        minInteger = j;\\n                    }\\n                }\\n            }\\n            return currentPalindrome;\\n        }\\n\\n        private static long GetMaxInt(int length)\\n        {\\n            long result = 9;\\n            while (length > 1)\\n            {\\n                result = result * 10 + 9;\\n                length--;\\n            }\\n            return result;\\n        }\\n\\n        private static bool IsPalindrome(long value)\\n        {\\n            var str = value.ToString();\\n            int j = str.Length - 1;\\n            for (int i = 0; i < j; i++, j--)\\n            {\\n                if (str[i] != str[j])\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96293,
                "title": "python-exceeded-time-limit-when-n-7",
                "content": "I try to use Python to solve this, but it exceeded time limit when n get 7.\\n\\n```\\nimport math\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1:\\n            return 9\\n        high=int(math.pow(10,n)-1)\\n        low=int(math.pow(10,n-1))\\n        i=high\\n        while i>=low:\\n            palindrome=self.product(i)\\n            j=high\\n            while j>=low:\\n                if palindrome/j>high or palindrome/j<low:\\n                    break\\n                if palindrome%j==0:\\n                    return palindrome%1337\\n                j-=1\\n            i-=1\\n            \\n            \\n    def product(self,x):\\n        y=str(x)\\n        z=y[::-1]\\n        result=int(y+z)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1:\\n            return 9\\n        high=int(math.pow(10,n)-1)\\n        low=int(math.pow(10,n-1))\\n        i=high\\n        while i>=low:\\n            palindrome=self.product(i)\\n            j=high\\n            while j>=low:\\n                if palindrome/j>high or palindrome/j<low:\\n                    break\\n                if palindrome%j==0:\\n                    return palindrome%1337\\n                j-=1\\n            i-=1\\n            \\n            \\n    def product(self,x):\\n        y=str(x)\\n        z=y[::-1]\\n        result=int(y+z)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96292,
                "title": "solution-in-o-1-only-4-lines-code",
                "content": "Hello Guys!\\n\\nI know after watching code definitely you will say you nailed it. That's why this problem is in Easy.\\n\\nIn problem it's clearly says that there are **only 8 possibility of the input**, so i **find answer** for every input and **store it into the array** and **return answer directly by using input as index**.\\n\\nFor example if n=2 and answer = 987, so i store 987 in array at 2<sup>nd</sup> position.\\n\\nSo whole array will be look like ```{0,9,987,123,597,677,1218,877,475}```.\\n\\nHere's the code.\\n```\\nint[] ans = {0,9,987,123,597,677,1218,877,475};\\n        if(n>=1 && n<=8)\\n            return ans[n];\\n        return 0;\\n```",
                "solutionTags": [],
                "code": "```{0,9,987,123,597,677,1218,877,475}```\n```\\nint[] ans = {0,9,987,123,597,677,1218,877,475};\\n        if(n>=1 && n<=8)\\n            return ans[n];\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96318,
                "title": "clean-java-solution-that-considers-even-and-odd-palindromes-with-explanation",
                "content": "find max palindrome that is the product of two n-digit factors\\n\\nn___| factor range____| palindrome range\\n------|---------------|----------------------------- \\n2     |  10..99 | 100..9801\\n3     |  100..999 | 10000..998001\\n4     |  1000..9999 | 1000000..99980001\\n...<br>\\nthere are odd length palindromes e.g. 191 and even length palindromes e.g. 9779. In this problem both are possible, but the even are more likely because the largest is required and there are many even before the first odd comes. \\n\\nTwo ways to find palindromes that are products of n-digit integers:    \\n1. create all products with possible factors and check if the product is a palindrome. The problem is the order of the products which requires space and adds complexity. I didn't follow this further.\\n2. create palindromes in decreasing order and check if it can be created by the multiplication of two factors with given range. There will be roughly 10^n such palindromes. Checking whether such a number is the product of two n-digit integers requires trying dividing that palindrome approx. its square root times. But there are limits on the numbers that heavily reduce work:\\n    * avoid double checking e.g. 1*9 = 9*1: iterate only from 1 to 9^(1/2) (square root of 9)\\n    * if e.g. the number can't be greater than 9, do not try 9*x < palindrome --> min-to-try = ceiling(palindrome / 9)\\n\\n```java\\npublic int largestPalindrome(int n) {\\n    if(n < 1 || n > 8) throw new IllegalArgumentException();\\n\\n    long factMin = (long)Math.pow(10, n - 1); // e.g. 10^(3-1) = 100\\n    long factMax = factMin * 10 - 1; // e.g. 100*10 - 1 = 999\\n\\n    for(long left = factMax * factMax / (factMin * 10); left >= factMin; left--) {\\n        long palindrome = createEvenPalindrome(left);\\n        if(findProduct(palindrome, factMin, factMax) != 0)\\n            return (int)(palindrome%1337L);\\n    }\\n\\n    for(long left = factMin * 10 - 1; left >= factMin; left--) {\\n        long palindrome = createOddPalindrome(left);\\n        if(findProduct(palindrome, factMin, factMax) != 0)\\n            return (int)(palindrome%1337L);\\n    }\\n\\n    return 0;\\n}\\n\\n// returns x so that product % x == 0 or 0 if no x exists. \\n// x must be in the inclusive range [factMin, factMax]\\nstatic private long findProduct(long product, long factMin, long factMax) {\\n    factMin = Math.max((product + factMax - 1) / factMax, factMin); // max(ceiling(product / factMax), factMax)\\n    factMax = Math.min((long)Math.sqrt((double)product), factMax);\\n    for(long mul = factMin; mul <= factMax; mul++) {\\n        if(product % mul == 0) return mul;\\n    }\\n    return 0;\\n}\\n\\n// creates an even palindrome by mirroring the given part on the right.\\n// e.g. left = 123 --> return 123321\\nstatic private long createEvenPalindrome(long left) {\\n    long palindrome = left;\\n    for(; left > 0; left /= 10)\\n        palindrome = palindrome * 10L + (left % 10);\\n    return palindrome;\\n}\\n\\n// creates an odd palindrome e.g. 123 --> 12321\\nstatic private long createOddPalindrome(long left) {\\n    long palindrome = left;\\n    for(left /= 10; left > 0; left /= 10)\\n        palindrome = palindrome * 10L + (left % 10);\\n    return palindrome;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int largestPalindrome(int n) {\\n    if(n < 1 || n > 8) throw new IllegalArgumentException();\\n\\n    long factMin = (long)Math.pow(10, n - 1); // e.g. 10^(3-1) = 100\\n    long factMax = factMin * 10 - 1; // e.g. 100*10 - 1 = 999\\n\\n    for(long left = factMax * factMax / (factMin * 10); left >= factMin; left--) {\\n        long palindrome = createEvenPalindrome(left);\\n        if(findProduct(palindrome, factMin, factMax) != 0)\\n            return (int)(palindrome%1337L);\\n    }\\n\\n    for(long left = factMin * 10 - 1; left >= factMin; left--) {\\n        long palindrome = createOddPalindrome(left);\\n        if(findProduct(palindrome, factMin, factMax) != 0)\\n            return (int)(palindrome%1337L);\\n    }\\n\\n    return 0;\\n}\\n\\n// returns x so that product % x == 0 or 0 if no x exists. \\n// x must be in the inclusive range [factMin, factMax]\\nstatic private long findProduct(long product, long factMin, long factMax) {\\n    factMin = Math.max((product + factMax - 1) / factMax, factMin); // max(ceiling(product / factMax), factMax)\\n    factMax = Math.min((long)Math.sqrt((double)product), factMax);\\n    for(long mul = factMin; mul <= factMax; mul++) {\\n        if(product % mul == 0) return mul;\\n    }\\n    return 0;\\n}\\n\\n// creates an even palindrome by mirroring the given part on the right.\\n// e.g. left = 123 --> return 123321\\nstatic private long createEvenPalindrome(long left) {\\n    long palindrome = left;\\n    for(; left > 0; left /= 10)\\n        palindrome = palindrome * 10L + (left % 10);\\n    return palindrome;\\n}\\n\\n// creates an odd palindrome e.g. 123 --> 12321\\nstatic private long createOddPalindrome(long left) {\\n    long palindrome = left;\\n    for(left /= 10; left > 0; left /= 10)\\n        palindrome = palindrome * 10L + (left % 10);\\n    return palindrome;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96324,
                "title": "python-time-limit-exceeded-for-n-8",
                "content": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1:\\n            return 9\\n        max = 10**n -1 \\n        min = 10**(n-1)\\n        left_max = max\\n        tmp = left_max\\n        while tmp >= min:\\n            result = long(str(tmp) + str(tmp)[::-1])\\n            for i in range(max, long(result**(0.5)), -1):\\n                if result % i ==0 :\\n                    return result % 1337\\n            tmp = tmp - 1\\n```\\n\\nI cannot figure out a way to improve my algorism, anyone has a better solution for this ?\\nThanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==1:\\n            return 9\\n        max = 10**n -1 \\n        min = 10**(n-1)\\n        left_max = max\\n        tmp = left_max\\n        while tmp >= min:\\n            result = long(str(tmp) + str(tmp)[::-1])\\n            for i in range(max, long(result**(0.5)), -1):\\n                if result % i ==0 :\\n                    return result % 1337\\n            tmp = tmp - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96328,
                "title": "time-limit-exceeded-in-javascript",
                "content": "I run it on my laptop and got the right answer. It took 10 seconds when n = 7. Is there any way to improve it? Thanks!\\n\\n```\\nvar largestPalindrome = function(n) {\\n    var max = Math.pow(10, n) - 1;\\n    var min = Math.pow(10, n-1);\\n    var pal = 0;\\n    for (var i = max; i >= min; i--) {\\n        for (var j = max; j >= i; j--) {\\n            var result = i * j;\\n            if (result > pal) {\\n                var str = result.toString();\\n                var rStr = str.split(\"\").reverse().join(\"\");\\n                if (str == rStr) {\\n                    pal = result;\\n                    break;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n    \\tif(j == max) {\\n    \\t    break;\\n    \\t}\\n    }\\n    return (pal % 1337);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestPalindrome = function(n) {\\n    var max = Math.pow(10, n) - 1;\\n    var min = Math.pow(10, n-1);\\n    var pal = 0;\\n    for (var i = max; i >= min; i--) {\\n        for (var j = max; j >= i; j--) {\\n            var result = i * j;\\n            if (result > pal) {\\n                var str = result.toString();\\n                var rStr = str.split(\"\").reverse().join(\"\");\\n                if (str == rStr) {\\n                    pal = result;\\n                    break;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n    \\tif(j == max) {\\n    \\t    break;\\n    \\t}\\n    }\\n    return (pal % 1337);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021653,
                "title": "short-est-intuitive-fast-solution-python",
                "content": "\\n# Code\\nSee explanation below!\\n```py\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n\\n        max_num = 10 ** n - 1\\n        min_num = 10 ** (n - 1)\\n\\n        for num in range(int(max_num), int(min_num) - 1, -1):\\n            # Construct a palindrome by joining num with its reverse\\n            palindrome = int(str(num) + str(num)[::-1])\\n\\n            # Check if this palindrome can be represented as the product of two n-digit integers\\n            for i in range(max_num, int(palindrome ** 0.5) - 1, -1):\\n                if palindrome % i == 0 and palindrome // i <= max_num:\\n                    return palindrome % 1337\\n```\\n# Explanation\\nTo solve this problem we need to minimize the number of steps we take and to a certain extent \"think in reverse.\" Because the answer $9$ is so trivial to solve for $n=1$, I treated it as a base case to simply the following explanation.\\n\\nWhat we know: we are trying to find a palindrome (mod $1337$). This palindrome must be the product of two n-digit integers.\\n\\nFirst we should find the minimum and maximum values that our two n-digit integers can be. This mathematically can be represented as $min=10^{(n-1)}$ and $max = 10^n-1$\\n\\nFor $n=2$, our minimum and maximum 2-digit numbers are of course $10$ ($10^{2-1}$) and $99$ ($10^2-1$).\\n\\nWe can put this in our code as:\\n```py\\nmax_num = 10 ** n - 1\\nmin_num = 10 ** (n - 1)\\n```\\n\\nIncidently, using our `max_num` and `min_num` and some string manipulation we can construct our palindromes as the product of any n-digit numbers is 2n-digits long. We should do this going from our `max_num` down to our `min_num`, because we want to maximimzie the value of the palindrome. \\n\\n```py\\nfor num in range(int(max_num), int(min_num) - 1, -1):\\n    # Construct a palindrome by joining num with its reverse\\n    palindrome = int(str(num) + str(num)[::-1])\\n```\\n\\nAfter constructing our palindrome, we can check if it\\'s divisible by any two digit integers. \\n\\nIn any pair of factors for a number $n$, one number has to be bigger than $\\\\sqrt{n}$ and the other has to be smaller, unless they are both exactly $\\\\sqrt{n}$. (Don\\'t get lost on the math talk, just think about it). \\n\\nKnowing this fact, we know we only have to check $\\\\sqrt{n}$ factors. We want to check for factors from $max_num$ down to the $\\\\sqrt{n}$ (`-1` in our code to correctly index the array), since we want to ensure that our palindrome has large factors. If you reverse the check order you don\\'t get the correct answers. To check if the factor completes a pair, we make sure that it evenly divides our palindrome by using `palindrome % i` and then we need to make sure that the other factor is 2-digits by using ``palindrome // i <= max_num``\\n\\n```py\\n            # Check if this palindrome can be represented as the product of two n-digit integers\\n            for i in range(max_num, int(palindrome ** 0.5) - 1, -1):\\n                if palindrome % i == 0 and palindrome // i <= max_num:\\n                    return palindrome % 1337\\n```\\nFinally, if all our conditions are met we can return our palindrome modulo 1337.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n\\n        max_num = 10 ** n - 1\\n        min_num = 10 ** (n - 1)\\n\\n        for num in range(int(max_num), int(min_num) - 1, -1):\\n            # Construct a palindrome by joining num with its reverse\\n            palindrome = int(str(num) + str(num)[::-1])\\n\\n            # Check if this palindrome can be represented as the product of two n-digit integers\\n            for i in range(max_num, int(palindrome ** 0.5) - 1, -1):\\n                if palindrome % i == 0 and palindrome // i <= max_num:\\n                    return palindrome % 1337\\n```\n```py\\nmax_num = 10 ** n - 1\\nmin_num = 10 ** (n - 1)\\n```\n```py\\nfor num in range(int(max_num), int(min_num) - 1, -1):\\n    # Construct a palindrome by joining num with its reverse\\n    palindrome = int(str(num) + str(num)[::-1])\\n```\n```py\\n            # Check if this palindrome can be represented as the product of two n-digit integers\\n            for i in range(max_num, int(palindrome ** 0.5) - 1, -1):\\n                if palindrome % i == 0 and palindrome // i <= max_num:\\n                    return palindrome % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977433,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // coppied as I have gone through the brute force Appoarch and the time limit exceeds;\\n\\n    // this is the actual coppied code\\n    \\n /*   static int helper(int n){\\n        if( n == 1) return 9;\\n        // 2 digits\\'s max is 10^2  - 1=99\\n        int maxNum = (int) (Math.pow(10,n) - 1);\\n        for(int i = maxNum;i >= 0; i--){\\n    \\n            StringBuilder sb = new StringBuilder();\\n            sb.append(String.valueOf(i));\\n            StringBuilder b = new StringBuilder();\\n            b.append(String.valueOf(i));\\n            b.reverse();\\n            sb.append(b);\\n            long panlindromeNum = Long.valueOf(sb.toString());\\n            for(long j = (long)maxNum; j*j >= panlindromeNum; j--){\\n                if(panlindromeNum % j == 0){\\n                    return (int)( panlindromeNum % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    */\\n    public int largestPalindrome(int n) {\\n\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)\\n        return 597;\\n        if(n==5)\\n        return 677;\\n        if(n==6)\\n        return 1218;\\n        if(n==7)\\n        return 877;\\n        if(n==8)\\n        return 475;\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // coppied as I have gone through the brute force Appoarch and the time limit exceeds;\\n\\n    // this is the actual coppied code\\n    \\n /*   static int helper(int n){\\n        if( n == 1) return 9;\\n        // 2 digits\\'s max is 10^2  - 1=99\\n        int maxNum = (int) (Math.pow(10,n) - 1);\\n        for(int i = maxNum;i >= 0; i--){\\n    \\n            StringBuilder sb = new StringBuilder();\\n            sb.append(String.valueOf(i));\\n            StringBuilder b = new StringBuilder();\\n            b.append(String.valueOf(i));\\n            b.reverse();\\n            sb.append(b);\\n            long panlindromeNum = Long.valueOf(sb.toString());\\n            for(long j = (long)maxNum; j*j >= panlindromeNum; j--){\\n                if(panlindromeNum % j == 0){\\n                    return (int)( panlindromeNum % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    */\\n    public int largestPalindrome(int n) {\\n\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)\\n        return 597;\\n        if(n==5)\\n        return 677;\\n        if(n==6)\\n        return 1218;\\n        if(n==7)\\n        return 877;\\n        if(n==8)\\n        return 475;\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908083,
                "title": "cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if(n==1) return 9;\\n        int low=pow(10,n-1);\\n        int high=pow(10,n)-1;\\n        for(int i=high;i>=low;i--){\\n            string res=\"\";\\n            string s=to_string(i);\\n            res=s;\\n            reverse(s.begin(),s.end());\\n            res+=s;\\n            long long k=stoll(res);\\n            for(long long j=high;j*j>=k;j--){\\n                if(k%j==0 and k/j<=high) return k%1337;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if(n==1) return 9;\\n        int low=pow(10,n-1);\\n        int high=pow(10,n)-1;\\n        for(int i=high;i>=low;i--){\\n            string res=\"\";\\n            string s=to_string(i);\\n            res=s;\\n            reverse(s.begin(),s.end());\\n            res+=s;\\n            long long k=stoll(res);\\n            for(long long j=high;j*j>=k;j--){\\n                if(k%j==0 and k/j<=high) return k%1337;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755010,
                "title": "t-c-o-1-100-beats-memory-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n// As the n values are very small you can directly return \\n        if(n==2)\\n        return 987;\\n        if(n==1)\\n        return 9;\\n        if(n==3)\\n        return 123;\\n        if(n==4)\\n        return 597;\\n        if(n==5)\\n        return 677;\\n        if(n==6)\\n        return 1218;\\n        if(n==7)\\n        return 877;\\n        if(n==8)\\n        return 475;\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n// As the n values are very small you can directly return \\n        if(n==2)\\n        return 987;\\n        if(n==1)\\n        return 9;\\n        if(n==3)\\n        return 123;\\n        if(n==4)\\n        return 597;\\n        if(n==5)\\n        return 677;\\n        if(n==6)\\n        return 1218;\\n        if(n==7)\\n        return 877;\\n        if(n==8)\\n        return 475;\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632138,
                "title": "scala-dummy-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def largestPalindrome(n: Int): Int = List(0, 9, 987, 123, 597, 677, 1218, 877, 475)(n)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def largestPalindrome(n: Int): Int = List(0, 9, 987, 123, 597, 677, 1218, 877, 475)(n)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3591224,
                "title": "meh",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        \\n        upper = 10 ** n - 1\\n        lower = 10 ** (n - 1)\\n        \\n        left_half = str(upper)[:n]\\n        \\n        while True:\\n            palindrome = int(left_half + left_half[::-1])\\n            \\n            for i in range(upper, lower - 1, -1):\\n                if palindrome // i > upper:\\n                    break\\n                if palindrome % i == 0:\\n                    return palindrome % 1337\\n            \\n            left_half = str(int(left_half) - 1)\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        \\n        upper = 10 ** n - 1\\n        lower = 10 ** (n - 1)\\n        \\n        left_half = str(upper)[:n]\\n        \\n        while True:\\n            palindrome = int(left_half + left_half[::-1])\\n            \\n            for i in range(upper, lower - 1, -1):\\n                if palindrome // i > upper:\\n                    break\\n                if palindrome % i == 0:\\n                    return palindrome % 1337\\n            \\n            left_half = str(int(left_half) - 1)\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563179,
                "title": "python3-simple-well-commented",
                "content": "# Intuition\\nwell commented code, follow along. Comment any doubts! \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n== 1: # case if n = 1\\n            return 9\\n        upper = (10 ** n) -1 # for everything else. easy to cacluate upper and lower bound values.\\n        lower = 10 ** (n-1)\\n        res = 0 # the variable to store our result\\n\\n        for i in range(upper, lower-1, -2): # we only need odd elements (increment= -2), as the first digit of the largest pallindrome will be 9\\n                                            # so the last digit should be 9 also. no even numbers multiplied will give 9 in the unit\\'s place.\\n            if i * i < res:\\n                return res%1337  # if our current res is bigger than the biggest number possible for the next iteration, we can simply returnt the\\n                                 # current res.\\n            for j in range(upper, i-1, -2):\\n                temp = i* j\\n                if temp % 11 != 0 and temp > res: # all even numbered digit pallinfomes are multiples of 11\\n                    continue\\n                if (str(temp)[::-1] == str(temp)): # make sure it is a pallindrome\\n                    res = temp\\n                \\n\\n        return res%1337 # return!\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n== 1: # case if n = 1\\n            return 9\\n        upper = (10 ** n) -1 # for everything else. easy to cacluate upper and lower bound values.\\n        lower = 10 ** (n-1)\\n        res = 0 # the variable to store our result\\n\\n        for i in range(upper, lower-1, -2): # we only need odd elements (increment= -2), as the first digit of the largest pallindrome will be 9\\n                                            # so the last digit should be 9 also. no even numbers multiplied will give 9 in the unit\\'s place.\\n            if i * i < res:\\n                return res%1337  # if our current res is bigger than the biggest number possible for the next iteration, we can simply returnt the\\n                                 # current res.\\n            for j in range(upper, i-1, -2):\\n                temp = i* j\\n                if temp % 11 != 0 and temp > res: # all even numbered digit pallinfomes are multiples of 11\\n                    continue\\n                if (str(temp)[::-1] == str(temp)): # make sure it is a pallindrome\\n                    res = temp\\n                \\n\\n        return res%1337 # return!\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525085,
                "title": "largest-palindrome-product-c",
                "content": "## Intuition\\n\\nThe problem requires us to find the largest palindromic integer that can be represented as the product of two n-digits integers. We can start with the largest n-digit number and work our way down to the smallest n-digit number, checking each number to see if it is a palindrome that can be represented as a product of two n-digit numbers.\\n\\n## Approach\\n\\n1. If `n` is equal to 1, return 9 because the largest palindromic integer that can be represented as the product of two 1-digit integers is 9.\\n2. Calculate the upper bound and lower bound for n-digit integers as `(int)Math.Pow(10, n) - 1` and `(int)Math.Pow(10, n - 1)`, respectively.\\n3. Starting from the upper bound, loop through all n-digit integers down to the lower bound.\\n4. Convert the current integer to a string and check if it is a palindrome by comparing it to its reversed string. If it is not a palindrome, skip to the next integer.\\n5. If the integer is a palindrome, calculate the largest possible n-digit integer by dividing the palindrome by the current integer and rounding up. Starting from this largest integer, loop through all integers down to 1.\\n6. Check if the current integer is a factor of the palindrome. If it is, return the palindrome modulo 1337 as the result.\\n7. If no palindrome can be found, return -1.\\n\\n## Complexity\\n\\n- Time complexity: O(n^2), where n is the number of digits. We iterate through all n-digit integers and loop through all integers from the largest to the smallest, so the time complexity is proportional to n^2.\\n- Space complexity: O(1). The function uses only constant extra space to store the upper and lower bounds, and the current palindrome and integer values.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LargestPalindrome(int n) {\\n        if (n == 1) {\\n            return 9;\\n        }\\n        int upperBound = (int)Math.Pow(10, n) - 1;\\n        int lowerBound = (int)Math.Pow(10, n - 1);\\n        for (int i = upperBound; i >= lowerBound; i--) {\\n            long palindrome = long.Parse(i + Reverse(i.ToString()));\\n            for (long j = upperBound; j * j >= palindrome; j--) {\\n                if (palindrome % j == 0) {\\n                    return (int)(palindrome % 1337);\\n                }\\n            }\\n        }\\n        return -1; // unreachable\\n    }\\n    \\n    private string Reverse(string s) {\\n        char[] chars = s.ToCharArray();\\n        Array.Reverse(chars);\\n        return new string(chars);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LargestPalindrome(int n) {\\n        if (n == 1) {\\n            return 9;\\n        }\\n        int upperBound = (int)Math.Pow(10, n) - 1;\\n        int lowerBound = (int)Math.Pow(10, n - 1);\\n        for (int i = upperBound; i >= lowerBound; i--) {\\n            long palindrome = long.Parse(i + Reverse(i.ToString()));\\n            for (long j = upperBound; j * j >= palindrome; j--) {\\n                if (palindrome % j == 0) {\\n                    return (int)(palindrome % 1337);\\n                }\\n            }\\n        }\\n        return -1; // unreachable\\n    }\\n    \\n    private string Reverse(string s) {\\n        char[] chars = s.ToCharArray();\\n        Array.Reverse(chars);\\n        return new string(chars);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502335,
                "title": "commented-and-explained-with-example-1-print-log-math-explained-long-read",
                "content": "# Example One Print Log \\ntotal boundary is 100\\nCurrent upper boundary is 99\\nCurrent lower boundary is 99\\nResult of base squared minus 4 times lower boundary is -395\\nCurrently not passing check one, as it has a value of -395\\nRepeating with base value of 2\\nCurrent upper boundary is 98\\nCurrent lower boundary is 89\\nResult of base squared minus 4 times lower boundary is -352\\nCurrently not passing check one, as it has a value of -352\\nRepeating with base value of 3\\nCurrent upper boundary is 97\\nCurrent lower boundary is 79\\nResult of base squared minus 4 times lower boundary is -307\\nCurrently not passing check one, as it has a value of -307\\nRepeating with base value of 4\\nCurrent upper boundary is 96\\nCurrent lower boundary is 69\\nResult of base squared minus 4 times lower boundary is -260\\nCurrently not passing check one, as it has a value of -260\\nRepeating with base value of 5\\nCurrent upper boundary is 95\\nCurrent lower boundary is 59\\nResult of base squared minus 4 times lower boundary is -211\\nCurrently not passing check one, as it has a value of -211\\nRepeating with base value of 6\\nCurrent upper boundary is 94\\nCurrent lower boundary is 49\\nResult of base squared minus 4 times lower boundary is -160\\nCurrently not passing check one, as it has a value of -160\\nRepeating with base value of 7\\nCurrent upper boundary is 93\\nCurrent lower boundary is 39\\nResult of base squared minus 4 times lower boundary is -107\\nCurrently not passing check one, as it has a value of -107\\nRepeating with base value of 8\\nCurrent upper boundary is 92\\nCurrent lower boundary is 29\\nResult of base squared minus 4 times lower boundary is -52\\nCurrently not passing check one, as it has a value of -52\\nRepeating with base value of 9\\nCurrent upper boundary is 91\\nCurrent lower boundary is 19\\nResult of base squared minus 4 times lower boundary is 5\\nSimple square root result is 2.23606797749979\\nInteger square root is 2\\nCheck two result is False\\nBase is too low, incrementing base to 10\\nCurrent upper boundary is 90\\nCurrent lower boundary is 9\\nResult of base squared minus 4 times lower boundary is 64\\nSimple square root result is 8.0\\nInteger square root is 8\\nCheck two result is True\\nPasses check one and two, product of upper boundary and total boundary is 9000\\nAfter incrementing by lower boundary, the result is 9009\\nFinal value after use of modular arithmetic is 987\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy use of modular arithmetic, we can continually set an upper and lower boundary value where we move the upper and lower as the total boundary minus a base value and the reversed integer cast of the string form of the upper boundary. This has the advantage of moving upper and lower in steps of approximately 10 for the lower as can be seen above. This eventually finds a base value where we can multiply the upper boundary and add the lower boundary to get our result. This is true in all cases and is based on the same modular arithmetic used in finding the correct key for message passing securely. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIncluded in the approach for ease of calculation is the print statements used to produce example 1\\'s output for your own analysis benefits. \\n\\nSet up your modulo as requested \\nIf n is 1, return 9 by default as provided in example 2 \\nSet a total boundary of 10 to the power of n, as alluded to by values seen in examples 1 and 2. \\n\\nSet base = 1 \\n\\nWhile base is less than total boundary \\n- calc upper boundary as total boundary - base \\n- calc lower boundary as flip of upper boundary as a string \\n- check if base squared minus 4 times lower boundary is positive, storing this in check one \\n    - if it is not positive, base is not yet big enough to give non-complex valuation \\n    - this is because of the base squared - 4 * 1 * c being related to the quadratic formula here \\n    - if it is not positive, increment base by 1 and continue \\n    - otherwise, we proceed to check two \\n- if we proceeded to check two, set up a simple square root result of check one\\'s value and an integer cast square root of this value \\n- if these two values are the same, we have arrived at a modulo that is similar to one another, and as such the base is correct \\n- if not, we can proceed to increment base and continue \\n- if we do have success though \\n    - the product of upper boundary and total boundary gives us our multiple result without the lower boundary \\n    - we increase this by adding lower boundary to the result \\n    - then we can do modulo to arrive at the correct value and return it \\n\\n# Math Explained \\nOur palindrome number at end is 10**n * a + b \\nIf we let n = 2 for the first example then \\n- palindrome number = 100 * (100-base) + b \\n- factor this out to get 100 * 100 - 100*base + b \\n- rearranging this, we can see (100 - c) * (100 - d) \\n    - where c + d = base \\n    - where c * d = b \\n- expanding this gives us \\n    - 100**2 - 100 * c - 100 * d + c * d \\n    - 100**2 -`100(c + d) + c * d  \\n    - 100 * (100 - base) + b \\n    - which if you notice is our factored out form, showing our correctness\\n- now that we know we can do that, we can set up our equations as \\n    - 100 * (100 - base) + b = (100 - c) * (100 - d) \\n    - 100 ** 2 - 100 * base + b = 100 ** 2 - 100 * c+d + c*d\\n    - remove the 100 ** 2 from both sides, add 100 * c + d to the left \\n    - -100*(base) + 100*(c+d) = c*d - b \\n    - factor the 100 side \\n    - 100 ((c+d) - base) = c*d - b \\n    - from our above definitions of where this is true, we can see that we have a quadratic equation situation, such that we can use \\n    - (c-d) ** 2 = base ** 2 - 4 * b \\n    - if we let temp = base ** 2 - 4 * b \\n    - then we can say that c - d = sqrt(temp)\\n    - based on this, so long as temp is positive, the result of c - d is real\\n    - based on that, if temp square rooted is also integer square root of temp, we know that we have a temp that is a whole number, a requirement for our initial finding of a palindrome number \\n    - Then, if temp is positive, and temp\\'s square root is the same as the integer square root of temp \\n        - 100 * (100 - base) + b is our palindrome number \\n    - BUT WHAT OF b?! \\n    - To find the correct b, we want the greatest such lower bound that satisfies these conditions. To check run the print statements on a test case with n = 3. Additionally, based on this we can also find this greatest such satisfying lower bound by moving in steps of 10 ** n - 1 where n is in this case where start, but if base gets large enough, might move down one in size. This could be found through repeated binary searching, but can also be found by having the lower boundary move based on the upper boundary string form reverse valuation. \\n    - This lets us have the lower range set itself appropriately, and based on the result for n = 1, means it will always find at least such a number at the boudning of 1. By showing the same for n = 2 above, we show that such is doable for all n in range, as we will move down appropriately. However something interesting would happen if you tried it on 9, so it is worth an investigation if you feel it.  \\n\\n# Complexity\\n- Time complexity: O(log(n))\\n    - Though base is incrementing by 1, that is not the true point of loop termination. The loop termination is based on lower and upper boundaries relationship, which moves in step sizes of approximately 10 ** (n-1). Thus, we can say that the loop actually terminates in log (n) time. \\n\\n\\n- Space complexity: O(1)\\n    - No additional storage is used  \\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        # set up mod \\n        self.mod = 1337\\n        # deal with edge case \\n        if n == 1 : \\n            return 9 \\n\\n        # set up base \\n        base = 1 \\n        # set up total boundary on palindromic size \\n        # intuition is from example case, where for n = 1 and n = 2 \\n        # we can see that the value of 10 ** n is greater than the answers \\n        # checked via print statements that can be reinitialized if desired \\n        total_boundary = 10**n\\n        # print(f\\'total boundary is {total_boundary}\\')\\n\\n        # loop in range \\n        while base < total_boundary :\\n            # calculate upper boundary \\n            upper_boundary = total_boundary - base\\n            # print(f\\'Current upper boundary is {upper_boundary}\\') \\n            # calculate lowewr boundary as the reversed form of upper boundary \\n            lower_boundary = int(str(upper_boundary)[::-1]) \\n            # print(f\\'Current lower boundary is {lower_boundary}\\')\\n            # first check is if base squared - 4 * lower boundary is greater than 0 \\n            # if no, keep going on incrementing base \\n            check_one = base**2 - 4*lower_boundary\\n            # print(f\\'Result of base squared minus 4 times lower boundary is {check_one}\\')\\n            # if not in range \\n            if check_one < 0 :\\n                # print(f\\'Currently not passing check one, as it has a value of {check_one}\\')\\n                # print(f\\'Repeating with base value of {base+1}\\')\\n                base += 1  \\n                continue \\n            # if we pass check one, check second condition, which is that you have a prime value \\n            # if you have a prime value, then you can for sure use this \\n            simple_square_root = check_one**0.5\\n            # print(f\\'Simple square root result is {simple_square_root}\\')\\n            integer_square_root = int(simple_square_root)\\n            # print(f\\'Integer square root is {integer_square_root}\\')\\n            check_two = simple_square_root == integer_square_root\\n            # print(f\\'Check two result is {check_two}\\')\\n            # if check one and check two \\n            if check_one and check_two : \\n                product = upper_boundary * total_boundary\\n                # print(f\\'Passes check one and two, product of upper boundary and total boundary is {product}\\')\\n                product += lower_boundary\\n                # print(f\\'After incrementing by lower boundary, the result is {product}\\')\\n                # print(f\\'Final value after use of modular arithmetic is {product % self.mod}\\')\\n                return product % self.mod \\n            # print(f\\'Base is too low, incrementing base to {base+1}\\')\\n            base += 1 \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        # set up mod \\n        self.mod = 1337\\n        # deal with edge case \\n        if n == 1 : \\n            return 9 \\n\\n        # set up base \\n        base = 1 \\n        # set up total boundary on palindromic size \\n        # intuition is from example case, where for n = 1 and n = 2 \\n        # we can see that the value of 10 ** n is greater than the answers \\n        # checked via print statements that can be reinitialized if desired \\n        total_boundary = 10**n\\n        # print(f\\'total boundary is {total_boundary}\\')\\n\\n        # loop in range \\n        while base < total_boundary :\\n            # calculate upper boundary \\n            upper_boundary = total_boundary - base\\n            # print(f\\'Current upper boundary is {upper_boundary}\\') \\n            # calculate lowewr boundary as the reversed form of upper boundary \\n            lower_boundary = int(str(upper_boundary)[::-1]) \\n            # print(f\\'Current lower boundary is {lower_boundary}\\')\\n            # first check is if base squared - 4 * lower boundary is greater than 0 \\n            # if no, keep going on incrementing base \\n            check_one = base**2 - 4*lower_boundary\\n            # print(f\\'Result of base squared minus 4 times lower boundary is {check_one}\\')\\n            # if not in range \\n            if check_one < 0 :\\n                # print(f\\'Currently not passing check one, as it has a value of {check_one}\\')\\n                # print(f\\'Repeating with base value of {base+1}\\')\\n                base += 1  \\n                continue \\n            # if we pass check one, check second condition, which is that you have a prime value \\n            # if you have a prime value, then you can for sure use this \\n            simple_square_root = check_one**0.5\\n            # print(f\\'Simple square root result is {simple_square_root}\\')\\n            integer_square_root = int(simple_square_root)\\n            # print(f\\'Integer square root is {integer_square_root}\\')\\n            check_two = simple_square_root == integer_square_root\\n            # print(f\\'Check two result is {check_two}\\')\\n            # if check one and check two \\n            if check_one and check_two : \\n                product = upper_boundary * total_boundary\\n                # print(f\\'Passes check one and two, product of upper boundary and total boundary is {product}\\')\\n                product += lower_boundary\\n                # print(f\\'After incrementing by lower boundary, the result is {product}\\')\\n                # print(f\\'Final value after use of modular arithmetic is {product % self.mod}\\')\\n                return product % self.mod \\n            # print(f\\'Base is too low, incrementing base to {base+1}\\')\\n            base += 1 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416761,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        if n == 1: return 9\\n\\n        a = 1\\n\\n        while a < 10**n:\\n            upper = 10**n-a\\n            lower = int(str(upper)[::-1])\\n            if a**2-lower*4 >= 0 and (a**2-lower*4)**0.5 == int((a**2-lower*4)**0.5):\\n                return (upper*10**n+lower)%1337\\n            a += 1\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        if n == 1: return 9\\n\\n        a = 1\\n\\n        while a < 10**n:\\n            upper = 10**n-a\\n            lower = int(str(upper)[::-1])\\n            if a**2-lower*4 >= 0 and (a**2-lower*4)**0.5 == int((a**2-lower*4)**0.5):\\n                return (upper*10**n+lower)%1337\\n            a += 1\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198832,
                "title": "c-o-1-time-complexity-most-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n == 1) {\\n            return 9;\\n        } else if (n == 2) {\\n            return 9009 % 1337;\\n        } else if (n == 3) {\\n            return 906609 % 1337;\\n        } else if (n == 4) {\\n            return 99000099 % 1337;\\n        } else if (n == 5) {\\n            return 9966006699 % 1337;\\n        } else if (n == 6) {\\n            return 999000000999 % 1337;\\n        } else if (n == 7) {\\n            return 99956644665999 % 1337;\\n        } else if(n == 8) {\\n            return 9999000000009999 % 1337;\\n\\n    }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n == 1) {\\n            return 9;\\n        } else if (n == 2) {\\n            return 9009 % 1337;\\n        } else if (n == 3) {\\n            return 906609 % 1337;\\n        } else if (n == 4) {\\n            return 99000099 % 1337;\\n        } else if (n == 5) {\\n            return 9966006699 % 1337;\\n        } else if (n == 6) {\\n            return 999000000999 % 1337;\\n        } else if (n == 7) {\\n            return 99956644665999 % 1337;\\n        } else if(n == 8) {\\n            return 9999000000009999 % 1337;\\n\\n    }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120390,
                "title": "easiest-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int flip(int n){\\n        // given integer abc returns intger cba by going to a temporary string\\n        auto str = to_string(n);\\n        std::reverse(str.begin(), str.end());\\n        return atoi(str.c_str());\\n    }\\n       \\n    bool isInteger(double v){\\n        // checks if the double v represents an integer value\\n        double tmp;\\n        return std::modf(v, &tmp) == 0.0;\\n        // alternative less robust implementation\\n        // return  static_cast<double>(static_cast<long>(v)) == v;\\n    }\\n    \\n    int largestPalindrome(int n) {\\n        \\n        if (n == 1) return 9;\\n        \\n        const long max = pow(10, n);\\n        \\n        for (int z = 2; z < max -1; z++){\\n            const long left = max -z;\\n            const long right = flip(left);\\n            const double sqrt_term = z*z - 4*right;\\n           \\n\\t\\t    // let\\'s avoid generating nans applying the square root to negative numbers\\n            if (sqrt_term < 0.0){ continue; }\\n            \\n            const double root1 = 0.5*(z + sqrt(sqrt_term));\\n            const double root2 = 0.5*(z - sqrt(sqrt_term));\\n            \\n            if (isInteger(root1) || isInteger(root2)){\\n                return (max*left + right) % 1337;\\n            }\\n        }\\n\\t\\t// This should never be reached so we don\\'t really care about what we return in here\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flip(int n){\\n        // given integer abc returns intger cba by going to a temporary string\\n        auto str = to_string(n);\\n        std::reverse(str.begin(), str.end());\\n        return atoi(str.c_str());\\n    }\\n       \\n    bool isInteger(double v){\\n        // checks if the double v represents an integer value\\n        double tmp;\\n        return std::modf(v, &tmp) == 0.0;\\n        // alternative less robust implementation\\n        // return  static_cast<double>(static_cast<long>(v)) == v;\\n    }\\n    \\n    int largestPalindrome(int n) {\\n        \\n        if (n == 1) return 9;\\n        \\n        const long max = pow(10, n);\\n        \\n        for (int z = 2; z < max -1; z++){\\n            const long left = max -z;\\n            const long right = flip(left);\\n            const double sqrt_term = z*z - 4*right;\\n           \\n\\t\\t    // let\\'s avoid generating nans applying the square root to negative numbers\\n            if (sqrt_term < 0.0){ continue; }\\n            \\n            const double root1 = 0.5*(z + sqrt(sqrt_term));\\n            const double root2 = 0.5*(z - sqrt(sqrt_term));\\n            \\n            if (isInteger(root1) || isInteger(root2)){\\n                return (max*left + right) % 1337;\\n            }\\n        }\\n\\t\\t// This should never be reached so we don\\'t really care about what we return in here\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018114,
                "title": "just-memorization-because-n-is-very-small",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018112,
                "title": "just-memorization-because-n-is-very-small",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012473,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        ll base = pow(10,n);\\n        ll mini  = base/10;\\n        ll limit = base - mini;\\n        ll poli = base*base-1;\\n        vector<ll> d(n,9);    \\n        vector<ll> multi(n);  \\n        vector<ll> multi9(n); \\n        int x = 1;\\n        for (ll x = 1,  i = n-1; i>=0; i--, x *=10) multi[i] = x;  \\n        for (ll x = 9,  i = n-1; i>=0; i--, x *=10) multi9[i] = x;  \\n        for( int i = 1; i<=limit; i++)\\n        {\\n            ll sq = sqrt((double)poli);\\n            for(ll k = base-1; k>sq; k--)\\n                if (poli%k == 0) return poli%1337;\\n            poli -= base;  \\n            int j=0;   \\n            while(d[j]==0)\\n            {\\n                poli += multi9[j];\\n                d[j] = 9;\\n                j++;\\n            }\\n            poli -= multi[j];\\n            d[j]--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        ll base = pow(10,n);\\n        ll mini  = base/10;\\n        ll limit = base - mini;\\n        ll poli = base*base-1;\\n        vector<ll> d(n,9);    \\n        vector<ll> multi(n);  \\n        vector<ll> multi9(n); \\n        int x = 1;\\n        for (ll x = 1,  i = n-1; i>=0; i--, x *=10) multi[i] = x;  \\n        for (ll x = 9,  i = n-1; i>=0; i--, x *=10) multi9[i] = x;  \\n        for( int i = 1; i<=limit; i++)\\n        {\\n            ll sq = sqrt((double)poli);\\n            for(ll k = base-1; k>sq; k--)\\n                if (poli%k == 0) return poli%1337;\\n            poli -= base;  \\n            int j=0;   \\n            while(d[j]==0)\\n            {\\n                poli += multi9[j];\\n                d[j] = 9;\\n                j++;\\n            }\\n            poli -= multi[j];\\n            d[j]--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903886,
                "title": "42ms-luck-based-solution-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestPalindrome(self, n: int):\\n        if n == 1: return 9\\n        for i in range(1, 99999999):\\n            left = str(10**n - 2*i)\\n            right = left[::-1]\\n            if i**2 > int(right) \\\\\\n            and sqrt(i**2 - int(right)).is_integer():\\n                return int(left + right) % 1337\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int):\\n        if n == 1: return 9\\n        for i in range(1, 99999999):\\n            left = str(10**n - 2*i)\\n            right = left[::-1]\\n            if i**2 > int(right) \\\\\\n            and sqrt(i**2 - int(right)).is_integer():\\n                return int(left + right) % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750549,
                "title": "just-for-fun-100-faster",
                "content": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        dic = {1: 9, 2: 987, 3: 123, 4: 597, 5: 677, 6: 1218, 7: 877, 8: 475}\\n        return dic[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        dic = {1: 9, 2: 987, 3: 123, 4: 597, 5: 677, 6: 1218, 7: 877, 8: 475}\\n        return dic[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680994,
                "title": "c",
                "content": "if(n==1)\\n        return 9;\\n    else if(n==2)\\n        return 987;\\n    else if(n==3)\\n        return 123;\\n    else if(n==4)\\n        return 597;\\n    else if(n==5)\\n        return 677;\\n    else if(n==6)\\n        return 1218;\\n    else if(n==7)\\n        return 877;\\n    else if(n==8)\\n        return 475;\\n    else\\n        return 0;",
                "solutionTags": [],
                "code": "if(n==1)\\n        return 9;\\n    else if(n==2)\\n        return 987;\\n    else if(n==3)\\n        return 123;\\n    else if(n==4)\\n        return 597;\\n    else if(n==5)\\n        return 677;\\n    else if(n==6)\\n        return 1218;\\n    else if(n==7)\\n        return 877;\\n    else if(n==8)\\n        return 475;\\n    else\\n        return 0;",
                "codeTag": "Unknown"
            },
            {
                "id": 2673496,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        min_ = 10**(n-1)\\n        max_ = 10**n-1\\n        pal = 0\\n        for i in range(max_, min_ - 1, -2): \\n            if i * i < pal:\\n                break\\n            for j in range(max_, i - 1, -2):\\n                prod = i*j\\n                if prod % 11 != 0 and prod >= pal:\\n                    continue\\n                if str(prod) == str(prod)[::-1]:\\n                    pal = prod\\n        return (pal % 1337)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n == 1:\\n            return 9\\n        min_ = 10**(n-1)\\n        max_ = 10**n-1\\n        pal = 0\\n        for i in range(max_, min_ - 1, -2): \\n            if i * i < pal:\\n                break\\n            for j in range(max_, i - 1, -2):\\n                prod = i*j\\n                if prod % 11 != 0 and prod >= pal:\\n                    continue\\n                if str(prod) == str(prod)[::-1]:\\n                    pal = prod\\n        return (pal % 1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604760,
                "title": "ain-t-much-but-its-honest-work-python",
                "content": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n\\n        if n ==7:\\n            return 877\\n\\n        if n==8 :\\n            return 475\\n\\n        def ispalindrom(i):\\n            return str(i)==str(i)[::-1]\\n        maxj=0\\n        bigj=0\\n        dic={}\\n        for i in range(10**n-1,10**(n-1),-3):\\n            if i<bigj:\\n                break\\n            for j in range(10**n-1,bigj,-2):\\n                if j*i>maxj and ispalindrom(j*i):\\n                    maxj=i*j\\n                    dic[j]=1\\n                    bigj=j\\n                    break\\n        return maxj%1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n\\n        if n ==7:\\n            return 877\\n\\n        if n==8 :\\n            return 475\\n\\n        def ispalindrom(i):\\n            return str(i)==str(i)[::-1]\\n        maxj=0\\n        bigj=0\\n        dic={}\\n        for i in range(10**n-1,10**(n-1),-3):\\n            if i<bigj:\\n                break\\n            for j in range(10**n-1,bigj,-2):\\n                if j*i>maxj and ispalindrom(j*i):\\n                    maxj=i*j\\n                    dic[j]=1\\n                    bigj=j\\n                    break\\n        return maxj%1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536613,
                "title": "c-precompute",
                "content": "We have just several input arguments; we can *precompute* the answers for every input argument:\\n\\n```\\npublic class Solution {\\n    \\n    private static readonly int[] s_Answers = new [] {\\n      0, 9, 987, 123, 597, 677, 1218, 877, 475\\n    };\\n    \\n    public int LargestPalindrome(int n) => s_Answers[n];\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private static readonly int[] s_Answers = new [] {\\n      0, 9, 987, 123, 597, 677, 1218, 877, 475\\n    };\\n    \\n    public int LargestPalindrome(int n) => s_Answers[n];\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461232,
                "title": "c-create-palindrome-check-for-multipliers",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        ll base = pow(10,n);\\n        ll mini  = base/10;\\n        ll limit = base - mini;\\n        ll poli = base*base-1;\\n        vector<ll> d(n,9);    // table use track lower half progress\\n        vector<ll> multi(n);  // table for lower half updates\\n        vector<ll> multi9(n);  // table for lower half updates\\n        int x = 1;\\n        for (ll x = 1,  i = n-1; i>=0; i--, x *=10) multi[i] = x;  // use for update lower half\\n        for (ll x = 9,  i = n-1; i>=0; i--, x *=10) multi9[i] = x;  // use for update lower half\\n        for( int i = 1; i<=limit; i++)\\n        {\\n            ll sq = sqrt((double)poli);\\n            for(ll k = base-1; k>sq; k--)\\n                if (poli%k == 0) return poli%1337;\\n            // find next Palindrome\\n            poli -= base;  // update upper half\\n            int j=0;       // update lower half\\n            while(d[j]==0)\\n            {\\n                poli += multi9[j];\\n                d[j] = 9;\\n                j++;\\n            }\\n            poli -= multi[j];\\n            d[j]--;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        ll base = pow(10,n);\\n        ll mini  = base/10;\\n        ll limit = base - mini;\\n        ll poli = base*base-1;\\n        vector<ll> d(n,9);    // table use track lower half progress\\n        vector<ll> multi(n);  // table for lower half updates\\n        vector<ll> multi9(n);  // table for lower half updates\\n        int x = 1;\\n        for (ll x = 1,  i = n-1; i>=0; i--, x *=10) multi[i] = x;  // use for update lower half\\n        for (ll x = 9,  i = n-1; i>=0; i--, x *=10) multi9[i] = x;  // use for update lower half\\n        for( int i = 1; i<=limit; i++)\\n        {\\n            ll sq = sqrt((double)poli);\\n            for(ll k = base-1; k>sq; k--)\\n                if (poli%k == 0) return poli%1337;\\n            // find next Palindrome\\n            poli -= base;  // update upper half\\n            int j=0;       // update lower half\\n            while(d[j]==0)\\n            {\\n                poli += multi9[j];\\n                d[j] = 9;\\n                j++;\\n            }\\n            poli -= multi[j];\\n            d[j]--;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145939,
                "title": "it-s-not-a-solution-just-memoization",
                "content": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n == 1 ){\\n            return 9;\\n        }\\n       if(n == 2){\\n           return 987;\\n       }\\n        if(n == 3){\\n            return 123;\\n        }\\n        if(n == 4){\\n            return 597;\\n        }\\n        if(n == 5){\\n            return  677;\\n        }\\n        if(n == 6){\\n            return 1218;\\n        }\\n        if(n == 7){\\n            return 877;\\n        }\\n        return 475;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n == 1 ){\\n            return 9;\\n        }\\n       if(n == 2){\\n           return 987;\\n       }\\n        if(n == 3){\\n            return 123;\\n        }\\n        if(n == 4){\\n            return 597;\\n        }\\n        if(n == 5){\\n            return  677;\\n        }\\n        if(n == 6){\\n            return 1218;\\n        }\\n        if(n == 7){\\n            return 877;\\n        }\\n        return 475;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111841,
                "title": "c-not-a-solution-just-interesting",
                "content": "The next technically solves the solution, since there aren\\'t many test cases.  I developed code that would get through about 6, but it always timed out.\\nI figured out 8 by just observation and symmetry, and 7 I got by just letting my code run locally for a bit longer.\\n\\nEither way, this kind of thing is definetely the kind of thing that is a candidate for solving once for all reasonable N and storing in a table.\\n\\n```\\n    public int LargestPalindrome(int n) \\n    {\\n        if (n==1) return (int)(9UL%1337);\\n        if (n==2) return (int)(9009UL%1337);\\n        if (n==3) return (int)(906609UL%1337);       \\n        if (n==4) return (int)(99000099UL%1337);\\n        if (n==5) return (int)(9966006699UL%1337);\\n        if (n==6) return (int)(999000000999UL%1337);\\n        if (n==7) return (int)(99956644665999UL%1337);\\n        if (n==8) return (int)(9999000000009999UL%1337);\\n        return 0;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int LargestPalindrome(int n) \\n    {\\n        if (n==1) return (int)(9UL%1337);\\n        if (n==2) return (int)(9009UL%1337);\\n        if (n==3) return (int)(906609UL%1337);       \\n        if (n==4) return (int)(99000099UL%1337);\\n        if (n==5) return (int)(9966006699UL%1337);\\n        if (n==6) return (int)(999000000999UL%1337);\\n        if (n==7) return (int)(99956644665999UL%1337);\\n        if (n==8) return (int)(9999000000009999UL%1337);\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105650,
                "title": "n-8-and-n-3-managed",
                "content": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n==8:return 475\\n        if n==3:return 123\\n        def ispal(n):\\n            s=str(n)\\n            i,j=0,len(s)-1\\n            while i<j:\\n                if s[i]!=s[j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        l=10**n\\n        s=10**n-1\\n        while True:\\n            l-=1\\n            if ispal(l*s): \\n                return (l*s)%1337\\n            if s==l:\\n                s-=1\\n                l=10**n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n: int) -> int:\\n        if n==8:return 475\\n        if n==3:return 123\\n        def ispal(n):\\n            s=str(n)\\n            i,j=0,len(s)-1\\n            while i<j:\\n                if s[i]!=s[j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        l=10**n\\n        s=10**n-1\\n        while True:\\n            l-=1\\n            if ispal(l*s): \\n                return (l*s)%1337\\n            if s==l:\\n                s-=1\\n                l=10**n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932908,
                "title": "largest-palindrome-product-solution-java",
                "content": "class Solution {\\n  public int largestPalindrome(int n) {\\n    if (n == 1)\\n      return 9;\\n\\n    final int kMod = 1337;\\n    final int upper = (int) Math.pow(10, n) - 1;\\n    final int lower = (int) Math.pow(10, n - 1) - 1;\\n\\n    for (int i = upper; i > lower; --i) {\\n      final long cand = getPalindromeCandidate(i);\\n      for (long j = upper; j * j >= cand; --j)\\n        if (cand % j == 0)\\n          return (int) (cand % kMod);\\n    }\\n\\n    throw new IllegalArgumentException();\\n  }\\n\\n  private long getPalindromeCandidate(int i) {\\n    final String reversed = new StringBuilder().append(i).reverse().toString();\\n    return Long.valueOf(i + reversed);\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int largestPalindrome(int n) {\\n    if (n == 1)\\n      return 9;\\n\\n    final int kMod = 1337;\\n    final int upper = (int) Math.pow(10, n) - 1;\\n    final int lower = (int) Math.pow(10, n - 1) - 1;\\n\\n    for (int i = upper; i > lower; --i) {\\n      final long cand = getPalindromeCandidate(i);\\n      for (long j = upper; j * j >= cand; --j)\\n        if (cand % j == 0)\\n          return (int) (cand % kMod);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1901103,
                "title": "rust-0ms-stupid-approach",
                "content": "```\\n\\nimpl Solution {\\n    pub fn largest_palindrome(n: i32) -> i32 {\\n        match n {\\n            1 => 9,\\n            2 => 987,\\n            3 => 123,\\n            4 => 597,\\n            5 => 677,\\n            6 => 1218,\\n            7 => 877,\\n            8 => 475,\\n            _ => unreachable!(),\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimpl Solution {\\n    pub fn largest_palindrome(n: i32) -> i32 {\\n        match n {\\n            1 => 9,\\n            2 => 987,\\n            3 => 123,\\n            4 => 597,\\n            5 => 677,\\n            6 => 1218,\\n            7 => 877,\\n            8 => 475,\\n            _ => unreachable!(),\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784255,
                "title": "javascript-build-palidrome-7351-ms",
                "content": "```\\nconst ll = BigInt;\\nconst reverse = (s) => { let res = \"\"; for (let i = s.length - 1; i >= 0; i--) { res += s[i]; } return res; };\\n\\nconst largestPalindrome = (n) => {\\n    let max = (\\'9\\'.repeat(n)) - \\'0\\', lmax = ll(max);\\n    for (let i = max;; i--) {\\n        let pal = (i + \\'\\') + reverse((i + \\'\\')), x = ll(pal);\\n        for (let j = lmax; j >= 2; j-= 2n) {\\n            if (x / j > max) break;\\n            if (x % j == 0) return max == 9 ? 9 : x % 1337n;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst ll = BigInt;\\nconst reverse = (s) => { let res = \"\"; for (let i = s.length - 1; i >= 0; i--) { res += s[i]; } return res; };\\n\\nconst largestPalindrome = (n) => {\\n    let max = (\\'9\\'.repeat(n)) - \\'0\\', lmax = ll(max);\\n    for (let i = max;; i--) {\\n        let pal = (i + \\'\\') + reverse((i + \\'\\')), x = ll(pal);\\n        for (let j = lmax; j >= 2; j-= 2n) {\\n            if (x / j > max) break;\\n            if (x % j == 0) return max == 9 ? 9 : x % 1337n;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764143,
                "title": "java-solution-using-enumeration",
                "content": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        //enumrate every palindrome number\\n        if( n == 1) return 9;\\n        // 2 digits\\'s max is 10^2  - 1=99\\n        int maxNum = (int) (Math.pow(10,n) - 1);\\n        for(int i = maxNum;i >= 0; i--){\\n            //find the panlindrome number\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(String.valueOf(i));\\n            StringBuilder b = new StringBuilder();\\n            b.append(String.valueOf(i));\\n            b.reverse();\\n            sb.append(b);\\n            //ex: a-123 b -123 -> b.reverse = 321\\n           //sb = a+ b.verse = 123321 is a palindrome number\\n            long panlindromeNum = Long.valueOf(sb.toString());\\n            for(long j = (long)maxNum; j*j >= panlindromeNum; j--){\\n                if(panlindromeNum % j == 0){\\n                    return (int)( panlindromeNum % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        //enumrate every palindrome number\\n        if( n == 1) return 9;\\n        // 2 digits\\'s max is 10^2  - 1=99\\n        int maxNum = (int) (Math.pow(10,n) - 1);\\n        for(int i = maxNum;i >= 0; i--){\\n            //find the panlindrome number\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(String.valueOf(i));\\n            StringBuilder b = new StringBuilder();\\n            b.append(String.valueOf(i));\\n            b.reverse();\\n            sb.append(b);\\n            //ex: a-123 b -123 -> b.reverse = 321\\n           //sb = a+ b.verse = 123321 is a palindrome number\\n            long panlindromeNum = Long.valueOf(sb.toString());\\n            for(long j = (long)maxNum; j*j >= panlindromeNum; j--){\\n                if(panlindromeNum % j == 0){\\n                    return (int)( panlindromeNum % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509773,
                "title": "c-c-solution-by-math-optimization-beat-80",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(unsigned long val)\\n    {\\n        if((val%10)!=9) return false;\\n        string s=to_string(val);\\n        int left=0, right=s.length()-1;\\n        while(left<right)\\n        {\\n            if(s[left++]!=s[right--]) return false;\\n        }\\n        return true;\\n    }\\n    int largestPalindrome(int n) {\\n        if(n==1) return 9;\\n        unsigned long n_digits=1;\\n        while(n--) n_digits*=10;\\n        unsigned long candidate=0, max_offset=0;\\n        long i, j;\\n        for(i=1; i<n_digits; i+=2)\\n        {\\n            int cnt=0;\\n            if(!((n_digits-i)%11))\\n            {\\n                unsigned long start;\\n                for(j=1, start=(n_digits-i)*(n_digits-j); j<=i; j+=2)\\n                {\\n                    cnt++;\\n                    unsigned long val=start;//(n_digits-i)*(n_digits-j);\\n                    if(isPalindrome(val))\\n                    {\\n                        candidate=val;\\n                        max_offset=n_digits-val/(n_digits-1);\\n                        break;\\n                    }\\n                    start-=((n_digits-i)<<1);\\n                }\\n            }\\n            else\\n            {\\n                unsigned long start;\\n                j=n_digits-n_digits/11*11;\\n                if(!(j&1)) j+=11;\\n                start=(n_digits-i)*(n_digits-j);\\n                int step=(n_digits-i)*22;\\n                for(; j<=i+11; j+=22)\\n                {\\n                    cnt++;\\n                    unsigned long val=start;//(n_digits-i)*(n_digits-j);\\n                    start-=step;\\n                    if(isPalindrome(val))\\n                    {\\n                        candidate=val;\\n                        max_offset=n_digits-val/(n_digits-1);\\n                        break;\\n                    }\\n                }               \\n            }\\n            \\n            if(candidate) break;\\n        }\\n        for(; i<=max_offset; i+=2)\\n        {\\n            for(j=1; j<=i; j+=2)\\n            {\\n                unsigned long val=(n_digits-i)*(n_digits-j);\\n                if(val<=candidate) break;\\n                if(isPalindrome(val))\\n                {\\n                    candidate=val;\\n                    max_offset=n_digits-val/(n_digits-1);\\n                    break;\\n                }\\n            }\\n        }  \\n        return candidate%1337;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(unsigned long val)\\n    {\\n        if((val%10)!=9) return false;\\n        string s=to_string(val);\\n        int left=0, right=s.length()-1;\\n        while(left<right)\\n        {\\n            if(s[left++]!=s[right--]) return false;\\n        }\\n        return true;\\n    }\\n    int largestPalindrome(int n) {\\n        if(n==1) return 9;\\n        unsigned long n_digits=1;\\n        while(n--) n_digits*=10;\\n        unsigned long candidate=0, max_offset=0;\\n        long i, j;\\n        for(i=1; i<n_digits; i+=2)\\n        {\\n            int cnt=0;\\n            if(!((n_digits-i)%11))\\n            {\\n                unsigned long start;\\n                for(j=1, start=(n_digits-i)*(n_digits-j); j<=i; j+=2)\\n                {\\n                    cnt++;\\n                    unsigned long val=start;//(n_digits-i)*(n_digits-j);\\n                    if(isPalindrome(val))\\n                    {\\n                        candidate=val;\\n                        max_offset=n_digits-val/(n_digits-1);\\n                        break;\\n                    }\\n                    start-=((n_digits-i)<<1);\\n                }\\n            }\\n            else\\n            {\\n                unsigned long start;\\n                j=n_digits-n_digits/11*11;\\n                if(!(j&1)) j+=11;\\n                start=(n_digits-i)*(n_digits-j);\\n                int step=(n_digits-i)*22;\\n                for(; j<=i+11; j+=22)\\n                {\\n                    cnt++;\\n                    unsigned long val=start;//(n_digits-i)*(n_digits-j);\\n                    start-=step;\\n                    if(isPalindrome(val))\\n                    {\\n                        candidate=val;\\n                        max_offset=n_digits-val/(n_digits-1);\\n                        break;\\n                    }\\n                }               \\n            }\\n            \\n            if(candidate) break;\\n        }\\n        for(; i<=max_offset; i+=2)\\n        {\\n            for(j=1; j<=i; j+=2)\\n            {\\n                unsigned long val=(n_digits-i)*(n_digits-j);\\n                if(val<=candidate) break;\\n                if(isPalindrome(val))\\n                {\\n                    candidate=val;\\n                    max_offset=n_digits-val/(n_digits-1);\\n                    break;\\n                }\\n            }\\n        }  \\n        return candidate%1337;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198450,
                "title": "ts-solution",
                "content": "```\\nfunction isPalindrome(num: number): boolean {\\n    return num === +(String(num).split(\\'\\').reverse().join(\\'\\'));\\n}\\n\\nfunction largestPalindrome(n: number): number {\\n    let result: number = 0;\\n    const bound: number = +Array(n).fill(9).join(\\'\\');\\n    // const temp: Array<number> = [];\\n\\n    for (let i = bound; i > 0; --i) {\\n        for (let j = bound; j > 0; --j) {\\n            if (isPalindrome(i * j) && result < i * j) {\\n                result = i * j;\\n                // temp.push(i * j);\\n            }\\n        }\\n    }\\n\\n    // return Math.max(...temp) % 1337;\\n    return result % 1337;\\n};\\n```\\n\\nCan someone help for optimization this ts solution to working condition.",
                "solutionTags": [],
                "code": "```\\nfunction isPalindrome(num: number): boolean {\\n    return num === +(String(num).split(\\'\\').reverse().join(\\'\\'));\\n}\\n\\nfunction largestPalindrome(n: number): number {\\n    let result: number = 0;\\n    const bound: number = +Array(n).fill(9).join(\\'\\');\\n    // const temp: Array<number> = [];\\n\\n    for (let i = bound; i > 0; --i) {\\n        for (let j = bound; j > 0; --j) {\\n            if (isPalindrome(i * j) && result < i * j) {\\n                result = i * j;\\n                // temp.push(i * j);\\n            }\\n        }\\n    }\\n\\n    // return Math.max(...temp) % 1337;\\n    return result % 1337;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1182268,
                "title": "whats-wrong-in-it",
                "content": "What is wrong with my code (below)....\\nwhen i run the code in vs code it runs fine , but when i run it here it says that i\\'m wrong.\\nI\\'m new here....should i do something different for it to consider the output instead of print()\\n\\n\\' \\' \\'\\nimport sys\\n\\ndef palindrome(num1,num2):\\n    num=num1*num2\\n    st=str(num)\\n    if st == st[::-1]:\\n        st=int(st)\\n        print(st%1337)\\n        sys.exit()\\n\\nn = input()\\nk = int(n)\\nm = int((9*(10**k))/10)\\nfor i in range(10**k,m,-1):\\n    for j in range(10**k,m,-1):\\n        palindrome(i,j)\\n\\' \\' \\'\\n",
                "solutionTags": [],
                "code": "What is wrong with my code (below)....\\nwhen i run the code in vs code it runs fine , but when i run it here it says that i\\'m wrong.\\nI\\'m new here....should i do something different for it to consider the output instead of print()\\n\\n\\' \\' \\'\\nimport sys\\n\\ndef palindrome(num1,num2):\\n    num=num1*num2\\n    st=str(num)\\n    if st == st[::-1]:\\n        st=int(st)\\n        print(st%1337)\\n        sys.exit()\\n\\nn = input()\\nk = int(n)\\nm = int((9*(10**k))/10)\\nfor i in range(10**k,m,-1):\\n    for j in range(10**k,m,-1):\\n        palindrome(i,j)\\n\\' \\' \\'\\n",
                "codeTag": "Python3"
            },
            {
                "id": 847795,
                "title": "go-100",
                "content": "```\\nfunc largestPalindrome(n int) int { \\n    if n == 1 {\\n        return 9\\n    }\\n    a := int(math.Pow10(n)) - 1\\n    for {\\n        p := makePali(a, n)\\n        if isProduct(p, n) {\\n            return p % 1337\\n        } else {\\n            a--\\n        }\\n    }\\n    return 0\\n}\\n\\nfunc makePali(a int, n int) int {\\n    res := a\\n    for a != 0 {\\n        res = res * 10 + a % 10\\n        a /= 10\\n    }\\n    return res\\n}\\n\\nfunc isProduct(a int, n int) bool {\\n    for i := int(math.Pow10(n)) - 1;\\n    i >= int(math.Pow10(n - 1)) && i >= int(math.Sqrt(float64(a)));\\n    i-- {\\n        if a % i == 0 && getDigit(a / i) == n {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc getDigit(a int) int {\\n    res := 0\\n    for a != 0 {\\n        a /= 10\\n        res++\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestPalindrome(n int) int { \\n    if n == 1 {\\n        return 9\\n    }\\n    a := int(math.Pow10(n)) - 1\\n    for {\\n        p := makePali(a, n)\\n        if isProduct(p, n) {\\n            return p % 1337\\n        } else {\\n            a--\\n        }\\n    }\\n    return 0\\n}\\n\\nfunc makePali(a int, n int) int {\\n    res := a\\n    for a != 0 {\\n        res = res * 10 + a % 10\\n        a /= 10\\n    }\\n    return res\\n}\\n\\nfunc isProduct(a int, n int) bool {\\n    for i := int(math.Pow10(n)) - 1;\\n    i >= int(math.Pow10(n - 1)) && i >= int(math.Sqrt(float64(a)));\\n    i-- {\\n        if a % i == 0 && getDigit(a / i) == n {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc getDigit(a int) int {\\n    res := 0\\n    for a != 0 {\\n        a /= 10\\n        res++\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 630699,
                "title": "java-260-ms-86-faster-non-string",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestPalindrome(int n) {\\n\\t\\t\\tif(n==1)return 9;\\n\\n\\t\\t\\tint high = (int)Math.pow(10,n)-1;\\n\\t\\t\\tint low = high/10;\\n\\n\\n\\n\\t\\t\\tfor(int i=high;i>=low;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong pal = getPalindrome(i);\\n\\n\\t\\t\\t\\tfor(long j=high;j*j>=pal;j--)    \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(pal%j ==0 && (pal/j) <= high){\\n\\n\\t\\t\\t\\t\\t\\treturn (int)(pal%1337);\\n\\t\\t\\t\\t\\t}    \\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\n\\n\\t\\t}\\n\\n\\t\\tpublic long getPalindrome(int num){\\n\\n\\t\\t\\tlong temp =num,result = 0,count =1;\\n\\n\\t\\t\\twhile(temp>0){\\n\\t\\t\\t\\tresult=result*10+temp%10;\\n\\t\\t\\t\\ttemp/=10;\\n\\t\\t\\t\\tcount*=10;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn num*count+result;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestPalindrome(int n) {\\n\\t\\t\\tif(n==1)return 9;\\n\\n\\t\\t\\tint high = (int)Math.pow(10,n)-1;\\n\\t\\t\\tint low = high/10;\\n\\n\\n\\n\\t\\t\\tfor(int i=high;i>=low;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong pal = getPalindrome(i);\\n\\n\\t\\t\\t\\tfor(long j=high;j*j>=pal;j--)    \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(pal%j ==0 && (pal/j) <= high){\\n\\n\\t\\t\\t\\t\\t\\treturn (int)(pal%1337);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 303742,
                "title": "java-tle-brute-force-solution",
                "content": "```\\n   // brute force. but we should not return it immediately\\n    // store it max and compare\\n\\n    public static int largestPalindrome(int n) {\\n        // making largest bound for 2 --> 99, 3 --> 999 etc\\n        long num1 = (long) Math.pow(10,  n) - 1;\\n        if (n > 0 && n < 2){\\n            return 9 % 1337;\\n        }\\n        long maxPalindromProd = 9;\\n        // making lowest bound 2 --> 10 , 3 --> 100\\n        long lowestNuber =  1 + num1 / 10;\\n        for (long i = num1; i >= lowestNuber; i--){\\n            for (long j = i; j >= lowestNuber; j--){\\n                long prod =  i * j;\\n                if (prod < maxPalindromProd){\\n                    break;\\n                }\\n                if (isPalindrome(prod)){\\n                    maxPalindromProd = Math.max(maxPalindromProd, prod);\\n                }\\n            }\\n        }\\n        return (int) (maxPalindromProd % 1337);\\n\\n    }\\n\\n    private static boolean isPalindrome(long prod) {\\n        String s = String.valueOf(prod);\\n        int i = 0;\\n        int j = s.length() -1;\\n        while (i < j){\\n            if (s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   // brute force. but we should not return it immediately\\n    // store it max and compare\\n\\n    public static int largestPalindrome(int n) {\\n        // making largest bound for 2 --> 99, 3 --> 999 etc\\n        long num1 = (long) Math.pow(10,  n) - 1;\\n        if (n > 0 && n < 2){\\n            return 9 % 1337;\\n        }\\n        long maxPalindromProd = 9;\\n        // making lowest bound 2 --> 10 , 3 --> 100\\n        long lowestNuber =  1 + num1 / 10;\\n        for (long i = num1; i >= lowestNuber; i--){\\n            for (long j = i; j >= lowestNuber; j--){\\n                long prod =  i * j;\\n                if (prod < maxPalindromProd){\\n                    break;\\n                }\\n                if (isPalindrome(prod)){\\n                    maxPalindromProd = Math.max(maxPalindromProd, prod);\\n                }\\n            }\\n        }\\n        return (int) (maxPalindromProd % 1337);\\n\\n    }\\n\\n    private static boolean isPalindrome(long prod) {\\n        String s = String.valueOf(prod);\\n        int i = 0;\\n        int j = s.length() -1;\\n        while (i < j){\\n            if (s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294753,
                "title": "big-o",
                "content": "Consider what you can prove or learn in an interview setting.\\nEven if you get a good solution, it seems the lowest upperbound you can give on the performance is O(100^n).\\nFor example for n=8, try every 8-digit number as the first half of the palindrome. And for each palindrome, we need to try dividing it by another 8-digit number. So worst case is 100^n calculations.\\nAny better ideas?",
                "solutionTags": [],
                "code": "Consider what you can prove or learn in an interview setting.\\nEven if you get a good solution, it seems the lowest upperbound you can give on the performance is O(100^n).\\nFor example for n=8, try every 8-digit number as the first half of the palindrome. And for each palindrome, we need to try dividing it by another 8-digit number. So worst case is 100^n calculations.\\nAny better ideas?",
                "codeTag": "Unknown"
            },
            {
                "id": 216878,
                "title": "accepted-python-solution-with-mathematically-optimized-search-space",
                "content": "\\n\\n        class Solution(object):\\n\\t\\t\\tdef largestPalindrome(self, n):\\n\\t\\t\\t\\tm = []\\n\\t\\t\\t\\tstrt = pow(10,n) - 1\\n\\t\\t\\t\\tstop = pow(10,n) - 1 - int(pow(10, math.ceil(n/2.0))) \\n\\t\\t\\n\\t\\t\\t\\tfor i in range(strt, stop, -10):\\n\\t\\t\\t\\t\\tfor j in range(strt, i-10, -10):\\n\\t\\t\\t\\t\\t\\tfor a in [0, -2, -6, -8]:\\n\\t\\t\\t\\t\\t\\t\\tfor b in [0, -2, -6, -8]:\\n\\t\\t\\t\\t\\t\\t\\t\\tk = (i+a)*(j+b)\\n\\t\\t\\t\\t\\t\\t\\t\\tl = int(str(k)[::-1])\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (k==l):\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprint i+a, j+b, k%1337\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn k%1337",
                "solutionTags": [],
                "code": "\\n\\n        class Solution(object):\\n\\t\\t\\tdef largestPalindrome(self, n):\\n\\t\\t\\t\\tm = []\\n\\t\\t\\t\\tstrt = pow(10,n) - 1\\n\\t\\t\\t\\tstop = pow(10,n) - 1 - int(pow(10, math.ceil(n/2.0))) \\n\\t\\t\\n\\t\\t\\t\\tfor i in range(strt, stop, -10):\\n\\t\\t\\t\\t\\tfor j in range(strt, i-10, -10):\\n\\t\\t\\t\\t\\t\\tfor a in [0, -2, -6, -8]:\\n\\t\\t\\t\\t\\t\\t\\tfor b in [0, -2, -6, -8]:\\n\\t\\t\\t\\t\\t\\t\\t\\tk = (i+a)*(j+b)\\n\\t\\t\\t\\t\\t\\t\\t\\tl = int(str(k)[::-1])\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (k==l):\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprint i+a, j+b, k%1337\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn k%1337",
                "codeTag": "Java"
            },
            {
                "id": 207510,
                "title": "fastest-solution-in-scala",
                "content": "1. If max polindrome is a product of two numbers or size n, it\\'s size will be 2n. Thus we have even sized polindrome. \\n2. An even sized polindrome is dividable by 11. So if we have pxq = palindrome, we can iterate over p in steps of 11.\\n3. Now, all we need to do is iterate over palindromes and find one, which id divadable by p, which is iterated down in steps of 11.\\n4. The stick is that p can not be less that palindrome divided by a longest integer of size n.\\nSimple math here:\\nmax = 9999\\npalindrome = pxq\\nq<max\\n->\\npalindrome = pxq<pxmax => p>palindrome/max\\n\\nCode:\\n```\\n  object Solution {\\n    def largestPalindrome(n: Int): Int = {\\n      if (n == 1) return 9\\n      val pow10 = Math.pow(10, n).toInt\\n      val max = pow10-1\\n      val maxp = if(n%2==0) max else max - 9\\n      val lmax = max.toLong\\n      val solutionIterator = for(\\n        ph<-(lmax-1 until lmax/10 by -1).toIterator;\\n        palindrome: Long = ph*pow10+reverseInt(ph);\\n        plim = (palindrome/max).toInt;\\n        p<-(maxp to plim by (-11)).toIterator;\\n        if palindrome%p==0) yield (palindrome % 1337).toInt\\n      solutionIterator.next\\n    }\\n\\n    def reverseInt(x: Long): Long = {\\n      var rev: Long = 0\\n      var q = x\\n      while(q!=0){\\n        rev=rev*10+q%10\\n        q=q/10\\n      }\\n      rev\\n    }\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  object Solution {\\n    def largestPalindrome(n: Int): Int = {\\n      if (n == 1) return 9\\n      val pow10 = Math.pow(10, n).toInt\\n      val max = pow10-1\\n      val maxp = if(n%2==0) max else max - 9\\n      val lmax = max.toLong\\n      val solutionIterator = for(\\n        ph<-(lmax-1 until lmax/10 by -1).toIterator;\\n        palindrome: Long = ph*pow10+reverseInt(ph);\\n        plim = (palindrome/max).toInt;\\n        p<-(maxp to plim by (-11)).toIterator;\\n        if palindrome%p==0) yield (palindrome % 1337).toInt\\n      solutionIterator.next\\n    }\\n\\n    def reverseInt(x: Long): Long = {\\n      var rev: Long = 0\\n      var q = x\\n      while(q!=0){\\n        rev=rev*10+q%10\\n        q=q/10\\n      }\\n      rev\\n    }\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 191564,
                "title": "the-2n-digits-palindrome-is-always-multiple-of-11",
                "content": "In this solution we assume that the number of digits of the palindrome is always 2*n.\nIf this is the case (even number of digits) : the palindrome is multiple of 11 (check the Divisibility by Eleven condition).\nSo one of the two numbers is multiple of 11.\n\nIn the following program, we start by creating the highest palaindrom and try if we can find a n-digits number that can divide it.\nOne can try all the numbers (10^n to 10^(n-1)). But we can iterate only on multipes of 11. \n\n``` java\npublic int largestPalindrome(int n) {\n        if (n == 1) return 9;\n        int max = (int) Math.pow(10, n) - 1;\n        int max_11 = (max / 11)  * 11;\n        long product;\n        for (int i=max; i > (int) Math.pow(10, n-1); i--){\n            product = Long.parseLong(i + new StringBuilder(String.valueOf(i)).reverse().toString());\n            for (long j = max_11; j > (int) Math.pow(10, n-1); j-=11) {\n                if ((product/j) / (max+1) == 0){ \n                    if (product%j==0) return (int)(product% 1337);\n                }\n                else break;\n            }\n        }\n        return -1;\n    }\n```",
                "solutionTags": [],
                "code": "``` java\npublic int largestPalindrome(int n) {\n        if (n == 1) return 9;\n        int max = (int) Math.pow(10, n) - 1;\n        int max_11 = (max / 11)  * 11;\n        long product;\n        for (int i=max; i > (int) Math.pow(10, n-1); i--){\n            product = Long.parseLong(i + new StringBuilder(String.valueOf(i)).reverse().toString());\n            for (long j = max_11; j > (int) Math.pow(10, n-1); j-=11) {\n                if ((product/j) / (max+1) == 0){ \n                    if (product%j==0) return (int)(product% 1337);\n                }\n                else break;\n            }\n        }\n        return -1;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 187673,
                "title": "python-one-line-solution-just-for-fun",
                "content": "```\nclass Solution(object):\n    def largestPalindrome(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return [9, 987, 123, 597, 677, 1218, 877, 475][n - 1]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def largestPalindrome(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return [9, 987, 123, 597, 677, 1218, 877, 475][n - 1]\n```",
                "codeTag": "Java"
            },
            {
                "id": 183388,
                "title": "cheat-solution",
                "content": "```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 9\\n        if n == 2: return 987\\n        if n == 3: return 123 # 913 993\\n        if n == 4: return 597 # 9901 9999\\n        if n == 5: return 677 # 99681 99979\\n        if n == 6: return 1218 # 999001 999999\\n        if n == 7: return 877 # 9997647 9998017\\n        if n == 8: return 475 # 99990001 99999999\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 9\\n        if n == 2: return 987\\n        if n == 3: return 123 # 913 993\\n        if n == 4: return 597 # 9901 9999\\n        if n == 5: return 677 # 99681 99979\\n        if n == 6: return 1218 # 999001 999999\\n        if n == 7: return 877 # 9997647 9998017\\n        if n == 8: return 475 # 99990001 99999999\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180805,
                "title": "who-can-explain-this-code",
                "content": "int reverse(int x)\\n{\\n    int rtn = 0;\\n    while(x)\\n    {\\n        rtn = rtn*10 + x%10;\\n        x /= 10;\\n    }\\n    return rtn;\\n}\\nint largestPalindrome(int n) {\\n    if(n == 1)\\n        return 9;\\n    int max = pow(10,n), rtn = 0;\\n    for(int x = 1; x < max; x++)\\n    {\\n        long L = max - x;\\n        long R = reverse(L);\\n        int dif = pow(x,2) - 4*R;\\n        if(dif < 0)\\n            continue;\\n        else\\n        {\\n            if(sqrt(dif) == (int)sqrt(dif))\\n            {\\n                rtn = (L*max + R)%1337;\\n                break;\\n            }     \\n        }\\n    }\\n    return rtn;\\n}\\n",
                "solutionTags": [],
                "code": "int reverse(int x)\\n{\\n    int rtn = 0;\\n    while(x)\\n    {\\n        rtn = rtn*10 + x%10;\\n        x /= 10;\\n    }\\n    return rtn;\\n}\\nint largestPalindrome(int n) {\\n    if(n == 1)\\n        return 9;\\n    int max = pow(10,n), rtn = 0;\\n    for(int x = 1; x < max; x++)\\n    {\\n        long L = max - x;\\n        long R = reverse(L);\\n        int dif = pow(x,2) - 4*R;\\n        if(dif < 0)\\n            continue;\\n        else\\n        {\\n            if(sqrt(dif) == (int)sqrt(dif))\\n            {\\n                rtn = (L*max + R)%1337;\\n                break;\\n            }     \\n        }\\n    }\\n    return rtn;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 146725,
                "title": "unsolved-only-reach-6-i-want-to-share-it-anyway",
                "content": "Enumerate from the largest product to the least, whenever it is palindrom, return it\\nusing method similar to this problem\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/\\ncan reach n=6, but ETL when n=7\\n```python\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 0\\n        \\n        nums = range(10**(n-1), 10**n)[::-1]\\n        size = len(nums)\\n        h = [(-nums[0]*nums[0], 0, 0)]\\n        while h:\\n            v, i, j = heapq.heappop(h)\\n            v = str(abs(v))\\n            if v == v[::-1]:\\n                return int(v) % 1337\\n            if i + 1 < size and j == 0:\\n                heapq.heappush(h, (-nums[i+1]*nums[0], i+1, 0))\\n            if j + 1 < size:\\n                heapq.heappush(h, (-nums[i]*nums[j+1], i, j+1))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 0\\n        \\n        nums = range(10**(n-1), 10**n)[::-1]\\n        size = len(nums)\\n        h = [(-nums[0]*nums[0], 0, 0)]\\n        while h:\\n            v, i, j = heapq.heappop(h)\\n            v = str(abs(v))\\n            if v == v[::-1]:\\n                return int(v) % 1337\\n            if i + 1 < size and j == 0:\\n                heapq.heappush(h, (-nums[i+1]*nums[0], i+1, 0))\\n            if j + 1 < size:\\n                heapq.heappush(h, (-nums[i]*nums[j+1], i, j+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140554,
                "title": "naive-implementation-for-c-with-70ms-and-mathematical-lower-bound",
                "content": "search (i, j) such that i<j and i*j>max_ans and i*j is palindrome.\\nmax_ans increase every update so that search space gradually decrease.\\nIn any 10>n>2, 111...111 * 111...111 = 123...321 is a palindrome.\\nMoreover, if n=even, (10^n-1) * (10^n+1-10^(n/2)) is also a palindrome.\\nThis is because :\\n(10^n-1) * (10^n+1) = 999...999 is a plindrome and there are 2*n 9s.\\nif middle n 9s are changed to n 0s, this number still be a parindrome.\\nThis change can be achieved by decrease (10^n-1)*10^(n/2)\\nSo that (10^n-1) * (10^n+1-10^(n/2)) is a parindrome and this gives lower bound when n = even.\\n\\n```\\nclass Solution {\\nprivate:\\n  bool check(long int x){\\n    int k=0;\\n    int x_copy = x;\\n    while(x!=0){\\n      k *= 10;\\n      k += x%10;\\n      x /= 10;\\n    }\\n    return (x_copy == k);\\n  }\\npublic:\\n    int largestPalindrome(int n) {\\n      if(n==1) return 9;\\n      \\n      long long int max_ans = 1;\\n      \\n      if(n%2==0){\\n        long long int a=1;\\n        long long int b=1;\\n        long long int c=1;\\n        for(int i=0; i<n; ++i){\\n          a*=10;\\n          b*=10;\\n        }\\n        a-=1;\\n        b+=1;\\n        for(int i=0; i<n/2; ++i){\\n          c*=10;\\n        }\\n        b-=c;\\n        max_ans = a*b;\\n      }else{\\n        long long int a=1;\\n        for(int i=0; i<n-1; ++i){\\n          a *= 10;\\n          a += 1;\\n        }\\n        max_ans = a*a;\\n      }\\n      \\n      long long int n_max = 1;\\n      for(int i=0; i<n; ++i){\\n        n_max*=10;\\n      }\\n      vector<long int> ans_vec;\\n      for(long long int i=n_max-1; i*(n_max-1)>max_ans; i-=2){\\n        if(i%5==0) continue;\\n        for(long long int j=n_max-1; (i*j>max_ans && j>=i); j-=2){\\n          if(((i%10)*(j%10))%10 != 9) continue;\\n          \\n          long long int k = i*j;\\n          if(check(k)){\\n            max_ans = k;\\n          }\\n        }\\n      }\\n      return max_ans%1337;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n  bool check(long int x){\\n    int k=0;\\n    int x_copy = x;\\n    while(x!=0){\\n      k *= 10;\\n      k += x%10;\\n      x /= 10;\\n    }\\n    return (x_copy == k);\\n  }\\npublic:\\n    int largestPalindrome(int n) {\\n      if(n==1) return 9;\\n      \\n      long long int max_ans = 1;\\n      \\n      if(n%2==0){\\n        long long int a=1;\\n        long long int b=1;\\n        long long int c=1;\\n        for(int i=0; i<n; ++i){\\n          a*=10;\\n          b*=10;\\n        }\\n        a-=1;\\n        b+=1;\\n        for(int i=0; i<n/2; ++i){\\n          c*=10;\\n        }\\n        b-=c;\\n        max_ans = a*b;\\n      }else{\\n        long long int a=1;\\n        for(int i=0; i<n-1; ++i){\\n          a *= 10;\\n          a += 1;\\n        }\\n        max_ans = a*a;\\n      }\\n      \\n      long long int n_max = 1;\\n      for(int i=0; i<n; ++i){\\n        n_max*=10;\\n      }\\n      vector<long int> ans_vec;\\n      for(long long int i=n_max-1; i*(n_max-1)>max_ans; i-=2){\\n        if(i%5==0) continue;\\n        for(long long int j=n_max-1; (i*j>max_ans && j>=i); j-=2){\\n          if(((i%10)*(j%10))%10 != 9) continue;\\n          \\n          long long int k = i*j;\\n          if(check(k)){\\n            max_ans = k;\\n          }\\n        }\\n      }\\n      return max_ans%1337;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122449,
                "title": "my-working-javascript-solution",
                "content": "As you guys mentioned before, it will be overflow when `n=8`, so I just hard coded the last input. Hope this helps.\\n\\n```\\nvar largestPalindrome = function(n){\\n  if(n == 1){\\n    return 9;\\n  // to deal with overflow\\n  }else if(n === 8){\\n    return 475;\\n  }\\n  //\\n  let max = Math.pow(10, n);\\n  let min = Math.pow(10, n-1);\\n  let ret = 0;\\n\\n  for(let i = max-1; i > 0; i--){\\n    ret = i * max + getReverse(i);\\n    // console.log(\\'ret\\', ret, i, n);\\n    for(let factor = ~~Math.sqrt(ret); factor < max; factor++){\\n      //\\n      if (ret % factor == 0 && ret / factor < max){\\n        return ret % 1337;\\n      }\\n    }\\n  }\\n  return -1;\\n}\\n\\n// 1234 --> 4321\\nfunction getReverse(n){\\n  let result = 0;\\n  // copy\\n  let num = n;\\n  while(num > 0){\\n    result = result * 10 + num % 10;\\n    num = ~~(num / 10);\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestPalindrome = function(n){\\n  if(n == 1){\\n    return 9;\\n  // to deal with overflow\\n  }else if(n === 8){\\n    return 475;\\n  }\\n  //\\n  let max = Math.pow(10, n);\\n  let min = Math.pow(10, n-1);\\n  let ret = 0;\\n\\n  for(let i = max-1; i > 0; i--){\\n    ret = i * max + getReverse(i);\\n    // console.log(\\'ret\\', ret, i, n);\\n    for(let factor = ~~Math.sqrt(ret); factor < max; factor++){\\n      //\\n      if (ret % factor == 0 && ret / factor < max){\\n        return ret % 1337;\\n      }\\n    }\\n  }\\n  return -1;\\n}\\n\\n// 1234 --> 4321\\nfunction getReverse(n){\\n  let result = 0;\\n  // copy\\n  let num = n;\\n  while(num > 0){\\n    result = result * 10 + num % 10;\\n    num = ~~(num / 10);\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112113,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nlong int creatPalindrome(long int num,int n){\\n    long int p=num*pow(10,n);\\n    for(int i=0;i<n;i++){\\n        p=p+(num/(long int)pow(10,n-i-1))*(long int)pow(10,i);\\n        num=num%(long int)pow(10,n-i-1);\\n    }\\n    return p;\\n}\\nint largestPalindrome(int n) {\\n    if(n==1){return 9;}\\n    long int p=pow(10,n)-1;\\n    long int q=p;\\n    long int temp=pow(10,n-1);\\n    long int ret=0;\\n    long int ret1=0;\\n    while(p>=temp){ \\n        ret=creatPalindrome(p,n);\\n        for(int i=q;i>=temp;i--){\\n            ret1=ret/i;\\n            if(ret1>=i){break;}\\n            if(ret1>=temp&&ret%i==0){return ret%1337;}\\n        }\\n        p--;\\n    }\\n    return NULL;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nlong int creatPalindrome(long int num,int n){\\n    long int p=num*pow(10,n);\\n    for(int i=0;i<n;i++){\\n        p=p+(num/(long int)pow(10,n-i-1))*(long int)pow(10,i);\\n        num=num%(long int)pow(10,n-i-1);\\n    }\\n    return p;\\n}\\nint largestPalindrome(int n) {\\n    if(n==1){return 9;}\\n    long int p=pow(10,n)-1;\\n    long int q=p;\\n    long int temp=pow(10,n-1);\\n    long int ret=0;\\n    long int ret1=0;\\n    while(p>=temp){ \\n        ret=creatPalindrome(p,n);\\n        for(int i=q;i>=temp;i--){\\n            ret1=ret/i;\\n            if(ret1>=i){break;}\\n            if(ret1>=temp&&ret%i==0){return ret%1337;}\\n        }\\n        p--;\\n    }\\n    return NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96289,
                "title": "java-back-tracking-beats-93",
                "content": "    public int largestPalindrome(int n) {\\n        if (n == 1)\\n            return 9;\\n        long up = (long)Math.pow(10, n)-1;\\n        long low = (long)Math.pow(10, n-1);\\n        long max = up*up;\\n        return scan(new StringBuilder(), 0, n, max, low, up);\\n    }\\n    \\n    private int scan(StringBuilder sb, int step, int n, long max, long low, long up) {\\n        if (step == n) {\\n            String reverse = new StringBuilder(sb.toString()).reverse().toString();\\n            long ret = Long.parseLong(sb.toString()+reverse);\\n            if (valid(ret, max, low, up))\\n                return (int)(ret % 1337);\\n            return -1;\\n        }\\n        for (int i = 9; i >= 0; i--) {\\n            sb.append(i);\\n            int ret = scan(sb, step+1, n, max, low, up);\\n            if (ret != -1)\\n                return ret;\\n            sb.deleteCharAt(step);\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean valid(long num, long max, long low, long up) {\\n        if (num > max)\\n            return false;\\n        for (long i = up; i >= low && i*i >= num; i--) {\\n            if (num % i == 0)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public int largestPalindrome(int n) {\\n        if (n == 1)\\n            return 9;\\n        long up = (long)Math.pow(10, n)-1;\\n        long low = (long)Math.pow(10, n-1);\\n        long max = up*up;\\n        return scan(new StringBuilder(), 0, n, max, low, up);\\n    }\\n    \\n    private int scan(StringBuilder sb, int step, int n, long max, long low, long up) {\\n        if (step == n) {\\n            String reverse = new StringBuilder(sb.toString()).reverse().toString();\\n            long ret = Long.parseLong(sb.toString()+reverse);\\n            if (valid(ret, max, low, up))\\n                return (int)(ret % 1337);\\n            return -1;\\n        }\\n        for (int i = 9; i >= 0; i--) {\\n            sb.append(i);\\n            int ret = scan(sb, step+1, n, max, low, up);\\n            if (ret != -1)\\n                return ret;\\n            sb.deleteCharAt(step);\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean valid(long num, long max, long low, long up) {\\n        if (num > max)\\n            return false;\\n        for (long i = up; i >= low && i*i >= num; i--) {\\n            if (num % i == 0)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 96295,
                "title": "brute-force-search-with-analysis-391ms-easy-to-understand-java-code",
                "content": "I can understand why this question is marked as easy, because it is actually a brute force search. But IMO, brute force search is not always easy. To analysis the time complexity, let's suppose the largest factor is N. If n = 4, N = 9999 = O(10^4).\\n\\nThought 1: Simple Brute Force.\\n\\nFor example, if n = 4, try all the multiplications for x * y where x <= 9999, y <= 9999, and check palindrome for each multiplication, and output the largest one. It takes O(N^2) time and up to O(10^16) since n can be 8. But actually the answer tends to be large, so there are lots of wasteful search for small multiplications. To do BF more wisely, we need to stop earlier when we find the answer. It comes to thought 2.\\n\\nThought 2: Ordered Brute Force\\n\\nStill BF, but can we search in some order and stop earlier? Can we search in descending order? For example n = 2, can we search in the order as: 99 * 99, 99 * 98, 98 * 98, 99 * 97,...? Actually there is another leetcode question to solve this. Basically we can use a heap with O(N) space, and each search takes O(logN) time, instead of O(1), but it is ordered search. Time is OK because N <= 10^8, then O(logN) ~= O(1). The problem is space, it takes up to 400MB. So think about how to reduce space...\\n\\nHow about guess the answer? It only has limited number of possible answers. Since we can check if the answer is valid in O(N) time, so we can try all possible answers in descending order, and check. for example n = 3, starting from answer 999999, 998899, 997799, and so on. Is there always an answer? Yes, 111 * 111 is always pal. So the search can stop at answer 12321. The worst case of this solution is still O(N^2) if the answer is actually small, but in most cases, the search stops early because answer is likely to be large. Here is the code:\\n\\n```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n    \\tlong prefix = (long)Math.pow(10, n) - 1; // 9999 for n = 4.\\n    \\tlong prefixMin = (long)Math.pow(10, n - 1); // 1000 for n = 4.\\n    \\tfor (long i = prefix; i >= prefixMin; --i) {\\n    \\t\\tlong pal = construct1(i);\\n    \\t\\tif (canFind(pal, prefix)) {\\n    \\t\\t\\treturn (int)(pal % 1337);\\n    \\t\\t}\\n    \\t}\\n    \\t// At least we know answer always exists, 1111 * 1111 = 1234321 for n = 4.\\n    \\tfor (long i = prefix; i >= prefixMin; --i) {\\n    \\t\\tlong pal = construct2(i);\\n    \\t\\tif (canFind(pal, prefix)) {\\n    \\t\\t\\treturn (int)(pal % 1337);\\n    \\t\\t}\\n    \\t}\\n    \\treturn -1;\\n    }\\n\\n    // With prefix xyz, construct pal xyzzyx.\\n    private long construct1(long prefix) {\\n    \\tlong base = prefix;\\n    \\tlong rst = 0;\\n    \\twhile (prefix > 0) {\\n    \\t\\tbase *= 10;\\n    \\t\\tlong d = prefix % 10;\\n    \\t\\trst = rst * 10 + d;\\n    \\t\\tprefix /= 10;\\n    \\t}\\n    \\trst += base;\\n    \\treturn rst;\\n    }\\n\\n    // With prefix xyz, construct pal xyzyx.\\n    private long construct2(long prefix) {\\n    \\tlong base = prefix;\\n    \\tprefix /= 10;\\n    \\tlong rst = 0;\\n    \\twhile (prefix > 0) {\\n    \\t\\tbase *= 10;\\n    \\t\\tlong d = prefix % 10;\\n    \\t\\trst = rst * 10 + d;\\n    \\t\\tprefix /= 10;\\n    \\t}\\n    \\trst += base;\\n    \\treturn rst;\\n    }\\n\\n    // Check if there are 2 integers x, y such that\\n    // x * y = pal and x <= upper and y <= upper.\\n    private boolean canFind(long pal, long upper) {\\n    \\tfor (long i = upper; i * i >= pal; --i) {\\n    \\t\\tif (pal % i == 0 && pal / i <= upper) {\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t}\\n    \\treturn false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n    \\tlong prefix = (long)Math.pow(10, n) - 1; // 9999 for n = 4.\\n    \\tlong prefixMin = (long)Math.pow(10, n - 1); // 1000 for n = 4.\\n    \\tfor (long i = prefix; i >= prefixMin; --i) {\\n    \\t\\tlong pal = construct1(i);\\n    \\t\\tif (canFind(pal, prefix)) {\\n    \\t\\t\\treturn (int)(pal % 1337);\\n    \\t\\t}\\n    \\t}\\n    \\t// At least we know answer always exists, 1111 * 1111 = 1234321 for n = 4.\\n    \\tfor (long i = prefix; i >= prefixMin; --i) {\\n    \\t\\tlong pal = construct2(i);\\n    \\t\\tif (canFind(pal, prefix)) {\\n    \\t\\t\\treturn (int)(pal % 1337);\\n    \\t\\t}\\n    \\t}\\n    \\treturn -1;\\n    }\\n\\n    // With prefix xyz, construct pal xyzzyx.\\n    private long construct1(long prefix) {\\n    \\tlong base = prefix;\\n    \\tlong rst = 0;\\n    \\twhile (prefix > 0) {\\n    \\t\\tbase *= 10;\\n    \\t\\tlong d = prefix % 10;\\n    \\t\\trst = rst * 10 + d;\\n    \\t\\tprefix /= 10;\\n    \\t}\\n    \\trst += base;\\n    \\treturn rst;\\n    }\\n\\n    // With prefix xyz, construct pal xyzyx.\\n    private long construct2(long prefix) {\\n    \\tlong base = prefix;\\n    \\tprefix /= 10;\\n    \\tlong rst = 0;\\n    \\twhile (prefix > 0) {\\n    \\t\\tbase *= 10;\\n    \\t\\tlong d = prefix % 10;\\n    \\t\\trst = rst * 10 + d;\\n    \\t\\tprefix /= 10;\\n    \\t}\\n    \\trst += base;\\n    \\treturn rst;\\n    }\\n\\n    // Check if there are 2 integers x, y such that\\n    // x * y = pal and x <= upper and y <= upper.\\n    private boolean canFind(long pal, long upper) {\\n    \\tfor (long i = upper; i * i >= pal; --i) {\\n    \\t\\tif (pal % i == 0 && pal / i <= upper) {\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t}\\n    \\treturn false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96296,
                "title": "easy-solution-time-complexity-o-1-language-agnostic",
                "content": "```\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        solutions = [\\n            None, 9, 9009, 906609, 99000099,\\n            9966006699, 999000000999,\\n            99956644665999, 9999000000009999\\n        ]\\n        return solutions[n] % 1337\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        solutions = [\\n            None, 9, 9009, 906609, 99000099,\\n            9966006699, 999000000999,\\n            99956644665999, 9999000000009999\\n        ]\\n        return solutions[n] % 1337\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96298,
                "title": "short-straightforward-solution-with-string-conversion",
                "content": "Since the input range `n` is so limited, I just did a straightforward solution with string to value conversion.\\n\\n**NOTE:** Avoid using C++ function `pow(double, double)` for floating point issue.\\n```cpp\\npublic:    \\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        \\n        UL half = stoul(string(n,'9')), low = stoul(string(n-1,'9'));\\n        while (half > low) {\\n            UL x = getPalindrome(half--);\\n            if (productN(x, n)) return x%1337;\\n        }\\n        return -1;\\n    }\\n    \\nprivate:\\n    typedef unsigned long UL;\\n    \\n    // get palindrome number with given first half\\n    UL getPalindrome(UL half) {\\n        string s = to_string(half), rev(s.rbegin(),s.rend());\\n        return stoul(s + rev);\\n    } \\n    \\n    // check if x is product of two n-digit numbers\\n    bool productN(UL x, int n) {\\n        for (UL d = stoul(string(n, '9')); d >= x/d; --d)\\n            if (x%d == 0 && to_string(x/d).size() == n) return true;\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\npublic:    \\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        \\n        UL half = stoul(string(n,'9')), low = stoul(string(n-1,'9'));\\n        while (half > low) {\\n            UL x = getPalindrome(half--);\\n            if (productN(x, n)) return x%1337;\\n        }\\n        return -1;\\n    }\\n    \\nprivate:\\n    typedef unsigned long UL;\\n    \\n    // get palindrome number with given first half\\n    UL getPalindrome(UL half) {\\n        string s = to_string(half), rev(s.rbegin(),s.rend());\\n        return stoul(s + rev);\\n    } \\n    \\n    // check if x is product of two n-digit numbers\\n    bool productN(UL x, int n) {\\n        for (UL d = stoul(string(n, '9')); d >= x/d; --d)\\n            if (x%d == 0 && to_string(x/d).size() == n) return true;\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96299,
                "title": "solution-for-fun-that-beats-100",
                "content": "The observation is that for the product to be representable by `long`, `n` cannot be very large. So we can pre-compute and memoize.\\n\\nHere's my solution:\\n\\n```\\npublic class Solution {\\n    public int LargestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        if (n == 2) return 987;\\n        if (n == 3) return 123;\\n        if (n == 4) return 597;\\n        if (n == 5) return 677;\\n        if (n == 6) return 1218;\\n        if (n == 7) return 877;\\n        if (n == 8) return 475;\\n        \\n        throw new NotSupportedException();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        if (n == 2) return 987;\\n        if (n == 3) return 123;\\n        if (n == 4) return 597;\\n        if (n == 5) return 677;\\n        if (n == 6) return 1218;\\n        if (n == 7) return 877;\\n        if (n == 8) return 475;\\n        \\n        throw new NotSupportedException();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96302,
                "title": "this-is-my-python-code-uff0cbut-output-time-limit-exceeded-when-input-8-who-can-help-me",
                "content": "This is my python code\\n\\n    def largestPalindrome(self, n):\\n        if n==1:\\n            return 9\\n        max=int(10**n-1)\\n        find=False\\n        v=int(max-1)\\n        while(v>9*max/10):\\n            u=self.getPalin(v)\\n            x=max\\n            while(x*x>=u):\\n                if(u%x==0):\\n                    find=True\\n                    break\\n                x-=1\\n            if find:\\n                break\\n            v-=1\\n        return int(u%1337)\\n\\n    def getPalin(self,x):\\n        total=str(x)+str(`x`[::-1])\\n        return long(total)",
                "solutionTags": [],
                "code": "This is my python code\\n\\n    def largestPalindrome(self, n):\\n        if n==1:\\n            return 9\\n        max=int(10**n-1)\\n        find=False\\n        v=int(max-1)\\n        while(v>9*max/10):\\n            u=self.getPalin(v)\\n            x=max\\n            while(x*x>=u):\\n                if(u%x==0):\\n                    find=True\\n                    break\\n                x-=1\\n            if find:\\n                break\\n            v-=1\\n        return int(u%1337)\\n\\n    def getPalin(self,x):\\n        total=str(x)+str(`x`[::-1])\\n        return long(total)",
                "codeTag": "Python3"
            },
            {
                "id": 96304,
                "title": "simple-java-solution",
                "content": "I separated out the case when n = 1. In all other cases, we can always find a palindrome with 2n digits. \\nThen for each palindrome I formed, test it whether it can be divided by size n integer.\\n```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 9;\\n        long start = (long)Math.pow((Math.pow(10,n)-1),2) / (long)Math.pow(10,n)-1;\\n        long end = (long)Math.pow(10,n-1);\\n        for(long i = start; i > end; i--){\\n            String s = new StringBuilder(Long.toString(i)).reverse().toString();\\n            long formedPali = Long.parseLong(Long.toString(i) + s);\\n            if(canBeDivide(formedPali,n))  return (int)(formedPali%1337);\\n        }        \\n        return -1%1337;\\n    }\\n    \\n    private boolean canBeDivide(long n, int size){\\n        long div = (long)Math.pow(10,size)-1;\\n        while(n/div < div){\\n            if(n%div==0) return true;\\n            div--;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 9;\\n        long start = (long)Math.pow((Math.pow(10,n)-1),2) / (long)Math.pow(10,n)-1;\\n        long end = (long)Math.pow(10,n-1);\\n        for(long i = start; i > end; i--){\\n            String s = new StringBuilder(Long.toString(i)).reverse().toString();\\n            long formedPali = Long.parseLong(Long.toString(i) + s);\\n            if(canBeDivide(formedPali,n))  return (int)(formedPali%1337);\\n        }        \\n        return -1%1337;\\n    }\\n    \\n    private boolean canBeDivide(long n, int size){\\n        long div = (long)Math.pow(10,size)-1;\\n        while(n/div < div){\\n            if(n%div==0) return true;\\n            div--;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96307,
                "title": "c-code-getting-tle-at-n-7",
                "content": "That code works at Geeksforgeeks website, which has the same question except the mod1337 part. But I get TLE when n= 7. n=8 works fine.\\n```\\nint largestPalindrome(int n) {\\n        long long maxProd = 0;\\n        long long low = pow(10, n-1);\\n        long long high = low*10-1;\\n        \\n        for(long long i = high; i >= low; i--) {\\n            for(long long j = i; j >= low; j--) {\\n                long long prod = i*j;\\n                if(prod <= maxProd) break;\\n                long long rev = 0, num = prod;\\n                while(num != 0) {\\n                    rev = rev * 10 + num % 10;\\n                    num/=10;\\n                }\\n                if(prod == rev && prod > maxProd) maxProd = prod;\\n            }\\n        }\\n        return maxProd%1337;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPalindrome(int n) {\\n        long long maxProd = 0;\\n        long long low = pow(10, n-1);\\n        long long high = low*10-1;\\n        \\n        for(long long i = high; i >= low; i--) {\\n            for(long long j = i; j >= low; j--) {\\n                long long prod = i*j;\\n                if(prod <= maxProd) break;\\n                long long rev = 0, num = prod;\\n                while(num != 0) {\\n                    rev = rev * 10 + num % 10;\\n                    num/=10;\\n                }\\n                if(prod == rev && prod > maxProd) maxProd = prod;\\n            }\\n        }\\n        return maxProd%1337;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96308,
                "title": "python-code-tle-when-n-is-8",
                "content": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if n == 1:\\n            return 9\\n        \\n        max_number = 10**n - 1\\n        upper_bound = max_number**2\\n        prefix = upper_bound / 10**n\\n        \\n        while True:\\n            suffix = 0\\n            temp = prefix\\n            while temp:\\n                suffix = 10 * suffix + temp % 10\\n                temp /= 10\\n            guess = prefix * 10**n + suffix\\n            if guess <= upper_bound:\\n                num = max_number\\n                while num > guess / max_number:\\n                    if guess % num == 0:\\n                        return guess % 1337\\n                    num -= 1\\n            prefix -= 1\\n```\\n```max_number```: the largest n-digit number\\n```upper_bound```: the largest possible product\\n```prefix```: the first half of the guessed palindrome number\\n```suffix```: the second half of the guessed palindrome number\\n```guess```: the guessed/generated palindrome number\\n\\nI think the code works fine, but it gets TLE for n = 8. Can anyone point out how to modify this code to get it passed? Thanks!",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if n == 1:\\n            return 9\\n        \\n        max_number = 10**n - 1\\n        upper_bound = max_number**2\\n        prefix = upper_bound / 10**n\\n        \\n        while True:\\n            suffix = 0\\n            temp = prefix\\n            while temp:\\n                suffix = 10 * suffix + temp % 10\\n                temp /= 10\\n            guess = prefix * 10**n + suffix\\n            if guess <= upper_bound:\\n                num = max_number\\n                while num > guess / max_number:\\n                    if guess % num == 0:\\n                        return guess % 1337\\n                    num -= 1\\n            prefix -= 1\\n```\n```max_number```\n```upper_bound```\n```prefix```\n```suffix```\n```guess```",
                "codeTag": "Java"
            },
            {
                "id": 96310,
                "title": "java-solution-backtracking",
                "content": "The lower/upper bounds are inspired by @chiranjeeb2 in [Java Solution using assumed max palindrom](/post/159550):\\n```\\npublic class Solution {\\n    int result = 0;\\n    boolean found = false;\\n\\n    public int largestPalindrome(int n) {\\n        if(n == 1) return 9;\\n        StringBuilder sb = new StringBuilder();\\n        solve(sb, 9, n);\\n        return result;\\n    }\\n    \\n    public void solve(StringBuilder sb, int n, int len){\\n        if(found) return;\\n        if(sb.length() == len*2){\\n            long x = Long.parseLong(sb.toString());\\n            int upperBound = (int) Math.pow(10, len) - 1; \\n            int lowerBound = upperBound / 10;\\n\\n            for(int div = upperBound; div > lowerBound; div--){\\n                if(x/div > upperBound) return;\\n                if(x % div == 0) {\\n                    found = true;\\n                    result = (int) (x % 1337);\\n                    return;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        for(int i = n; i >= 0; i--){\\n            if(found) return;\\n            sb.insert(sb.length()/2, i+\"\"+i);\\n            solve(sb, 9, len);\\n            int idx = (sb.length()-1)/2;\\n            sb.delete(idx,idx+2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int result = 0;\\n    boolean found = false;\\n\\n    public int largestPalindrome(int n) {\\n        if(n == 1) return 9;\\n        StringBuilder sb = new StringBuilder();\\n        solve(sb, 9, n);\\n        return result;\\n    }\\n    \\n    public void solve(StringBuilder sb, int n, int len){\\n        if(found) return;\\n        if(sb.length() == len*2){\\n            long x = Long.parseLong(sb.toString());\\n            int upperBound = (int) Math.pow(10, len) - 1; \\n            int lowerBound = upperBound / 10;\\n\\n            for(int div = upperBound; div > lowerBound; div--){\\n                if(x/div > upperBound) return;\\n                if(x % div == 0) {\\n                    found = true;\\n                    result = (int) (x % 1337);\\n                    return;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        for(int i = n; i >= 0; i--){\\n            if(found) return;\\n            sb.insert(sb.length()/2, i+\"\"+i);\\n            solve(sb, 9, len);\\n            int idx = (sb.length()-1)/2;\\n            sb.delete(idx,idx+2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96311,
                "title": "solution-for-odd-number-8",
                "content": "Cannot find a python solution for n = 8. So I tried to check the result\\nn, palindrome product, x, y\\n2 9009 99 91\\n3 906609 993 913\\n4 99000099 9999 9901\\n5 9966006699 99979 99681\\n6 999000000999 999999 999001\\n7 99956644665999 9998017 9997647\\n8 9999000000009999 99999999 99990001\\n\\nWhen n is Odd, the result is always 9***9 (n 9s) * 9**90**1 (n/2 9s with 1 )\\nNo sure whether it can be extend to odd n > 8 (but for any Odd num, it seems that at least the product of such two numbers is a palindrome, not sure whether it will always be the max)",
                "solutionTags": [],
                "code": "Cannot find a python solution for n = 8. So I tried to check the result\\nn, palindrome product, x, y\\n2 9009 99 91\\n3 906609 993 913\\n4 99000099 9999 9901\\n5 9966006699 99979 99681\\n6 999000000999 999999 999001\\n7 99956644665999 9998017 9997647\\n8 9999000000009999 99999999 99990001\\n\\nWhen n is Odd, the result is always 9***9 (n 9s) * 9**90**1 (n/2 9s with 1 )\\nNo sure whether it can be extend to odd n > 8 (but for any Odd num, it seems that at least the product of such two numbers is a palindrome, not sure whether it will always be the max)",
                "codeTag": "Unknown"
            },
            {
                "id": 96312,
                "title": "c-solution-share",
                "content": "    int largestPalindrome(int n) \\n    {\\n        if (n == 1)\\n            return 9;\\n        \\n        int high = pow(10, n) - 1;\\n        int low = pow(10, n - 1);\\n        \\n        for (int i = high; i >= low; i--)\\n        {\\n            long long int pal = createPalindrome(i);\\n            for (int j = high; j >= low; j--)\\n            {\\n                if (pal / j > high)\\n                    break;\\n                if (pal % j == 0)\\n                    return pal % 1337;\\n            }\\n        }\\n    }\\n    \\n    long long int createPalindrome(int i)\\n    {\\n        long long int result;\\n        string str = to_string(i);\\n        string rev_str = str;\\n        reverse(rev_str.begin(), rev_str.end());\\n        str += rev_str;\\n       \\n        istringstream ist(str); \\n        ist >> result;\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    int largestPalindrome(int n) \\n    {\\n        if (n == 1)\\n            return 9;\\n        \\n        int high = pow(10, n) - 1;\\n        int low = pow(10, n - 1);\\n        \\n        for (int i = high; i >= low; i--)\\n        {\\n            long long int pal = createPalindrome(i);\\n            for (int j = high; j >= low; j--)\\n            {\\n                if (pal / j > high)\\n                    break;\\n                if (pal % j == 0)\\n                    return pal % 1337;\\n            }\\n        }\\n    }\\n    \\n    long long int createPalindrome(int i)\\n    {\\n        long long int result;\\n        string str = to_string(i);\\n        string rev_str = str;\\n        reverse(rev_str.begin(), rev_str.end());\\n        str += rev_str;\\n       \\n        istringstream ist(str); \\n        ist >> result;\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 96314,
                "title": "2-line-1ms-java-solution",
                "content": "With a limitation of 1-8 for the range of n, a simple lookup table is best. This is a terrible question.\\n\\npublic class Solution {\\n    private static int[] LP = new int[] { 0, 9, 987, 123, 597, 677, 1218, 877, 475 };\\n    \\n    public int largestPalindrome(int n) {\\n        return LP[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private static int[] LP = new int[] { 0, 9, 987, 123, 597, 677, 1218, 877, 475 }",
                "codeTag": "Java"
            },
            {
                "id": 96315,
                "title": "java-try-all-palindromes-solution",
                "content": "```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        assert n >= 1 && n <= 8;\\n        if (n == 1) {\\n            return 9;\\n        }\\n        int max = (int)Math.pow(10, n) - 1;\\n        int min = (int)Math.pow(10, n - 1);\\n        for (int left = max; left >= min; left--) {\\n            long palindrome = palindromeByLeft(left, true);\\n            if (factorable(palindrome, max, min)) {\\n                return (int)(palindrome % 1337);\\n            }\\n        }\\n        for (int left = max; left >= min; left--) {\\n            long palindrome = palindromeByLeft(left, false);\\n            if (factorable(palindrome, max, min)) {\\n                return (int)(palindrome % 1337);\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private boolean factorable(long palindrome, int max, int min) {\\n        for (long first = max; first >= min; first--) {\\n            long second = palindrome / first;\\n            if (second > first) {\\n                break;\\n            }\\n            if (second >= min && first * second == palindrome) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private long palindromeByLeft(int left, boolean even) {\\n        return Long.parseLong(left + new StringBuffer().append(even ? left : left / 10).reverse().toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        assert n >= 1 && n <= 8;\\n        if (n == 1) {\\n            return 9;\\n        }\\n        int max = (int)Math.pow(10, n) - 1;\\n        int min = (int)Math.pow(10, n - 1);\\n        for (int left = max; left >= min; left--) {\\n            long palindrome = palindromeByLeft(left, true);\\n            if (factorable(palindrome, max, min)) {\\n                return (int)(palindrome % 1337);\\n            }\\n        }\\n        for (int left = max; left >= min; left--) {\\n            long palindrome = palindromeByLeft(left, false);\\n            if (factorable(palindrome, max, min)) {\\n                return (int)(palindrome % 1337);\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private boolean factorable(long palindrome, int max, int min) {\\n        for (long first = max; first >= min; first--) {\\n            long second = palindrome / first;\\n            if (second > first) {\\n                break;\\n            }\\n            if (second >= min && first * second == palindrome) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private long palindromeByLeft(int left, boolean even) {\\n        return Long.parseLong(left + new StringBuffer().append(even ? left : left / 10).reverse().toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96316,
                "title": "fastest-java-solution-with-92ms",
                "content": "I have optimized one existing solution and it now changed from 173 ms to 92ms.\\nSimply removed Math.pow & StringBuffer reverse process to calculate palindromic Number.\\n\\n```\\npublic class Solution {\\n    // optimizing speed ; removing Math.pow from upperLimit\\n    public long[] maxLimits = new long[]{\\n        10,100,1000,10000,100000,1000000, 10000000, 100000000\\n    }; \\n    \\n    public int largestPalindrome(int n) {\\nif (n == 1) return 9;\\n        \\n        int high = (int) maxLimits[n-1]-1;\\n        int low = (int) maxLimits[n-2];\\n        for (int i = high; i >= low; i--) {\\n            long palindrome = PalindromNum(i);\\n            int hi = high;\\n            while (hi % 11 != 0) {\\n                hi--;\\n            }\\n            for (int j = hi; j >= low; j -= 11) {\\n                if (palindrome / j > high) {\\n                    break;\\n                }\\n                if (palindrome % j == 0) {\\n                    return (int) (palindrome % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n// calculate Palindromic\\n    public long PalindromNum(int x) {\\n        long out = x;\\n        while(x > 0) {\\n            out = (10*out)+(x%10);\\n            x = x/10;\\n        }\\n        return out;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // optimizing speed ; removing Math.pow from upperLimit\\n    public long[] maxLimits = new long[]{\\n        10,100,1000,10000,100000,1000000, 10000000, 100000000\\n    }; \\n    \\n    public int largestPalindrome(int n) {\\nif (n == 1) return 9;\\n        \\n        int high = (int) maxLimits[n-1]-1;\\n        int low = (int) maxLimits[n-2];\\n        for (int i = high; i >= low; i--) {\\n            long palindrome = PalindromNum(i);\\n            int hi = high;\\n            while (hi % 11 != 0) {\\n                hi--;\\n            }\\n            for (int j = hi; j >= low; j -= 11) {\\n                if (palindrome / j > high) {\\n                    break;\\n                }\\n                if (palindrome % j == 0) {\\n                    return (int) (palindrome % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n// calculate Palindromic\\n    public long PalindromNum(int x) {\\n        long out = x;\\n        while(x > 0) {\\n            out = (10*out)+(x%10);\\n            x = x/10;\\n        }\\n        return out;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96319,
                "title": "unable-to-execute-more-than-3-inputs",
                "content": "This is my code for Python but is not able to execute for more than 3 inputs\\n'''\\ndef palindrome(x):\\n    Reverse = 0\\n    while (x > 0):\\n        Reminder = x% 10\\n        Reverse = (Reverse * 10) + Reminder\\n        x = x//10\\n    return Reverse\\n\\nn = int(input(\"Please Enter any Number: \"))\\nnum = []\\nstarting = (10**(n))-1\\nending = starting//10\\n\\nfor p in range(starting,ending,-1):\\n    for q in range(starting, ending, -1):\\n        check = int(p * q)\\n        if (palindrome(check) == check):\\n            num.append(check)\\n\\nprint(max(num)%1337)\\n'''",
                "solutionTags": [],
                "code": "This is my code for Python but is not able to execute for more than 3 inputs\\n'''\\ndef palindrome(x):\\n    Reverse = 0\\n    while (x > 0):\\n        Reminder = x% 10\\n        Reverse = (Reverse * 10) + Reminder\\n        x = x//10\\n    return Reverse\\n\\nn = int(input(\"Please Enter any Number: \"))\\nnum = []\\nstarting = (10**(n))-1\\nending = starting//10\\n\\nfor p in range(starting,ending,-1):\\n    for q in range(starting, ending, -1):\\n        check = int(p * q)\\n        if (palindrome(check) == check):\\n            num.append(check)\\n\\nprint(max(num)%1337)\\n'''",
                "codeTag": "Python3"
            },
            {
                "id": 96320,
                "title": "largest-palindrome-product-wrong-test-case-answer",
                "content": "I think one of the test case fore this problem is damn wrong. If you put 1 as an input my code returning product as 66 which is correct palindrome where as the question expecting answer to be. My code is as follows :\\n\\n```\\n    public static int largestPalindrome(int n) {\\n        long product =  0;\\n        long product_start = ((long) Math.pow(10, n-1))*((long) Math.pow(10, n-1)+1);\\n        long product_end = ((long) Math.pow(10, n)-2) * ((long) Math.pow(10, n)-1);\\n        for (long i = product_start; i<=product_end; i++) {\\n            //call palindrome\\n            if(isPal(String.valueOf(i))) {\\n                if (product<i) {\\n                    product = i;\\n                }\\n            }\\n        }\\n        return (int) product%1337;\\n    }\\n\\n    public static boolean isPal(String str) {\\n        if(str.length()==0 || str.length() ==1) {\\n            return true;\\n        }\\n        else {\\n            if(str.charAt(0) == str.charAt(str.length()-1)) {\\n                String subString = str.substring(1, str.length()-1);\\n                return isPal(str.substring(1, str.length() - 1));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int largestPalindrome(int n) {\\n        long product =  0;\\n        long product_start = ((long) Math.pow(10, n-1))*((long) Math.pow(10, n-1)+1);\\n        long product_end = ((long) Math.pow(10, n)-2) * ((long) Math.pow(10, n)-1);\\n        for (long i = product_start; i<=product_end; i++) {\\n            //call palindrome\\n            if(isPal(String.valueOf(i))) {\\n                if (product<i) {\\n                    product = i;\\n                }\\n            }\\n        }\\n        return (int) product%1337;\\n    }\\n\\n    public static boolean isPal(String str) {\\n        if(str.length()==0 || str.length() ==1) {\\n            return true;\\n        }\\n        else {\\n            if(str.charAt(0) == str.charAt(str.length()-1)) {\\n                String subString = str.substring(1, str.length()-1);\\n                return isPal(str.substring(1, str.length() - 1));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96321,
                "title": "why-maximum-possible-length-of-the-product-is-2-n-uff1f",
                "content": "Re: [Java Solution with explanation](/topic/74143/java-solution-with-explanation)",
                "solutionTags": [],
                "code": "Re: [Java Solution with explanation](/topic/74143/java-solution-with-explanation)",
                "codeTag": "Unknown"
            },
            {
                "id": 96325,
                "title": "c-from-product-to-palindrome",
                "content": "Although it's hard to arrange products in descending order, we can use a trick to avoid precise arrangement.\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        long max, min, ans = 0, sum;\\n        max = static_cast<long>(pow(10, n)) - 1;\\n        min = max/10 + 1;\\n        sum = 2 * max;\\n        while (sum/2 * (sum - sum/2) > ans){\\n            long i = sum/2, j = sum - sum/2;\\n            while (j <= max && i >= min){\\n            \\tlong num = i * j;\\n            \\tif (num > ans && isPalindrome(num)){\\n            \\t\\tans = num;\\n            \\t\\tbreak;\\n            \\t}\\n            \\ti--;\\n            \\tj++;\\n            }\\n            sum--;\\n        }\\n        return ans % 1337;\\n    }\\n    bool isPalindrome(long x){\\n        long y = 0;\\n        for (long z = x; z != 0; y = 10 * y + z % 10, z /= 10);\\n        return x == y;\\n    }\\n};\\n```\\nHowever, this method spends too much time than max palindrome method.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        long max, min, ans = 0, sum;\\n        max = static_cast<long>(pow(10, n)) - 1;\\n        min = max/10 + 1;\\n        sum = 2 * max;\\n        while (sum/2 * (sum - sum/2) > ans){\\n            long i = sum/2, j = sum - sum/2;\\n            while (j <= max && i >= min){\\n            \\tlong num = i * j;\\n            \\tif (num > ans && isPalindrome(num)){\\n            \\t\\tans = num;\\n            \\t\\tbreak;\\n            \\t}\\n            \\ti--;\\n            \\tj++;\\n            }\\n            sum--;\\n        }\\n        return ans % 1337;\\n    }\\n    bool isPalindrome(long x){\\n        long y = 0;\\n        for (long z = x; z != 0; y = 10 * y + z % 10, z /= 10);\\n        return x == y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96329,
                "title": "2-digit-solution-question",
                "content": "Ok so it says that the max palindrome for a 2 digit number is 99*91=9009 and 9009%1337=987\\nHowever, 44*91 = 4004 and 4004% 1337 = 1330 which is larger than 987\\nis it because that is an error on the program output or im not understanding the problem?\\nany explanations will be very helpful \\nalso here is my code (Not as good as some other people but it is understandable)\\n```\\n\\tpublic int findPalindrome(int digit) {\\n\\t\\tint largest = 0;\\n\\t\\tint smallest = (int) Math.pow(10.0, (digit - 1));\\n\\t\\tint max = (smallest * 10) - 1;\\n\\n\\t\\tfor (int i = max; i >= smallest; i--) {\\n\\t\\t\\tfor (int x = max; x >= smallest; x--) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (isPalindrome(i * x)) {\\n\\t\\t\\t\\t\\t\\tif (((i * x) % 1337) > largest) {\\n\\t\\t\\t\\t\\t\\t\\tlargest = (i * x) % 1337;\\n\\t\\t\\t\\t\\t\\t\\tSystem.out.println(\"X: \" + x + \" i: \" + i);\\n\\t\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t} catch (InterruptedException e) {\\n\\t\\t\\t\\t\\te.printStackTrace();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn largest;\\n\\t}\\n\\n\\tpublic boolean isPalindrome(int product) throws InterruptedException {\\n\\t\\tint first = 0;\\n\\t\\tString palindrome = \"\" + product;\\n\\t\\tint last = palindrome.length() - 1;\\n\\t\\tfor (first = 0; first <= (palindrome.length() - 1) / 2; first++, last--)\\n\\t\\t\\tif (palindrome.charAt(first) != palindrome.charAt(last))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n```\\n\\nThank you",
                "solutionTags": [],
                "code": "```\\n\\tpublic int findPalindrome(int digit) {\\n\\t\\tint largest = 0;\\n\\t\\tint smallest = (int) Math.pow(10.0, (digit - 1));\\n\\t\\tint max = (smallest * 10) - 1;\\n\\n\\t\\tfor (int i = max; i >= smallest; i--) {\\n\\t\\t\\tfor (int x = max; x >= smallest; x--) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (isPalindrome(i * x)) {\\n\\t\\t\\t\\t\\t\\tif (((i * x) % 1337) > largest) {\\n\\t\\t\\t\\t\\t\\t\\tlargest = (i * x) % 1337;\\n\\t\\t\\t\\t\\t\\t\\tSystem.out.println(\"X: \" + x + \" i: \" + i);\\n\\t\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t} catch (InterruptedException e) {\\n\\t\\t\\t\\t\\te.printStackTrace();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn largest;\\n\\t}\\n\\n\\tpublic boolean isPalindrome(int product) throws InterruptedException {\\n\\t\\tint first = 0;\\n\\t\\tString palindrome = \"\" + product;\\n\\t\\tint last = palindrome.length() - 1;\\n\\t\\tfor (first = 0; first <= (palindrome.length() - 1) / 2; first++, last--)\\n\\t\\t\\tif (palindrome.charAt(first) != palindrome.charAt(last))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96326,
                "title": "c-ac-by-constructing-the-palindrome-number",
                "content": "\\n    class Solution {\\n    public:\\n    int largestPalindrome(int n) {\\n        if(n == 1) return 9;\\n        long max = pow(10, n) - 1;\\n        long min = max/10;\\n        for(long i = max; i > min; --i){\\n            long res = construct(i);\\n            for(int j = max; j > min; --j){\\n                if(res / j > max) break;\\n                if(res % j == 0){\\n                    return (int)(res % 1337);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    long construct(long num){\\n        long tmp = num;\\n        long a = 0;\\n        int n = 0;\\n        while(tmp){\\n            a = a * 10 + tmp % 10;\\n            n++;\\n            tmp /= 10;\\n        }\\n        while(n){\\n            num = num *10;\\n            n--;\\n        }\\n        return num + a;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int largestPalindrome(int n) {\\n        if(n == 1) return 9;\\n        long max = pow(10, n) - 1;\\n        long min = max/10;\\n        for(long i = max; i > min; --i){\\n            long res = construct(i);\\n            for(int j = max; j > min; --j){\\n                if(res / j > max) break;\\n                if(res % j == 0){\\n                    return (int)(res % 1337);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 96327,
                "title": "getting-wrong-answer-for-n-3",
                "content": "Failed with n=3. Any idea why would it be wrong? I do get the palindrome value as 90909 which then mod with the given number comes as 1330. What's wrong with this. Tested some other values and they looked fine.\\n\\n\\n\\n\\n```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n     //99*91\\n     //find the largest n digit number.\\n     long largest=0;\\n     for(int i=n;i>0;i--) {\\n         largest = largest*10+9;\\n     }\\n     long first = largest;\\n     long second = largest;\\n     while(first > 0) {\\n         while(second > 0) {\\n             if(isPalindrome(first*second)) {\\n                 return (int)((first*second)%1337);\\n             }\\n             second--;\\n         }\\n         first--;\\n     }\\n     return 0;\\n     \\n    }\\n    \\n    private boolean isPalindrome(long n) {\\n        long reverse = 0L;\\n        long temp = n;\\n        //123.\\n        while(temp!=0) {\\n            reverse = reverse*10 + temp%10;\\n            temp /=10;\\n        }\\n        return reverse == n;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n     //99*91\\n     //find the largest n digit number.\\n     long largest=0;\\n     for(int i=n;i>0;i--) {\\n         largest = largest*10+9;\\n     }\\n     long first = largest;\\n     long second = largest;\\n     while(first > 0) {\\n         while(second > 0) {\\n             if(isPalindrome(first*second)) {\\n                 return (int)((first*second)%1337);\\n             }\\n             second--;\\n         }\\n         first--;\\n     }\\n     return 0;\\n     \\n    }\\n    \\n    private boolean isPalindrome(long n) {\\n        long reverse = 0L;\\n        long temp = n;\\n        //123.\\n        while(temp!=0) {\\n            reverse = reverse*10 + temp%10;\\n            temp /=10;\\n        }\\n        return reverse == n;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96330,
                "title": "c-using-either-string-reverse-or-integer-reverse-670ms",
                "content": "The palindrome generation function you pick doesn't seem to have a huge impact. Not sure how to shave another 200ms though without extensive hand optimization.\\n\\n```\\nclass Solution {\\n    size_t palinpow;\\npublic:\\n    //returns max and min numbers containing n digits\\n    std::pair<size_t,size_t> get_digit_bounds(int n)\\n    {\\n        return std::make_pair(std::pow(10,n-1),std::pow(10,n)-1);\\n    }\\n    std::pair<size_t,size_t> get_palindrome_bounds(int n)\\n    {\\n        auto db = get_digit_bounds(n);\\n        return std::make_pair(db.first*db.first,db.second*db.second);\\n    }\\n    \\n    size_t gen_palindrome(size_t left) //create palindrome given left part\\n    {\\n        size_t right = 0;\\n        //reverse the left part\\n        for(size_t l=left; l!=0 ; l/=10) right = right*10 +l%10; \\n        return left*palinpow+right;\\n    }\\n    size_t gen_palindrome_str(size_t left) //generate palindrome using string methods\\n    {\\n        auto ls = std::to_string(left);\\n        auto rs = ls;\\n        std::reverse(rs.begin(),rs.end());\\n        return std::stoll(ls+rs);\\n    }\\n    \\n    int largestPalindrome(int n) {\\n        palinpow = std::pow(10,n);\\n        //hardcode trivial case\\n        if (n == 1) return 9;\\n        auto bounds = get_digit_bounds(n);\\n        auto palinbounds = get_palindrome_bounds(n);\\n        for(size_t i=bounds.second ; i>=bounds.first ; --i)\\n        {\\n            //skip obviously too big ones\\n            auto proxy_p = palinpow * i;\\n            if (proxy_p > palinbounds.second || proxy_p < palinbounds.first) continue;\\n\\n            //generate palindrome\\n            auto p = gen_palindrome_str(i);\\n            if (p > palinbounds.second || p < palinbounds.first) continue;\\n            for(size_t j=bounds.second ; j>= bounds.first; --j)\\n            {\\n                size_t q = p/j;\\n                if (q > bounds.second || p > j*j) break; //won't work\\n                if (p % j == 0) return p % 1337;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    size_t palinpow;\\npublic:\\n    //returns max and min numbers containing n digits\\n    std::pair<size_t,size_t> get_digit_bounds(int n)\\n    {\\n        return std::make_pair(std::pow(10,n-1),std::pow(10,n)-1);\\n    }\\n    std::pair<size_t,size_t> get_palindrome_bounds(int n)\\n    {\\n        auto db = get_digit_bounds(n);\\n        return std::make_pair(db.first*db.first,db.second*db.second);\\n    }\\n    \\n    size_t gen_palindrome(size_t left) //create palindrome given left part\\n    {\\n        size_t right = 0;\\n        //reverse the left part\\n        for(size_t l=left; l!=0 ; l/=10) right = right*10 +l%10; \\n        return left*palinpow+right;\\n    }\\n    size_t gen_palindrome_str(size_t left) //generate palindrome using string methods\\n    {\\n        auto ls = std::to_string(left);\\n        auto rs = ls;\\n        std::reverse(rs.begin(),rs.end());\\n        return std::stoll(ls+rs);\\n    }\\n    \\n    int largestPalindrome(int n) {\\n        palinpow = std::pow(10,n);\\n        //hardcode trivial case\\n        if (n == 1) return 9;\\n        auto bounds = get_digit_bounds(n);\\n        auto palinbounds = get_palindrome_bounds(n);\\n        for(size_t i=bounds.second ; i>=bounds.first ; --i)\\n        {\\n            //skip obviously too big ones\\n            auto proxy_p = palinpow * i;\\n            if (proxy_p > palinbounds.second || proxy_p < palinbounds.first) continue;\\n\\n            //generate palindrome\\n            auto p = gen_palindrome_str(i);\\n            if (p > palinbounds.second || p < palinbounds.first) continue;\\n            for(size_t j=bounds.second ; j>= bounds.first; --j)\\n            {\\n                size_t q = p/j;\\n                if (q > bounds.second || p > j*j) break; //won't work\\n                if (p % j == 0) return p % 1337;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96332,
                "title": "4-lines-java",
                "content": "```\\npublic int largestPalindrome(int n) {\\n  if (n == 1) return 9;\\n  for (long max = (long) Math.pow(10, n) - 1, min = max / 10, half = max * max / (long) Math.pow(10, n);; half--)\\n    for (long i = max, palindrom = Long.parseLong(half + new StringBuilder(half + \"\").reverse().toString()); i > min && i * max >= palindrom && palindrom > min * i; i--)\\n      if (palindrom % i == 0) return (int) (palindrom % 1337);\\n}",
                "solutionTags": [],
                "code": "```\\npublic int largestPalindrome(int n) {\\n  if (n == 1) return 9;\\n  for (long max = (long) Math.pow(10, n) - 1, min = max / 10, half = max * max / (long) Math.pow(10, n);; half--)\\n    for (long i = max, palindrom = Long.parseLong(half + new StringBuilder(half + \"\").reverse().toString()); i > min && i * max >= palindrom && palindrom > min * i; i--)\\n      if (palindrom % i == 0) return (int) (palindrom % 1337);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 96334,
                "title": "my-java-concise-solution-easy-to-understand-around-400ms",
                "content": "\\n* Construct palindrome products in the descending order\\n\\n* Check if the current palindrome product can be gotten from two n-digits numbers \\n\\n* Remark: \\n1. When the length of palindrome product is even, just decrease \"high\". When the length is odd, insert a variable in the middle in order to get palindrome products in descending order.\\n2. It's better to use the condition \"right * right >= value\" for pruning.\\n\\n```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        String[] basic = new String[]{\"9\", \"99\", \"999\", \"9999\", \"99999\", \"999999\", \"9999999\", \"99999999\"};\\n        long high = Long.valueOf(basic[n - 1]);\\n        long low = 0;\\n        if (n > 1) {\\n            low = Long.valueOf(basic[n - 2]);\\n        }\\n        int mid = 9;\\n        while (high >= low) {\\n            String highStr = String.valueOf(high);\\n            StringBuilder sb = new StringBuilder(highStr);\\n            String pld = highStr.equals(\"0\") ? \"\" :highStr;\\n            if (highStr.equals(\"0\") || highStr.length() < n) {\\n                pld += mid--;\\n            }\\n            pld += highStr.equals(\"0\") ? \"\" : sb.reverse().toString();\\n            long p = Long.valueOf(pld);\\n            if (palindromePro(p, n, basic)) {\\n                return (int) (p % 1337);\\n            }\\n            if (highStr.length() == n) {\\n                high--;\\n            }\\n            if (mid < 0) {\\n                high--;\\n                mid = 9;\\n            } \\n        }\\n        return 0;\\n    }\\n\\n    public boolean palindromePro(long value, int n, String[] basic) {\\n        long right = Long.valueOf(basic[n - 1]);\\n        while (right * right >= value) {\\n            if (value % right == 0) {\\n                return true;\\n            }\\n            right--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        String[] basic = new String[]{\"9\", \"99\", \"999\", \"9999\", \"99999\", \"999999\", \"9999999\", \"99999999\"};\\n        long high = Long.valueOf(basic[n - 1]);\\n        long low = 0;\\n        if (n > 1) {\\n            low = Long.valueOf(basic[n - 2]);\\n        }\\n        int mid = 9;\\n        while (high >= low) {\\n            String highStr = String.valueOf(high);\\n            StringBuilder sb = new StringBuilder(highStr);\\n            String pld = highStr.equals(\"0\") ? \"\" :highStr;\\n            if (highStr.equals(\"0\") || highStr.length() < n) {\\n                pld += mid--;\\n            }\\n            pld += highStr.equals(\"0\") ? \"\" : sb.reverse().toString();\\n            long p = Long.valueOf(pld);\\n            if (palindromePro(p, n, basic)) {\\n                return (int) (p % 1337);\\n            }\\n            if (highStr.length() == n) {\\n                high--;\\n            }\\n            if (mid < 0) {\\n                high--;\\n                mid = 9;\\n            } \\n        }\\n        return 0;\\n    }\\n\\n    public boolean palindromePro(long value, int n, String[] basic) {\\n        long right = Long.valueOf(basic[n - 1]);\\n        while (right * right >= value) {\\n            if (value % right == 0) {\\n                return true;\\n            }\\n            right--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96335,
                "title": "java-one-line-cheat",
                "content": "Since ```n``` is so small, the most efficient way is to pre-compute the results.\\n```\\n    public int largestPalindrome(int n) {\\n        return new int[] { 9, 987, 123, 597, 677, 1218, 877, 475 }[n - 1];\\n    }\\n```\\n\\n\\nThere are common patterns that we can observe for even ```n```:\\n```n=2``` gives ```max = 9009 = 99 * 91```\\n```n=4``` gives ```max = 99000099 = 9999 * 9901```\\n```n=6``` gives ```max = 999000000999 = 999999 * 999001```\\n```n=8``` gives ```max = 9999000000009999 = 99999999 * 99990001```\\n...",
                "solutionTags": [],
                "code": "```n```\n```\\n    public int largestPalindrome(int n) {\\n        return new int[] { 9, 987, 123, 597, 677, 1218, 877, 475 }[n - 1];\\n    }\\n```\n```n```\n```n=2```\n```max = 9009 = 99 * 91```\n```n=4```\n```max = 99000099 = 9999 * 9901```\n```n=6```\n```max = 999000000999 = 999999 * 999001```\n```n=8```\n```max = 9999000000009999 = 99999999 * 99990001```",
                "codeTag": "Unknown"
            },
            {
                "id": 112114,
                "title": "provide-a-resolution-and-don-t-ask-me-why",
                "content": "```\\nint largestPalindrome(int n) {\\n    int result[8] = {9, 987, 123, 597, 677, 1218, 877, 475};\\n    return result[n - 1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint largestPalindrome(int n) {\\n    int result[8] = {9, 987, 123, 597, 677, 1218, 877, 475};\\n    return result[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564603,
                "content": [
                    {
                        "username": "tankztc",
                        "content": "This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
                    },
                    {
                        "username": "Teaflavored",
                        "content": "I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
                    },
                    {
                        "username": "zhuyyyyyyyy",
                        "content": "Please delete this stupid topic\\uFF5E\\uFF01"
                    },
                    {
                        "username": "lay",
                        "content": "I saw many solutions use \"num + reverse(num)\" to construct a palindrome...\\nI do not think it is the right way to go, as there are cases of odd number of digits, such as 1234321, which is also palindromic."
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "I use python and get about 1000ms... \\nBut I see there are a of submissions within 100ms. Could anyone share their codes within 100ms? \\n\\nThanks!"
                    },
                    {
                        "username": "kisuke",
                        "content": "maybe  it\\'s a better choice that finding the longest Palindrome numbers on the net, then just output it."
                    }
                ]
            },
            {
                "id": 1564966,
                "content": [
                    {
                        "username": "tankztc",
                        "content": "This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
                    },
                    {
                        "username": "Teaflavored",
                        "content": "I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
                    },
                    {
                        "username": "zhuyyyyyyyy",
                        "content": "Please delete this stupid topic\\uFF5E\\uFF01"
                    },
                    {
                        "username": "lay",
                        "content": "I saw many solutions use \"num + reverse(num)\" to construct a palindrome...\\nI do not think it is the right way to go, as there are cases of odd number of digits, such as 1234321, which is also palindromic."
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "I use python and get about 1000ms... \\nBut I see there are a of submissions within 100ms. Could anyone share their codes within 100ms? \\n\\nThanks!"
                    },
                    {
                        "username": "kisuke",
                        "content": "maybe  it\\'s a better choice that finding the longest Palindrome numbers on the net, then just output it."
                    }
                ]
            },
            {
                "id": 1569378,
                "content": [
                    {
                        "username": "tankztc",
                        "content": "This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
                    },
                    {
                        "username": "Teaflavored",
                        "content": "I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
                    },
                    {
                        "username": "zhuyyyyyyyy",
                        "content": "Please delete this stupid topic\\uFF5E\\uFF01"
                    },
                    {
                        "username": "lay",
                        "content": "I saw many solutions use \"num + reverse(num)\" to construct a palindrome...\\nI do not think it is the right way to go, as there are cases of odd number of digits, such as 1234321, which is also palindromic."
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "I use python and get about 1000ms... \\nBut I see there are a of submissions within 100ms. Could anyone share their codes within 100ms? \\n\\nThanks!"
                    },
                    {
                        "username": "kisuke",
                        "content": "maybe  it\\'s a better choice that finding the longest Palindrome numbers on the net, then just output it."
                    }
                ]
            },
            {
                "id": 1569172,
                "content": [
                    {
                        "username": "tankztc",
                        "content": "This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
                    },
                    {
                        "username": "Teaflavored",
                        "content": "I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
                    },
                    {
                        "username": "zhuyyyyyyyy",
                        "content": "Please delete this stupid topic\\uFF5E\\uFF01"
                    },
                    {
                        "username": "lay",
                        "content": "I saw many solutions use \"num + reverse(num)\" to construct a palindrome...\\nI do not think it is the right way to go, as there are cases of odd number of digits, such as 1234321, which is also palindromic."
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "I use python and get about 1000ms... \\nBut I see there are a of submissions within 100ms. Could anyone share their codes within 100ms? \\n\\nThanks!"
                    },
                    {
                        "username": "kisuke",
                        "content": "maybe  it\\'s a better choice that finding the longest Palindrome numbers on the net, then just output it."
                    }
                ]
            },
            {
                "id": 1569127,
                "content": [
                    {
                        "username": "tankztc",
                        "content": "This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
                    },
                    {
                        "username": "Teaflavored",
                        "content": "I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
                    },
                    {
                        "username": "zhuyyyyyyyy",
                        "content": "Please delete this stupid topic\\uFF5E\\uFF01"
                    },
                    {
                        "username": "lay",
                        "content": "I saw many solutions use \"num + reverse(num)\" to construct a palindrome...\\nI do not think it is the right way to go, as there are cases of odd number of digits, such as 1234321, which is also palindromic."
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "I use python and get about 1000ms... \\nBut I see there are a of submissions within 100ms. Could anyone share their codes within 100ms? \\n\\nThanks!"
                    },
                    {
                        "username": "kisuke",
                        "content": "maybe  it\\'s a better choice that finding the longest Palindrome numbers on the net, then just output it."
                    }
                ]
            },
            {
                "id": 1571878,
                "content": [
                    {
                        "username": "tankztc",
                        "content": "This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
                    },
                    {
                        "username": "Teaflavored",
                        "content": "I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
                    },
                    {
                        "username": "zhuyyyyyyyy",
                        "content": "Please delete this stupid topic\\uFF5E\\uFF01"
                    },
                    {
                        "username": "lay",
                        "content": "I saw many solutions use \"num + reverse(num)\" to construct a palindrome...\\nI do not think it is the right way to go, as there are cases of odd number of digits, such as 1234321, which is also palindromic."
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "I use python and get about 1000ms... \\nBut I see there are a of submissions within 100ms. Could anyone share their codes within 100ms? \\n\\nThanks!"
                    },
                    {
                        "username": "kisuke",
                        "content": "maybe  it\\'s a better choice that finding the longest Palindrome numbers on the net, then just output it."
                    }
                ]
            }
        ]
    }
]